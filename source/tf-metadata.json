[
  {
    "name": "Abort",
    "summary": "Raise a exception to abort the process when called.",
    "description": "If exit_without_error is true, the process will exit normally,\notherwise it will exit with a SIGABORT signal.\n\nReturns nothing but an exception.",
    "attributes": [
      {
        "name": "error_msg",
        "type": "string",
        "description": "A string which is the message associated with the exception.",
        "default": ""
      },
      {
        "name": "exit_without_error",
        "type": "boolean",
        "default": false
      }
    ]
  },
  {
    "name": "Abs",
    "summary": "Computes the absolute value of a tensor.",
    "description": "Given a tensor `x`, this operation returns a tensor containing the absolute\nvalue of each element in `x`. For example, if x is an input element and y is\nan output element, this operation computes \\\\(y = |x|\\\\).",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `int8`, `int16`, `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "AccumulateNV2",
    "summary": "Returns the element-wise sum of a list of tensors.",
    "description": "`tf.accumulate_n_v2` performs the same operation as `tf.add_n`, but does not\nwait for all of its inputs to be ready before beginning to sum. This can\nsave memory if inputs are ready at different times, since minimum temporary\nstorage is proportional to the output size rather than the inputs size.\n\nUnlike the original `accumulate_n`, `accumulate_n_v2` is differentiable.\n\nReturns a `Tensor` of same shape and type as the elements of `inputs`.",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "shape",
        "type": "shape",
        "description": "Shape of elements of `inputs`."
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "description": "A list of `Tensor` objects, each with same shape and type.",
        "numberAttr": "N",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "sum",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "AccumulatorApplyGradient",
    "summary": "Applies a gradient to a given accumulator.",
    "description": "Does not add if local_step is lesser than the accumulator's global_step.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The data type of accumulated gradients. Needs to correspond to the type\nof the accumulator. Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a accumulator.",
        "type": 7,
        "isRef": true
      },
      {
        "name": "local_step",
        "description": "The local_step value at which the gradient was computed.",
        "type": 9
      },
      {
        "name": "gradient",
        "description": "A tensor of the gradient to be accumulated.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "AccumulatorNumAccumulated",
    "summary": "Returns the number of gradients aggregated in the given accumulators.",
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to an accumulator.",
        "type": 7,
        "isRef": true
      }
    ],
    "outputs": [
      {
        "name": "num_accumulated",
        "description": "The number of gradients aggregated in the given accumulator.",
        "type": 3
      }
    ]
  },
  {
    "name": "AccumulatorSetGlobalStep",
    "summary": "Updates the accumulator with a new value for global_step.",
    "description": "Logs warning if the accumulator's value is already higher than\nnew_global_step.",
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to an accumulator.",
        "type": 7,
        "isRef": true
      },
      {
        "name": "new_global_step",
        "description": "The new global_step value to set.",
        "type": 9
      }
    ]
  },
  {
    "name": "AccumulatorTakeGradient",
    "summary": "Extracts the average gradient in the given ConditionalAccumulator.",
    "description": "The op blocks until sufficient (i.e., more than num_required)\ngradients have been accumulated.  If the accumulator has already\naggregated more than num_required gradients, it returns the average of\nthe accumulated gradients.  Also automatically increments the recorded\nglobal_step in the accumulator by 1, and resets the aggregate to 0.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The data type of accumulated gradients. Needs to correspond to the type\nof the accumulator. Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to an accumulator.",
        "type": 7,
        "isRef": true
      },
      {
        "name": "num_required",
        "description": "Number of gradients required before we return an aggregate.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "average",
        "description": "The average of the accumulated gradients.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "Acos",
    "summary": "Computes acos of x element-wise.",
    "description": "\n  Provided an input tensor, the `tf.math.acos` operation returns the inverse cosine of each element of the tensor. If `y = tf.math.cos(x)` then, `x = tf.math.acos(y)`.\n\n  Input range is `[-1, 1]` and the output has a range of `[0, pi]`.\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Acosh",
    "summary": "Computes inverse hyperbolic cosine of x element-wise.",
    "description": "Given an input tensor, the function computes inverse hyperbolic cosine of every element.\nInput range is `[1, inf]`. It returns `nan` if the input lies outside the range.\n\n```python\nx = tf.constant([-2, -0.5, 1, 1.2, 200, 10000, float(\"inf\")])\ntf.math.acosh(x) ==> [nan nan 0. 0.62236255 5.9914584 9.903487 inf]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Add",
    "summary": "Returns x + y element-wise.",
    "description": "*NOTE*: `Add` supports broadcasting. `AddN` does not. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)\n\nGiven two input tensors, the `tf.add` operation computes the sum for every element in the tensor.\n\nBoth input and output have a range `(-inf, inf)`.\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `uint8`, `int8`, `int16`, `int32`, `int64`, `complex64`, `complex128`, `string`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "AddManySparseToTensorsMap",
    "summary": "Add an `N`-minibatch `SparseTensor` to a `SparseTensorsMap`, return `N` handles.",
    "description": "A `SparseTensor` of rank `R` is represented by three tensors: `sparse_indices`,\n`sparse_values`, and `sparse_shape`, where\n\n```sparse_indices.shape[1] == sparse_shape.shape[0] == R```\n\nAn `N`-minibatch of `SparseTensor` objects is represented as a `SparseTensor`\nhaving a first `sparse_indices` column taking values between `[0, N)`, where\nthe minibatch size `N == sparse_shape[0]`.\n\nThe input `SparseTensor` must have rank `R` greater than 1, and the first\ndimension is treated as the minibatch dimension.  Elements of the `SparseTensor`\nmust be sorted in increasing order of this first dimension.  The stored\n`SparseTensor` objects pointed to by each row of the output `sparse_handles`\nwill have rank `R-1`.\n\nThe `SparseTensor` values can then be read out as part of a minibatch by passing\nthe given keys as vector elements to `TakeManySparseFromTensorsMap`.  To ensure\nthe correct `SparseTensorsMap` is accessed, ensure that the same\n`container` and `shared_name` are passed to that Op.  If no `shared_name`\nis provided here, instead use the *name* of the Operation created by calling\n`AddManySparseToTensorsMap` as the `shared_name` passed to\n`TakeManySparseFromTensorsMap`.  Ensure the Operations are colocated.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "container",
        "type": "string",
        "description": "The container name for the `SparseTensorsMap` created by this op.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "The shared name for the `SparseTensorsMap` created by this op.\nIf blank, the new Operation's unique name is used.",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "sparse_indices",
        "description": "2-D.  The `indices` of the minibatch `SparseTensor`.\n`sparse_indices[:, 0]` must be ordered values in `[0, N)`.",
        "type": 9
      },
      {
        "name": "sparse_values",
        "description": "1-D.  The `values` of the minibatch `SparseTensor`.",
        "typeAttr": "T"
      },
      {
        "name": "sparse_shape",
        "description": "1-D.  The `shape` of the minibatch `SparseTensor`.\nThe minibatch size `N == sparse_shape[0]`.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "sparse_handles",
        "description": "1-D.  The handles of the `SparseTensor` now stored in the\n`SparseTensorsMap`.  Shape: `[N]`.",
        "type": 9
      }
    ]
  },
  {
    "name": "AddN",
    "summary": "Add all input tensors element wise.",
    "description": "  Inputs must be of same size and shape.\n\n  ```python\n  x = [9, 7, 10]\n  tf.math.add_n(x) ==> 26\n  ```",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`, `variant`."
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "numberAttr": "N",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "sum",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "AddSparseToTensorsMap",
    "summary": "Add a `SparseTensor` to a `SparseTensorsMap` return its handle.",
    "description": "A `SparseTensor` is represented by three tensors: `sparse_indices`,\n`sparse_values`, and `sparse_shape`.\n\nThis operator takes the given `SparseTensor` and adds it to a container\nobject (a `SparseTensorsMap`).  A unique key within this container is generated\nin the form of an `int64`, and this is the value that is returned.\n\nThe `SparseTensor` can then be read out as part of a minibatch by passing\nthe key as a vector element to `TakeManySparseFromTensorsMap`.  To ensure\nthe correct `SparseTensorsMap` is accessed, ensure that the same\n`container` and `shared_name` are passed to that Op.  If no `shared_name`\nis provided here, instead use the *name* of the Operation created by calling\n`AddSparseToTensorsMap` as the `shared_name` passed to\n`TakeManySparseFromTensorsMap`.  Ensure the Operations are colocated.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "container",
        "type": "string",
        "description": "The container name for the `SparseTensorsMap` created by this op.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "The shared name for the `SparseTensorsMap` created by this op.\nIf blank, the new Operation's unique name is used.",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "sparse_indices",
        "description": "2-D.  The `indices` of the `SparseTensor`.",
        "type": 9
      },
      {
        "name": "sparse_values",
        "description": "1-D.  The `values` of the `SparseTensor`.",
        "typeAttr": "T"
      },
      {
        "name": "sparse_shape",
        "description": "1-D.  The `shape` of the `SparseTensor`.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "sparse_handle",
        "description": "0-D.  The handle of the `SparseTensor` now stored in the\n`SparseTensorsMap`.",
        "type": 9
      }
    ]
  },
  {
    "name": "AddV2",
    "summary": "Returns x + y element-wise.",
    "description": "*NOTE*: `Add` supports broadcasting. `AddN` does not. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `uint8`, `uint16`, `uint32`, `uint64`, `int8`, `int16`, `int32`, `int64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "AdjustContrast",
    "summary": "Deprecated. Disallowed in GraphDef version >= 2.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `uint8`, `int8`, `int16`, `int32`, `int64`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "images",
        "typeAttr": "T"
      },
      {
        "name": "contrast_factor",
        "type": 1
      },
      {
        "name": "min_value",
        "type": 1
      },
      {
        "name": "max_value",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 1
      }
    ]
  },
  {
    "name": "AdjustContrastv2",
    "summary": "Adjust the contrast of one or more images.",
    "description": "`images` is a tensor of at least 3 dimensions.  The last 3 dimensions are\ninterpreted as `[height, width, channels]`.  The other dimensions only\nrepresent a collection of images, such as `[batch, height, width, channels].`\n\nContrast is adjusted independently for each channel of each image.\n\nFor each channel, the Op first computes the mean of the image pixels in the\nchannel and then adjusts each component of each pixel to\n`(x - mean) * contrast_factor + mean`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "images",
        "description": "Images to adjust.  At least 3-D.",
        "typeAttr": "T"
      },
      {
        "name": "contrast_factor",
        "description": "A float multiplier for adjusting contrast.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The contrast-adjusted image or images.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "AdjustHue",
    "summary": "Adjust the hue of one or more images.",
    "description": "`images` is a tensor of at least 3 dimensions.  The last dimension is\ninterpreted as channels, and must be three.\n\nThe input image is considered in the RGB colorspace. Conceptually, the RGB\ncolors are first mapped into HSV. A delta is then applied all the hue values,\nand then remapped back to RGB colorspace.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "images",
        "description": "Images to adjust.  At least 3-D.",
        "typeAttr": "T"
      },
      {
        "name": "delta",
        "description": "A float delta to add to the hue.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The hue-adjusted image or images.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "AdjustSaturation",
    "summary": "Adjust the saturation of one or more images.",
    "description": "`images` is a tensor of at least 3 dimensions.  The last dimension is\ninterpreted as channels, and must be three.\n\nThe input image is considered in the RGB colorspace. Conceptually, the RGB\ncolors are first mapped into HSV. A scale is then applied all the saturation\nvalues, and then remapped back to RGB colorspace.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "images",
        "description": "Images to adjust.  At least 3-D.",
        "typeAttr": "T"
      },
      {
        "name": "scale",
        "description": "A float scale to add to the saturation.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The hue-adjusted image or images.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "All",
    "summary": "Computes the \"logical and\" of elements across dimensions of a tensor.",
    "description": "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1.",
    "attributes": [
      {
        "name": "keep_dims",
        "type": "boolean",
        "description": "If true, retain reduced dimensions with length 1.",
        "default": false
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The tensor to reduce.",
        "type": 10
      },
      {
        "name": "reduction_indices",
        "description": "The dimensions to reduce. Must be in the range\n`[-rank(input), rank(input))`.",
        "typeAttr": "Tidx"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The reduced tensor.",
        "type": 10
      }
    ]
  },
  {
    "name": "AllCandidateSampler",
    "summary": "Generates labels for candidate sampling with a learned unigram distribution.",
    "description": "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels.",
    "attributes": [
      {
        "name": "num_true",
        "type": "int64",
        "description": "Number of true labels per context.",
        "minimum": 1
      },
      {
        "name": "num_sampled",
        "type": "int64",
        "description": "Number of candidates to produce.",
        "minimum": 1
      },
      {
        "name": "unique",
        "type": "boolean",
        "description": "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities."
      },
      {
        "name": "seed",
        "type": "int64",
        "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "description": "An second seed to avoid seed collision.",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "true_classes",
        "description": "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "sampled_candidates",
        "description": "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate.",
        "type": 9
      },
      {
        "name": "true_expected_count",
        "description": "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability.",
        "type": 1
      },
      {
        "name": "sampled_expected_count",
        "description": "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability.",
        "type": 1
      }
    ]
  },
  {
    "name": "AllToAll",
    "summary": "An Op to exchange data across TPU replicas.",
    "description": "On each replica, the input is split into `split_count` blocks along\n`split_dimension` and send to the other replicas given group_assignment. After\nreceiving `split_count` - 1 blocks from other replicas, we concatenate the\nblocks along `concat_dimension` as the output.\n\nFor example, suppose there are 2 TPU replicas:\nreplica 0 receives input: `[[A, B]]`\nreplica 1 receives input: `[[C, D]]`\n\ngroup_assignment=`[[0, 1]]`\nconcat_dimension=0\nsplit_dimension=1\nsplit_count=2\n\nreplica 0's output: `[[A], [C]]`\nreplica 1's output: `[[B], [D]]`",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "The type of elements to be exchanged. Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`, `bool`."
      },
      {
        "name": "concat_dimension",
        "type": "int64",
        "description": "The dimension number to concatenate."
      },
      {
        "name": "split_dimension",
        "type": "int64",
        "description": "The dimension number to split."
      },
      {
        "name": "split_count",
        "type": "int64",
        "description": "The number of splits, this number must equal to the sub-group\nsize(group_assignment.get_shape()[1])"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The local input to the sum.",
        "typeAttr": "T"
      },
      {
        "name": "group_assignment",
        "description": "An int32 tensor with shape\n[num_groups, num_replicas_per_group]. `group_assignment[i]` represents the\nreplica ids in the ith subgroup.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The exchanged result.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Angle",
    "summary": "Returns the argument of a complex number.",
    "description": "Given a tensor `input` of complex numbers, this operation returns a tensor of\ntype `float` that is the argument of each element in `input`. All elements in\n`input` must be complex numbers of the form \\\\(a + bj\\\\), where *a*\nis the real part and *b* is the imaginary part.\n\nThe argument returned by this operation is of the form \\\\(atan2(b, a)\\\\).\n\nFor example:\n\n```\n# tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]\ntf.math.angle(input) ==> [2.0132, 1.056]\n```\n\n@compatibility(numpy)\nEquivalent to np.angle.\n@end_compatibility",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      },
      {
        "name": "Tout",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "AnonymousHashTable",
    "summary": "Creates a uninitialized anonymous hash table.",
    "description": "This op creates a new anonymous hash table (as a resource) everytime\nit is executed, with the specified dtype of its keys and values,\nreturning the resource handle.  Before using the table you will have\nto initialize it.  After initialization the table will be\nimmutable. The table is anonymous in the sense that it can only be\naccessed by the returned resource handle (e.g. it cannot be looked up\nby a name in a resource manager). The table will be automatically\ndeleted when all resource handles pointing to it are gone.",
    "attributes": [
      {
        "name": "key_dtype",
        "type": "type",
        "description": "Type of the table keys."
      },
      {
        "name": "value_dtype",
        "type": "type",
        "description": "Type of the table values."
      }
    ],
    "outputs": [
      {
        "name": "table_handle",
        "description": "The resource handle to the newly created hash-table resource.",
        "type": 20
      }
    ]
  },
  {
    "name": "AnonymousIterator",
    "summary": "A container for an iterator resource.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "A handle to the iterator that can be passed to a \"MakeIterator\" or\n\"IteratorGetNext\" op. In contrast to Iterator, AnonymousIterator prevents\nresource sharing by name, and does not keep a reference to the resource\ncontainer.",
        "type": 20
      }
    ]
  },
  {
    "name": "AnonymousIteratorV2",
    "summary": "A container for an iterator resource.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "A handle to the iterator that can be passed to a \"MakeIterator\" or\n\"IteratorGetNext\" op. In contrast to Iterator, AnonymousIterator prevents\nresource sharing by name, and does not keep a reference to the resource\ncontainer.",
        "type": 20
      },
      {
        "name": "deleter",
        "description": "A variant deleter that should be passed into the op that deletes the iterator.",
        "type": 21
      }
    ]
  },
  {
    "name": "AnonymousIteratorV3",
    "summary": "A container for an iterator resource.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "A handle to the iterator that can be passed to a \"MakeIterator\" or\n\"IteratorGetNext\" op. In contrast to Iterator, AnonymousIterator prevents\nresource sharing by name, and does not keep a reference to the resource\ncontainer.",
        "type": 20
      }
    ]
  },
  {
    "name": "AnonymousMemoryCache",
    "outputs": [
      {
        "name": "handle",
        "type": 20
      },
      {
        "name": "deleter",
        "type": 21
      }
    ]
  },
  {
    "name": "AnonymousMultiDeviceIterator",
    "summary": "A container for a multi device iterator resource.",
    "attributes": [
      {
        "name": "devices",
        "type": "string[]",
        "minimum": 1
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "A handle to a multi device iterator that can be passed to a\n\"MultiDeviceIteratorGetNextFromShard\" op. In contrast to MultiDeviceIterator,\nAnonymousIterator prevents resource sharing by name, and does not keep a\nreference to the resource container.",
        "type": 20
      },
      {
        "name": "deleter",
        "description": "A variant deleter that should be passed into the op that deletes the iterator.",
        "type": 21
      }
    ]
  },
  {
    "name": "AnonymousMultiDeviceIteratorV3",
    "summary": "A container for a multi device iterator resource.",
    "attributes": [
      {
        "name": "devices",
        "type": "string[]",
        "minimum": 1
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "A handle to a multi device iterator that can be passed to a\n\"MultiDeviceIteratorGetNextFromShard\" op. In contrast to MultiDeviceIterator,\nAnonymousIterator prevents resource sharing by name, and does not keep a\nreference to the resource container.",
        "type": 20
      }
    ]
  },
  {
    "name": "AnonymousMutableDenseHashTable",
    "summary": "Creates an empty anonymous mutable hash table that uses tensors as the backing store.",
    "description": "This op creates a new anonymous mutable hash table (as a resource) everytime\nit is executed, with the specified dtype of its keys and values,\nreturning the resource handle. Each value must be a scalar.\nData can be inserted into the table using\nthe insert operations. It does not support the initialization operation.\n\nIt uses \"open addressing\" with quadratic reprobing to resolve\ncollisions.\n\nThe table is anonymous in the sense that it can only be\naccessed by the returned resource handle (e.g. it cannot be looked up\nby a name in a resource manager). The table will be automatically\ndeleted when all resource handles pointing to it are gone.",
    "attributes": [
      {
        "name": "key_dtype",
        "type": "type",
        "description": "Type of the table keys."
      },
      {
        "name": "value_dtype",
        "type": "type",
        "description": "Type of the table values."
      },
      {
        "name": "value_shape",
        "type": "shape",
        "description": "The shape of each value.",
        "default": {
          "type": "shape",
          "value": "?"
        }
      },
      {
        "name": "initial_num_buckets",
        "type": "int64",
        "description": "The initial number of hash table buckets. Must be a power\nto 2.",
        "default": 131072
      },
      {
        "name": "max_load_factor",
        "type": "float32",
        "description": "The maximum ratio between number of entries and number of\nbuckets before growing the table. Must be between 0 and 1.",
        "default": 0.800000011920929
      }
    ],
    "inputs": [
      {
        "name": "empty_key",
        "description": "The key used to represent empty key buckets internally. Must not\nbe used in insert or lookup operations.",
        "typeAttr": "key_dtype"
      },
      {
        "name": "deleted_key",
        "typeAttr": "key_dtype"
      }
    ],
    "outputs": [
      {
        "name": "table_handle",
        "description": "The resource handle to the newly created hash-table resource.",
        "type": 20
      }
    ]
  },
  {
    "name": "AnonymousMutableHashTable",
    "summary": "Creates an empty anonymous mutable hash table.",
    "description": "This op creates a new anonymous mutable hash table (as a resource) everytime\nit is executed, with the specified dtype of its keys and values,\nreturning the resource handle. Each value must be a scalar.\nData can be inserted into the table using\nthe insert operations. It does not support the initialization operation.\nThe table is anonymous in the sense that it can only be\naccessed by the returned resource handle (e.g. it cannot be looked up\nby a name in a resource manager). The table will be automatically\ndeleted when all resource handles pointing to it are gone.",
    "attributes": [
      {
        "name": "key_dtype",
        "type": "type",
        "description": "Type of the table keys."
      },
      {
        "name": "value_dtype",
        "type": "type",
        "description": "Type of the table values."
      }
    ],
    "outputs": [
      {
        "name": "table_handle",
        "description": "The resource handle to the newly created hash-table resource.",
        "type": 20
      }
    ]
  },
  {
    "name": "AnonymousMutableHashTableOfTensors",
    "summary": "Creates an empty anonymous mutable hash table of vector values.",
    "description": "This op creates a new anonymous mutable hash table (as a resource) everytime\nit is executed, with the specified dtype of its keys and values,\nreturning the resource handle. Each value must be a vector.\nData can be inserted into the table using\nthe insert operations. It does not support the initialization operation.\nThe table is anonymous in the sense that it can only be\naccessed by the returned resource handle (e.g. it cannot be looked up\nby a name in a resource manager). The table will be automatically\ndeleted when all resource handles pointing to it are gone.",
    "attributes": [
      {
        "name": "key_dtype",
        "type": "type",
        "description": "Type of the table keys."
      },
      {
        "name": "value_dtype",
        "type": "type",
        "description": "Type of the table values."
      },
      {
        "name": "value_shape",
        "type": "shape",
        "default": {
          "type": "shape",
          "value": "?"
        }
      }
    ],
    "outputs": [
      {
        "name": "table_handle",
        "description": "The resource handle to the newly created hash-table resource.",
        "type": 20
      }
    ]
  },
  {
    "name": "AnonymousRandomSeedGenerator",
    "inputs": [
      {
        "name": "seed",
        "type": 9
      },
      {
        "name": "seed2",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 20
      },
      {
        "name": "deleter",
        "type": 21
      }
    ]
  },
  {
    "name": "AnonymousSeedGenerator",
    "inputs": [
      {
        "name": "seed",
        "type": 9
      },
      {
        "name": "seed2",
        "type": 9
      },
      {
        "name": "reshuffle",
        "type": 10
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 20
      },
      {
        "name": "deleter",
        "type": 21
      }
    ]
  },
  {
    "name": "Any",
    "summary": "Computes the \"logical or\" of elements across dimensions of a tensor.",
    "description": "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1.",
    "attributes": [
      {
        "name": "keep_dims",
        "type": "boolean",
        "description": "If true, retain reduced dimensions with length 1.",
        "default": false
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The tensor to reduce.",
        "type": 10
      },
      {
        "name": "reduction_indices",
        "description": "The dimensions to reduce. Must be in the range\n`[-rank(input), rank(input))`.",
        "typeAttr": "Tidx"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The reduced tensor.",
        "type": 10
      }
    ]
  },
  {
    "name": "ApplyAdaMax",
    "summary": "Update '*var' according to the AdaMax algorithm.",
    "description": "m_t <- beta1 * m_{t-1} + (1 - beta1) * g\nv_t <- max(beta2 * v_{t-1}, abs(g))\nvariable <- variable - learning_rate / (1 - beta1^t) * m_t / (v_t + epsilon)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var, m, and v tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "m",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "v",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "beta1_power",
        "description": "Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "beta1",
        "description": "Momentum factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "beta2",
        "description": "Momentum factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "epsilon",
        "description": "Ridge term. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ApplyAdadelta",
    "summary": "Update '*var' according to the adadelta scheme.",
    "description": "accum = rho() * accum + (1 - rho()) * grad.square();\nupdate = (update_accum + epsilon).sqrt() * (accum + epsilon()).rsqrt() * grad;\nupdate_accum = rho() * update_accum + (1 - rho()) * update.square();\nvar -= update;",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, updating of the var, accum and update_accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "accum_update",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "rho",
        "description": "Decay factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "epsilon",
        "description": "Constant factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ApplyAdagrad",
    "summary": "Update '*var' according to the adagrad scheme.",
    "description": "accum += grad * grad\nvar -= lr * grad * (1 / sqrt(accum))",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "update_slots",
        "type": "boolean",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ApplyAdagradDA",
    "summary": "Update '*var' according to the proximal adagrad scheme.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "gradient_accumulator",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "gradient_squared_accumulator",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l1",
        "description": "L1 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2",
        "description": "L2 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "global_step",
        "description": "Training step number. Must be a scalar.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ApplyAdagradV2",
    "summary": "Update '*var' according to the adagrad scheme.",
    "description": "accum += grad * grad\nvar -= lr * grad * (1 / sqrt(accum))",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "update_slots",
        "type": "boolean",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "epsilon",
        "description": "Constant factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ApplyAdam",
    "summary": "Update '*var' according to the Adam algorithm.",
    "description": "$$\\text{lr}_t := \\mathrm{lr} \\cdot \\frac{\\sqrt{1 - \\beta_2^t}}{1 - \\beta_1^t}$$\n$$m_t := \\beta_1 \\cdot m_{t-1} + (1 - \\beta_1) \\cdot g$$\n$$v_t := \\beta_2 \\cdot v_{t-1} + (1 - \\beta_2) \\cdot g^2$$\n$$\\text{var} := \\begin{cases} \\text{var} - (m_t \\beta_1 + g \\cdot (1 - \\beta_1))\\cdot\\text{lr}_t/(\\sqrt{v_t} + \\epsilon), &\\text{if use_nesterov}\\\\\\\\  \\text{var} - m_t \\cdot \\text{lr}_t /(\\sqrt{v_t} + \\epsilon), &\\text{otherwise} \\end{cases}$$",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var, m, and v tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "use_nesterov",
        "type": "boolean",
        "description": "If `True`, uses the nesterov update.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "m",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "v",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "beta1_power",
        "description": "Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "beta2_power",
        "description": "Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "beta1",
        "description": "Momentum factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "beta2",
        "description": "Momentum factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "epsilon",
        "description": "Ridge term. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ApplyAddSign",
    "summary": "Update '*var' according to the AddSign update.",
    "description": "m_t <- beta1 * m_{t-1} + (1 - beta1) * g\nupdate <- (alpha + sign_decay * sign(g) *sign(m)) * g\nvariable <- variable - lr_t * update",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and m tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "m",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "alpha",
        "description": "Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "sign_decay",
        "description": "Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "beta",
        "description": "Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ApplyCenteredRMSProp",
    "summary": "Update '*var' according to the centered RMSProp algorithm.",
    "description": "The centered RMSProp algorithm uses an estimate of the centered second moment\n(i.e., the variance) for normalization, as opposed to regular RMSProp, which\nuses the (uncentered) second moment. This often helps with training, but is\nslightly more expensive in terms of computation and memory.\n\nNote that in dense implementation of this algorithm, mg, ms, and mom will\nupdate even if the grad is zero, but in this sparse implementation, mg, ms,\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nmean_grad = decay * mean_grad + (1-decay) * gradient\n\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)\n\nmg <- rho * mg_{t-1} + (1-rho) * grad\nms <- rho * ms_{t-1} + (1-rho) * grad * grad\nmom <- momentum * mom_{t-1} + lr * grad / sqrt(ms - mg * mg + epsilon)\nvar <- var - mom",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var, mg, ms, and mom tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "mg",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "ms",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "mom",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "rho",
        "description": "Decay rate. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "momentum",
        "description": "Momentum Scale. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "epsilon",
        "description": "Ridge term. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ApplyFtrl",
    "summary": "Update '*var' according to the Ftrl-proximal scheme.",
    "description": "accum_new = accum + grad * grad\nlinear += grad - (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "multiply_linear_by_lr",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "linear",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l1",
        "description": "L1 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2",
        "description": "L2 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "lr_power",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ApplyFtrlV2",
    "summary": "Update '*var' according to the Ftrl-proximal scheme.",
    "description": "grad_with_shrinkage = grad + 2 * l2_shrinkage * var\naccum_new = accum + grad * grad\nlinear += grad_with_shrinkage -\n    (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "multiply_linear_by_lr",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "linear",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l1",
        "description": "L1 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2",
        "description": "L2 shrinkage regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2_shrinkage",
        "typeAttr": "T"
      },
      {
        "name": "lr_power",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ApplyGradientDescent",
    "summary": "Update '*var' by subtracting 'alpha' * 'delta' from it.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "alpha",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "delta",
        "description": "The change.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ApplyMomentum",
    "summary": "Update '*var' according to the momentum scheme.",
    "description": "Set use_nesterov = True if you want to use Nesterov momentum.\n\naccum = accum * momentum + grad\nvar -= lr * accum",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "use_nesterov",
        "type": "boolean",
        "description": "If `True`, the tensor passed to compute grad will be\nvar - lr * momentum * accum, so in the end, the var you get is actually\nvar - lr * momentum * accum.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "momentum",
        "description": "Momentum. Must be a scalar.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ApplyPowerSign",
    "summary": "Update '*var' according to the AddSign update.",
    "description": "m_t <- beta1 * m_{t-1} + (1 - beta1) * g\nupdate <- exp(logbase * sign_decay * sign(g) * sign(m_t)) * g\nvariable <- variable - lr_t * update",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and m tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "m",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "logbase",
        "description": "Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "sign_decay",
        "description": "Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "beta",
        "description": "Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ApplyProximalAdagrad",
    "summary": "Update '*var' and '*accum' according to FOBOS with Adagrad learning rate.",
    "description": "accum += grad * grad\nprox_v = var - lr * grad * (1 / sqrt(accum))\nvar = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l1",
        "description": "L1 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2",
        "description": "L2 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ApplyProximalGradientDescent",
    "summary": "Update '*var' as FOBOS algorithm with fixed learning rate.",
    "description": "prox_v = var - alpha * delta\nvar = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "alpha",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l1",
        "description": "L1 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2",
        "description": "L2 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "delta",
        "description": "The change.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ApplyRMSProp",
    "summary": "Update '*var' according to the RMSProp algorithm.",
    "description": "Note that in dense implementation of this algorithm, ms and mom will\nupdate even if the grad is zero, but in this sparse implementation, ms\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon)\n\nms <- rho * ms_{t-1} + (1-rho) * grad * grad\nmom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)\nvar <- var - mom",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var, ms, and mom tensors is protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "ms",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "mom",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "rho",
        "description": "Decay rate. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "momentum",
        "typeAttr": "T"
      },
      {
        "name": "epsilon",
        "description": "Ridge term. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ApproxTopK",
    "summary": "Returns min/max k values and their indices of the input operand in an approximate manner.",
    "description": "See https://arxiv.org/abs/2206.14286 for the algorithm details.\nThis op is only optimized on TPU currently.",
    "attributes": [
      {
        "name": "k",
        "type": "int64",
        "description": "Specifies the number of min/max-k.",
        "minimum": 0
      },
      {
        "name": "reduction_dimension",
        "type": "int64",
        "description": "Integer dimension along which to search. Default: -1.",
        "default": -1
      },
      {
        "name": "recall_target",
        "type": "float32",
        "description": "Recall target for the approximation. Range in (0,1]",
        "default": 0.949999988079071
      },
      {
        "name": "is_max_k",
        "type": "boolean",
        "description": "When true, computes max-k; otherwise computes min-k.",
        "default": true
      },
      {
        "name": "reduction_input_size_override",
        "type": "int64",
        "description": "When set to a positive value, it overrides the size determined by\n`input[reduction_dim]` for evaluating the recall. This option is useful when\nthe given `input` is only a subset of the overall computation in SPMD or\ndistributed pipelines, where the true input size cannot be deferred by the\n`input` shape.",
        "default": -1
      },
      {
        "name": "aggregate_to_topk",
        "type": "boolean",
        "description": "When true, aggregates approximate results to top-k. When false, returns the\napproximate results. The number of the approximate results is implementation\ndefined and is greater equals to the specified `k`.",
        "default": true
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Array to search. Must be at least 1-D of the floating type",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "values",
        "description": "The min/max k values along the `reduction_dimension` of the `input` operand.\nThe dimension are the same as the `input` operand except for the\n`reduction_dimension`: when `aggregate_to_topk` is true, the reduction\ndimension is `k`; otherwise, it is greater equals to `k` where the size is\nimplementation-defined.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "The indices of `values` along the `reduction_dimension` of the `input` operand.",
        "type": 3
      }
    ]
  },
  {
    "name": "ApproximateEqual",
    "summary": "Returns the truth value of abs(x-y) < tolerance element-wise.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "tolerance",
        "type": "float32",
        "default": 9.999999747378752e-06
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "type": 10
      }
    ]
  },
  {
    "name": "ArgMax",
    "summary": "Returns the index with the largest value across dimensions of a tensor.",
    "description": "Note that in case of ties the identity of the return value is not guaranteed.\n\nUsage:\n  ```python\n  import tensorflow as tf\n  a = [1, 10, 26.9, 2.8, 166.32, 62.3]\n  b = tf.math.argmax(input = a)\n  c = tf.keras.backend.eval(b)\n  # c = 4\n  # here a[4] = 166.32 which is the largest element of a across axis 0\n  ```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`, `qint8`, `quint8`, `qint32`, `qint16`, `quint16`, `bool`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int16`, `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "output_type",
        "type": "type",
        "description": "Must be one of the following: `int16`, `uint16`, `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "dimension",
        "description": "int16, int32 or int64, must be in the range `[-rank(input), rank(input))`.\nDescribes which dimension of the input Tensor to reduce across. For vectors,\nuse dimension = 0.",
        "typeAttr": "Tidx"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "output_type"
      }
    ]
  },
  {
    "name": "ArgMin",
    "summary": "Returns the index with the smallest value across dimensions of a tensor.",
    "description": "Note that in case of ties the identity of the return value is not guaranteed.\n\nUsage:\n  ```python\n  import tensorflow as tf\n  a = [1, 10, 26.9, 2.8, 166.32, 62.3]\n  b = tf.math.argmin(input = a)\n  c = tf.keras.backend.eval(b)\n  # c = 0\n  # here a[0] = 1 which is the smallest element of a across axis 0\n  ```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`, `qint8`, `quint8`, `qint32`, `qint16`, `quint16`, `bool`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "output_type",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "dimension",
        "description": "int32 or int64, must be in the range `[-rank(input), rank(input))`.\nDescribes which dimension of the input Tensor to reduce across. For vectors,\nuse dimension = 0.",
        "typeAttr": "Tidx"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "output_type"
      }
    ]
  },
  {
    "name": "AsString",
    "summary": "Converts each entry in the given tensor to strings.",
    "description": "Supports many numeric types and boolean.\n\nFor Unicode, see the\n[https://www.tensorflow.org/tutorials/representation/unicode](Working with Unicode text)\ntutorial.\n\nExamples:\n\n>>> tf.strings.as_string([3, 2])\n<tf.Tensor: shape=(2,), dtype=string, numpy=array([b'3', b'2'], dtype=object)>\n>>> tf.strings.as_string([3.1415926, 2.71828], precision=2).numpy()\narray([b'3.14', b'2.72'], dtype=object)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`, `complex64`, `complex128`, `bool`, `variant`, `string`."
      },
      {
        "name": "precision",
        "type": "int64",
        "description": "The post-decimal precision to use for floating point numbers.\nOnly used if precision > -1.",
        "default": -1
      },
      {
        "name": "scientific",
        "type": "boolean",
        "description": "Use scientific notation for floating point numbers.",
        "default": false
      },
      {
        "name": "shortest",
        "type": "boolean",
        "description": "Use shortest representation (either scientific or standard) for\nfloating point numbers.",
        "default": false
      },
      {
        "name": "width",
        "type": "int64",
        "description": "Pad pre-decimal numbers to this width.\nApplies to both floating point and integer numbers.\nOnly used if width > -1.",
        "default": -1
      },
      {
        "name": "fill",
        "type": "string",
        "description": "The value to pad if width > -1.  If empty, pads with spaces.\nAnother typical value is '0'.  String cannot be longer than 1 character.",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 7
      }
    ]
  },
  {
    "name": "Asin",
    "summary": "Computes the trignometric inverse sine of x element-wise.",
    "description": "The `tf.math.asin` operation returns the inverse of `tf.math.sin`, such that\nif `y = tf.math.sin(x)` then, `x = tf.math.asin(y)`.\n\n**Note**: The output of `tf.math.asin` will lie within the invertible range\nof sine, i.e [-pi/2, pi/2].\n\nFor example:\n\n```python\n# Note: [1.047, 0.785] ~= [(pi/3), (pi/4)]\nx = tf.constant([1.047, 0.785])\ny = tf.math.sin(x) # [0.8659266, 0.7068252]\n\ntf.math.asin(y) # [1.047, 0.785] = x\n```\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Asinh",
    "summary": "Computes inverse hyperbolic sine of x element-wise.",
    "description": "  Given an input tensor, this function computes inverse hyperbolic sine\n  for every element in the tensor. Both input and output has a range of\n  `[-inf, inf]`.\n\n  ```python\n  x = tf.constant([-float(\"inf\"), -2, -0.5, 1, 1.2, 200, 10000, float(\"inf\")])\n  tf.math.asinh(x) ==> [-inf -1.4436355 -0.4812118 0.8813736 1.0159732 5.991471 9.903487 inf]\n  ```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Assert",
    "summary": "Asserts that the given condition is true.",
    "description": "If `condition` evaluates to false, print the list of tensors in `data`.\n`summarize` determines how many entries of the tensors to print.",
    "attributes": [
      {
        "name": "T",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "summarize",
        "type": "int64",
        "description": "Print this many entries of each tensor.",
        "default": 3
      }
    ],
    "inputs": [
      {
        "name": "condition",
        "description": "The condition to evaluate.",
        "type": 10
      },
      {
        "name": "data",
        "description": "The tensors to print out when condition is false.",
        "typeListAttr": "T"
      }
    ]
  },
  {
    "name": "AssertCardinalityDataset",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "cardinality",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "AssertNextDataset",
    "summary": "A transformation that asserts which transformations happen next.",
    "description": "This transformation checks whether the camel-case names (i.e. \"FlatMap\", not\n\"flat_map\") of the transformations following this transformation match the list\nof names in the `transformations` argument. If there is a mismatch, the\ntransformation raises an exception.\n\nThe check occurs when iterating over the contents of the dataset, which\nmeans that the check happens *after* any static optimizations are applied\nto the dataset graph.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the input dataset.\n`AssertNextDataset` passes through the outputs of its input dataset.",
        "type": 21
      },
      {
        "name": "transformations",
        "description": "A `tf.string` vector `tf.Tensor` identifying the transformations that are\nexpected to happen next.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "AssertPrevDataset",
    "summary": "A transformation that asserts which transformations happened previously.",
    "description": "This transformation checks the names and, optionally, the attribute name-value\npairs in the `transformations` argument against those of the transformations\nthat preceded this transformation.  If there is a mismatch, the transformation\nraises an exception.\n\nThe check occurs when iterating over the contents of the dataset, which\nmeans that the check happens *after* any static optimizations are applied\nto the dataset graph.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the input dataset.\n`AssertPrevDataset` passes through the outputs of its input dataset.",
        "type": 21
      },
      {
        "name": "transformations",
        "description": "A `tf.string` vector `tf.Tensor` identifying the transformations, with optional\nattribute name-value pairs, that are expected to have happened previously.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "Assign",
    "category": "Control",
    "summary": "Update 'ref' by assigning 'value' to it.",
    "description": "This operation outputs \"ref\" after the assignment is done.\nThis makes it easier to chain operations that need to use the reset value.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "validate_shape",
        "type": "boolean",
        "description": "If true, the operation will validate that the shape\nof 'value' matches the shape of the Tensor being assigned to.  If false,\n'ref' will take on the shape of 'value'.",
        "default": true
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, the assignment will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "description": "Should be from a `Variable` node. May be uninitialized.",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "value",
        "description": "The value to be assigned to the variable.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output_ref",
        "description": "= Same as \"ref\".  Returned as a convenience for operations that want\nto use the new value after the variable has been reset.",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "AssignAdd",
    "summary": "Update 'ref' by adding 'value' to it.",
    "description": "This operation outputs \"ref\" after the update is done.\nThis makes it easier to chain operations that need to use the reset value.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, the addition will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "description": "Should be from a `Variable` node.",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "value",
        "description": "The value to be added to the variable.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output_ref",
        "description": "= Same as \"ref\".  Returned as a convenience for operations that want\nto use the new value after the variable has been updated.",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "AssignAddVariableOp",
    "summary": "Adds a value to the current value of a variable.",
    "description": "Any ReadVariableOp with a control dependency on this op is guaranteed to\nsee the incremented value or a subsequent newer one.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "the dtype of the value."
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "description": "handle to the resource in which to store the variable.",
        "type": 20
      },
      {
        "name": "value",
        "description": "the value by which the variable will be incremented.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "AssignSub",
    "summary": "Update 'ref' by subtracting 'value' from it.",
    "description": "This operation outputs \"ref\" after the update is done.\nThis makes it easier to chain operations that need to use the reset value.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "description": "Should be from a `Variable` node.",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "value",
        "description": "The value to be subtracted to the variable.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output_ref",
        "description": "= Same as \"ref\".  Returned as a convenience for operations that want\nto use the new value after the variable has been updated.",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "AssignSubVariableOp",
    "summary": "Subtracts a value from the current value of a variable.",
    "description": "Any ReadVariableOp with a control dependency on this op is guaranteed to\nsee the decremented value or a subsequent newer one.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "the dtype of the value."
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "description": "handle to the resource in which to store the variable.",
        "type": 20
      },
      {
        "name": "value",
        "description": "the value by which the variable will be incremented.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "AssignVariableOp",
    "summary": "Assigns a new value to a variable.",
    "description": "Any ReadVariableOp with a control dependency on this op is guaranteed to return\nthis value or a subsequent newer value of the variable.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "the dtype of the value."
      },
      {
        "name": "validate_shape",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "description": "handle to the resource in which to store the variable.",
        "type": 20
      },
      {
        "name": "value",
        "description": "the value to set the new tensor to use.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "AssignVariableXlaConcatND",
    "summary": "Concats input tensor across all dimensions.",
    "description": "An op which merges slices the input tensor based on the given num_splits\nattribute, strips paddings optionally, and writes the merged tensor without\npaddings to the resource variable.\n\nThis op may be generated via the TPU bridge.\n\nFor example, with `input` tensor:\n```\n[[0, 1],\n [4, 5]]\n[[2, 3],\n [6, 7]]\n[[8, 9],\n [12, 13]]\n[[10, 11],\n [14, 15]]\n```\n`num_splits`:\n```\n[2, 2]\n```\nand `paddings`:\n```\n[1, 1]\n```\nthe expected `outputs` is:\n```\n[[0, 1, 2],\n [4, 5, 6],\n [8, 9, 10]]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "num_concats",
        "type": "int64[]",
        "description": "Number of ways to merge per dimension."
      },
      {
        "name": "paddings",
        "type": "int64[]",
        "description": "Optional list of right paddings per dimension to strip from the final merged\ntensor. These paddings must not exceed the dimension size of the merged result\nprior to stripping paddings.",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "description": "Resource variable for concatenated input tensors across all dimensions.",
        "type": 20
      },
      {
        "name": "inputs",
        "description": "Input tensor slices in row-major order to merge across all dimensions. All\ninputs must have the same shape.",
        "numberAttr": "N",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Atan",
    "summary": "Computes the trignometric inverse tangent of x element-wise.",
    "description": "The `tf.math.atan` operation returns the inverse of `tf.math.tan`, such that\nif `y = tf.math.tan(x)` then, `x = tf.math.atan(y)`.\n\n**Note**: The output of `tf.math.atan` will lie within the invertible range\nof tan, i.e (-pi/2, pi/2).\n\nFor example:\n\n```python\n# Note: [1.047, 0.785] ~= [(pi/3), (pi/4)]\nx = tf.constant([1.047, 0.785])\ny = tf.math.tan(x) # [1.731261, 0.99920404]\n\ntf.math.atan(y) # [1.047, 0.785] = x\n```\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Atan2",
    "summary": "Computes arctangent of `y/x` element-wise, respecting signs of the arguments.",
    "description": "This is the angle \\\\( \\theta \\in [-\\pi, \\pi] \\\\) such that\n\\\\[ x = r \\cos(\\theta) \\\\]\nand\n\\\\[ y = r \\sin(\\theta) \\\\]\nwhere \\\\(r = \\sqrt{x^2 + y^2} \\\\).\n\nFor example:\n\n>>> x = [1., 1.]\n>>> y = [1., -1.]\n>>> print((tf.math.atan2(y,x) * (180 / np.pi)).numpy())\n[ 45. -45.]\n\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "y",
        "typeAttr": "T"
      },
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Atanh",
    "summary": "Computes inverse hyperbolic tangent of x element-wise.",
    "description": "  Given an input tensor, this function computes inverse hyperbolic tangent\n  for every element in the tensor. Input range is `[-1,1]` and output range is\n  `[-inf, inf]`. If input is `-1`, output will be `-inf` and if the\n  input is `1`, output will be `inf`. Values outside the range will have\n  `nan` as output.\n\n  ```python\n  x = tf.constant([-float(\"inf\"), -1, -0.5, 1, 0, 0.5, 10, float(\"inf\")])\n  tf.math.atanh(x) ==> [nan -inf -0.54930615 inf  0. 0.54930615 nan nan]\n  ```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "AudioSpectrogram",
    "summary": "Produces a visualization of audio data over time.",
    "description": "Spectrograms are a standard way of representing audio information as a series of\nslices of frequency information, one slice for each window of time. By joining\nthese together into a sequence, they form a distinctive fingerprint of the sound\nover time.\n\nThis op expects to receive audio data as an input, stored as floats in the range\n-1 to 1, together with a window width in samples, and a stride specifying how\nfar to move the window between slices. From this it generates a three\ndimensional output. The first dimension is for the channels in the input, so a\nstereo audio input would have two here for example. The second dimension is time,\nwith successive frequency slices. The third dimension has an amplitude value for\neach frequency during that time slice.\n\nThis means the layout when converted and saved as an image is rotated 90 degrees\nclockwise from a typical spectrogram. Time is descending down the Y axis, and\nthe frequency decreases from left to right.\n\nEach value in the result represents the square root of the sum of the real and\nimaginary parts of an FFT on the current window of samples. In this way, the\nlowest dimension represents the power of each frequency in the current window,\nand adjacent windows are concatenated in the next dimension.\n\nTo get a more intuitive and visual look at what this operation does, you can run\ntensorflow/examples/wav_to_spectrogram to read in an audio file and save out the\nresulting spectrogram as a PNG image.",
    "attributes": [
      {
        "name": "window_size",
        "type": "int64",
        "description": "How wide the input window is in samples. For the highest efficiency\nthis should be a power of two, but other values are accepted."
      },
      {
        "name": "stride",
        "type": "int64",
        "description": "How widely apart the center of adjacent sample windows should be."
      },
      {
        "name": "magnitude_squared",
        "type": "boolean",
        "description": "Whether to return the squared magnitude or just the\nmagnitude. Using squared magnitude can avoid extra calculations.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Float representation of audio data.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "spectrogram",
        "description": "3D representation of the audio frequencies as an image.",
        "type": 1
      }
    ]
  },
  {
    "name": "AudioSummary",
    "summary": "Outputs a `Summary` protocol buffer with audio.",
    "description": "The summary has up to `max_outputs` summary values containing audio. The\naudio is built from `tensor` which must be 3-D with shape `[batch_size,\nframes, channels]` or 2-D with shape `[batch_size, frames]`. The values are\nassumed to be in the range of `[-1.0, 1.0]` with a sample rate of `sample_rate`.\n\nThe `tag` argument is a scalar `Tensor` of type `string`.  It is used to\nbuild the `tag` of the summary values:\n\n*  If `max_outputs` is 1, the summary value tag is '*tag*/audio'.\n*  If `max_outputs` is greater than 1, the summary value tags are\n   generated sequentially as '*tag*/audio/0', '*tag*/audio/1', etc.",
    "attributes": [
      {
        "name": "sample_rate",
        "type": "float32",
        "description": "The sample rate of the signal in hertz."
      },
      {
        "name": "max_outputs",
        "type": "int64",
        "description": "Max number of batch elements to generate audio for.",
        "minimum": 1,
        "default": 3
      }
    ],
    "inputs": [
      {
        "name": "tag",
        "description": "Scalar. Used to build the `tag` attribute of the summary values.",
        "type": 7
      },
      {
        "name": "tensor",
        "description": "2-D of shape `[batch_size, frames]`.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "summary",
        "description": "Scalar. Serialized `Summary` protocol buffer.",
        "type": 7
      }
    ]
  },
  {
    "name": "AudioSummaryV2",
    "summary": "Outputs a `Summary` protocol buffer with audio.",
    "description": "The summary has up to `max_outputs` summary values containing audio. The\naudio is built from `tensor` which must be 3-D with shape `[batch_size,\nframes, channels]` or 2-D with shape `[batch_size, frames]`. The values are\nassumed to be in the range of `[-1.0, 1.0]` with a sample rate of `sample_rate`.\n\nThe `tag` argument is a scalar `Tensor` of type `string`.  It is used to\nbuild the `tag` of the summary values:\n\n*  If `max_outputs` is 1, the summary value tag is '*tag*/audio'.\n*  If `max_outputs` is greater than 1, the summary value tags are\n   generated sequentially as '*tag*/audio/0', '*tag*/audio/1', etc.",
    "attributes": [
      {
        "name": "max_outputs",
        "type": "int64",
        "description": "Max number of batch elements to generate audio for.",
        "minimum": 1,
        "default": 3
      }
    ],
    "inputs": [
      {
        "name": "tag",
        "description": "Scalar. Used to build the `tag` attribute of the summary values.",
        "type": 7
      },
      {
        "name": "tensor",
        "description": "2-D of shape `[batch_size, frames]`.",
        "type": 1
      },
      {
        "name": "sample_rate",
        "description": "The sample rate of the signal in hertz.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "summary",
        "description": "Scalar. Serialized `Summary` protocol buffer.",
        "type": 7
      }
    ]
  },
  {
    "name": "AutoShardDataset",
    "summary": "Creates a dataset that shards the input dataset.",
    "description": "Creates a dataset that shards the input dataset by num_workers, returning a\nsharded dataset for the index-th worker. This attempts to automatically shard\na dataset by examining the Dataset graph and inserting a shard op before the\ninputs to a reader Dataset (e.g. CSVDataset, TFRecordDataset).\n\nThis dataset will throw a NotFound error if we cannot shard the dataset\nautomatically.",
    "attributes": [
      {
        "name": "auto_shard_policy",
        "type": "int64",
        "default": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "num_replicas",
        "type": "int64",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the input dataset.",
        "type": 21
      },
      {
        "name": "num_workers",
        "description": "A scalar representing the number of workers to distribute this dataset across.",
        "type": 9
      },
      {
        "name": "index",
        "description": "A scalar representing the index of the current worker out of num_workers.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "AvgPool",
    "category": "Pool",
    "summary": "Performs average pooling on the input.",
    "description": "Each entry in `output` is the mean of the corresponding size `ksize`\nwindow in `value`.",
    "attributes": [
      {
        "name": "ksize",
        "type": "int64[]",
        "description": "The size of the sliding window for each dimension of `value`.",
        "minimum": 4
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "The stride of the sliding window for each dimension of `value`.",
        "minimum": 4
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width]. Must be one of the following: `NHWC`, `NCHW`.",
        "default": "NHWC"
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "value",
        "description": "4-D with shape `[batch, height, width, channels]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The average pooled output tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "AvgPool3D",
    "summary": "Performs 3D average pooling on the input.",
    "description": "Each entry in `output` is the mean of the corresponding size `ksize` window in\n`value`.",
    "attributes": [
      {
        "name": "ksize",
        "type": "int64[]",
        "description": "1-D tensor of length 5. The size of the window for each dimension of\nthe input tensor. Must have `ksize[0] = ksize[4] = 1`.",
        "minimum": 5
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
        "minimum": 5
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width]. Must be one of the following: `NDHWC`, `NCDHW`.",
        "default": "NDHWC"
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Shape `[batch, depth, rows, cols, channels]` tensor to pool over.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The average pooled output tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "AvgPool3DGrad",
    "summary": "Computes gradients of average pooling function.",
    "attributes": [
      {
        "name": "ksize",
        "type": "int64[]",
        "description": "1-D tensor of length 5. The size of the window for each dimension of\nthe input tensor. Must have `ksize[0] = ksize[4] = 1`.",
        "minimum": 5
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
        "minimum": 5
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width]. Must be one of the following: `NDHWC`, `NCDHW`.",
        "default": "NDHWC"
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "orig_input_shape",
        "description": "The original input dimensions.",
        "type": 3
      },
      {
        "name": "grad",
        "description": "Output backprop of shape `[batch, depth, rows, cols, channels]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The backprop for input.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "AvgPoolGrad",
    "summary": "Computes gradients of the average pooling function.",
    "attributes": [
      {
        "name": "ksize",
        "type": "int64[]",
        "description": "The size of the sliding window for each dimension of the input.",
        "minimum": 4
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "The stride of the sliding window for each dimension of the input.",
        "minimum": 4
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width]. Must be one of the following: `NHWC`, `NCHW`.",
        "default": "NHWC"
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "orig_input_shape",
        "description": "1-D.  Shape of the original input to `avg_pool`.",
        "type": 3
      },
      {
        "name": "grad",
        "description": "4-D with shape `[batch, height, width, channels]`.  Gradients w.r.t.\nthe output of `avg_pool`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "4-D.  Gradients w.r.t. the input of `avg_pool`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BandedTriangularSolve",
    "attributes": [
      {
        "name": "lower",
        "type": "boolean",
        "default": true
      },
      {
        "name": "adjoint",
        "type": "boolean",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float64`, `float32`, `float16`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "matrix",
        "typeAttr": "T"
      },
      {
        "name": "rhs",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Barrier",
    "summary": "Defines a barrier that persists across different graph executions.",
    "description": "A barrier represents a key-value map, where each key is a string, and\neach value is a tuple of tensors.\n\nAt runtime, the barrier contains 'complete' and 'incomplete'\nelements. A complete element has defined tensors for all components of\nits value tuple, and may be accessed using BarrierTakeMany. An\nincomplete element has some undefined components in its value tuple,\nand may be updated using BarrierInsertMany.",
    "attributes": [
      {
        "name": "component_types",
        "type": "type[]",
        "description": "The type of each component in a value.",
        "minimum": 1
      },
      {
        "name": "shapes",
        "type": "shape[]",
        "description": "The shape of each component in a value. Each shape must be 1 in the\nfirst dimension. The length of this attr must be the same as the length of\ncomponent_types.",
        "minimum": 0,
        "default": []
      },
      {
        "name": "capacity",
        "type": "int64",
        "description": "The capacity of the barrier.  The default capacity is MAX_INT32,\nwhich is the largest capacity of the underlying queue.",
        "default": -1
      },
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this barrier is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this barrier will be shared under the given name\nacross multiple sessions.",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "The handle to the barrier.",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "BarrierClose",
    "summary": "Closes the given barrier.",
    "description": "This operation signals that no more new elements will be inserted in the\ngiven barrier. Subsequent InsertMany that try to introduce a new key will fail.\nSubsequent InsertMany operations that just add missing components to already\nexisting elements will continue to succeed. Subsequent TakeMany operations will\ncontinue to succeed if sufficient completed elements remain in the barrier.\nSubsequent TakeMany operations that would block will fail immediately.",
    "attributes": [
      {
        "name": "cancel_pending_enqueues",
        "type": "boolean",
        "description": "If true, all pending enqueue requests that are\nblocked on the barrier's queue will be canceled. InsertMany will fail, even\nif no new key is introduced.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a barrier.",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "BarrierIncompleteSize",
    "summary": "Computes the number of incomplete elements in the given barrier.",
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a barrier.",
        "type": 7,
        "isRef": true
      }
    ],
    "outputs": [
      {
        "name": "size",
        "description": "The number of incomplete elements (i.e. those with some of their value\ncomponents not set) in the barrier.",
        "type": 3
      }
    ]
  },
  {
    "name": "BarrierInsertMany",
    "summary": "For each key, assigns the respective value to the specified component.",
    "description": "If a key is not found in the barrier, this operation will create a new\nincomplete element. If a key is found in the barrier, and the element\nalready has a value at component_index, this operation will fail with\nINVALID_ARGUMENT, and leave the barrier in an undefined state.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "component_index",
        "type": "int64",
        "description": "The component of the barrier elements that is being assigned."
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a barrier.",
        "type": 7,
        "isRef": true
      },
      {
        "name": "keys",
        "description": "A one-dimensional tensor of keys, with length n.",
        "type": 7
      },
      {
        "name": "values",
        "description": "An any-dimensional tensor of values, which are associated with the\nrespective keys. The 0th dimension must have length n.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BarrierReadySize",
    "summary": "Computes the number of complete elements in the given barrier.",
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a barrier.",
        "type": 7,
        "isRef": true
      }
    ],
    "outputs": [
      {
        "name": "size",
        "description": "The number of complete elements (i.e. those with all of their value\ncomponents set) in the barrier.",
        "type": 3
      }
    ]
  },
  {
    "name": "BarrierTakeMany",
    "summary": "Takes the given number of completed elements from a barrier.",
    "description": "This operation concatenates completed-element component tensors along\nthe 0th dimension to make a single component tensor.\n\nElements come out of the barrier when they are complete, and in the order\nin which they were placed into the barrier.  The indices output provides\ninformation about the batch in which each element was originally inserted\ninto the barrier.",
    "attributes": [
      {
        "name": "component_types",
        "type": "type[]",
        "description": "The type of each component in a value.",
        "minimum": 1
      },
      {
        "name": "allow_small_batch",
        "type": "boolean",
        "description": "Allow to return less than num_elements items if barrier is\nalready closed.",
        "default": false
      },
      {
        "name": "wait_for_incomplete",
        "type": "boolean",
        "default": false
      },
      {
        "name": "timeout_ms",
        "type": "int64",
        "description": "If the queue is empty, this operation will block for up to\ntimeout_ms milliseconds.\nNote: This option is not supported yet.",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a barrier.",
        "type": 7,
        "isRef": true
      },
      {
        "name": "num_elements",
        "description": "A single-element tensor containing the number of elements to\ntake.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "indices",
        "description": "A one-dimensional tensor of indices, with length num_elems.\nThese indices refer to the batch in which the values were placed into the\nbarrier (starting with MIN_LONG and increasing with each BarrierInsertMany).",
        "type": 9
      },
      {
        "name": "keys",
        "description": "A one-dimensional tensor of keys, with length num_elements.",
        "type": 7
      },
      {
        "name": "values",
        "description": "One any-dimensional tensor per component in a barrier element. All\nvalues have length num_elements in the 0th dimension.",
        "typeListAttr": "component_types"
      }
    ]
  },
  {
    "name": "Batch",
    "summary": "Batches all input tensors nondeterministically.",
    "description": "When many instances of this Op are being run concurrently with the same\ncontainer/shared_name in the same device, some will output zero-shaped Tensors\nand others will output Tensors of size up to max_batch_size.\n\nAll Tensors in in_tensors are batched together (so, for example, labels and\nfeatures should be batched with a single instance of this operation.\n\nEach invocation of batch emits an `id` scalar which will be used to identify\nthis particular invocation when doing unbatch or its gradient.\n\nEach op which emits a non-empty batch will also emit a non-empty batch_index\nTensor, which, is a [K, 3] matrix where each row contains the invocation's id,\nstart, and length of elements of each set of Tensors present in batched_tensors.\n\nBatched tensors are concatenated along the first dimension, and all tensors in\nin_tensors must have the first dimension of the same size.\n\nin_tensors: The tensors to be batched.\nnum_batch_threads: Number of scheduling threads for processing batches of work.\n Determines the number of batches processed in parallel.\nmax_batch_size: Batch sizes will never be bigger than this.\nbatch_timeout_micros: Maximum number of microseconds to wait before outputting\n an incomplete batch.\nallowed_batch_sizes: Optional list of allowed batch sizes. If left empty, does\n nothing. Otherwise, supplies a list of batch sizes, causing the op to pad\n batches up to one of those sizes. The entries must increase monotonically, and\n the final entry must equal max_batch_size.\ngrad_timeout_micros: The timeout to use for the gradient. See Unbatch.\nbatched_tensors: Either empty tensors or a batch of concatenated Tensors.\nbatch_index: If out_tensors is non-empty, has information to invert it.\ncontainer: Controls the scope of sharing of this batch.\nid: always contains a scalar with a unique ID for this invocation of Batch.\nshared_name: Concurrently running instances of batch in the same device with the\n same container and shared_name will batch their elements together. If left\n empty, the op name will be used as the shared name.\nT: the types of tensors to be batched.",
    "attributes": [
      {
        "name": "num_batch_threads",
        "type": "int64"
      },
      {
        "name": "max_batch_size",
        "type": "int64"
      },
      {
        "name": "max_enqueued_batches",
        "type": "int64",
        "default": 10
      },
      {
        "name": "batch_timeout_micros",
        "type": "int64"
      },
      {
        "name": "allowed_batch_sizes",
        "type": "int64[]",
        "default": []
      },
      {
        "name": "grad_timeout_micros",
        "type": "int64"
      },
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "batching_queue",
        "type": "string",
        "default": ""
      },
      {
        "name": "T",
        "type": "type[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "in_tensors",
        "typeListAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "batched_tensors",
        "typeListAttr": "T"
      },
      {
        "name": "batch_index",
        "type": 9
      },
      {
        "name": "id",
        "type": 9
      }
    ]
  },
  {
    "name": "BatchCholesky",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float64`, `float32`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BatchCholeskyGrad",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "l",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BatchDataset",
    "summary": "Creates a dataset that batches `batch_size` elements from `input_dataset`.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "batch_size",
        "description": "A scalar representing the number of elements to accumulate in a\nbatch.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "BatchDatasetV2",
    "summary": "Creates a dataset that batches `batch_size` elements from `input_dataset`.",
    "attributes": [
      {
        "name": "parallel_copy",
        "type": "boolean",
        "default": false
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "batch_size",
        "description": "A scalar representing the number of elements to accumulate in a batch.",
        "type": 9
      },
      {
        "name": "drop_remainder",
        "description": "A scalar representing whether the last batch should be dropped in case its size\nis smaller than desired.",
        "type": 10
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "BatchFFT",
    "inputs": [
      {
        "name": "input",
        "type": 8
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 8
      }
    ]
  },
  {
    "name": "BatchFFT2D",
    "inputs": [
      {
        "name": "input",
        "type": 8
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 8
      }
    ]
  },
  {
    "name": "BatchFFT3D",
    "inputs": [
      {
        "name": "input",
        "type": 8
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 8
      }
    ]
  },
  {
    "name": "BatchFunction",
    "summary": "Batches all the inputs tensors to the computation done by the function.",
    "description": "So, for example, in the following code\n\n  ```python\n\n  # This input will be captured.\n  y = tf.placeholder_with_default(1.0, shape=[])\n\n  @tf.Defun(tf.float32)\n  def computation(a):\n    return tf.matmul(a, a) + y\n\n  b = gen_batch_ops.batch_function(\n          f=computation\n          in_tensors=[a],\n          captured_tensors=computation.captured_inputs,\n          Tout=[o.type for o in computation.definition.signature.output_arg],\n          num_batch_threads=1,\n          max_batch_size=10,\n          batch_timeout_micros=100000,  # 100ms\n          allowed_batch_sizes=[3, 10],\n          batching_queue=\"\")\n  ```\n\nIf more than one session.run call is simultaneously trying to compute `b`\nthe values of `a` will be gathered, non-deterministically concatenated\nalong the first axis, and only one thread will run the computation.\n\nAssumes that all arguments of the function are Tensors which will be batched\nalong their first dimension.\n\nArguments that are captured, are not batched. The session.run call which does\nthe concatenation, will use the values of the captured tensors available to it.\nTherefore, typical uses of captured tensors should involve values which remain\nunchanged across session.run calls. Inference is a good example of this.\n\nSparseTensor is not supported. The return value of the decorated function\nmust be a Tensor or a list/tuple of Tensors.",
    "attributes": [
      {
        "name": "f",
        "type": "function"
      },
      {
        "name": "num_batch_threads",
        "type": "int64",
        "description": "Number of scheduling threads for processing batches of work.\nDetermines the number of batches processed in parallel."
      },
      {
        "name": "max_batch_size",
        "type": "int64",
        "description": "Batch sizes will never be bigger than this."
      },
      {
        "name": "batch_timeout_micros",
        "type": "int64",
        "description": "Maximum number of microseconds to wait before outputting\nan incomplete batch."
      },
      {
        "name": "max_enqueued_batches",
        "type": "int64",
        "description": "Maximum number of batches enqueued. Default: 10.",
        "default": 10
      },
      {
        "name": "allowed_batch_sizes",
        "type": "int64[]",
        "description": "Optional list of allowed batch sizes. If left empty, does\nnothing. Otherwise, supplies a list of batch sizes, causing the op to pad\nbatches up to one of those sizes. The entries must increase monotonically.\nIf enable_large_batch_splitting is false (i.e., large-input-split is not\nenabled) the final entry must equal max_batch_size.",
        "default": []
      },
      {
        "name": "container",
        "type": "string",
        "description": "Controls the scope of sharing of this batch.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "Concurrently running instances of batch in the same device with the\nsame container and shared_name will batch their elements together. If left\nempty, the op name will be used as the shared name.",
        "default": ""
      },
      {
        "name": "batching_queue",
        "type": "string",
        "default": ""
      },
      {
        "name": "low_priority_max_batch_size",
        "type": "int64",
        "default": 0
      },
      {
        "name": "low_priority_batch_timeout_micros",
        "type": "int64",
        "default": 0
      },
      {
        "name": "low_priority_allowed_batch_sizes",
        "type": "int64[]",
        "default": []
      },
      {
        "name": "low_priority_max_enqueued_batches",
        "type": "int64",
        "default": 0
      },
      {
        "name": "mixed_priority_policy",
        "type": "string",
        "description": "Must be one of the following: `low_priority_padding_with_max_batch_size`, `low_priority_padding_with_next_allowed_batch_size`, `priority_isolation`.",
        "default": "low_priority_padding_with_max_batch_size"
      },
      {
        "name": "Tin",
        "type": "type[]",
        "description": "the types of tensors to be batched.",
        "minimum": 1
      },
      {
        "name": "Tcaptured",
        "type": "type[]",
        "description": "the types of the captured tensors.",
        "minimum": 0
      },
      {
        "name": "Tout",
        "type": "type[]",
        "description": "the types of the output tensors.",
        "minimum": 1
      },
      {
        "name": "enable_large_batch_splitting",
        "type": "boolean",
        "description": "input with a large size (i.e., larger than the largest value of\n`allowed_batch_sizes`) will be splitted into multiple batches with batch size.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "in_tensors",
        "description": "The tensors to be batched.",
        "typeListAttr": "Tin"
      },
      {
        "name": "captured_tensors",
        "description": "The tensors which are captured in the function, and don't need\nto be batched.",
        "typeListAttr": "Tcaptured"
      }
    ],
    "outputs": [
      {
        "name": "out_tensors",
        "description": "The output tensors.",
        "typeListAttr": "Tout"
      }
    ]
  },
  {
    "name": "BatchIFFT",
    "inputs": [
      {
        "name": "input",
        "type": 8
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 8
      }
    ]
  },
  {
    "name": "BatchIFFT2D",
    "inputs": [
      {
        "name": "input",
        "type": 8
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 8
      }
    ]
  },
  {
    "name": "BatchIFFT3D",
    "inputs": [
      {
        "name": "input",
        "type": 8
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 8
      }
    ]
  },
  {
    "name": "BatchMatMul",
    "summary": "Multiplies slices of two tensors in batches.",
    "description": "Multiplies all slices of `Tensor` `x` and `y` (each slice can be\nviewed as an element of a batch), and arranges the individual results\nin a single output tensor of the same batch size. Each of the\nindividual slices can optionally be adjointed (to adjoint a matrix\nmeans to transpose and conjugate it) before multiplication by setting\nthe `adj_x` or `adj_y` flag to `True`, which are by default `False`.\n\nThe input tensors `x` and `y` are 2-D or higher with shape `[..., r_x, c_x]`\nand `[..., r_y, c_y]`.\n\nThe output tensor is 2-D or higher with shape `[..., r_o, c_o]`, where:\n\n    r_o = c_x if adj_x else r_x\n    c_o = r_y if adj_y else c_y\n\nIt is computed as:\n\n    output[..., :, :] = matrix(x[..., :, :]) * matrix(y[..., :, :])",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `int32`, `int64`, `complex64`, `complex128`."
      },
      {
        "name": "adj_x",
        "type": "boolean",
        "description": "If `True`, adjoint the slices of `x`. Defaults to `False`.",
        "default": false
      },
      {
        "name": "adj_y",
        "type": "boolean",
        "description": "If `True`, adjoint the slices of `y`. Defaults to `False`.",
        "default": false
      },
      {
        "name": "grad_x",
        "type": "boolean",
        "default": false
      },
      {
        "name": "grad_y",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "2-D or higher with shape `[..., r_x, c_x]`.",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "description": "2-D or higher with shape `[..., r_y, c_y]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "3-D or higher with shape `[..., r_o, c_o]`",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BatchMatMulV2",
    "summary": "Multiplies slices of two tensors in batches.",
    "description": "Multiplies all slices of `Tensor` `x` and `y` (each slice can be\nviewed as an element of a batch), and arranges the individual results\nin a single output tensor of the same batch size. Each of the\nindividual slices can optionally be adjointed (to adjoint a matrix\nmeans to transpose and conjugate it) before multiplication by setting\nthe `adj_x` or `adj_y` flag to `True`, which are by default `False`.\n\nThe input tensors `x` and `y` are 2-D or higher with shape `[..., r_x, c_x]`\nand `[..., r_y, c_y]`.\n\nThe output tensor is 2-D or higher with shape `[..., r_o, c_o]`, where:\n\n    r_o = c_x if adj_x else r_x\n    c_o = r_y if adj_y else c_y\n\nIt is computed as:\n\n    output[..., :, :] = matrix(x[..., :, :]) * matrix(y[..., :, :])\n\n*NOTE*: `BatchMatMulV2` supports broadcasting in the batch dimensions. More\nabout broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html).\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `uint32`, `uint64`, `complex64`, `complex128`."
      },
      {
        "name": "adj_x",
        "type": "boolean",
        "description": "If `True`, adjoint the slices of `x`. Defaults to `False`.",
        "default": false
      },
      {
        "name": "adj_y",
        "type": "boolean",
        "description": "If `True`, adjoint the slices of `y`. Defaults to `False`.",
        "default": false
      },
      {
        "name": "grad_x",
        "type": "boolean",
        "default": false
      },
      {
        "name": "grad_y",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "2-D or higher with shape `[..., r_x, c_x]`.",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "description": "2-D or higher with shape `[..., r_y, c_y]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "3-D or higher with shape `[..., r_o, c_o]`",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BatchMatMulV3",
    "summary": "Multiplies slices of two tensors in batches.",
    "description": "Multiplies all slices of `Tensor` `x` and `y` (each slice can be\nviewed as an element of a batch), and arranges the individual results\nin a single output tensor of the same batch size. Each of the\nindividual slices can optionally be adjointed (to adjoint a matrix\nmeans to transpose and conjugate it) before multiplication by setting\nthe `adj_x` or `adj_y` flag to `True`, which are by default `False`.\n\nThe input tensors `x` and `y` are 2-D or higher with shape `[..., r_x, c_x]`\nand `[..., r_y, c_y]`.\n\nThe output tensor is 2-D or higher with shape `[..., r_o, c_o]`, where:\n\n    r_o = c_x if adj_x else r_x\n    c_o = r_y if adj_y else c_y\n\nIt is computed as:\n\n    output[..., :, :] = matrix(x[..., :, :]) * matrix(y[..., :, :])\n\n*NOTE*: `BatchMatMulV3` supports broadcasting in the batch dimensions. More\nabout broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html).\n",
    "attributes": [
      {
        "name": "Ta",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `uint8`, `int8`, `int16`, `int32`, `int64`, `complex64`, `complex128`."
      },
      {
        "name": "Tb",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `uint8`, `int8`, `int16`, `int32`, `int64`, `complex64`, `complex128`."
      },
      {
        "name": "Tout",
        "type": "type",
        "description": "If not spcified, Tout is the same type to input type. Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `int16`, `int32`, `int64`, `complex64`, `complex128`."
      },
      {
        "name": "adj_x",
        "type": "boolean",
        "description": "If `True`, adjoint the slices of `x`. Defaults to `False`.",
        "default": false
      },
      {
        "name": "adj_y",
        "type": "boolean",
        "description": "If `True`, adjoint the slices of `y`. Defaults to `False`.",
        "default": false
      },
      {
        "name": "grad_x",
        "type": "boolean",
        "default": false
      },
      {
        "name": "grad_y",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "2-D or higher with shape `[..., r_x, c_x]`.",
        "typeAttr": "Ta"
      },
      {
        "name": "y",
        "description": "2-D or higher with shape `[..., r_y, c_y]`.",
        "typeAttr": "Tb"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "3-D or higher with shape `[..., r_o, c_o]`",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "BatchMatrixBandPart",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "num_lower",
        "type": 9
      },
      {
        "name": "num_upper",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "band",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BatchMatrixDeterminant",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BatchMatrixDiag",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "diagonal",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BatchMatrixDiagPart",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "diagonal",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BatchMatrixInverse",
    "attributes": [
      {
        "name": "adjoint",
        "type": "boolean",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float64`, `float32`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BatchMatrixSetDiag",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "diagonal",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BatchMatrixSolve",
    "attributes": [
      {
        "name": "adjoint",
        "type": "boolean",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float64`, `float32`."
      }
    ],
    "inputs": [
      {
        "name": "matrix",
        "typeAttr": "T"
      },
      {
        "name": "rhs",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BatchMatrixSolveLs",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float64`, `float32`."
      },
      {
        "name": "fast",
        "type": "boolean",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "matrix",
        "typeAttr": "T"
      },
      {
        "name": "rhs",
        "typeAttr": "T"
      },
      {
        "name": "l2_regularizer",
        "type": 2
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BatchMatrixTriangularSolve",
    "attributes": [
      {
        "name": "lower",
        "type": "boolean",
        "default": true
      },
      {
        "name": "adjoint",
        "type": "boolean",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float64`, `float32`."
      }
    ],
    "inputs": [
      {
        "name": "matrix",
        "typeAttr": "T"
      },
      {
        "name": "rhs",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BatchNormWithGlobalNormalization",
    "category": "Normalization",
    "summary": "Batch normalization.",
    "description": "This op is deprecated. Prefer `tf.nn.batch_normalization`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "variance_epsilon",
        "type": "float32",
        "description": "A small float number to avoid dividing by 0."
      },
      {
        "name": "scale_after_normalization",
        "type": "boolean",
        "description": "A bool indicating whether the resulted tensor\nneeds to be multiplied with gamma."
      }
    ],
    "inputs": [
      {
        "name": "t",
        "description": "A 4D input Tensor.",
        "typeAttr": "T"
      },
      {
        "name": "m",
        "description": "A 1D mean Tensor with size matching the last dimension of t.\nThis is the first output from tf.nn.moments,\nor a saved moving average thereof.",
        "typeAttr": "T"
      },
      {
        "name": "v",
        "description": "A 1D variance Tensor with size matching the last dimension of t.\nThis is the second output from tf.nn.moments,\nor a saved moving average thereof.",
        "typeAttr": "T"
      },
      {
        "name": "beta",
        "description": "A 1D beta Tensor with size matching the last dimension of t.\nAn offset to be added to the normalized tensor.",
        "typeAttr": "T"
      },
      {
        "name": "gamma",
        "description": "A 1D gamma Tensor with size matching the last dimension of t.\nIf \"scale_after_normalization\" is true, this tensor will be multiplied\nwith the normalized tensor.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BatchNormWithGlobalNormalizationGrad",
    "summary": "Gradients for batch normalization.",
    "description": "This op is deprecated. See `tf.nn.batch_normalization`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "variance_epsilon",
        "type": "float32",
        "description": "A small float number to avoid dividing by 0."
      },
      {
        "name": "scale_after_normalization",
        "type": "boolean",
        "description": "A bool indicating whether the resulted tensor\nneeds to be multiplied with gamma."
      }
    ],
    "inputs": [
      {
        "name": "t",
        "description": "A 4D input Tensor.",
        "typeAttr": "T"
      },
      {
        "name": "m",
        "description": "A 1D mean Tensor with size matching the last dimension of t.\nThis is the first output from tf.nn.moments,\nor a saved moving average thereof.",
        "typeAttr": "T"
      },
      {
        "name": "v",
        "description": "A 1D variance Tensor with size matching the last dimension of t.\nThis is the second output from tf.nn.moments,\nor a saved moving average thereof.",
        "typeAttr": "T"
      },
      {
        "name": "gamma",
        "description": "A 1D gamma Tensor with size matching the last dimension of t.\nIf \"scale_after_normalization\" is true, this Tensor will be multiplied\nwith the normalized Tensor.",
        "typeAttr": "T"
      },
      {
        "name": "backprop",
        "description": "4D backprop Tensor.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "dx",
        "description": "4D backprop tensor for input.",
        "typeAttr": "T"
      },
      {
        "name": "dm",
        "description": "1D backprop tensor for mean.",
        "typeAttr": "T"
      },
      {
        "name": "dv",
        "description": "1D backprop tensor for variance.",
        "typeAttr": "T"
      },
      {
        "name": "db",
        "description": "1D backprop tensor for beta.",
        "typeAttr": "T"
      },
      {
        "name": "dg",
        "description": "1D backprop tensor for gamma.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BatchSelfAdjointEig",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float64`, `float32`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BatchSelfAdjointEigV2",
    "attributes": [
      {
        "name": "compute_v",
        "type": "boolean",
        "default": true
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float64`, `float32`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "e",
        "typeAttr": "T"
      },
      {
        "name": "v",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BatchSvd",
    "attributes": [
      {
        "name": "compute_uv",
        "type": "boolean",
        "default": true
      },
      {
        "name": "full_matrices",
        "type": "boolean",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float64`, `float32`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "s",
        "typeAttr": "T"
      },
      {
        "name": "u",
        "typeAttr": "T"
      },
      {
        "name": "v",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BatchToSpace",
    "summary": "BatchToSpace for 4-D tensors of type T.",
    "description": "This is a legacy version of the more general BatchToSpaceND.\n\nRearranges (permutes) data from batch into blocks of spatial data, followed by\ncropping. This is the reverse transformation of SpaceToBatch. More specifically,\nthis op outputs a copy of the input tensor where values from the `batch`\ndimension are moved in spatial blocks to the `height` and `width` dimensions,\nfollowed by cropping along the `height` and `width` dimensions.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "block_size",
        "type": "int64",
        "minimum": 2
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "4-D tensor with shape\n`[batch*block_size*block_size, height_pad/block_size, width_pad/block_size,\n  depth]`. Note that the batch size of the input tensor must be divisible by\n`block_size * block_size`.",
        "typeAttr": "T"
      },
      {
        "name": "crops",
        "description": "2-D tensor of non-negative integers with shape `[2, 2]`. It specifies\nhow many elements to crop from the intermediate result across the spatial\ndimensions as follows:\n\n    crops = [[crop_top, crop_bottom], [crop_left, crop_right]]",
        "typeAttr": "Tidx"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "4-D with shape `[batch, height, width, depth]`, where:\n\n      height = height_pad - crop_top - crop_bottom\n      width = width_pad - crop_left - crop_right\n\nThe attr `block_size` must be greater than one. It indicates the block size.\n\nSome examples:\n\n(1) For the following input of shape `[4, 1, 1, 1]` and block_size of 2:\n\n```\n[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]\n```\n\nThe output tensor has shape `[1, 2, 2, 1]` and value:\n\n```\nx = [[[[1], [2]], [[3], [4]]]]\n```\n\n(2) For the following input of shape `[4, 1, 1, 3]` and block_size of 2:\n\n```\n[[[[1, 2, 3]]], [[[4, 5, 6]]], [[[7, 8, 9]]], [[[10, 11, 12]]]]\n```\n\nThe output tensor has shape `[1, 2, 2, 3]` and value:\n\n```\nx = [[[[1, 2, 3], [4, 5, 6]],\n      [[7, 8, 9], [10, 11, 12]]]]\n```\n\n(3) For the following input of shape `[4, 2, 2, 1]` and block_size of 2:\n\n```\nx = [[[[1], [3]], [[9], [11]]],\n     [[[2], [4]], [[10], [12]]],\n     [[[5], [7]], [[13], [15]]],\n     [[[6], [8]], [[14], [16]]]]\n```\n\nThe output tensor has shape `[1, 4, 4, 1]` and value:\n\n```\nx = [[[[1],   [2],  [3],  [4]],\n     [[5],   [6],  [7],  [8]],\n     [[9],  [10], [11],  [12]],\n     [[13], [14], [15],  [16]]]]\n```\n\n(4) For the following input of shape `[8, 1, 2, 1]` and block_size of 2:\n\n```\nx = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]],\n     [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]]\n```\n\nThe output tensor has shape `[2, 2, 4, 1]` and value:\n\n```\nx = [[[[1], [3]], [[5], [7]]],\n     [[[2], [4]], [[10], [12]]],\n     [[[5], [7]], [[13], [15]]],\n     [[[6], [8]], [[14], [16]]]]\n```",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BatchToSpaceND",
    "summary": "BatchToSpace for N-D tensors of type T.",
    "description": "This operation reshapes the \"batch\" dimension 0 into `M + 1` dimensions of shape\n`block_shape + [batch]`, interleaves these blocks back into the grid defined by\nthe spatial dimensions `[1, ..., M]`, to obtain a result with the same rank as\nthe input.  The spatial dimensions of this intermediate result are then\noptionally cropped according to `crops` to produce the output.  This is the\nreverse of SpaceToBatch.  See below for a precise description.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tblock_shape",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "Tcrops",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "N-D with shape `input_shape = [batch] + spatial_shape + remaining_shape`,\nwhere spatial_shape has M dimensions.",
        "typeAttr": "T"
      },
      {
        "name": "block_shape",
        "description": "1-D with shape `[M]`, all values must be >= 1.",
        "typeAttr": "Tblock_shape"
      },
      {
        "name": "crops",
        "description": "2-D with shape `[M, 2]`, all values must be >= 0.\n  `crops[i] = [crop_start, crop_end]` specifies the amount to crop from input\n  dimension `i + 1`, which corresponds to spatial dimension `i`.  It is\n  required that\n  `crop_start[i] + crop_end[i] <= block_shape[i] * input_shape[i + 1]`.\n\nThis operation is equivalent to the following steps:\n\n1. Reshape `input` to `reshaped` of shape:\n     [block_shape[0], ..., block_shape[M-1],\n      batch / prod(block_shape),\n      input_shape[1], ..., input_shape[N-1]]\n\n2. Permute dimensions of `reshaped` to produce `permuted` of shape\n     [batch / prod(block_shape),\n\n      input_shape[1], block_shape[0],\n      ...,\n      input_shape[M], block_shape[M-1],\n\n      input_shape[M+1], ..., input_shape[N-1]]\n\n3. Reshape `permuted` to produce `reshaped_permuted` of shape\n     [batch / prod(block_shape),\n\n      input_shape[1] * block_shape[0],\n      ...,\n      input_shape[M] * block_shape[M-1],\n\n      input_shape[M+1],\n      ...,\n      input_shape[N-1]]\n\n4. Crop the start and end of dimensions `[1, ..., M]` of\n   `reshaped_permuted` according to `crops` to produce the output of shape:\n     [batch / prod(block_shape),\n\n      input_shape[1] * block_shape[0] - crops[0,0] - crops[0,1],\n      ...,\n      input_shape[M] * block_shape[M-1] - crops[M-1,0] - crops[M-1,1],\n\n      input_shape[M+1], ..., input_shape[N-1]]\n\nSome examples:\n\n(1) For the following input of shape `[4, 1, 1, 1]`, `block_shape = [2, 2]`, and\n    `crops = [[0, 0], [0, 0]]`:\n\n```\n[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]\n```\n\nThe output tensor has shape `[1, 2, 2, 1]` and value:\n\n```\nx = [[[[1], [2]], [[3], [4]]]]\n```\n\n(2) For the following input of shape `[4, 1, 1, 3]`, `block_shape = [2, 2]`, and\n    `crops = [[0, 0], [0, 0]]`:\n\n```\n[[[[1, 2, 3]]], [[[4, 5, 6]]], [[[7, 8, 9]]], [[[10, 11, 12]]]]\n```\n\nThe output tensor has shape `[1, 2, 2, 3]` and value:\n\n```\nx = [[[[1, 2, 3], [4, 5, 6]],\n      [[7, 8, 9], [10, 11, 12]]]]\n```\n\n(3) For the following input of shape `[4, 2, 2, 1]`, `block_shape = [2, 2]`, and\n    `crops = [[0, 0], [0, 0]]`:\n\n```\nx = [[[[1], [3]], [[9], [11]]],\n     [[[2], [4]], [[10], [12]]],\n     [[[5], [7]], [[13], [15]]],\n     [[[6], [8]], [[14], [16]]]]\n```\n\nThe output tensor has shape `[1, 4, 4, 1]` and value:\n\n```\nx = [[[[1],   [2],  [3],  [4]],\n     [[5],   [6],  [7],  [8]],\n     [[9],  [10], [11],  [12]],\n     [[13], [14], [15],  [16]]]]\n```\n\n(4) For the following input of shape `[8, 1, 3, 1]`, `block_shape = [2, 2]`, and\n    `crops = [[0, 0], [2, 0]]`:\n\n```\nx = [[[[0], [1], [3]]], [[[0], [9], [11]]],\n     [[[0], [2], [4]]], [[[0], [10], [12]]],\n     [[[0], [5], [7]]], [[[0], [13], [15]]],\n     [[[0], [6], [8]]], [[[0], [14], [16]]]]\n```\n\nThe output tensor has shape `[2, 2, 4, 1]` and value:\n\n```\nx = [[[[1],   [2],  [3],  [4]],\n      [[5],   [6],  [7],  [8]]],\n     [[[9],  [10], [11],  [12]],\n      [[13], [14], [15],  [16]]]]\n```",
        "typeAttr": "Tcrops"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BesselI0",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BesselI0e",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BesselI1",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BesselI1e",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BesselJ0",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BesselJ1",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BesselK0",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BesselK0e",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BesselK1",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BesselK1e",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BesselY0",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BesselY1",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Betainc",
    "summary": "Compute the regularized incomplete beta integral \\\\(I_x(a, b)\\\\).",
    "description": "The regularized incomplete beta integral is defined as:\n\n\n\\\\(I_x(a, b) = \\frac{B(x; a, b)}{B(a, b)}\\\\)\n\nwhere\n\n\n\\\\(B(x; a, b) = \\int_0^x t^{a-1} (1 - t)^{b-1} dt\\\\)\n\n\nis the incomplete beta function and \\\\(B(a, b)\\\\) is the *complete*\nbeta function.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "a",
        "typeAttr": "T"
      },
      {
        "name": "b",
        "typeAttr": "T"
      },
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BiasAdd",
    "category": "Layer",
    "summary": "Adds `bias` to `value`.",
    "description": "This is a special case of `tf.add` where `bias` is restricted to be 1-D.\nBroadcasting is supported, so `value` may have any number of dimensions.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the bias tensor will be added to the last dimension\nof the value tensor.\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].\nThe tensor will be added to \"in_channels\", the third-to-the-last\n    dimension. Must be one of the following: `NHWC`, `NCHW`.",
        "default": "NHWC"
      }
    ],
    "inputs": [
      {
        "name": "value",
        "description": "Any number of dimensions.",
        "typeAttr": "T"
      },
      {
        "name": "bias",
        "description": "1-D with size the last dimension of `value`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Broadcasted sum of `value` and `bias`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BiasAddGrad",
    "summary": "The backward operation for \"BiasAdd\" on the \"bias\" tensor.",
    "description": "It accumulates all the values from out_backprop into the feature dimension.\nFor NHWC data format, the feature dimension is the last. For NCHW data format,\nthe feature dimension is the third-to-last.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the bias tensor will be added to the last dimension\nof the value tensor.\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].\nThe tensor will be added to \"in_channels\", the third-to-the-last\n    dimension. Must be one of the following: `NHWC`, `NCHW`.",
        "default": "NHWC"
      }
    ],
    "inputs": [
      {
        "name": "out_backprop",
        "description": "Any number of dimensions.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "1-D with size the feature dimension of `out_backprop`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BiasAddV1",
    "summary": "Adds `bias` to `value`.",
    "description": "This is a deprecated version of BiasAdd and will be soon removed.\n\nThis is a special case of `tf.add` where `bias` is restricted to be 1-D.\nBroadcasting is supported, so `value` may have any number of dimensions.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "value",
        "description": "Any number of dimensions.",
        "typeAttr": "T"
      },
      {
        "name": "bias",
        "description": "1-D with size the last dimension of `value`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Broadcasted sum of `value` and `bias`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Bincount",
    "summary": "Counts the number of occurrences of each value in an integer array.",
    "description": "Outputs a vector with length `size` and the same dtype as `weights`. If\n`weights` are empty, then index `i` stores the number of times the value `i` is\ncounted in `arr`. If `weights` are non-empty, then index `i` stores the sum of\nthe value in `weights` at each index where the corresponding value in `arr` is\n`i`.\n\nValues in `arr` outside of the range [0, size) are ignored.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "arr",
        "description": "int32 `Tensor`.",
        "type": 3
      },
      {
        "name": "size",
        "description": "non-negative int32 scalar `Tensor`.",
        "type": 3
      },
      {
        "name": "weights",
        "description": "is an int32, int64, float32, or float64 `Tensor` with the same\nshape as `arr`, or a length-0 `Tensor`, in which case it acts as all weights\nequal to 1.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "bins",
        "description": "1D `Tensor` with length equal to `size`. The counts or summed weights for\neach value in the range [0, size).",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Bitcast",
    "summary": "Bitcasts a tensor from one type to another without copying data.",
    "description": "Given a tensor `input`, this operation returns a tensor that has the same buffer\ndata as `input` with datatype `type`.\n\nIf the input datatype `T` is larger than the output datatype `type` then the\nshape changes from [...] to [..., sizeof(`T`)/sizeof(`type`)].\n\nIf `T` is smaller than `type`, the operator requires that the rightmost\ndimension be equal to sizeof(`type`)/sizeof(`T`). The shape then goes from\n[..., sizeof(`type`)/sizeof(`T`)] to [...].\n\ntf.bitcast() and tf.cast() work differently when real dtype is casted as a complex dtype\n(e.g. tf.complex64 or tf.complex128) as tf.cast() make imaginary part 0 while tf.bitcast()\ngives module error.\nFor example,\n\nExample 1:\n\n>>> a = [1., 2., 3.]\n>>> equality_bitcast = tf.bitcast(a, tf.complex128)\nTraceback (most recent call last):\n...\nInvalidArgumentError: Cannot bitcast from 1 to 18 [Op:Bitcast]\n>>> equality_cast = tf.cast(a, tf.complex128)\n>>> print(equality_cast)\ntf.Tensor([1.+0.j 2.+0.j 3.+0.j], shape=(3,), dtype=complex128)\n\nExample 2:\n\n>>> tf.bitcast(tf.constant(0xffffffff, dtype=tf.uint32), tf.uint8)\n<tf.Tensor: shape=(4,), dtype=uint8, numpy=array([255, 255, 255, 255], dtype=uint8)>\n\nExample 3:\n\n>>> x = [1., 2., 3.]\n>>> y = [0., 2., 3.]\n>>> equality= tf.equal(x,y)\n>>> equality_cast = tf.cast(equality,tf.float32)\n>>> equality_bitcast = tf.bitcast(equality_cast,tf.uint8)\n>>> print(equality)\ntf.Tensor([False True True], shape=(3,), dtype=bool)\n>>> print(equality_cast)\ntf.Tensor([0. 1. 1.], shape=(3,), dtype=float32)\n>>> print(equality_bitcast)\ntf.Tensor(\n    [[  0   0   0   0]\n     [  0   0 128  63]\n     [  0   0 128  63]], shape=(3, 4), dtype=uint8)\n\n*NOTE*: Bitcast is implemented as a low-level cast, so machines with different\nendian orderings will give different results. A copy from input buffer to output\nbuffer is made on BE machines when types are of different sizes in order to get\nthe same casting results as on LE machines.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `int64`, `int32`, `uint8`, `uint16`, `uint32`, `uint64`, `int8`, `int16`, `complex64`, `complex128`, `qint8`, `quint8`, `qint16`, `quint16`, `qint32`."
      },
      {
        "name": "type",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `int64`, `int32`, `uint8`, `uint16`, `uint32`, `uint64`, `int8`, `int16`, `complex64`, `complex128`, `qint8`, `quint8`, `qint16`, `quint16`, `qint32`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "type"
      }
    ]
  },
  {
    "name": "BitwiseAnd",
    "summary": "Elementwise computes the bitwise AND of `x` and `y`.",
    "description": "The result will have those bits set, that are set in both `x` and `y`. The\ncomputation is performed on the underlying representations of `x` and `y`.\n\nFor example:\n\n```python\nimport tensorflow as tf\nfrom tensorflow.python.ops import bitwise_ops\ndtype_list = [tf.int8, tf.int16, tf.int32, tf.int64,\n              tf.uint8, tf.uint16, tf.uint32, tf.uint64]\n\nfor dtype in dtype_list:\n  lhs = tf.constant([0, 5, 3, 14], dtype=dtype)\n  rhs = tf.constant([5, 0, 7, 11], dtype=dtype)\n  exp = tf.constant([0, 0, 3, 10], dtype=tf.float32)\n\n  res = bitwise_ops.bitwise_and(lhs, rhs)\n  tf.assert_equal(tf.cast(res, tf.float32), exp) # TRUE\n```\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BitwiseOr",
    "summary": "Elementwise computes the bitwise OR of `x` and `y`.",
    "description": "The result will have those bits set, that are set in `x`, `y` or both. The\ncomputation is performed on the underlying representations of `x` and `y`.\n\nFor example:\n\n```python\nimport tensorflow as tf\nfrom tensorflow.python.ops import bitwise_ops\ndtype_list = [tf.int8, tf.int16, tf.int32, tf.int64,\n              tf.uint8, tf.uint16, tf.uint32, tf.uint64]\n\nfor dtype in dtype_list:\n  lhs = tf.constant([0, 5, 3, 14], dtype=dtype)\n  rhs = tf.constant([5, 0, 7, 11], dtype=dtype)\n  exp = tf.constant([5, 5, 7, 15], dtype=tf.float32)\n\n  res = bitwise_ops.bitwise_or(lhs, rhs)\n  tf.assert_equal(tf.cast(res,  tf.float32), exp)  # TRUE\n```\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BitwiseXor",
    "summary": "Elementwise computes the bitwise XOR of `x` and `y`.",
    "description": "The result will have those bits set, that are different in `x` and `y`. The\ncomputation is performed on the underlying representations of `x` and `y`.\n\nFor example:\n\n```python\nimport tensorflow as tf\nfrom tensorflow.python.ops import bitwise_ops\ndtype_list = [tf.int8, tf.int16, tf.int32, tf.int64,\n              tf.uint8, tf.uint16, tf.uint32, tf.uint64]\n\nfor dtype in dtype_list:\n  lhs = tf.constant([0, 5, 3, 14], dtype=dtype)\n  rhs = tf.constant([5, 0, 7, 11], dtype=dtype)\n  exp = tf.constant([5, 5, 4, 5],  dtype=tf.float32)\n\n  res = bitwise_ops.bitwise_xor(lhs, rhs)\n  tf.assert_equal(tf.cast(res, tf.float32), exp) # TRUE\n```\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BlockLSTM",
    "summary": "Computes the LSTM cell forward propagation for all the time steps.",
    "description": "This is equivalent to applying LSTMBlockCell in a loop, like so:\n\n```python\nfor x1 in unpack(x):\n  i1, cs1, f1, o1, ci1, co1, h1 = LSTMBlock(\n    x1, cs_prev, h_prev, w, wci, wcf, wco, b)\n  cs_prev = cs1\n  h_prev = h1\n  i.append(i1)\n  cs.append(cs1)\n  f.append(f1)\n  o.append(o1)\n  ci.append(ci1)\n  co.append(co1)\n  h.append(h1)\nreturn pack(i), pack(cs), pack(f), pack(o), pack(ci), pack(ch), pack(h)\n```",
    "attributes": [
      {
        "name": "forget_bias",
        "type": "float32",
        "description": "The forget gate bias.",
        "default": 1.0
      },
      {
        "name": "cell_clip",
        "type": "float32",
        "description": "Value to clip the 'cs' value to.",
        "default": 3.0
      },
      {
        "name": "use_peephole",
        "type": "boolean",
        "description": "Whether to use peephole weights.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`."
      }
    ],
    "inputs": [
      {
        "name": "seq_len_max",
        "description": "Maximum time length actually used by this input. Outputs are padded\nwith zeros beyond this length.",
        "type": 9
      },
      {
        "name": "x",
        "description": "The sequence input to the LSTM, shape (timelen, batch_size, num_inputs).",
        "typeAttr": "T"
      },
      {
        "name": "cs_prev",
        "description": "Value of the initial cell state.",
        "typeAttr": "T"
      },
      {
        "name": "h_prev",
        "description": "Initial output of cell (to be used for peephole).",
        "typeAttr": "T"
      },
      {
        "name": "w",
        "description": "The weight matrix.",
        "typeAttr": "T"
      },
      {
        "name": "wci",
        "description": "The weight matrix for input gate peephole connection.",
        "typeAttr": "T"
      },
      {
        "name": "wcf",
        "description": "The weight matrix for forget gate peephole connection.",
        "typeAttr": "T"
      },
      {
        "name": "wco",
        "description": "The weight matrix for output gate peephole connection.",
        "typeAttr": "T"
      },
      {
        "name": "b",
        "description": "The bias vector.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "i",
        "description": "The input gate over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "cs",
        "description": "The cell state before the tanh over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "f",
        "description": "The forget gate over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "o",
        "description": "The output gate over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "ci",
        "description": "The cell input over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "co",
        "description": "The cell after the tanh over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "h",
        "description": "The output h vector over the whole time sequence.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BlockLSTMGrad",
    "summary": "Computes the LSTM cell backward propagation for the entire time sequence.",
    "description": "This implementation is to be used in conjunction of LSTMBlock.",
    "attributes": [
      {
        "name": "use_peephole",
        "type": "boolean",
        "description": "Whether to use peephole weights."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`."
      }
    ],
    "inputs": [
      {
        "name": "seq_len_max",
        "description": "Maximum time length actually used by this input. Outputs are padded\nwith zeros beyond this length.",
        "type": 9
      },
      {
        "name": "x",
        "description": "The sequence input to the LSTM, shape (timelen, batch_size, num_inputs).",
        "typeAttr": "T"
      },
      {
        "name": "cs_prev",
        "description": "Value of the initial cell state.",
        "typeAttr": "T"
      },
      {
        "name": "h_prev",
        "description": "Initial output of cell (to be used for peephole).",
        "typeAttr": "T"
      },
      {
        "name": "w",
        "description": "The weight matrix.",
        "typeAttr": "T"
      },
      {
        "name": "wci",
        "description": "The weight matrix for input gate peephole connection.",
        "typeAttr": "T"
      },
      {
        "name": "wcf",
        "description": "The weight matrix for forget gate peephole connection.",
        "typeAttr": "T"
      },
      {
        "name": "wco",
        "description": "The weight matrix for output gate peephole connection.",
        "typeAttr": "T"
      },
      {
        "name": "b",
        "description": "The bias vector.",
        "typeAttr": "T"
      },
      {
        "name": "i",
        "description": "The input gate over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "cs",
        "description": "The cell state before the tanh over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "f",
        "description": "The forget gate over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "o",
        "description": "The output gate over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "ci",
        "description": "The cell input over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "co",
        "description": "The cell after the tanh over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "h",
        "description": "The output h vector over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "cs_grad",
        "description": "The current gradient of cs.",
        "typeAttr": "T"
      },
      {
        "name": "h_grad",
        "description": "The gradient of h vector.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "x_grad",
        "description": "The gradient of x to be back-propped.",
        "typeAttr": "T"
      },
      {
        "name": "cs_prev_grad",
        "description": "The gradient of cs_prev to be back-propped.",
        "typeAttr": "T"
      },
      {
        "name": "h_prev_grad",
        "description": "The gradient of h_prev to be back-propped.",
        "typeAttr": "T"
      },
      {
        "name": "w_grad",
        "description": "The gradient for w to be back-propped.",
        "typeAttr": "T"
      },
      {
        "name": "wci_grad",
        "description": "The gradient for wci to be back-propped.",
        "typeAttr": "T"
      },
      {
        "name": "wcf_grad",
        "description": "The gradient for wcf to be back-propped.",
        "typeAttr": "T"
      },
      {
        "name": "wco_grad",
        "description": "The gradient for wco to be back-propped.",
        "typeAttr": "T"
      },
      {
        "name": "b_grad",
        "description": "The gradient for w to be back-propped.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BlockLSTMGradV2",
    "summary": "Computes the LSTM cell backward propagation for the entire time sequence.",
    "description": "This implementation is to be used in conjunction of BlockLSTMV2.",
    "attributes": [
      {
        "name": "use_peephole",
        "type": "boolean",
        "description": "Whether to use peephole weights."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`."
      }
    ],
    "inputs": [
      {
        "name": "seq_len_max",
        "description": "Maximum time length actually used by this input. Outputs are padded\nwith zeros beyond this length.",
        "type": 9
      },
      {
        "name": "x",
        "description": "The sequence input to the LSTM, shape (timelen, batch_size, num_inputs).",
        "typeAttr": "T"
      },
      {
        "name": "cs_prev",
        "description": "Value of the initial cell state.",
        "typeAttr": "T"
      },
      {
        "name": "h_prev",
        "description": "Initial output of cell (to be used for peephole).",
        "typeAttr": "T"
      },
      {
        "name": "w",
        "description": "The weight matrix.",
        "typeAttr": "T"
      },
      {
        "name": "wci",
        "description": "The weight matrix for input gate peephole connection.",
        "typeAttr": "T"
      },
      {
        "name": "wcf",
        "description": "The weight matrix for forget gate peephole connection.",
        "typeAttr": "T"
      },
      {
        "name": "wco",
        "description": "The weight matrix for output gate peephole connection.",
        "typeAttr": "T"
      },
      {
        "name": "b",
        "description": "The bias vector.",
        "typeAttr": "T"
      },
      {
        "name": "i",
        "description": "The input gate over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "cs",
        "description": "The cell state before the tanh over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "f",
        "description": "The forget gate over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "o",
        "description": "The output gate over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "ci",
        "description": "The cell input over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "co",
        "description": "The cell after the tanh over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "h",
        "description": "The output h vector over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "cs_grad",
        "description": "The current gradient of cs.",
        "typeAttr": "T"
      },
      {
        "name": "h_grad",
        "description": "The gradient of h vector.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "x_grad",
        "description": "The gradient of x to be back-propped.",
        "typeAttr": "T"
      },
      {
        "name": "cs_prev_grad",
        "description": "The gradient of cs_prev to be back-propped.",
        "typeAttr": "T"
      },
      {
        "name": "h_prev_grad",
        "description": "The gradient of h_prev to be back-propped.",
        "typeAttr": "T"
      },
      {
        "name": "w_grad",
        "description": "The gradient for w to be back-propped.",
        "typeAttr": "T"
      },
      {
        "name": "wci_grad",
        "description": "The gradient for wci to be back-propped.",
        "typeAttr": "T"
      },
      {
        "name": "wcf_grad",
        "description": "The gradient for wcf to be back-propped.",
        "typeAttr": "T"
      },
      {
        "name": "wco_grad",
        "description": "The gradient for wco to be back-propped.",
        "typeAttr": "T"
      },
      {
        "name": "b_grad",
        "description": "The gradient for w to be back-propped.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BlockLSTMV2",
    "summary": "Computes the LSTM cell forward propagation for all the time steps.",
    "description": "This is equivalent to applying LSTMBlockCell in a loop, like so:\n\n```python\nfor x1 in unpack(x):\n  i1, cs1, f1, o1, ci1, co1, h1 = LSTMBlock(\n    x1, cs_prev, h_prev, w, wci, wcf, wco, b)\n  cs_prev = cs1\n  h_prev = h1\n  i.append(i1)\n  cs.append(cs1)\n  f.append(f1)\n  o.append(o1)\n  ci.append(ci1)\n  co.append(co1)\n  h.append(h1)\nreturn pack(i), pack(cs), pack(f), pack(o), pack(ci), pack(ch), pack(h)\n\nNote that unlike LSTMBlockCell (and BlockLSTM) which uses ICFO gate layout,\nthis op uses IFCO. So in order for the following snippet to be equivalent\nall gate-related outputs should be reordered.\n```",
    "attributes": [
      {
        "name": "cell_clip",
        "type": "float32",
        "description": "Value to clip the 'cs' value to.",
        "default": 0.0
      },
      {
        "name": "use_peephole",
        "type": "boolean",
        "description": "Whether to use peephole weights.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`."
      }
    ],
    "inputs": [
      {
        "name": "seq_len_max",
        "description": "Maximum time length actually used by this input. Outputs are padded\nwith zeros beyond this length.",
        "type": 9
      },
      {
        "name": "x",
        "description": "The sequence input to the LSTM, shape (timelen, batch_size, num_inputs).",
        "typeAttr": "T"
      },
      {
        "name": "cs_prev",
        "description": "Value of the initial cell state.",
        "typeAttr": "T"
      },
      {
        "name": "h_prev",
        "description": "Initial output of cell (to be used for peephole).",
        "typeAttr": "T"
      },
      {
        "name": "w",
        "description": "The weight matrix.",
        "typeAttr": "T"
      },
      {
        "name": "wci",
        "description": "The weight matrix for input gate peephole connection.",
        "typeAttr": "T"
      },
      {
        "name": "wcf",
        "description": "The weight matrix for forget gate peephole connection.",
        "typeAttr": "T"
      },
      {
        "name": "wco",
        "description": "The weight matrix for output gate peephole connection.",
        "typeAttr": "T"
      },
      {
        "name": "b",
        "description": "The bias vector.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "i",
        "description": "The input gate over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "cs",
        "description": "The cell state before the tanh over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "f",
        "description": "The forget gate over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "o",
        "description": "The output gate over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "ci",
        "description": "The cell input over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "co",
        "description": "The cell after the tanh over the whole time sequence.",
        "typeAttr": "T"
      },
      {
        "name": "h",
        "description": "The output h vector over the whole time sequence.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BoostedTreesAggregateStats",
    "summary": "Aggregates the summary of accumulated stats for the batch.",
    "description": "The summary stats contains gradients and hessians accumulated for each node, feature dimension id and bucket.",
    "attributes": [
      {
        "name": "max_splits",
        "type": "int64",
        "description": "int; the maximum number of splits possible in the whole tree.",
        "minimum": 1
      },
      {
        "name": "num_buckets",
        "type": "int64",
        "description": "int; equals to the maximum possible value of bucketized feature.",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "node_ids",
        "description": "int32; Rank 1 Tensor containing node ids for each example, shape [batch_size].",
        "type": 3
      },
      {
        "name": "gradients",
        "description": "float32; Rank 2 Tensor (shape=[batch_size, logits_dimension]) with gradients for each example.",
        "type": 1
      },
      {
        "name": "hessians",
        "description": "float32; Rank 2 Tensor (shape=[batch_size, hessian_dimension]) with hessians for each example.",
        "type": 1
      },
      {
        "name": "feature",
        "description": "int32; Rank 2 feature Tensors (shape=[batch_size, feature_dimension]).",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "stats_summary",
        "description": "output Rank 4 Tensor (shape=[splits, feature_dimension, buckets, logits_dimension + hessian_dimension])\ncontaining accumulated stats for each node, feature dimension and bucket.",
        "type": 1
      }
    ]
  },
  {
    "name": "BoostedTreesBucketize",
    "summary": "Bucketize each feature based on bucket boundaries.",
    "description": "An op that returns a list of float tensors, where each tensor represents the\nbucketized values for a single feature.",
    "attributes": [
      {
        "name": "num_features",
        "type": "int64",
        "description": "inferred int; number of features.",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "float_values",
        "description": "float; List of Rank 1 Tensor each containing float values for a single feature.",
        "numberAttr": "num_features",
        "type": 1
      },
      {
        "name": "bucket_boundaries",
        "description": "float; List of Rank 1 Tensors each containing the bucket boundaries for a single\nfeature.",
        "numberAttr": "num_features",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "buckets",
        "description": "int; List of Rank 1 Tensors each containing the bucketized values for a single feature.",
        "numberAttr": "num_features",
        "type": 3
      }
    ]
  },
  {
    "name": "BoostedTreesCalculateBestFeatureSplit",
    "summary": "Calculates gains for each feature and returns the best possible split information for the feature.",
    "description": "The split information is the best threshold (bucket id), gains and left/right node contributions per node for each feature.\n\nIt is possible that not all nodes can be split on each feature. Hence, the list of possible nodes can differ between the features. Therefore, we return `node_ids_list` for each feature, containing the list of nodes that this feature can be used to split.\n\nIn this manner, the output is the best split per features and per node, so that it needs to be combined later to produce the best split for each node (among all possible features).\n\nThe output shapes are compatible in a way that the first dimension of all tensors are the same and equal to the number of possible split nodes for each feature.",
    "attributes": [
      {
        "name": "logits_dimension",
        "type": "int64",
        "description": "The dimension of logit, i.e., number of classes.",
        "minimum": 1
      },
      {
        "name": "split_type",
        "type": "string",
        "description": "A string indicating if this Op should perform inequality split or equality split. Must be one of the following: `inequality`, `equality`.",
        "default": "inequality"
      }
    ],
    "inputs": [
      {
        "name": "node_id_range",
        "description": "A Rank 1 tensor (shape=[2]) to specify the range [first, last) of node ids to process within `stats_summary_list`. The nodes are iterated between the two nodes specified by the tensor, as like `for node_id in range(node_id_range[0], node_id_range[1])` (Note that the last index node_id_range[1] is exclusive).",
        "type": 3
      },
      {
        "name": "stats_summary",
        "description": "A Rank 4 tensor (#shape=[max_splits, feature_dims, bucket, stats_dims]) for accumulated stats summary (gradient/hessian) per node, per dimension, per buckets for each feature.\nThe first dimension of the tensor is the maximum number of splits, and thus not all elements of it will be used, but only the indexes specified by node_ids will be used.",
        "type": 1
      },
      {
        "name": "l1",
        "description": "l1 regularization factor on leaf weights, per instance based.",
        "type": 1
      },
      {
        "name": "l2",
        "description": "l2 regularization factor on leaf weights, per instance based.",
        "type": 1
      },
      {
        "name": "tree_complexity",
        "description": "adjustment to the gain, per leaf based.",
        "type": 1
      },
      {
        "name": "min_node_weight",
        "description": "minimum avg of hessians in a node before required for the node to be considered for splitting.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "node_ids",
        "description": "A Rank 1 tensors indicating possible split node ids for each feature. The length of the list is num_features, but each tensor has different size as each feature provides different possible nodes. See above for details like shapes and sizes.",
        "type": 3
      },
      {
        "name": "gains",
        "description": "A Rank 1 tensors indicating the best gains for each feature to split for certain nodes. See above for details like shapes and sizes.",
        "type": 1
      },
      {
        "name": "feature_dimensions",
        "description": "A Rank 1 tensors indicating the best feature dimension for each feature to split for certain nodes if the feature is multi-dimension. See above for details like shapes and sizes.",
        "type": 3
      },
      {
        "name": "thresholds",
        "description": "A Rank 1 tensors indicating the bucket id to compare with (as a threshold) for split in each node. See above for details like shapes and sizes.",
        "type": 3
      },
      {
        "name": "left_node_contribs",
        "description": "A Rank 2 tensors indicating the contribution of the left nodes when branching from parent nodes (given by the tensor element in the output node_ids_list) to the left direction by the given threshold for each feature. This value will be used to make the left node value by adding to the parent node value. Second dimension size is 1 for 1-dimensional logits, but would be larger for multi-class problems. See above for details like shapes and sizes.",
        "type": 1
      },
      {
        "name": "right_node_contribs",
        "description": "A Rank 2 tensors, with the same shape/conditions as left_node_contribs_list, but just that the value is for the right node.",
        "type": 1
      },
      {
        "name": "split_with_default_directions",
        "description": "A Rank 1 tensors indicating the which direction to go if data is missing. See above for details like shapes and sizes.\nInequality with default left returns 0, inequality with default right returns 1, equality with default right returns 2.",
        "type": 7
      }
    ]
  },
  {
    "name": "BoostedTreesCalculateBestFeatureSplitV2",
    "summary": "Calculates gains for each feature and returns the best possible split information for each node. However, if no split is found, then no split information is returned for that node.",
    "description": "The split information is the best threshold (bucket id), gains and left/right node contributions per node for each feature.\n\nIt is possible that not all nodes can be split on each feature. Hence, the list of possible nodes can differ between the features. Therefore, we return `node_ids_list` for each feature, containing the list of nodes that this feature can be used to split.\n\nIn this manner, the output is the best split per features and per node, so that it needs to be combined later to produce the best split for each node (among all possible features).\n\nThe output shapes are compatible in a way that the first dimension of all tensors are the same and equal to the number of possible split nodes for each feature.",
    "attributes": [
      {
        "name": "num_features",
        "type": "int64",
        "description": "inferred from the size of `stats_summary_list`; the number of total features.",
        "minimum": 1
      },
      {
        "name": "logits_dimension",
        "type": "int64",
        "description": "The dimension of logit, i.e., number of classes.",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "node_id_range",
        "description": "A Rank 1 tensor (shape=[2]) to specify the range [first, last) of node ids to process within `stats_summary_list`. The nodes are iterated between the two nodes specified by the tensor, as like `for node_id in range(node_id_range[0], node_id_range[1])` (Note that the last index node_id_range[1] is exclusive).",
        "type": 3
      },
      {
        "name": "stats_summaries_list",
        "description": "A list of Rank 4 tensor (#shape=[max_splits, feature_dims, bucket, stats_dims]) for accumulated stats summary (gradient/hessian) per node, per dimension, per buckets for each feature.\nThe first dimension of the tensor is the maximum number of splits, and thus not all elements of it will be used, but only the indexes specified by node_ids will be used.",
        "numberAttr": "num_features",
        "type": 1
      },
      {
        "name": "split_types",
        "description": "A Rank 1 tensor indicating if this Op should perform inequality split or equality split per feature.",
        "type": 7
      },
      {
        "name": "candidate_feature_ids",
        "description": "Rank 1 tensor with ids for each feature. This is the real id of the feature.",
        "type": 3
      },
      {
        "name": "l1",
        "description": "l1 regularization factor on leaf weights, per instance based.",
        "type": 1
      },
      {
        "name": "l2",
        "description": "l2 regularization factor on leaf weights, per instance based.",
        "type": 1
      },
      {
        "name": "tree_complexity",
        "description": "adjustment to the gain, per leaf based.",
        "type": 1
      },
      {
        "name": "min_node_weight",
        "description": "minimum avg of hessians in a node before required for the node to be considered for splitting.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "node_ids",
        "description": "A Rank 1 tensors indicating possible split node ids for each feature. The length of the list is num_features, but each tensor has different size as each feature provides different possible nodes. See above for details like shapes and sizes.",
        "type": 3
      },
      {
        "name": "gains",
        "description": "A Rank 1 tensor indicating the best gains for each feature to split for certain nodes. See above for details like shapes and sizes.",
        "type": 1
      },
      {
        "name": "feature_ids",
        "description": "A Rank 1 tensors indicating the best feature id for each node. See above for details like shapes and sizes.",
        "type": 3
      },
      {
        "name": "feature_dimensions",
        "description": "A Rank 1 tensors indicating the best feature dimension for each feature to split for certain nodes if the feature is multi-dimension. See above for details like shapes and sizes.",
        "type": 3
      },
      {
        "name": "thresholds",
        "description": "A Rank 1 tensors indicating the bucket id to compare with (as a threshold) for split in each node. See above for details like shapes and sizes.",
        "type": 3
      },
      {
        "name": "left_node_contribs",
        "description": "A Rank 2 tensors indicating the contribution of the left nodes when branching from parent nodes (given by the tensor element in the output node_ids_list) to the left direction by the given threshold for each feature. This value will be used to make the left node value by adding to the parent node value. Second dimension size is 1 for 1-dimensional logits, but would be larger for multi-class problems. See above for details like shapes and sizes.",
        "type": 1
      },
      {
        "name": "right_node_contribs",
        "description": "A Rank 2 tensors, with the same shape/conditions as left_node_contribs_list, but just that the value is for the right node.",
        "type": 1
      },
      {
        "name": "split_with_default_directions",
        "description": "A Rank 1 tensors indicating the which direction to go if data is missing. See above for details like shapes and sizes.\nInequality with default left returns 0, inequality with default right returns 1, equality with default right returns 2.",
        "type": 7
      }
    ]
  },
  {
    "name": "BoostedTreesCalculateBestGainsPerFeature",
    "summary": "Calculates gains for each feature and returns the best possible split information for the feature.",
    "description": "The split information is the best threshold (bucket id), gains and left/right node contributions per node for each feature.\n\nIt is possible that not all nodes can be split on each feature. Hence, the list of possible nodes can differ between the features. Therefore, we return `node_ids_list` for each feature, containing the list of nodes that this feature can be used to split.\n\nIn this manner, the output is the best split per features and per node, so that it needs to be combined later to produce the best split for each node (among all possible features).\n\nThe length of output lists are all of the same length, `num_features`.\nThe output shapes are compatible in a way that the first dimension of all tensors of all lists are the same and equal to the number of possible split nodes for each feature.",
    "attributes": [
      {
        "name": "max_splits",
        "type": "int64",
        "description": "the number of nodes that can be split in the whole tree. Used as a dimension of output tensors.",
        "minimum": 1
      },
      {
        "name": "num_features",
        "type": "int64",
        "description": "inferred from the size of `stats_summary_list`; the number of total features.",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "node_id_range",
        "description": "A Rank 1 tensor (shape=[2]) to specify the range [first, last) of node ids to process within `stats_summary_list`. The nodes are iterated between the two nodes specified by the tensor, as like `for node_id in range(node_id_range[0], node_id_range[1])` (Note that the last index node_id_range[1] is exclusive).",
        "type": 3
      },
      {
        "name": "stats_summary_list",
        "description": "A list of Rank 3 tensor (#shape=[max_splits, bucket, 2]) for accumulated stats summary (gradient/hessian) per node per buckets for each feature. The first dimension of the tensor is the maximum number of splits, and thus not all elements of it will be used, but only the indexes specified by node_ids will be used.",
        "numberAttr": "num_features",
        "type": 1
      },
      {
        "name": "l1",
        "description": "l1 regularization factor on leaf weights, per instance based.",
        "type": 1
      },
      {
        "name": "l2",
        "description": "l2 regularization factor on leaf weights, per instance based.",
        "type": 1
      },
      {
        "name": "tree_complexity",
        "description": "adjustment to the gain, per leaf based.",
        "type": 1
      },
      {
        "name": "min_node_weight",
        "description": "minimum avg of hessians in a node before required for the node to be considered for splitting.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "node_ids_list",
        "description": "An output list of Rank 1 tensors indicating possible split node ids for each feature. The length of the list is num_features, but each tensor has different size as each feature provides different possible nodes. See above for details like shapes and sizes.",
        "numberAttr": "num_features",
        "type": 3
      },
      {
        "name": "gains_list",
        "description": "An output list of Rank 1 tensors indicating the best gains for each feature to split for certain nodes. See above for details like shapes and sizes.",
        "numberAttr": "num_features",
        "type": 1
      },
      {
        "name": "thresholds_list",
        "description": "An output list of Rank 1 tensors indicating the bucket id to compare with (as a threshold) for split in each node. See above for details like shapes and sizes.",
        "numberAttr": "num_features",
        "type": 3
      },
      {
        "name": "left_node_contribs_list",
        "description": "A list of Rank 2 tensors indicating the contribution of the left nodes when branching from parent nodes (given by the tensor element in the output node_ids_list) to the left direction by the given threshold for each feature. This value will be used to make the left node value by adding to the parent node value. Second dimension size is 1 for 1-dimensional logits, but would be larger for multi-class problems. See above for details like shapes and sizes.",
        "numberAttr": "num_features",
        "type": 1
      },
      {
        "name": "right_node_contribs_list",
        "description": "A list of Rank 2 tensors, with the same shape/conditions as left_node_contribs_list, but just that the value is for the right node.",
        "numberAttr": "num_features",
        "type": 1
      }
    ]
  },
  {
    "name": "BoostedTreesCenterBias",
    "summary": "Calculates the prior from the training data (the bias) and fills in the first node with the logits' prior. Returns a boolean indicating whether to continue centering.",
    "inputs": [
      {
        "name": "tree_ensemble_handle",
        "description": "Handle to the tree ensemble.",
        "type": 20
      },
      {
        "name": "mean_gradients",
        "description": "A tensor with shape=[logits_dimension] with mean of gradients for a first node.",
        "type": 1
      },
      {
        "name": "mean_hessians",
        "description": "A tensor with shape=[logits_dimension] mean of hessians for a first node.",
        "type": 1
      },
      {
        "name": "l1",
        "description": "l1 regularization factor on leaf weights, per instance based.",
        "type": 1
      },
      {
        "name": "l2",
        "description": "l2 regularization factor on leaf weights, per instance based.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "continue_centering",
        "description": "Bool, whether to continue bias centering.",
        "type": 10
      }
    ]
  },
  {
    "name": "BoostedTreesCreateEnsemble",
    "summary": "Creates a tree ensemble model and returns a handle to it.",
    "inputs": [
      {
        "name": "tree_ensemble_handle",
        "description": "Handle to the tree ensemble resource to be created.",
        "type": 20
      },
      {
        "name": "stamp_token",
        "description": "Token to use as the initial value of the resource stamp.",
        "type": 9
      },
      {
        "name": "tree_ensemble_serialized",
        "description": "Serialized proto of the tree ensemble.",
        "type": 7
      }
    ]
  },
  {
    "name": "BoostedTreesCreateQuantileStreamResource",
    "summary": "Create the Resource for Quantile Streams.",
    "attributes": [
      {
        "name": "max_elements",
        "type": "int64",
        "description": "int; The maximum number of data points that can be fed to the stream.",
        "default": 1099511627776
      }
    ],
    "inputs": [
      {
        "name": "quantile_stream_resource_handle",
        "description": "resource; Handle to quantile stream resource.",
        "type": 20
      },
      {
        "name": "epsilon",
        "description": "float; The required approximation error of the stream resource.",
        "type": 1
      },
      {
        "name": "num_streams",
        "description": "int; The number of streams managed by the resource that shares the same epsilon.",
        "type": 9
      }
    ]
  },
  {
    "name": "BoostedTreesDeserializeEnsemble",
    "summary": "Deserializes a serialized tree ensemble config and replaces current tree",
    "description": "ensemble.",
    "inputs": [
      {
        "name": "tree_ensemble_handle",
        "description": "Handle to the tree ensemble.",
        "type": 20
      },
      {
        "name": "stamp_token",
        "description": "Token to use as the new value of the resource stamp.",
        "type": 9
      },
      {
        "name": "tree_ensemble_serialized",
        "description": "Serialized proto of the ensemble.",
        "type": 7
      }
    ]
  },
  {
    "name": "BoostedTreesEnsembleResourceHandleOp",
    "summary": "Creates a handle to a BoostedTreesEnsembleResource",
    "attributes": [
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "resource",
        "type": 20
      }
    ]
  },
  {
    "name": "BoostedTreesExampleDebugOutputs",
    "summary": "Debugging/model interpretability outputs for each example.",
    "description": "It traverses all the trees and computes debug metrics for individual examples,\nsuch as getting split feature ids and logits after each split along the decision\npath used to compute directional feature contributions.",
    "attributes": [
      {
        "name": "num_bucketized_features",
        "type": "int64",
        "description": "Inferred.",
        "minimum": 1
      },
      {
        "name": "logits_dimension",
        "type": "int64",
        "description": "scalar, dimension of the logits, to be used for constructing the protos in\nexamples_debug_outputs_serialized."
      }
    ],
    "inputs": [
      {
        "name": "tree_ensemble_handle",
        "type": 20
      },
      {
        "name": "bucketized_features",
        "description": "A list of rank 1 Tensors containing bucket id for each\nfeature.",
        "numberAttr": "num_bucketized_features",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "examples_debug_outputs_serialized",
        "description": "Output rank 1 Tensor containing a proto serialized as a string for each example.",
        "type": 7
      }
    ]
  },
  {
    "name": "BoostedTreesFlushQuantileSummaries",
    "summary": "Flush the quantile summaries from each quantile stream resource.",
    "description": "An op that outputs a list of quantile summaries of a quantile stream resource.\nEach summary Tensor is rank 2, containing summaries (value, weight, min_rank,\nmax_rank) for a single feature.",
    "attributes": [
      {
        "name": "num_features",
        "type": "int64",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "quantile_stream_resource_handle",
        "description": "resource handle referring to a QuantileStreamResource.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "summaries",
        "numberAttr": "num_features",
        "type": 1
      }
    ]
  },
  {
    "name": "BoostedTreesGetEnsembleStates",
    "summary": "Retrieves the tree ensemble resource stamp token, number of trees and growing statistics.",
    "inputs": [
      {
        "name": "tree_ensemble_handle",
        "description": "Handle to the tree ensemble.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "stamp_token",
        "description": "Stamp token of the tree ensemble resource.",
        "type": 9
      },
      {
        "name": "num_trees",
        "description": "The number of trees in the tree ensemble resource.",
        "type": 3
      },
      {
        "name": "num_finalized_trees",
        "description": "The number of trees that were finished successfully.",
        "type": 3
      },
      {
        "name": "num_attempted_layers",
        "description": "The number of layers we attempted to build (but not necessarily succeeded).",
        "type": 3
      },
      {
        "name": "last_layer_nodes_range",
        "description": "Rank size 2 tensor that contains start and end ids of the nodes in the latest\nlayer.",
        "type": 3
      }
    ]
  },
  {
    "name": "BoostedTreesMakeQuantileSummaries",
    "summary": "Makes the summary of quantiles for the batch.",
    "description": "An op that takes a list of tensors (one tensor per feature) and outputs the\nquantile summaries for each tensor.",
    "attributes": [
      {
        "name": "num_features",
        "type": "int64",
        "description": "int; Inferred from the size of float_values.\nThe number of float features.",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "float_values",
        "description": "float; List of Rank 1 Tensors each containing values for a single feature.",
        "numberAttr": "num_features",
        "type": 1
      },
      {
        "name": "example_weights",
        "description": "float; Rank 1 Tensor with weights per instance.",
        "type": 1
      },
      {
        "name": "epsilon",
        "description": "float; The required maximum approximation error.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "summaries",
        "description": "float; List of Rank 2 Tensors each containing the quantile summary\n(value, weight, min_rank, max_rank) of a single feature.",
        "numberAttr": "num_features",
        "type": 1
      }
    ]
  },
  {
    "name": "BoostedTreesMakeStatsSummary",
    "summary": "Makes the summary of accumulated stats for the batch.",
    "description": "The summary stats contains gradients and hessians accumulated into the corresponding node and bucket for each example.",
    "attributes": [
      {
        "name": "max_splits",
        "type": "int64",
        "description": "int; the maximum number of splits possible in the whole tree.",
        "minimum": 1
      },
      {
        "name": "num_buckets",
        "type": "int64",
        "description": "int; equals to the maximum possible value of bucketized feature.",
        "minimum": 1
      },
      {
        "name": "num_features",
        "type": "int64",
        "description": "int; inferred from the size of bucketized_features_list; the number of features.",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "node_ids",
        "description": "int32 Rank 1 Tensor containing node ids, which each example falls into for the requested layer.",
        "type": 3
      },
      {
        "name": "gradients",
        "description": "float32; Rank 2 Tensor (shape=[#examples, 1]) for gradients.",
        "type": 1
      },
      {
        "name": "hessians",
        "description": "float32; Rank 2 Tensor (shape=[#examples, 1]) for hessians.",
        "type": 1
      },
      {
        "name": "bucketized_features_list",
        "description": "int32 list of Rank 1 Tensors, each containing the bucketized feature (for each feature column).",
        "numberAttr": "num_features",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "stats_summary",
        "description": "output Rank 4 Tensor (shape=[#features, #splits, #buckets, 2]) containing accumulated stats put into the corresponding node and bucket. The first index of 4th dimension refers to gradients, and the second to hessians.",
        "type": 1
      }
    ]
  },
  {
    "name": "BoostedTreesPredict",
    "summary": "Runs multiple additive regression ensemble predictors on input instances and",
    "description": "computes the logits. It is designed to be used during prediction.\nIt traverses all the trees and calculates the final score for each instance.",
    "attributes": [
      {
        "name": "num_bucketized_features",
        "type": "int64",
        "description": "Inferred.",
        "minimum": 1
      },
      {
        "name": "logits_dimension",
        "type": "int64",
        "description": "scalar, dimension of the logits, to be used for partial logits\nshape."
      }
    ],
    "inputs": [
      {
        "name": "tree_ensemble_handle",
        "type": 20
      },
      {
        "name": "bucketized_features",
        "description": "A list of rank 1 Tensors containing bucket id for each\nfeature.",
        "numberAttr": "num_bucketized_features",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "logits",
        "description": "Output rank 2 Tensor containing logits for each example.",
        "type": 1
      }
    ]
  },
  {
    "name": "BoostedTreesQuantileStreamResourceAddSummaries",
    "summary": "Add the quantile summaries to each quantile stream resource.",
    "description": "An op that adds a list of quantile summaries to a quantile stream resource. Each\nsummary Tensor is rank 2, containing summaries (value, weight, min_rank, max_rank)\nfor a single feature.",
    "attributes": [
      {
        "name": "num_features",
        "type": "int64",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "quantile_stream_resource_handle",
        "description": "resource handle referring to a QuantileStreamResource.",
        "type": 20
      },
      {
        "name": "summaries",
        "description": "string; List of Rank 2 Tensor each containing the summaries for a single feature.",
        "numberAttr": "num_features",
        "type": 1
      }
    ]
  },
  {
    "name": "BoostedTreesQuantileStreamResourceDeserialize",
    "summary": "Deserialize bucket boundaries and ready flag into current QuantileAccumulator.",
    "description": "An op that deserializes bucket boundaries and are boundaries ready flag into current QuantileAccumulator.",
    "attributes": [
      {
        "name": "num_streams",
        "type": "int64",
        "description": "inferred int; number of features to get bucket boundaries for.",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "quantile_stream_resource_handle",
        "description": "resource handle referring to a QuantileStreamResource.",
        "type": 20
      },
      {
        "name": "bucket_boundaries",
        "description": "float; List of Rank 1 Tensors each containing the bucket boundaries for a feature.",
        "numberAttr": "num_streams",
        "type": 1
      }
    ]
  },
  {
    "name": "BoostedTreesQuantileStreamResourceFlush",
    "summary": "Flush the summaries for a quantile stream resource.",
    "description": "An op that flushes the summaries for a quantile stream resource.",
    "attributes": [
      {
        "name": "generate_quantiles",
        "type": "boolean",
        "description": "bool; If True, the output will be the num_quantiles for each stream where the ith\nentry is the ith quantile of the input with an approximation error of epsilon.\nDuplicate values may be present.\nIf False, the output will be the points in the histogram that we got which roughly\ntranslates to 1/epsilon boundaries and without any duplicates.\nDefault to False.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "quantile_stream_resource_handle",
        "description": "resource handle referring to a QuantileStreamResource.",
        "type": 20
      },
      {
        "name": "num_buckets",
        "description": "int; approximate number of buckets unless using generate_quantiles.",
        "type": 9
      }
    ]
  },
  {
    "name": "BoostedTreesQuantileStreamResourceGetBucketBoundaries",
    "summary": "Generate the bucket boundaries for each feature based on accumulated summaries.",
    "description": "An op that returns a list of float tensors for a quantile stream resource. Each\ntensor is Rank 1 containing bucket boundaries for a single feature.",
    "attributes": [
      {
        "name": "num_features",
        "type": "int64",
        "description": "inferred int; number of features to get bucket boundaries for.",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "quantile_stream_resource_handle",
        "description": "resource handle referring to a QuantileStreamResource.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "bucket_boundaries",
        "description": "float; List of Rank 1 Tensors each containing the bucket boundaries for a feature.",
        "numberAttr": "num_features",
        "type": 1
      }
    ]
  },
  {
    "name": "BoostedTreesQuantileStreamResourceHandleOp",
    "summary": "Creates a handle to a BoostedTreesQuantileStreamResource.",
    "attributes": [
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "resource",
        "type": 20
      }
    ]
  },
  {
    "name": "BoostedTreesSerializeEnsemble",
    "summary": "Serializes the tree ensemble to a proto.",
    "inputs": [
      {
        "name": "tree_ensemble_handle",
        "description": "Handle to the tree ensemble.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "stamp_token",
        "description": "Stamp token of the tree ensemble resource.",
        "type": 9
      },
      {
        "name": "tree_ensemble_serialized",
        "description": "Serialized proto of the ensemble.",
        "type": 7
      }
    ]
  },
  {
    "name": "BoostedTreesSparseAggregateStats",
    "summary": "Aggregates the summary of accumulated stats for the batch.",
    "description": "The summary stats contains gradients and hessians accumulated for each node, bucket and dimension id.",
    "attributes": [
      {
        "name": "max_splits",
        "type": "int64",
        "description": "int; the maximum number of splits possible in the whole tree.",
        "minimum": 1
      },
      {
        "name": "num_buckets",
        "type": "int64",
        "description": "int; equals to the maximum possible value of bucketized feature + 1.",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "node_ids",
        "description": "int32; Rank 1 Tensor containing node ids for each example, shape [batch_size].",
        "type": 3
      },
      {
        "name": "gradients",
        "description": "float32; Rank 2 Tensor (shape=[batch_size, logits_dimension]) with gradients for each example.",
        "type": 1
      },
      {
        "name": "hessians",
        "description": "float32; Rank 2 Tensor (shape=[batch_size, hessian_dimension]) with hessians for each example.",
        "type": 1
      },
      {
        "name": "feature_indices",
        "description": "int32; Rank 2 indices of feature sparse Tensors (shape=[number of sparse entries, 2]).\nNumber of sparse entries across all instances from the batch. The first value is\nthe index of the instance, the second is dimension of the feature. The second axis\ncan only have 2 values, i.e., the input dense version of Tensor can only be matrix.",
        "type": 3
      },
      {
        "name": "feature_values",
        "description": "int32; Rank 1 values of feature sparse Tensors (shape=[number of sparse entries]).\nNumber of sparse entries across all instances from the batch. The first value is\nthe index of the instance, the second is dimension of the feature.",
        "type": 3
      },
      {
        "name": "feature_shape",
        "description": "int32; Rank 1 dense shape of feature sparse Tensors (shape=[2]).\nThe first axis can only have 2 values, [batch_size, feature_dimension].",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "stats_summary_indices",
        "description": "int32; Rank 2 indices of summary sparse Tensors (shape=[number of non zero statistics, 4])\nThe second axis can only be 4 including node id, feature dimension, bucket id, and statistics_dimension.\nstatistics_dimension = logits_dimension + hessian_dimension.",
        "type": 3
      },
      {
        "name": "stats_summary_values",
        "description": "output Rank 1 Tensor (shape=[number of non zero statistics])",
        "type": 1
      },
      {
        "name": "stats_summary_shape",
        "description": "output Rank 1 Tensor (shape=[4])\nThe tensor has following 4 values: [max_splits, feature_dimension, num_buckets, statistics_dimension],\nwhere statistics_dimension = gradient_dimension + hessian_dimension. gradient_dimension\nis the same as label_dimension, i.e., the output space. hessian_dimension can be the same\nas logits dimension when diagonal hessian is used, or label_dimension^2 when full\nhessian is used.",
        "type": 3
      }
    ]
  },
  {
    "name": "BoostedTreesSparseCalculateBestFeatureSplit",
    "summary": "Calculates gains for each feature and returns the best possible split information for the feature.",
    "description": "The split information is the best threshold (bucket id), gains and left/right node contributions per node for each feature.\n\nIt is possible that not all nodes can be split on each feature. Hence, the list of possible nodes can differ between the features. Therefore, we return `node_ids_list` for each feature, containing the list of nodes that this feature can be used to split.\n\nIn this manner, the output is the best split per features and per node, so that it needs to be combined later to produce the best split for each node (among all possible features).\n\nThe output shapes are compatible in a way that the first dimension of all tensors are the same and equal to the number of possible split nodes for each feature.",
    "attributes": [
      {
        "name": "logits_dimension",
        "type": "int64",
        "description": "The dimension of logit, i.e., number of classes.",
        "minimum": 1
      },
      {
        "name": "split_type",
        "type": "string",
        "description": "A string indicating if this Op should perform inequality split or equality split. Must be one of the following: `inequality`.",
        "default": "inequality"
      }
    ],
    "inputs": [
      {
        "name": "node_id_range",
        "description": "A Rank 1 tensor (shape=[2]) to specify the range [first, last) of node ids to process within `stats_summary_list`. The nodes are iterated between the two nodes specified by the tensor, as like `for node_id in range(node_id_range[0], node_id_range[1])` (Note that the last index node_id_range[1] is exclusive).",
        "type": 3
      },
      {
        "name": "stats_summary_indices",
        "description": "A Rank 2 int64 tensor of dense shape [N, 4] (N specifies the number of non-zero values) for accumulated stats summary (gradient/hessian) per node per bucket for each feature. The second dimension contains node id, feature dimension, bucket id, and stats dim.\nstats dim is the sum of logits dimension and hessian dimension, hessian dimension can either be logits dimension if diagonal hessian is used, or logits dimension^2 if full hessian is used.",
        "type": 3
      },
      {
        "name": "stats_summary_values",
        "description": "A Rank 1 float tensor of dense shape [N] (N specifies the number of non-zero values), which supplies the values for each element in summary_indices.",
        "type": 1
      },
      {
        "name": "stats_summary_shape",
        "description": "A Rank 1 float tensor of dense shape [4], which specifies the dense shape of the sparse tensor, which is [num tree nodes, feature dimensions, num buckets, stats dim].",
        "type": 3
      },
      {
        "name": "l1",
        "description": "l1 regularization factor on leaf weights, per instance based.",
        "type": 1
      },
      {
        "name": "l2",
        "description": "l2 regularization factor on leaf weights, per instance based.",
        "type": 1
      },
      {
        "name": "tree_complexity",
        "description": "adjustment to the gain, per leaf based.",
        "type": 1
      },
      {
        "name": "min_node_weight",
        "description": "minimum avg of hessians in a node before required for the node to be considered for splitting.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "node_ids",
        "description": "A Rank 1 tensor indicating possible node ids that can be split.",
        "type": 3
      },
      {
        "name": "gains",
        "description": "A Rank 1 tensor indicating the best gains to split each node.",
        "type": 1
      },
      {
        "name": "feature_dimensions",
        "description": "A Rank 1 tensor indicating the best feature dimension for each feature to split for each node.",
        "type": 3
      },
      {
        "name": "thresholds",
        "description": "A Rank 1 tensor indicating the bucket id to compare with (as a threshold) for split in each node.",
        "type": 3
      },
      {
        "name": "left_node_contribs",
        "description": "A Rank 2 tensor indicating the contribution of the left nodes when branching from parent nodes to the left direction by the given threshold for each feature.\nThis value will be used to make the left node value by adding to the parent node value. Second dimension size is logits dimension.",
        "type": 1
      },
      {
        "name": "right_node_contribs",
        "description": "A Rank 2 tensor, with the same shape/conditions as left_node_contribs_list, but just that the value is for the right node.",
        "type": 1
      },
      {
        "name": "split_with_default_directions",
        "description": "A Rank 1 tensor indicating which direction to go if data is missing.\nInequality with default left returns 0, inequality with default right returns 1, equality with default right returns 2.",
        "type": 7
      }
    ]
  },
  {
    "name": "BoostedTreesTrainingPredict",
    "summary": "Runs multiple additive regression ensemble predictors on input instances and",
    "description": "computes the update to cached logits. It is designed to be used during training.\nIt traverses the trees starting from cached tree id and cached node id and\ncalculates the updates to be pushed to the cache.",
    "attributes": [
      {
        "name": "num_bucketized_features",
        "type": "int64",
        "description": "Inferred.",
        "minimum": 1
      },
      {
        "name": "logits_dimension",
        "type": "int64",
        "description": "scalar, dimension of the logits, to be used for partial logits\nshape."
      }
    ],
    "inputs": [
      {
        "name": "tree_ensemble_handle",
        "type": 20
      },
      {
        "name": "cached_tree_ids",
        "description": "Rank 1 Tensor containing cached tree ids which is the starting\ntree of prediction.",
        "type": 3
      },
      {
        "name": "cached_node_ids",
        "description": "Rank 1 Tensor containing cached node id which is the starting\nnode of prediction.",
        "type": 3
      },
      {
        "name": "bucketized_features",
        "description": "A list of rank 1 Tensors containing bucket id for each\nfeature.",
        "numberAttr": "num_bucketized_features",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "partial_logits",
        "description": "Rank 2 Tensor containing logits update (with respect to cached\nvalues stored) for each example.",
        "type": 1
      },
      {
        "name": "tree_ids",
        "description": "Rank 1 Tensor containing new tree ids for each example.",
        "type": 3
      },
      {
        "name": "node_ids",
        "description": "Rank 1 Tensor containing new node ids in the new tree_ids.",
        "type": 3
      }
    ]
  },
  {
    "name": "BoostedTreesUpdateEnsemble",
    "summary": "Updates the tree ensemble by either adding a layer to the last tree being grown",
    "description": "or by starting a new tree.",
    "attributes": [
      {
        "name": "pruning_mode",
        "type": "int64",
        "description": "0-No pruning, 1-Pre-pruning, 2-Post-pruning.",
        "minimum": 0
      },
      {
        "name": "num_features",
        "type": "int64",
        "description": "Number of features that have best splits returned. INFERRED.",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "tree_ensemble_handle",
        "description": "Handle to the ensemble variable.",
        "type": 20
      },
      {
        "name": "feature_ids",
        "description": "Rank 1 tensor with ids for each feature. This is the real id of\nthe feature that will be used in the split.",
        "type": 3
      },
      {
        "name": "node_ids",
        "description": "List of rank 1 tensors representing the nodes for which this feature\nhas a split.",
        "numberAttr": "num_features",
        "type": 3
      },
      {
        "name": "gains",
        "description": "List of rank 1 tensors representing the gains for each of the feature's\nsplit.",
        "numberAttr": "num_features",
        "type": 1
      },
      {
        "name": "thresholds",
        "description": "List of rank 1 tensors representing the thesholds for each of the\nfeature's split.",
        "numberAttr": "num_features",
        "type": 3
      },
      {
        "name": "left_node_contribs",
        "description": "List of rank 2 tensors with left leaf contribs for each of\nthe feature's splits. Will be added to the previous node values to constitute\nthe values of the left nodes.",
        "numberAttr": "num_features",
        "type": 1
      },
      {
        "name": "right_node_contribs",
        "description": "List of rank 2 tensors with right leaf contribs for each\nof the feature's splits. Will be added to the previous node values to constitute\nthe values of the right nodes.",
        "numberAttr": "num_features",
        "type": 1
      },
      {
        "name": "max_depth",
        "description": "Max depth of the tree to build.",
        "type": 3
      },
      {
        "name": "learning_rate",
        "description": "shrinkage const for each new tree.",
        "type": 1
      }
    ]
  },
  {
    "name": "BoostedTreesUpdateEnsembleV2",
    "summary": "Updates the tree ensemble by adding a layer to the last tree being grown",
    "description": "or by starting a new tree.",
    "attributes": [
      {
        "name": "num_features",
        "type": "int64",
        "description": "Number of features that have best splits returned. INFERRED.",
        "minimum": 0
      },
      {
        "name": "logits_dimension",
        "type": "int64",
        "description": "scalar, dimension of the logits",
        "default": 1
      },
      {
        "name": "num_groups",
        "type": "int64",
        "description": "Number of groups of split information to process, where a group contains feature\nids that are processed together in BoostedTreesCalculateBestFeatureSplitOpV2.\nINFERRED.",
        "minimum": 1,
        "default": 1
      }
    ],
    "inputs": [
      {
        "name": "tree_ensemble_handle",
        "description": "Handle to the ensemble variable.",
        "type": 20
      },
      {
        "name": "feature_ids",
        "description": "Rank 1 tensor with ids for each feature. This is the real id of\nthe feature that will be used in the split.",
        "numberAttr": "num_groups",
        "type": 3
      },
      {
        "name": "dimension_ids",
        "description": "List of rank 1 tensors representing the dimension in each feature.",
        "numberAttr": "num_features",
        "type": 3
      },
      {
        "name": "node_ids",
        "description": "List of rank 1 tensors representing the nodes for which this feature\nhas a split.",
        "numberAttr": "num_features",
        "type": 3
      },
      {
        "name": "gains",
        "description": "List of rank 1 tensors representing the gains for each of the feature's\nsplit.",
        "numberAttr": "num_features",
        "type": 1
      },
      {
        "name": "thresholds",
        "description": "List of rank 1 tensors representing the thesholds for each of the\nfeature's split.",
        "numberAttr": "num_features",
        "type": 3
      },
      {
        "name": "left_node_contribs",
        "description": "List of rank 2 tensors with left leaf contribs for each of\nthe feature's splits. Will be added to the previous node values to constitute\nthe values of the left nodes.",
        "numberAttr": "num_features",
        "type": 1
      },
      {
        "name": "right_node_contribs",
        "description": "List of rank 2 tensors with right leaf contribs for each\nof the feature's splits. Will be added to the previous node values to constitute\nthe values of the right nodes.",
        "numberAttr": "num_features",
        "type": 1
      },
      {
        "name": "split_types",
        "description": "List of rank 1 tensors representing the split type for each feature.",
        "numberAttr": "num_features",
        "type": 7
      },
      {
        "name": "max_depth",
        "description": "Max depth of the tree to build.",
        "type": 3
      },
      {
        "name": "learning_rate",
        "description": "shrinkage const for each new tree.",
        "type": 1
      },
      {
        "name": "pruning_mode",
        "description": "0-No pruning, 1-Pre-pruning, 2-Post-pruning.",
        "type": 3
      }
    ]
  },
  {
    "name": "BroadcastArgs",
    "summary": "Return the shape of s0 op s1 with broadcast.",
    "description": "Given `s0` and `s1`, tensors that represent shapes, compute `r0`, the\nbroadcasted shape. `s0`, `s1` and `r0` are all integer vectors.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "s0",
        "typeAttr": "T"
      },
      {
        "name": "s1",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "r0",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BroadcastGradientArgs",
    "summary": "Return the reduction indices for computing gradients of s0 op s1 with broadcast.",
    "description": "This is typically used by gradient computations for a broadcasting operation.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "s0",
        "typeAttr": "T"
      },
      {
        "name": "s1",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "r0",
        "typeAttr": "T"
      },
      {
        "name": "r1",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "BroadcastTo",
    "summary": "Broadcast an array for a compatible shape.",
    "description": "Broadcasting is the process of making arrays to have compatible shapes\nfor arithmetic operations. Two shapes are compatible if for each\ndimension pair they are either equal or one of them is one.\n\nFor example:\n\n>>> x = tf.constant([[1, 2, 3]])   # Shape (1, 3,)\n>>> y = tf.broadcast_to(x, [2, 3])\n>>> print(y)\ntf.Tensor(\n    [[1 2 3]\n     [1 2 3]], shape=(2, 3), dtype=int32)\n\nIn the above example, the input Tensor with the shape of `[1, 3]`\nis broadcasted to output Tensor with shape of `[2, 3]`.\n\nWhen broadcasting, if a tensor has fewer axes than necessary its shape is\npadded on the left with ones. So this gives the same result as the previous\nexample:\n\n>>> x = tf.constant([1, 2, 3])   # Shape (3,)\n>>> y = tf.broadcast_to(x, [2, 3])\n\n\nWhen doing broadcasted operations such as multiplying a tensor\nby a scalar, broadcasting (usually) confers some time or space\nbenefit, as the broadcasted tensor is never materialized.\n\nHowever, `broadcast_to` does not carry with it any such benefits.\nThe newly-created tensor takes the full memory of the broadcasted\nshape. (In a graph context, `broadcast_to` might be fused to\nsubsequent operation and then be optimized away, however.)",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A Tensor to broadcast.",
        "typeAttr": "T"
      },
      {
        "name": "shape",
        "description": "An 1-D `int` Tensor. The shape of the desired output.",
        "typeAttr": "Tidx"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A Tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Bucketize",
    "summary": "Bucketizes 'input' based on 'boundaries'.",
    "description": "For example, if the inputs are\n    boundaries = [0, 10, 100]\n    input = [[-5, 10000]\n             [150,   10]\n             [5,    100]]\n\nthen the output will be\n    output = [[0, 3]\n              [3, 2]\n              [1, 3]]",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`, `float32`, `float64`."
      },
      {
        "name": "boundaries",
        "type": "float32[]",
        "description": "A sorted list of floats gives the boundary of the buckets."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Any shape of Tensor contains with int or float type.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Same shape with 'input', each value of input replaced with bucket index.\n\n@compatibility(numpy)\nEquivalent to np.digitize.\n@end_compatibility",
        "type": 3
      }
    ]
  },
  {
    "name": "BytesProducedStatsDataset",
    "summary": "Records the bytes size of each element of `input_dataset` in a StatsAggregator.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "tag",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "CSRSparseMatrixComponents",
    "summary": "Reads out the CSR components at batch `index`.",
    "description": "This op is meant only for debugging / testing, and its interface is not expected\nto be stable.",
    "attributes": [
      {
        "name": "type",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "csr_sparse_matrix",
        "description": "A batched CSRSparseMatrix.",
        "type": 21
      },
      {
        "name": "index",
        "description": "The index in `csr_sparse_matrix`'s batch.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "row_ptrs",
        "description": "An array containing CSR matrix row pointers.",
        "type": 3
      },
      {
        "name": "col_inds",
        "description": "An array containing CSR matrix column indices.",
        "type": 3
      },
      {
        "name": "values",
        "description": "An array containing CSR matrix nonzero values.",
        "typeAttr": "type"
      }
    ]
  },
  {
    "name": "CSRSparseMatrixToDense",
    "summary": "Convert a (possibly batched) CSRSparseMatrix to dense.",
    "attributes": [
      {
        "name": "type",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "sparse_input",
        "description": "A batched CSRSparseMatrix.",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "dense_output",
        "description": "A dense tensor.",
        "typeAttr": "type"
      }
    ]
  },
  {
    "name": "CSRSparseMatrixToSparseTensor",
    "summary": "Converts a (possibly batched) CSRSparesMatrix to a SparseTensor.",
    "attributes": [
      {
        "name": "type",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "sparse_matrix",
        "description": "A (possibly batched) CSRSparseMatrix.",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "indices",
        "description": "SparseTensor indices.",
        "type": 9
      },
      {
        "name": "values",
        "description": "SparseTensor values.",
        "typeAttr": "type"
      },
      {
        "name": "dense_shape",
        "description": "SparseTensor dense shape.",
        "type": 9
      }
    ]
  },
  {
    "name": "CSVDataset",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1,
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `int64`, `string`."
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "filenames",
        "type": 7
      },
      {
        "name": "compression_type",
        "type": 7
      },
      {
        "name": "buffer_size",
        "type": 9
      },
      {
        "name": "header",
        "type": 10
      },
      {
        "name": "field_delim",
        "type": 7
      },
      {
        "name": "use_quote_delim",
        "type": 10
      },
      {
        "name": "na_value",
        "type": 7
      },
      {
        "name": "select_cols",
        "type": 9
      },
      {
        "name": "record_defaults",
        "typeListAttr": "output_types"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "CSVDatasetV2",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1,
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `int64`, `string`."
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "filenames",
        "type": 7
      },
      {
        "name": "compression_type",
        "type": 7
      },
      {
        "name": "buffer_size",
        "type": 9
      },
      {
        "name": "header",
        "type": 10
      },
      {
        "name": "field_delim",
        "type": 7
      },
      {
        "name": "use_quote_delim",
        "type": 10
      },
      {
        "name": "na_value",
        "type": 7
      },
      {
        "name": "select_cols",
        "type": 9
      },
      {
        "name": "record_defaults",
        "typeListAttr": "output_types"
      },
      {
        "name": "exclude_cols",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "CTCBeamSearchDecoder",
    "summary": "Performs beam search decoding on the logits given in input.",
    "description": "A note about the attribute merge_repeated: For the beam search decoder,\nthis means that if consecutive entries in a beam are the same, only\nthe first of these is emitted.  That is, when the top path is \"A B B B B\",\n\"A B\" is returned if merge_repeated = True but \"A B B B B\" is\nreturned if merge_repeated = False.",
    "attributes": [
      {
        "name": "beam_width",
        "type": "int64",
        "description": "A scalar >= 0 (beam search beam width).",
        "minimum": 1
      },
      {
        "name": "top_paths",
        "type": "int64",
        "description": "A scalar >= 0, <= beam_width (controls output size).",
        "minimum": 1
      },
      {
        "name": "merge_repeated",
        "type": "boolean",
        "description": "If true, merge repeated classes in output.",
        "default": true
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "description": "3-D, shape: `(max_time x batch_size x num_classes)`, the logits.",
        "typeAttr": "T"
      },
      {
        "name": "sequence_length",
        "description": "A vector containing sequence lengths, size `(batch)`.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "decoded_indices",
        "description": "A list (length: top_paths) of indices matrices.  Matrix j,\nsize `(total_decoded_outputs[j] x 2)`, has indices of a\n`SparseTensor<int64, 2>`.  The rows store: [batch, time].",
        "numberAttr": "top_paths",
        "type": 9
      },
      {
        "name": "decoded_values",
        "description": "A list (length: top_paths) of values vectors.  Vector j,\nsize `(length total_decoded_outputs[j])`, has the values of a\n`SparseTensor<int64, 2>`.  The vector stores the decoded classes for beam j.",
        "numberAttr": "top_paths",
        "type": 9
      },
      {
        "name": "decoded_shape",
        "description": "A list (length: top_paths) of shape vector.  Vector j,\nsize `(2)`, stores the shape of the decoded `SparseTensor[j]`.\nIts values are: `[batch_size, max_decoded_length[j]]`.",
        "numberAttr": "top_paths",
        "type": 9
      },
      {
        "name": "log_probability",
        "description": "A matrix, shaped: `(batch_size x top_paths)`.  The\nsequence log-probabilities.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CTCGreedyDecoder",
    "summary": "Performs greedy decoding on the logits given in inputs.",
    "description": "A note about the attribute merge_repeated: if enabled, when\nconsecutive logits' maximum indices are the same, only the first of\nthese is emitted.  Labeling the blank '*', the sequence \"A B B * B B\"\nbecomes \"A B B\" if merge_repeated = True and \"A B B B B\" if\nmerge_repeated = False.\n\nRegardless of the value of merge_repeated, if the maximum index of a given\ntime and batch corresponds to the blank, index `(num_classes - 1)`, no new\nelement is emitted.",
    "attributes": [
      {
        "name": "merge_repeated",
        "type": "boolean",
        "description": "If True, merge repeated classes in output.",
        "default": false
      },
      {
        "name": "blank_index",
        "type": "int64",
        "default": -1
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "description": "3-D, shape: `(max_time x batch_size x num_classes)`, the logits.",
        "typeAttr": "T"
      },
      {
        "name": "sequence_length",
        "description": "A vector containing sequence lengths, size `(batch_size)`.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "decoded_indices",
        "description": "Indices matrix, size `(total_decoded_outputs x 2)`,\nof a `SparseTensor<int64, 2>`.  The rows store: [batch, time].",
        "type": 9
      },
      {
        "name": "decoded_values",
        "description": "Values vector, size: `(total_decoded_outputs)`,\nof a `SparseTensor<int64, 2>`.  The vector stores the decoded classes.",
        "type": 9
      },
      {
        "name": "decoded_shape",
        "description": "Shape vector, size `(2)`, of the decoded SparseTensor.\nValues are: `[batch_size, max_decoded_length]`.",
        "type": 9
      },
      {
        "name": "log_probability",
        "description": "Matrix, size `(batch_size x 1)`, containing sequence\nlog-probabilities.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CTCLoss",
    "summary": "Calculates the CTC Loss (log probability) for each batch entry.  Also calculates",
    "description": "the gradient.  This class performs the softmax operation for you, so inputs\nshould be e.g. linear projections of outputs by an LSTM.",
    "attributes": [
      {
        "name": "preprocess_collapse_repeated",
        "type": "boolean",
        "description": "Scalar, if true then repeated labels are\ncollapsed prior to the CTC calculation.",
        "default": false
      },
      {
        "name": "ctc_merge_repeated",
        "type": "boolean",
        "description": "Scalar.  If set to false, *during* CTC calculation\nrepeated non-blank labels will not be merged and are interpreted as\nindividual labels.  This is a simplified version of CTC.",
        "default": true
      },
      {
        "name": "ignore_longer_outputs_than_inputs",
        "type": "boolean",
        "description": "Scalar. If set to true, during CTC\ncalculation, items that have longer output sequences than input sequences\nare skipped: they don't contribute to the loss term and have zero-gradient.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "description": "3-D, shape: `(max_time x batch_size x num_classes)`, the logits.",
        "typeAttr": "T"
      },
      {
        "name": "labels_indices",
        "description": "The indices of a `SparseTensor<int32, 2>`.\n`labels_indices(i, :) == [b, t]` means `labels_values(i)` stores the id for\n`(batch b, time t)`.",
        "type": 9
      },
      {
        "name": "labels_values",
        "description": "The values (labels) associated with the given batch and time.",
        "type": 3
      },
      {
        "name": "sequence_length",
        "description": "A vector containing sequence lengths (batch).",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "loss",
        "description": "A vector (batch) containing log-probabilities.",
        "typeAttr": "T"
      },
      {
        "name": "gradient",
        "description": "The gradient of `loss`.  3-D, shape:\n`(max_time x batch_size x num_classes)`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CTCLossV2",
    "summary": "Calculates the CTC Loss (log probability) for each batch entry.  Also calculates",
    "description": "the gradient.  This class performs the softmax operation for you, so inputs\nshould be e.g. linear projections of outputs by an LSTM.",
    "attributes": [
      {
        "name": "preprocess_collapse_repeated",
        "type": "boolean",
        "description": "Scalar, if true then repeated labels are\ncollapsed prior to the CTC calculation.",
        "default": false
      },
      {
        "name": "ctc_merge_repeated",
        "type": "boolean",
        "description": "Scalar.  If set to false, *during* CTC calculation\nrepeated non-blank labels will not be merged and are interpreted as\nindividual labels.  This is a simplified version of CTC.",
        "default": true
      },
      {
        "name": "ignore_longer_outputs_than_inputs",
        "type": "boolean",
        "description": "Scalar. If set to true, during CTC\ncalculation, items that have longer output sequences than input sequences\nare skipped: they don't contribute to the loss term and have zero-gradient.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "description": "3-D, shape: `(max_time x batch_size x num_classes)`, the logits. Default blank\nlabel is 0 rather num_classes - 1.",
        "type": 1
      },
      {
        "name": "labels_indices",
        "description": "The indices of a `SparseTensor<int32, 2>`.\n`labels_indices(i, :) == [b, t]` means `labels_values(i)` stores the id for\n`(batch b, time t)`.",
        "type": 9
      },
      {
        "name": "labels_values",
        "description": "The values (labels) associated with the given batch and time.",
        "type": 3
      },
      {
        "name": "sequence_length",
        "description": "A vector containing sequence lengths (batch).",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "loss",
        "description": "A vector (batch) containing log-probabilities.",
        "type": 1
      },
      {
        "name": "gradient",
        "description": "The gradient of `loss`.  3-D, shape:\n`(max_time x batch_size x num_classes)`.",
        "type": 1
      }
    ]
  },
  {
    "name": "CacheDataset",
    "summary": "Creates a dataset that caches elements from `input_dataset`.",
    "description": "A CacheDataset will iterate over the input_dataset, and store tensors. If the\ncache already exists, the cache will be used. If the cache is inappropriate\n(e.g. cannot be opened, contains tensors of the wrong shape / size), an error\nwill the returned when used.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "filename",
        "description": "A path on the filesystem where we should cache the dataset. Note: this\nwill be a directory.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "CacheDatasetV2",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "filename",
        "type": 7
      },
      {
        "name": "cache",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "Case",
    "summary": "An n-way switch statement which calls a single branch function.",
    "description": "    An n-way switch statement, implementing the following:\n    ```\n    switch (branch_index) {\n      case 0:\n        output = branches[0](input);\n        break;\n      case 1:\n        output = branches[1](input);\n        break;\n      ...\n      case [[nbranches-1]]:\n      default:\n        output = branches[nbranches-1](input);\n        break;\n    }\n    ```",
    "attributes": [
      {
        "name": "Tin",
        "type": "type[]",
        "description": "A list of input types.",
        "minimum": 0
      },
      {
        "name": "Tout",
        "type": "type[]",
        "description": "A list of output types.",
        "minimum": 0
      },
      {
        "name": "branches",
        "type": "function[]",
        "description": "      A list of functions each of which takes 'inputs' and returns a list of\n      tensors, whose types are the same as what every other branch returns.",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "branch_index",
        "description": "The branch selector, an int32 Tensor.",
        "type": 3
      },
      {
        "name": "input",
        "description": "A list of input tensors passed to the branch function.",
        "typeListAttr": "Tin"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A list of return values.",
        "typeListAttr": "Tout"
      }
    ]
  },
  {
    "name": "Cast",
    "summary": "Cast x of type SrcT to y of DstT.",
    "attributes": [
      {
        "name": "SrcT",
        "type": "type"
      },
      {
        "name": "DstT",
        "type": "type"
      },
      {
        "name": "Truncate",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "SrcT"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "DstT"
      }
    ]
  },
  {
    "name": "Ceil",
    "summary": "Returns element-wise smallest integer not less than x.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CheckNumerics",
    "summary": "Checks a tensor for NaN and Inf values.",
    "description": "When run, reports an `InvalidArgument` error if `tensor` has any values\nthat are not a number (NaN) or infinity (Inf). Otherwise, returns the input\ntensor.\n\nExample usage:\n\n``` python\na = tf.Variable(1.0)\ntf.debugging.check_numerics(a, message='')\n\nb = tf.Variable(np.nan)\ntry:\n  tf.debugging.check_numerics(b, message='Checking b')\nexcept Exception as e:\n  assert \"Checking b : Tensor had NaN values\" in e.message\n\nc = tf.Variable(np.inf)\ntry:\n  tf.debugging.check_numerics(c, message='Checking c')\nexcept Exception as e:\n  assert \"Checking c : Tensor had Inf values\" in e.message\n```\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "message",
        "type": "string",
        "description": "Prefix of the error message."
      }
    ],
    "inputs": [
      {
        "name": "tensor",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CheckNumericsV2",
    "summary": "Checks a tensor for NaN, -Inf and +Inf values.",
    "description": "When run, reports an `InvalidArgument` error if `tensor` has any values\nthat are not a number (NaN) or infinity (Inf). Otherwise, returns the input\ntensor. Unlike CheckNumerics (V1), CheckNumericsV2 distinguishes -Inf and +Inf\nin the errors it throws.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "message",
        "type": "string",
        "description": "Prefix of the error message."
      }
    ],
    "inputs": [
      {
        "name": "tensor",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Cholesky",
    "summary": "Computes the Cholesky decomposition of one or more square matrices.",
    "description": "The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices.\n\nThe input has to be symmetric and positive definite. Only the lower-triangular\npart of the input will be used for this operation. The upper-triangular part\nwill not be read.\n\nThe output is a tensor of the same shape as the input\ncontaining the Cholesky decompositions for all input submatrices `[..., :, :]`.\n\n**Note**: The gradient computation on GPU is faster for large matrices but\nnot for large batch dimensions when the submatrices are small. In this\ncase it might be faster to use the CPU.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float64`, `float32`, `float16`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Shape is `[..., M, M]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Shape is `[..., M, M]`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CholeskyGrad",
    "summary": "Computes the reverse mode backpropagated gradient of the Cholesky algorithm.",
    "description": "For an explanation see \"Differentiation of the Cholesky algorithm\" by\nIain Murray http://arxiv.org/abs/1602.07527.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "l",
        "description": "Output of batch Cholesky algorithm l = cholesky(A). Shape is `[..., M, M]`.\nAlgorithm depends only on lower triangular part of the innermost matrices of\nthis tensor.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "df/dl where f is some scalar function. Shape is `[..., M, M]`.\nAlgorithm depends only on lower triangular part of the innermost matrices of\nthis tensor.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Symmetrized version of df/dA . Shape is `[..., M, M]`",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ChooseFastestBranchDataset",
    "attributes": [
      {
        "name": "Targuments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "num_elements_per_branch",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "branches",
        "type": "function[]",
        "minimum": 1
      },
      {
        "name": "other_arguments_lengths",
        "type": "int64[]",
        "minimum": 1
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "ratio_numerator",
        "type": 9
      },
      {
        "name": "ratio_denominator",
        "type": 9
      },
      {
        "name": "other_arguments",
        "typeListAttr": "Targuments"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ChooseFastestDataset",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 2
      },
      {
        "name": "num_experiments",
        "type": "int64"
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_datasets",
        "numberAttr": "N",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ClipByValue",
    "summary": "Clips tensor values to a specified min and max.",
    "description": "Given a tensor `t`, this operation returns a tensor of the same type and\nshape as `t` with its values clipped to `clip_value_min` and `clip_value_max`.\nAny values less than `clip_value_min` are set to `clip_value_min`. Any values\ngreater than `clip_value_max` are set to `clip_value_max`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "t",
        "description": "A `Tensor`.",
        "typeAttr": "T"
      },
      {
        "name": "clip_value_min",
        "description": "A 0-D (scalar) `Tensor`, or a `Tensor` with the same shape\nas `t`. The minimum value to clip by.",
        "typeAttr": "T"
      },
      {
        "name": "clip_value_max",
        "description": "A 0-D (scalar) `Tensor`, or a `Tensor` with the same shape\nas `t`. The maximum value to clip by.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A clipped `Tensor` with the same shape as input 't'.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CloseSummaryWriter",
    "inputs": [
      {
        "name": "writer",
        "type": 20
      }
    ]
  },
  {
    "name": "CollateTPUEmbeddingMemory",
    "summary": "An op that merges the string-encoded memory config protos from all hosts.",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "memory_configs",
        "description": "String-encoded memory config protos containing metadata about\nthe memory allocations reserved for TPUEmbedding across all hosts.",
        "numberAttr": "N",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "merged_memory_config",
        "type": 7
      }
    ]
  },
  {
    "name": "CollectiveAllToAllV2",
    "summary": "Mutually exchanges multiple tensors of identical type and shape.",
    "description": "`is_stateless` means each op does not need control dependencies to other\ncollective ops. In this case, keys that are unique at runtime\n(e.g. `instance_key`) should be used to distinguish collective groups.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float32`, `float16`, `float64`, `int32`, `int64`."
      },
      {
        "name": "communication_hint",
        "type": "string",
        "default": "auto"
      },
      {
        "name": "timeout_seconds",
        "type": "float32",
        "default": 0.0
      },
      {
        "name": "is_stateless",
        "type": "boolean",
        "default": false
      },
      {
        "name": "Nordering_token",
        "type": "int64",
        "minimum": 0,
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "group_size",
        "type": 3
      },
      {
        "name": "group_key",
        "type": 3
      },
      {
        "name": "instance_key",
        "type": 3
      },
      {
        "name": "ordering_token",
        "numberAttr": "Nordering_token",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "data",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CollectiveAllToAllV3",
    "summary": "Mutually exchanges multiple tensors of identical type and shape.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float32`, `float16`, `float64`, `int32`, `int64`."
      },
      {
        "name": "timeout_seconds",
        "type": "float32",
        "default": 0.0
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "communicator",
        "type": 20
      },
      {
        "name": "group_assignment",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "data",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CollectiveAssignGroupV2",
    "summary": "Assign group keys based on group assignment.",
    "inputs": [
      {
        "name": "group_assignment",
        "type": 3
      },
      {
        "name": "device_index",
        "type": 3
      },
      {
        "name": "base_key",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "group_size",
        "type": 3
      },
      {
        "name": "group_key",
        "type": 3
      }
    ]
  },
  {
    "name": "CollectiveBcastRecv",
    "summary": "Receives a tensor value broadcast from another device.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bool`, `float32`, `float16`, `float64`, `int32`, `int64`."
      },
      {
        "name": "group_size",
        "type": "int64"
      },
      {
        "name": "group_key",
        "type": "int64"
      },
      {
        "name": "instance_key",
        "type": "int64"
      },
      {
        "name": "shape",
        "type": "shape"
      },
      {
        "name": "communication_hint",
        "type": "string",
        "default": "auto"
      },
      {
        "name": "timeout_seconds",
        "type": "float32",
        "default": 0.0
      }
    ],
    "outputs": [
      {
        "name": "data",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CollectiveBcastRecvV2",
    "summary": "Receives a tensor value broadcast from another device.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bool`, `float32`, `float16`, `float64`, `int32`, `int64`."
      },
      {
        "name": "Tshape",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "communication_hint",
        "type": "string",
        "default": "auto"
      },
      {
        "name": "timeout_seconds",
        "type": "float32",
        "default": 0.0
      }
    ],
    "inputs": [
      {
        "name": "group_size",
        "type": 3
      },
      {
        "name": "group_key",
        "type": 3
      },
      {
        "name": "instance_key",
        "type": 3
      },
      {
        "name": "shape",
        "typeAttr": "Tshape"
      }
    ],
    "outputs": [
      {
        "name": "data",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CollectiveBcastSend",
    "summary": "Broadcasts a tensor value to one or more other devices.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bool`, `float32`, `float16`, `float64`, `int32`, `int64`."
      },
      {
        "name": "group_size",
        "type": "int64"
      },
      {
        "name": "group_key",
        "type": "int64"
      },
      {
        "name": "instance_key",
        "type": "int64"
      },
      {
        "name": "shape",
        "type": "shape"
      },
      {
        "name": "communication_hint",
        "type": "string",
        "default": "auto"
      },
      {
        "name": "timeout_seconds",
        "type": "float32",
        "default": 0.0
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "data",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CollectiveBcastSendV2",
    "summary": "Broadcasts a tensor value to one or more other devices.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bool`, `float32`, `float16`, `float64`, `int32`, `int64`."
      },
      {
        "name": "communication_hint",
        "type": "string",
        "default": "auto"
      },
      {
        "name": "timeout_seconds",
        "type": "float32",
        "default": 0.0
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "group_size",
        "type": 3
      },
      {
        "name": "group_key",
        "type": 3
      },
      {
        "name": "instance_key",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "data",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CollectiveGather",
    "summary": "Mutually accumulates multiple tensors of identical type and shape.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float16`, `float64`, `int32`, `int64`."
      },
      {
        "name": "group_size",
        "type": "int64"
      },
      {
        "name": "group_key",
        "type": "int64"
      },
      {
        "name": "instance_key",
        "type": "int64"
      },
      {
        "name": "shape",
        "type": "shape"
      },
      {
        "name": "communication_hint",
        "type": "string",
        "default": "auto"
      },
      {
        "name": "timeout_seconds",
        "type": "float32",
        "default": 0.0
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "data",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CollectiveGatherV2",
    "summary": "Mutually accumulates multiple tensors of identical type and shape.",
    "description": "`is_stateless` means each op does not need control dependencies to other\ncollective ops. In this case, keys that are unique at runtime\n(e.g. `instance_key`) should be used to distinguish collective groups.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float16`, `float64`, `int32`, `int64`."
      },
      {
        "name": "communication_hint",
        "type": "string",
        "default": "auto"
      },
      {
        "name": "timeout_seconds",
        "type": "float32",
        "default": 0.0
      },
      {
        "name": "is_stateless",
        "type": "boolean",
        "default": false
      },
      {
        "name": "Nordering_token",
        "type": "int64",
        "minimum": 0,
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "group_size",
        "type": 3
      },
      {
        "name": "group_key",
        "type": 3
      },
      {
        "name": "instance_key",
        "type": 3
      },
      {
        "name": "ordering_token",
        "numberAttr": "Nordering_token",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "data",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CollectiveInitializeCommunicator",
    "summary": "Initializes a group for collective operations.",
    "attributes": [
      {
        "name": "communication_hint",
        "type": "string",
        "default": "auto"
      },
      {
        "name": "timeout_seconds",
        "type": "float32",
        "default": 0.0
      }
    ],
    "inputs": [
      {
        "name": "group_key",
        "type": 3
      },
      {
        "name": "rank",
        "type": 3
      },
      {
        "name": "group_size",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "communicator",
        "type": 20
      }
    ]
  },
  {
    "name": "CollectivePermute",
    "summary": "An Op to permute tensors across replicated TPU instances.",
    "description": "Each instance supplies its own input.\n\nFor example, suppose there are 4 TPU instances: `[A, B, C, D]`. Passing\nsource_target_pairs=`[[0,1],[1,2],[2,3],[3,0]]` gets the outputs:\n`[D, A, B, C]`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "The type of elements to be exchanged. Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The local input to be permuted. Currently only supports float and\nbfloat16.",
        "typeAttr": "T"
      },
      {
        "name": "source_target_pairs",
        "description": "A tensor with shape [num_pairs, 2].",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The permuted input.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CollectiveReduce",
    "summary": "Mutually reduces multiple tensors of identical type and shape.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float32`, `float16`, `float64`, `int32`, `int64`."
      },
      {
        "name": "group_size",
        "type": "int64"
      },
      {
        "name": "group_key",
        "type": "int64"
      },
      {
        "name": "instance_key",
        "type": "int64"
      },
      {
        "name": "merge_op",
        "type": "string",
        "description": "Must be one of the following: `Min`, `Max`, `Mul`, `Add`."
      },
      {
        "name": "final_op",
        "type": "string",
        "description": "Must be one of the following: `Id`, `Div`."
      },
      {
        "name": "subdiv_offsets",
        "type": "int64[]"
      },
      {
        "name": "wait_for",
        "type": "int64[]",
        "default": []
      },
      {
        "name": "communication_hint",
        "type": "string",
        "default": "auto"
      },
      {
        "name": "timeout_seconds",
        "type": "float32",
        "default": 0.0
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "data",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CollectiveReduceScatterV2",
    "summary": "Mutually reduces multiple tensors of identical type and shape and scatters the result.",
    "description": "`is_stateless` means each op does not need control dependencies to other\ncollective ops. In this case, keys that are unique at runtime\n(e.g. `instance_key`) should be used to distinguish collective groups.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float32`, `float16`, `float64`, `int32`, `int64`."
      },
      {
        "name": "merge_op",
        "type": "string",
        "description": "Must be one of the following: `Min`, `Max`, `Mul`, `Add`."
      },
      {
        "name": "final_op",
        "type": "string",
        "description": "Must be one of the following: `Id`, `Div`."
      },
      {
        "name": "communication_hint",
        "type": "string",
        "default": "auto"
      },
      {
        "name": "timeout_seconds",
        "type": "float32",
        "default": 0.0
      },
      {
        "name": "is_stateless",
        "type": "boolean",
        "default": false
      },
      {
        "name": "Nordering_token",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "max_subdivs_per_device",
        "type": "int64",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "group_size",
        "type": 3
      },
      {
        "name": "group_key",
        "type": 3
      },
      {
        "name": "instance_key",
        "type": 3
      },
      {
        "name": "ordering_token",
        "numberAttr": "Nordering_token",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "data",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CollectiveReduceV2",
    "summary": "Mutually reduces multiple tensors of identical type and shape.",
    "description": "`is_stateless` means each op does not need control dependencies to other\ncollective ops. In this case, keys that are unique at runtime\n(e.g. `instance_key`) should be used to distinguish collective groups.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float32`, `float16`, `float64`, `int32`, `int64`."
      },
      {
        "name": "merge_op",
        "type": "string",
        "description": "Must be one of the following: `Min`, `Max`, `Mul`, `Add`."
      },
      {
        "name": "final_op",
        "type": "string",
        "description": "Must be one of the following: `Id`, `Div`."
      },
      {
        "name": "communication_hint",
        "type": "string",
        "default": "auto"
      },
      {
        "name": "timeout_seconds",
        "type": "float32",
        "default": 0.0
      },
      {
        "name": "is_stateless",
        "type": "boolean",
        "default": false
      },
      {
        "name": "Nordering_token",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "max_subdivs_per_device",
        "type": "int64",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "group_size",
        "type": 3
      },
      {
        "name": "group_key",
        "type": 3
      },
      {
        "name": "instance_key",
        "type": 3
      },
      {
        "name": "ordering_token",
        "numberAttr": "Nordering_token",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "data",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CollectiveReduceV3",
    "summary": "Mutually reduces multiple tensors of identical type and shape.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float32`, `float16`, `float64`, `int32`, `int64`."
      },
      {
        "name": "reduction",
        "type": "string",
        "description": "Must be one of the following: `Min`, `Max`, `Mul`, `Add`."
      },
      {
        "name": "timeout_seconds",
        "type": "float32",
        "default": 0.0
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "communicator",
        "type": 20
      },
      {
        "name": "group_assignment",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "data",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CombinedNonMaxSuppression",
    "summary": "Greedily selects a subset of bounding boxes in descending order of score,",
    "description": "This operation performs non_max_suppression on the inputs per batch, across\nall classes.\nPrunes away boxes that have high intersection-over-union (IOU) overlap\nwith previously selected boxes.  Bounding boxes are supplied as\n[y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any\ndiagonal pair of box corners and the coordinates can be provided as normalized\n(i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm\nis agnostic to where the origin is in the coordinate system. Also note that\nthis algorithm is invariant to orthogonal transformations and translations\nof the coordinate system; thus translating or reflections of the coordinate\nsystem result in the same boxes being selected by the algorithm.\nThe output of this operation is the final boxes, scores and classes tensor\nreturned after performing non_max_suppression.",
    "attributes": [
      {
        "name": "pad_per_class",
        "type": "boolean",
        "description": "If false, the output nmsed boxes, scores and classes\nare padded/clipped to `max_total_size`. If true, the\noutput nmsed boxes, scores and classes are padded to be of length\n`max_size_per_class`*`num_classes`, unless it exceeds `max_total_size` in\nwhich case it is clipped to `max_total_size`. Defaults to false.",
        "default": false
      },
      {
        "name": "clip_boxes",
        "type": "boolean",
        "description": "If true, assume the box coordinates are between [0, 1] and clip the output boxes\nif they fall beyond [0, 1]. If false, do not do clipping and output the box\ncoordinates as it is.",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "boxes",
        "description": "A 4-D float tensor of shape `[batch_size, num_boxes, q, 4]`. If `q` is 1 then\nsame boxes are used for all classes otherwise, if `q` is equal to number of\nclasses, class-specific boxes are used.",
        "type": 1
      },
      {
        "name": "scores",
        "description": "A 3-D float tensor of shape `[batch_size, num_boxes, num_classes]`\nrepresenting a single score corresponding to each box (each row of boxes).",
        "type": 1
      },
      {
        "name": "max_output_size_per_class",
        "description": "A scalar integer tensor representing the maximum number of\nboxes to be selected by non max suppression per class",
        "type": 3
      },
      {
        "name": "max_total_size",
        "description": "An int32 scalar representing the maximum number of boxes retained over all\nclasses. Note that setting this value to a large number may result in OOM error\ndepending on the system workload.",
        "type": 3
      },
      {
        "name": "iou_threshold",
        "description": "A 0-D float tensor representing the threshold for deciding whether\nboxes overlap too much with respect to IOU.",
        "type": 1
      },
      {
        "name": "score_threshold",
        "description": "A 0-D float tensor representing the threshold for deciding when to remove\nboxes based on score.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "nmsed_boxes",
        "description": "A [batch_size, max_detections, 4] float32 tensor\ncontaining the non-max suppressed boxes.",
        "type": 1
      },
      {
        "name": "nmsed_scores",
        "description": "A [batch_size, max_detections] float32 tensor\ncontaining the scores for the boxes.",
        "type": 1
      },
      {
        "name": "nmsed_classes",
        "description": "A [batch_size, max_detections] float32 tensor\ncontaining the classes for the boxes.",
        "type": 1
      },
      {
        "name": "valid_detections",
        "description": "A [batch_size] int32 tensor indicating the number of\nvalid detections per batch item. Only the top num_detections[i] entries in\nnms_boxes[i], nms_scores[i] and nms_class[i] are valid. The rest of the\nentries are zero paddings.",
        "type": 3
      }
    ]
  },
  {
    "name": "Complex",
    "summary": "Converts two real numbers to a complex number.",
    "description": "Given a tensor `real` representing the real part of a complex number, and a\ntensor `imag` representing the imaginary part of a complex number, this\noperation returns complex numbers elementwise of the form \\\\(a + bj\\\\), where\n*a* represents the `real` part and *b* represents the `imag` part.\n\nThe input tensors `real` and `imag` must have the same shape.\n\nFor example:\n\n```\n# tensor 'real' is [2.25, 3.25]\n# tensor `imag` is [4.75, 5.75]\ntf.complex(real, imag) ==> [[2.25 + 4.75j], [3.25 + 5.75j]]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "Tout",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      }
    ],
    "inputs": [
      {
        "name": "real",
        "typeAttr": "T"
      },
      {
        "name": "imag",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "ComplexAbs",
    "summary": "Computes the complex absolute value of a tensor.",
    "description": "Given a tensor `x` of complex numbers, this operation returns a tensor of type\n`float` or `double` that is the absolute value of each element in `x`. All\nelements in `x` must be complex numbers of the form \\\\(a + bj\\\\). The absolute\nvalue is computed as \\\\( \\sqrt{a^2 + b^2}\\\\).\n\nFor example:\n\n>>> x = tf.complex(3.0, 4.0)\n>>> print((tf.raw_ops.ComplexAbs(x=x, Tout=tf.dtypes.float32, name=None)).numpy())\n5.0\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      },
      {
        "name": "Tout",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "CompositeTensorVariantFromComponents",
    "summary": "Encodes an `ExtensionType` value into a `variant` scalar Tensor.",
    "description": "Returns a scalar variant tensor containing a single `CompositeTensorVariant`\nwith the specified Tensor components and TypeSpec.",
    "attributes": [
      {
        "name": "metadata",
        "type": "string",
        "description": "String serialization for the TypeSpec.  (Note: the encoding for the TypeSpec\nmay change in future versions of TensorFlow.)"
      },
      {
        "name": "Tcomponents",
        "type": "type[]",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "components",
        "description": "The component tensors for the extension type value.",
        "typeListAttr": "Tcomponents"
      }
    ],
    "outputs": [
      {
        "name": "encoded",
        "description": "A `variant` Tensor that containing the encoded value.",
        "type": 21
      }
    ]
  },
  {
    "name": "CompositeTensorVariantToComponents",
    "summary": "Decodes a `variant` scalar Tensor into an `ExtensionType` value.",
    "description": "Returns the Tensor components encoded in a `CompositeTensorVariant`.\n\nRaises an error if `type_spec_proto` doesn't match the TypeSpec\nin `encoded`.",
    "attributes": [
      {
        "name": "metadata",
        "type": "string",
        "description": "String serialization for the TypeSpec.  Must be compatible with the\n`TypeSpec` contained in `encoded`.  (Note: the encoding for the TypeSpec\nmay change in future versions of TensorFlow.)"
      },
      {
        "name": "Tcomponents",
        "type": "type[]",
        "description": "Expected dtypes for components.",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "encoded",
        "description": "A scalar `variant` Tensor containing an encoded ExtensionType value.",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "components",
        "description": "The component tensors for the ExtensionType value in `encoded`.",
        "typeListAttr": "Tcomponents"
      }
    ]
  },
  {
    "name": "CompressElement",
    "summary": "Compresses a dataset element.",
    "attributes": [
      {
        "name": "input_types",
        "type": "type[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "components",
        "typeListAttr": "input_types"
      }
    ],
    "outputs": [
      {
        "name": "compressed",
        "type": 21
      }
    ]
  },
  {
    "name": "ComputeAccidentalHits",
    "summary": "Computes the ids of the positions in sampled_candidates that match true_labels.",
    "description": "When doing log-odds NCE, the result of this op should be passed through a\nSparseToDense op, then added to the logits of the sampled candidates. This has\nthe effect of 'removing' the sampled labels that match the true labels by\nmaking the classifier sure that they are sampled labels.",
    "attributes": [
      {
        "name": "num_true",
        "type": "int64",
        "description": "Number of true labels per context."
      },
      {
        "name": "seed",
        "type": "int64",
        "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "description": "An second seed to avoid seed collision.",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "true_classes",
        "description": "The true_classes output of UnpackSparseLabels.",
        "type": 9
      },
      {
        "name": "sampled_candidates",
        "description": "The sampled_candidates output of CandidateSampler.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "indices",
        "description": "A vector of indices corresponding to rows of true_candidates.",
        "type": 3
      },
      {
        "name": "ids",
        "description": "A vector of IDs of positions in sampled_candidates that match a true_label\nfor the row with the corresponding index in indices.",
        "type": 9
      },
      {
        "name": "weights",
        "description": "A vector of the same length as indices and ids, in which each element\nis -FLOAT_MAX.",
        "type": 1
      }
    ]
  },
  {
    "name": "ComputeBatchSize",
    "summary": "Computes the static batch size of a dataset sans partial batches.",
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "batch_size",
        "type": 9
      }
    ]
  },
  {
    "name": "ComputeDedupDataSize",
    "summary": "An op computes the size of the deduplication data from embedding core and returns the updated config.",
    "description": "This op is to compute size of the deduplication data so to provide this\ninformation to the op that computes the tuple mask of deduplication data can\nhave static output shape.",
    "attributes": [
      {
        "name": "config",
        "type": "string",
        "description": "Serialized TPUEmbeddingConfiguration proto."
      }
    ],
    "outputs": [
      {
        "name": "num_elements",
        "description": "The size of the deduplicated data from infeed.",
        "type": 3
      }
    ]
  },
  {
    "name": "ComputeDedupDataSizeV2",
    "summary": "An op computes the size of the deduplication data from embedding core and returns the updated config.",
    "description": "This op is to compute size of the deduplication data so to provide this\ninformation to the op that computes the tuple mask of deduplication data can\nhave static output shape.",
    "attributes": [
      {
        "name": "config",
        "type": "string",
        "description": "Serialized TPUEmbeddingConfiguration proto."
      },
      {
        "name": "embedding_partitions",
        "type": "string",
        "description": "Serialized EmbeddingPartitionsProto proto."
      },
      {
        "name": "hbm_buffers_config",
        "type": "string",
        "description": "Serialized HbmBuffersConfig proto."
      },
      {
        "name": "tpu_topology",
        "type": "string",
        "description": "Serialized TpuTopologyArgsProto proto."
      }
    ],
    "outputs": [
      {
        "name": "num_elements",
        "description": "The size of the deduplicated data from infeed.",
        "type": 3
      }
    ]
  },
  {
    "name": "ComputeDedupDataTupleMask",
    "summary": "An op computes tuple mask of deduplication data from embedding core.",
    "description": "The deduplication data receiving from embedding core is a Tensor with\ntype=DT_VARIANT. The tensor itself is an XLA nested tuple, whose elements are\nrank 1 tensors. This op is to represents types and length of these elements.",
    "attributes": [
      {
        "name": "config",
        "type": "string",
        "description": "Serialized TPUEmbeddingConfiguration proto."
      }
    ],
    "outputs": [
      {
        "name": "output_shape",
        "description": "A 2-D int tensor represent mask of deduplication data tuple generated by\n`XlaRecvTPUEmbeddingDeduplicationData`. The tuple has several integer and float\ntype 1-D tensor tuple elements. The first dimenion of this output_shape 2-D\ntensor is tensor type of tuple elements, `0` represents integer tensor, `1`\nrepresents float tensor. The second dimension of `output_shape` gives length of\neach tuple element.",
        "type": 3
      }
    ]
  },
  {
    "name": "ComputeDedupDataTupleMaskV2",
    "summary": "An op computes tuple mask of deduplication data from embedding core.",
    "description": "The deduplication data receiving from embedding core is a Tensor with\ntype=DT_VARIANT. The tensor itself is an XLA nested tuple, whose elements are\nrank 1 tensors. This op is to represents types and length of these elements.",
    "attributes": [
      {
        "name": "config",
        "type": "string",
        "description": "Serialized TPUEmbeddingConfiguration proto."
      },
      {
        "name": "embedding_partitions",
        "type": "string",
        "description": "Serialized EmbeddingPartitionsProto proto."
      },
      {
        "name": "hbm_buffers_config",
        "type": "string",
        "description": "Serialized HbmBuffersConfig proto."
      },
      {
        "name": "tpu_topology",
        "type": "string",
        "description": "Serialized TpuTopologyArgsProto proto."
      }
    ],
    "outputs": [
      {
        "name": "output_shape",
        "description": "A 2-D int tensor represent mask of deduplication data tuple generated by\n`XlaRecvTPUEmbeddingDeduplicationData`. The tuple has several integer and float\ntype 1-D tensor tuple elements. The first dimenion of this output_shape 2-D\ntensor is tensor type of tuple elements, `0` represents integer tensor, `1`\nrepresents float tensor. The second dimension of `output_shape` gives length of\neach tuple element.",
        "type": 3
      }
    ]
  },
  {
    "name": "Concat",
    "category": "Tensor",
    "summary": "Concatenates tensors along one dimension.",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 2
      },
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "concat_dim",
        "description": "0-D.  The dimension along which to concatenate.  Must be in the\nrange [0, rank(values)).",
        "type": 3
      },
      {
        "name": "values",
        "description": "The `N` Tensors to concatenate. Their ranks and types must match,\nand their sizes must match in all dimensions except `concat_dim`.",
        "numberAttr": "N",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A `Tensor` with the concatenation of values stacked along the\n`concat_dim` dimension.  This tensor's shape matches that of `values` except\nin `concat_dim` where it has the sum of the sizes.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ConcatOffset",
    "summary": "Computes offsets of concat inputs within its output.",
    "description": "For example:\n\n>>> x = [2, 2, 7]\n>>> y = [2, 3, 7]\n>>> z = [2, 9, 7]\n>>> offsets = concat_offset(1, [x, y, z])\n>>> [list(off.numpy()) for off in offsets]\n[[0, 0, 0], [0, 2, 0], [0, 5, 0]]\n\nThis is typically used by gradient computations for a concat operation.",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 2
      },
      {
        "name": "shape_type",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "concat_dim",
        "description": "The dimension along which to concatenate.",
        "type": 3
      },
      {
        "name": "shape",
        "description": "The `N` int32 or int64 vectors representing shape of tensors being concatenated.",
        "numberAttr": "N",
        "typeAttr": "shape_type"
      }
    ],
    "outputs": [
      {
        "name": "offset",
        "description": "The `N` vectors representing the starting offset\nof input tensors within the concatenated output with type matching `shape`.",
        "numberAttr": "N",
        "typeAttr": "shape_type"
      }
    ]
  },
  {
    "name": "ConcatV2",
    "category": "Tensor",
    "summary": "Concatenates tensors along one dimension.",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 2
      },
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "values",
        "description": "List of `N` Tensors to concatenate. Their ranks and types must match,\nand their sizes must match in all dimensions except `concat_dim`.",
        "numberAttr": "N",
        "typeAttr": "T"
      },
      {
        "name": "axis",
        "description": "0-D.  The dimension along which to concatenate.  Must be in the\nrange [-rank(values), rank(values)).",
        "typeAttr": "Tidx"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A `Tensor` with the concatenation of values stacked along the\n`concat_dim` dimension.  This tensor's shape matches that of `values` except\nin `concat_dim` where it has the sum of the sizes.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ConcatenateDataset",
    "summary": "Creates a dataset that concatenates `input_dataset` with `another_dataset`.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "another_dataset",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ConditionalAccumulator",
    "summary": "A conditional accumulator for aggregating gradients.",
    "description": "The accumulator accepts gradients marked with local_step greater or\nequal to the most recent global_step known to the accumulator. The\naverage can be extracted from the accumulator, provided sufficient\ngradients have been accumulated. Extracting the average automatically\nresets the aggregate to 0, and increments the global_step recorded by\nthe accumulator.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the value being accumulated. Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "shape",
        "type": "shape",
        "description": "The shape of the values, can be [], in which case shape is unknown."
      },
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this accumulator is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this accumulator will be shared under the\ngiven name across multiple sessions.",
        "default": ""
      },
      {
        "name": "reduction_type",
        "type": "string",
        "description": "Must be one of the following: `MEAN`, `SUM`.",
        "default": "MEAN"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "The handle to the accumulator.",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "ConfigureAndInitializeGlobalTPU",
    "summary": "An op that sets up the centralized structures for a distributed TPU system.",
    "attributes": [
      {
        "name": "use_tfrt_host_runtime",
        "type": "boolean",
        "default": true
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A vector containing the global TPU id of each TPU on the host.",
        "type": 3
      }
    ]
  },
  {
    "name": "ConfigureDistributedTPU",
    "summary": "Sets up the centralized structures for a distributed TPU system.",
    "attributes": [
      {
        "name": "embedding_config",
        "type": "string",
        "description": "Reserved. Do not use.",
        "default": ""
      },
      {
        "name": "tpu_embedding_config",
        "type": "string",
        "description": "Serialized tensorflow.tpu.TPUEmbeddingConfiguration that\ndescribes the embedding lookups of the program.",
        "default": ""
      },
      {
        "name": "is_global_init",
        "type": "boolean",
        "description": "Reserved. Do not use.",
        "default": false
      },
      {
        "name": "enable_whole_mesh_compilations",
        "type": "boolean",
        "default": false
      },
      {
        "name": "compilation_failure_closes_chips",
        "type": "boolean",
        "default": true
      },
      {
        "name": "tpu_cancellation_closes_chips",
        "type": "int64",
        "default": 0
      }
    ],
    "outputs": [
      {
        "name": "topology",
        "description": "A serialized tensorflow.tpu.TopologyProto that describes the TPU\ntopology.",
        "type": 7
      }
    ]
  },
  {
    "name": "ConfigureTPUEmbedding",
    "summary": "Sets up TPUEmbedding in a distributed TPU system.",
    "attributes": [
      {
        "name": "config",
        "type": "string",
        "description": "Serialized tensorflow.tpu.TPUEmbeddingConfiguration that\ndescribes the embedding lookups of the program."
      }
    ]
  },
  {
    "name": "ConfigureTPUEmbeddingHost",
    "summary": "An op that configures the TPUEmbedding software on a host.",
    "attributes": [
      {
        "name": "config",
        "type": "string",
        "description": "An TPUEmbeddingConfiguration proto serialized to a string,\ndescribing the desired TPUEmbedding configuration."
      }
    ],
    "inputs": [
      {
        "name": "common_config",
        "description": "A string-encoded common configuration proto containing metadata\nabout the TPUEmbedding partitioner output.",
        "type": 7
      },
      {
        "name": "memory_config",
        "description": "A string-encoded memory config proto containing metadata about\nthe memory allocations reserved for TPUEmbedding.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "network_config",
        "description": "A string containing metadata about the hostname and RPC port\nused for communication with this host.",
        "type": 7
      }
    ]
  },
  {
    "name": "ConfigureTPUEmbeddingMemory",
    "summary": "An op that configures the TPUEmbedding software on a host.",
    "inputs": [
      {
        "name": "common_config",
        "description": "A string-encoded CommonConfiguration proto containing metadata\nabout the TPUEmbedding partitioner output and the HBM size (in bytes) required\nfor operation.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "memory_config",
        "description": "A string-encoded memory configuration containing metadata about\nthe memory allocations reserved for TPUEmbedding.",
        "type": 7
      }
    ]
  },
  {
    "name": "Conj",
    "summary": "Returns the complex conjugate of a complex number.",
    "description": "Given a tensor `input` of complex numbers, this operation returns a tensor of\ncomplex numbers that are the complex conjugate of each element in `input`. The\ncomplex numbers in `input` must be of the form \\\\(a + bj\\\\), where *a* is the\nreal part and *b* is the imaginary part.\n\nThe complex conjugate returned by this operation is of the form \\\\(a - bj\\\\).\n\nFor example:\n\n```\n# tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]\ntf.conj(input) ==> [-2.25 - 4.75j, 3.25 - 5.75j]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`, `variant`.",
        "default": {
          "type": "type",
          "value": 8
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ConjugateTranspose",
    "summary": "Shuffle dimensions of x according to a permutation and conjugate the result.",
    "description": "The output `y` has the same rank as `x`. The shapes of `x` and `y` satisfy:\n  `y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]`\n  `y[i,j,k,...,s,t,u] == conj(x[perm[i], perm[j], perm[k],...,perm[s], perm[t], perm[u]])`",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tperm",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "perm",
        "typeAttr": "Tperm"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ConnectTPUEmbeddingHosts",
    "summary": "An op that sets up communication between TPUEmbedding host software instances",
    "description": "after ConfigureTPUEmbeddingHost has been called on each host.",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "network_configs",
        "description": "Strings containing metadata about the hostname and RPC port\nused for communication with all hosts.",
        "numberAttr": "N",
        "type": 7
      }
    ]
  },
  {
    "name": "Const",
    "category": "Constant",
    "summary": "Returns a constant tensor.",
    "attributes": [
      {
        "name": "value",
        "type": "tensor",
        "description": "Attr `value` is the tensor to return."
      },
      {
        "name": "dtype",
        "type": "type"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "ConsumeMutexLock",
    "summary": "This op consumes a lock created by `MutexLock`.",
    "description": "This op exists to consume a tensor created by `MutexLock` (other than\ndirect control dependencies).  It should be the only that consumes the tensor,\nand will raise an error if it is not.  Its only purpose is to keep the\nmutex lock tensor alive until it is consumed by this op.\n\n**NOTE**: This operation must run on the same device as its input.  This may\nbe enforced via the `colocate_with` mechanism.",
    "inputs": [
      {
        "name": "mutex_lock",
        "description": "A tensor returned by `MutexLock`.",
        "type": 21
      }
    ]
  },
  {
    "name": "ControlTrigger",
    "summary": "Does nothing. Serves as a control trigger for scheduling.",
    "description": "Only useful as a placeholder for control edges."
  },
  {
    "name": "Conv",
    "summary": "Computes a N-D convolution given (N+1+batch_dims)-D `input` and (N+2)-D `filter` tensors.",
    "description": "General function for computing a N-D convolution. It is required that\n`1 <= N <= 3`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`, `int32`."
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "1-D tensor of length `N+2`. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[N+1] = 1`."
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`, `EXPLICIT`."
      },
      {
        "name": "explicit_paddings",
        "type": "int64[]",
        "description": "If `padding` is `\"EXPLICIT\"`, the list of explicit padding amounts. For the ith\ndimension, the amount of padding inserted before and after the dimension is\n`explicit_paddings[2 * i]` and `explicit_paddings[2 * i + 1]`, respectively. If\n`padding` is not `\"EXPLICIT\"`, `explicit_paddings` must be empty.",
        "default": []
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "Used to set the data format. By default `CHANNELS_FIRST`, uses \n`NHWC (2D) / NDHWC (3D)` or if `CHANNELS_LAST`, uses `NCHW (2D) / NCDHW (3D)`. Must be one of the following: `CHANNELS_FIRST`, `CHANNELS_LAST`.",
        "default": "CHANNELS_LAST"
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "description": "1-D tensor of length `N+2`. The dilation factor for each dimension of\n`input`. If set to `k > 1`, there will be `k-1` skipped cells between each\nfilter element on that dimension. The dimension order is determined by the\nvalue of `channels_last_format`, see above for details. Dilations in the batch\nand depth dimensions must be 1.",
        "default": []
      },
      {
        "name": "batch_dims",
        "type": "int64",
        "description": "A positive integer specifying the number of batch dimensions for the input\ntensor. Should be less than the rank of the input tensor.",
        "default": 1
      },
      {
        "name": "groups",
        "type": "int64",
        "description": "A positive integer specifying the number of groups in which the input is split\nalong the channel axis. Each group is convolved separately with\n`filters / groups` filters. The output is the concatenation of all the groups\nresults along the channel axis. Input channels and filters must both be\ndivisible by groups.",
        "default": 1
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Tensor of type T and shape `batch_shape + spatial_shape + [in_channels]` in the\ncase that `channels_last_format = true` or shape\n`batch_shape + [in_channels] + spatial_shape` if `channels_last_format = false`.\nspatial_shape is N-dimensional with `N=2` or `N=3`.\nAlso note that `batch_shape` is dictated by the parameter `batch_dims`\nand defaults to 1.",
        "typeAttr": "T"
      },
      {
        "name": "filter",
        "description": "An `(N+2)-D` Tensor with the same type as `input` and shape\n`spatial_filter_shape + [in_channels, out_channels]`, where spatial_filter_shape\nis N-dimensional with `N=2` or `N=3`.\n",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A (N+1+batch_dims)-D tensor. The dimension order is determined by the value of\n`channels_last_format`, see below for details.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Conv2D",
    "category": "Layer",
    "summary": "Computes a 2-D convolution given 4-D `input` and `filter` tensors.",
    "description": "Given an input tensor of shape `[batch, in_height, in_width, in_channels]`\nand a filter / kernel tensor of shape\n`[filter_height, filter_width, in_channels, out_channels]`, this op\nperforms the following:\n\n1. Flattens the filter to a 2-D matrix with shape\n   `[filter_height * filter_width * in_channels, output_channels]`.\n2. Extracts image patches from the input tensor to form a *virtual*\n   tensor of shape `[batch, out_height, out_width,\n   filter_height * filter_width * in_channels]`.\n3. For each patch, right-multiplies the filter matrix and the image patch\n   vector.\n\nIn detail, with the default NHWC format,\n\n    output[b, i, j, k] =\n        sum_{di, dj, q} input[b, strides[1] * i + di, strides[2] * j + dj, q] *\n                        filter[di, dj, q, k]\n\nMust have `strides[0] = strides[3] = 1`.  For the most common case of the same\nhorizontal and vertices strides, `strides = [1, stride, stride, 1]`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`, `int32`."
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "1-D tensor of length 4.  The stride of the sliding window for each\ndimension of `input`. The dimension order is determined by the value of\n`data_format`, see below for details."
      },
      {
        "name": "use_cudnn_on_gpu",
        "type": "boolean",
        "default": true
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`, `EXPLICIT`."
      },
      {
        "name": "explicit_paddings",
        "type": "int64[]",
        "description": "If `padding` is `\"EXPLICIT\"`, the list of explicit padding amounts. For the ith\ndimension, the amount of padding inserted before and after the dimension is\n`explicit_paddings[2 * i]` and `explicit_paddings[2 * i + 1]`, respectively. If\n`padding` is not `\"EXPLICIT\"`, `explicit_paddings` must be empty.",
        "default": []
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, height, width, channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, channels, height, width]. Must be one of the following: `NHWC`, `NCHW`.",
        "default": "NHWC"
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "description": "1-D tensor of length 4.  The dilation factor for each dimension of\n`input`. If set to k > 1, there will be k-1 skipped cells between each\nfilter element on that dimension. The dimension order is determined by the\nvalue of `data_format`, see above for details. Dilations in the batch and\ndepth dimensions must be 1.",
        "default": [
          1,
          1,
          1,
          1
        ]
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A 4-D tensor. The dimension order is interpreted according to the value\nof `data_format`, see below for details.",
        "typeAttr": "T"
      },
      {
        "name": "filter",
        "description": "A 4-D tensor of shape\n`[filter_height, filter_width, in_channels, out_channels]`",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A 4-D tensor. The dimension order is determined by the value of\n`data_format`, see below for details.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Conv2DBackpropFilter",
    "summary": "Computes the gradients of convolution with respect to the filter.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "The stride of the sliding window for each dimension of the input\nof the convolution. Must be in the same order as the dimension specified with\nformat."
      },
      {
        "name": "use_cudnn_on_gpu",
        "type": "boolean",
        "default": true
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`, `EXPLICIT`."
      },
      {
        "name": "explicit_paddings",
        "type": "int64[]",
        "description": "If `padding` is `\"EXPLICIT\"`, the list of explicit padding amounts. For the ith\ndimension, the amount of padding inserted before and after the dimension is\n`explicit_paddings[2 * i]` and `explicit_paddings[2 * i + 1]`, respectively. If\n`padding` is not `\"EXPLICIT\"`, `explicit_paddings` must be empty.",
        "default": []
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width]. Must be one of the following: `NHWC`, `NCHW`.",
        "default": "NHWC"
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "description": "1-D tensor of length 4.  The dilation factor for each dimension of\n`input`. If set to k > 1, there will be k-1 skipped cells between each filter\nelement on that dimension. The dimension order is determined by the value of\n`data_format`, see above for details. Dilations in the batch and depth\ndimensions must be 1.",
        "default": [
          1,
          1,
          1,
          1
        ]
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "4-D with shape `[batch, in_height, in_width, in_channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "filter_sizes",
        "description": "An integer vector representing the tensor shape of `filter`,\nwhere `filter` is a 4-D\n`[filter_height, filter_width, in_channels, out_channels]` tensor.",
        "type": 3
      },
      {
        "name": "out_backprop",
        "description": "4-D with shape `[batch, out_height, out_width, out_channels]`.\nGradients w.r.t. the output of the convolution.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "4-D with shape\n`[filter_height, filter_width, in_channels, out_channels]`.  Gradient w.r.t.\nthe `filter` input of the convolution.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Conv2DBackpropFilterV2",
    "summary": "Computes the gradients of convolution with respect to the filter.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "The stride of the sliding window for each dimension of the input\nof the convolution. Must be in the same order as the dimension specified with\nformat."
      },
      {
        "name": "use_cudnn_on_gpu",
        "type": "boolean",
        "default": true
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`, `EXPLICIT`."
      },
      {
        "name": "explicit_paddings",
        "type": "int64[]",
        "description": "If `padding` is `\"EXPLICIT\"`, the list of explicit padding amounts. For the ith\ndimension, the amount of padding inserted before and after the dimension is\n`explicit_paddings[2 * i]` and `explicit_paddings[2 * i + 1]`, respectively. If\n`padding` is not `\"EXPLICIT\"`, `explicit_paddings` must be empty.",
        "default": []
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width]. Must be one of the following: `NHWC`, `NCHW`.",
        "default": "NHWC"
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "description": "1-D tensor of length 4.  The dilation factor for each dimension of\n`input`. If set to k > 1, there will be k-1 skipped cells between each filter\nelement on that dimension. The dimension order is determined by the value of\n`data_format`, see above for details. Dilations in the batch and depth\ndimensions must be 1.",
        "default": [
          1,
          1,
          1,
          1
        ]
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "4-D with shape `[batch, in_height, in_width, in_channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "filter",
        "description": "4-D with shape `[filter_height, filter_width, in_channels, out_channels]`.\nOnly shape of tensor is used.",
        "typeAttr": "T"
      },
      {
        "name": "out_backprop",
        "description": "4-D with shape `[batch, out_height, out_width, out_channels]`.\nGradients w.r.t. the output of the convolution.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "4-D with shape\n`[filter_height, filter_width, in_channels, out_channels]`.  Gradient w.r.t.\nthe `filter` input of the convolution.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Conv2DBackpropInput",
    "summary": "Computes the gradients of convolution with respect to the input.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`, `int32`."
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "The stride of the sliding window for each dimension of the input\nof the convolution. Must be in the same order as the dimension specified with\nformat."
      },
      {
        "name": "use_cudnn_on_gpu",
        "type": "boolean",
        "default": true
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`, `EXPLICIT`."
      },
      {
        "name": "explicit_paddings",
        "type": "int64[]",
        "description": "If `padding` is `\"EXPLICIT\"`, the list of explicit padding amounts. For the ith\ndimension, the amount of padding inserted before and after the dimension is\n`explicit_paddings[2 * i]` and `explicit_paddings[2 * i + 1]`, respectively. If\n`padding` is not `\"EXPLICIT\"`, `explicit_paddings` must be empty.",
        "default": []
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width]. Must be one of the following: `NHWC`, `NCHW`.",
        "default": "NHWC"
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "description": "1-D tensor of length 4.  The dilation factor for each dimension of\n`input`. If set to k > 1, there will be k-1 skipped cells between each filter\nelement on that dimension. The dimension order is determined by the value of\n`data_format`, see above for details. Dilations in the batch and depth\ndimensions must be 1.",
        "default": [
          1,
          1,
          1,
          1
        ]
      }
    ],
    "inputs": [
      {
        "name": "input_sizes",
        "description": "An integer vector representing the shape of `input`,\nwhere `input` is a 4-D `[batch, height, width, channels]` tensor.",
        "type": 3
      },
      {
        "name": "filter",
        "description": "4-D with shape\n`[filter_height, filter_width, in_channels, out_channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "out_backprop",
        "description": "4-D with shape `[batch, out_height, out_width, out_channels]`.\nGradients w.r.t. the output of the convolution.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "4-D with shape `[batch, in_height, in_width, in_channels]`.  Gradient\nw.r.t. the input of the convolution.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Conv2DBackpropInputV2",
    "summary": "Computes the gradients of convolution with respect to the input.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`, `int32`."
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "The stride of the sliding window for each dimension of the input\nof the convolution. Must be in the same order as the dimension specified with\nformat."
      },
      {
        "name": "use_cudnn_on_gpu",
        "type": "boolean",
        "default": true
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`, `EXPLICIT`."
      },
      {
        "name": "explicit_paddings",
        "type": "int64[]",
        "description": "If `padding` is `\"EXPLICIT\"`, the list of explicit padding amounts. For the ith\ndimension, the amount of padding inserted before and after the dimension is\n`explicit_paddings[2 * i]` and `explicit_paddings[2 * i + 1]`, respectively. If\n`padding` is not `\"EXPLICIT\"`, `explicit_paddings` must be empty.",
        "default": []
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width]. Must be one of the following: `NHWC`, `NCHW`.",
        "default": "NHWC"
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "description": "1-D tensor of length 4.  The dilation factor for each dimension of\n`input`. If set to k > 1, there will be k-1 skipped cells between each filter\nelement on that dimension. The dimension order is determined by the value of\n`data_format`, see above for details. Dilations in the batch and depth\ndimensions must be 1.",
        "default": [
          1,
          1,
          1,
          1
        ]
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "4-D with shape `[batch, in_height, in_width, in_channels]`.\nOnly shape of tensor is used.",
        "typeAttr": "T"
      },
      {
        "name": "filter",
        "description": "4-D with shape\n`[filter_height, filter_width, in_channels, out_channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "out_backprop",
        "description": "4-D with shape `[batch, out_height, out_width, out_channels]`.\nGradients w.r.t. the output of the convolution.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "4-D with shape `[batch, in_height, in_width, in_channels]`.  Gradient\nw.r.t. the input of the convolution.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Conv3D",
    "summary": "Computes a 3-D convolution given 5-D `input` and `filter` tensors.",
    "description": "In signal processing, cross-correlation is a measure of similarity of\ntwo waveforms as a function of a time-lag applied to one of them. This\nis also known as a sliding dot product or sliding inner-product.\n\nOur Conv3D implements a form of cross-correlation.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
        "minimum": 5
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width]. Must be one of the following: `NDHWC`, `NCDHW`.",
        "default": "NDHWC"
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "description": "1-D tensor of length 5.  The dilation factor for each dimension of\n`input`. If set to k > 1, there will be k-1 skipped cells between each\nfilter element on that dimension. The dimension order is determined by the\nvalue of `data_format`, see above for details. Dilations in the batch and\ndepth dimensions must be 1.",
        "default": [
          1,
          1,
          1,
          1,
          1
        ]
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Shape `[batch, in_depth, in_height, in_width, in_channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "filter",
        "description": "Shape `[filter_depth, filter_height, filter_width, in_channels,\nout_channels]`. `in_channels` must match between `input` and `filter`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Conv3DBackpropFilter",
    "summary": "Computes the gradients of 3-D convolution with respect to the filter.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`, `float64`."
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
        "minimum": 5
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "default": [
          1,
          1,
          1,
          1,
          1
        ]
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Shape `[batch, depth, rows, cols, in_channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "filter",
        "description": "Shape `[depth, rows, cols, in_channels, out_channels]`.\n`in_channels` must match between `input` and `filter`.",
        "typeAttr": "T"
      },
      {
        "name": "out_backprop",
        "description": "Backprop signal of shape `[batch, out_depth, out_rows, out_cols,\nout_channels]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Conv3DBackpropFilterV2",
    "summary": "Computes the gradients of 3-D convolution with respect to the filter.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
        "minimum": 5
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width]. Must be one of the following: `NDHWC`, `NCDHW`.",
        "default": "NDHWC"
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "description": "1-D tensor of length 5.  The dilation factor for each dimension of\n`input`. If set to k > 1, there will be k-1 skipped cells between each\nfilter element on that dimension. The dimension order is determined by the\nvalue of `data_format`, see above for details. Dilations in the batch and\ndepth dimensions must be 1.",
        "default": [
          1,
          1,
          1,
          1,
          1
        ]
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Shape `[batch, depth, rows, cols, in_channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "filter_sizes",
        "description": "An integer vector representing the tensor shape of `filter`,\nwhere `filter` is a 5-D\n`[filter_depth, filter_height, filter_width, in_channels, out_channels]`\ntensor.",
        "type": 3
      },
      {
        "name": "out_backprop",
        "description": "Backprop signal of shape `[batch, out_depth, out_rows, out_cols,\nout_channels]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Conv3DBackpropInput",
    "summary": "Computes the gradients of 3-D convolution with respect to the input.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`, `float64`."
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
        "minimum": 5
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "default": [
          1,
          1,
          1,
          1,
          1
        ]
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Shape `[batch, depth, rows, cols, in_channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "filter",
        "description": "Shape `[depth, rows, cols, in_channels, out_channels]`.\n`in_channels` must match between `input` and `filter`.",
        "typeAttr": "T"
      },
      {
        "name": "out_backprop",
        "description": "Backprop signal of shape `[batch, out_depth, out_rows, out_cols,\nout_channels]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Conv3DBackpropInputV2",
    "summary": "Computes the gradients of 3-D convolution with respect to the input.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
        "minimum": 5
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width]. Must be one of the following: `NDHWC`, `NCDHW`.",
        "default": "NDHWC"
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "description": "1-D tensor of length 5.  The dilation factor for each dimension of\n`input`. If set to k > 1, there will be k-1 skipped cells between each\nfilter element on that dimension. The dimension order is determined by the\nvalue of `data_format`, see above for details. Dilations in the batch and\ndepth dimensions must be 1.",
        "default": [
          1,
          1,
          1,
          1,
          1
        ]
      },
      {
        "name": "Tshape",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input_sizes",
        "description": "An integer vector representing the tensor shape of `input`,\nwhere `input` is a 5-D\n`[batch, depth, rows, cols, in_channels]` tensor.",
        "typeAttr": "Tshape"
      },
      {
        "name": "filter",
        "description": "Shape `[depth, rows, cols, in_channels, out_channels]`.\n`in_channels` must match between `input` and `filter`.",
        "typeAttr": "T"
      },
      {
        "name": "out_backprop",
        "description": "Backprop signal of shape `[batch, out_depth, out_rows, out_cols,\nout_channels]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ConvertToCooTensor",
    "attributes": [
      {
        "name": "sample_count",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "combiner",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "name": "indices_or_row_splits",
        "type": 3
      },
      {
        "name": "values",
        "type": 3
      },
      {
        "name": "weights",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "row_ids",
        "type": 3
      },
      {
        "name": "col_ids",
        "type": 3
      },
      {
        "name": "gains",
        "type": 1
      }
    ]
  },
  {
    "name": "ConvertToListOfSparseCoreCooTensors",
    "attributes": [
      {
        "name": "sample_count",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "num_sc_per_chip",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "row_offset",
        "type": "int64",
        "minimum": 0
      },
      {
        "name": "col_offset",
        "type": "int64",
        "minimum": 0
      },
      {
        "name": "col_shift",
        "type": "int64",
        "minimum": 0
      },
      {
        "name": "num_sc_shards",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "stacked_table_sample_count",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "combiner",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "name": "indices_or_row_splits",
        "type": 3
      },
      {
        "name": "values",
        "type": 3
      },
      {
        "name": "weights",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "row_ids_list",
        "numberAttr": "num_sc_per_chip",
        "type": 3
      },
      {
        "name": "col_ids_list",
        "numberAttr": "num_sc_per_chip",
        "type": 3
      },
      {
        "name": "gains_list",
        "numberAttr": "num_sc_per_chip",
        "type": 1
      }
    ]
  },
  {
    "name": "ConvertToSparseCoreCsrWrappedCooTensor",
    "attributes": [
      {
        "name": "sample_count_per_sc",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "num_replica",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "max_minibatches_per_sc",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "max_ids_per_chip_per_sample",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "table_vocab_size",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "feature_width",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "num_sc_per_chip",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "table_name",
        "type": "string"
      },
      {
        "name": "allow_id_dropping",
        "type": "boolean"
      }
    ],
    "inputs": [
      {
        "name": "sorted_row_ids_list",
        "numberAttr": "num_sc_per_chip",
        "type": 3
      },
      {
        "name": "sorted_col_ids_list",
        "numberAttr": "num_sc_per_chip",
        "type": 3
      },
      {
        "name": "sorted_gains_list",
        "numberAttr": "num_sc_per_chip",
        "type": 1
      },
      {
        "name": "id_counts_list",
        "numberAttr": "num_sc_per_chip",
        "type": 3
      },
      {
        "name": "splits",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "row_pointers",
        "type": 3
      },
      {
        "name": "sorted_sample_ids",
        "type": 3
      },
      {
        "name": "sorted_token_ids",
        "type": 3
      },
      {
        "name": "sorted_gains",
        "type": 1
      },
      {
        "name": "row_pointers_unpadded_size",
        "type": 3
      },
      {
        "name": "ids_unpadded_size",
        "type": 3
      },
      {
        "name": "num_minibatches_per_sc",
        "type": 3
      }
    ]
  },
  {
    "name": "Copy",
    "summary": "Copy a tensor from CPU-to-CPU or GPU-to-GPU.",
    "description": "Performs CPU-to-CPU or GPU-to-GPU deep-copying of tensor, depending on the\ndevice on which the tensor is allocated.\nN.B.: If the all downstream attached debug ops are disabled given the current\ngRPC gating status, the output will simply forward the input tensor without\ndeep-copying. See the documentation of Debug* ops for more details.\n\nUnlike the CopyHost Op, this op does not have HostMemory constraint on its\ninput or output.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "tensor_name",
        "type": "string",
        "description": "The name of the input tensor.",
        "default": ""
      },
      {
        "name": "debug_ops_spec",
        "type": "string[]",
        "description": "A list of debug op spec (op, url, gated_grpc) for attached debug\nops. Each element of the list has the format\n<debug_op>;<grpc_url>;<gated_grpc>, wherein gated_grpc is boolean represented\nas 0/1. E.g., \"DebugIdentity;grpc://foo:3333;1\",\n\"DebugIdentity;file:///tmp/tfdbg_1;0\".",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Input tensor.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CopyHost",
    "summary": "Copy a tensor to host.",
    "description": "Performs CPU-to-CPU deep-copying of tensor.\nN.B.: If the all downstream attached debug ops are disabled given the current\ngRPC gating status, the output will simply forward the input tensor without\ndeep-copying. See the documentation of Debug* ops for more details.\n\nUnlike the Copy Op, this op has HostMemory constraint on its input or output.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "tensor_name",
        "type": "string",
        "description": "The name of the input tensor.",
        "default": ""
      },
      {
        "name": "debug_ops_spec",
        "type": "string[]",
        "description": "A list of debug op spec (op, url, gated_grpc) for attached debug\nops. Each element of the list has the format\n<debug_op>;<grpc_url>;<gated_grpc>, wherein gated_grpc is boolean represented\nas 0/1. E.g., \"DebugIdentity;grpc://foo:3333;1\",\n\"DebugIdentity;file:///tmp/tfdbg_1;0\".",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Input tensor.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CopyToMesh",
    "attributes": [
      {
        "name": "mesh",
        "type": "string"
      },
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CopyToMeshGrad",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "forward_input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Cos",
    "summary": "Computes cos of x element-wise.",
    "description": "  Given an input tensor, this function computes cosine of every\n  element in the tensor. Input range is `(-inf, inf)` and\n  output range is `[-1,1]`. If input lies outside the boundary, `nan`\n  is returned.\n\n  ```python\n  x = tf.constant([-float(\"inf\"), -9, -0.5, 1, 1.2, 200, 10000, float(\"inf\")])\n  tf.math.cos(x) ==> [nan -0.91113025 0.87758255 0.5403023 0.36235774 0.48718765 -0.95215535 nan]\n  ```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Cosh",
    "summary": "Computes hyperbolic cosine of x element-wise.",
    "description": "  Given an input tensor, this function computes hyperbolic cosine of every\n  element in the tensor. Input range is `[-inf, inf]` and output range\n  is `[1, inf]`.\n\n  ```python\n  x = tf.constant([-float(\"inf\"), -9, -0.5, 1, 1.2, 2, 10, float(\"inf\")])\n  tf.math.cosh(x) ==> [inf 4.0515420e+03 1.1276259e+00 1.5430807e+00 1.8106556e+00 3.7621956e+00 1.1013233e+04 inf]\n  ```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CountUpTo",
    "summary": "Increments 'ref' until it reaches 'limit'.",
    "attributes": [
      {
        "name": "limit",
        "type": "int64",
        "description": "If incrementing ref would bring it above limit, instead generates an\n'OutOfRange' error."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "description": "Should be from a scalar `Variable` node.",
        "typeAttr": "T",
        "isRef": true
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A copy of the input before increment. If nothing else modifies the\ninput, the values produced will all be distinct.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CreateSummaryDbWriter",
    "inputs": [
      {
        "name": "writer",
        "type": 20
      },
      {
        "name": "db_uri",
        "type": 7
      },
      {
        "name": "experiment_name",
        "type": 7
      },
      {
        "name": "run_name",
        "type": 7
      },
      {
        "name": "user_name",
        "type": 7
      }
    ]
  },
  {
    "name": "CreateSummaryFileWriter",
    "inputs": [
      {
        "name": "writer",
        "type": 20
      },
      {
        "name": "logdir",
        "type": 7
      },
      {
        "name": "max_queue",
        "type": 3
      },
      {
        "name": "flush_millis",
        "type": 3
      },
      {
        "name": "filename_suffix",
        "type": 7
      }
    ]
  },
  {
    "name": "CropAndResize",
    "summary": "Extracts crops from the input image tensor and resizes them.",
    "description": "Extracts crops from the input image tensor and resizes them using bilinear\nsampling or nearest neighbor sampling (possibly with aspect ratio change) to a\ncommon output size specified by `crop_size`. This is more general than the\n`crop_to_bounding_box` op which extracts a fixed size slice from the input image\nand does not allow resizing or aspect ratio change.\n\nReturns a tensor with `crops` from the input `image` at positions defined at the\nbounding box locations in `boxes`. The cropped boxes are all resized (with\nbilinear or nearest neighbor interpolation) to a fixed\n`size = [crop_height, crop_width]`. The result is a 4-D tensor\n`[num_boxes, crop_height, crop_width, depth]`. The resizing is corner aligned.\nIn particular, if `boxes = [[0, 0, 1, 1]]`, the method will give identical\nresults to using `tf.image.resize_bilinear()` or\n`tf.image.resize_nearest_neighbor()`(depends on the `method` argument) with\n`align_corners=True`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `uint8`, `uint16`, `int8`, `int16`, `int32`, `int64`, `float16`, `float32`, `float64`."
      },
      {
        "name": "method",
        "type": "string",
        "description": "A string specifying the sampling method for resizing. It can be either\n`\"bilinear\"` or `\"nearest\"` and default to `\"bilinear\"`. Currently two sampling\nmethods are supported: Bilinear and Nearest Neighbor. Must be one of the following: `bilinear`, `nearest`.",
        "default": "bilinear"
      },
      {
        "name": "extrapolation_value",
        "type": "float32",
        "description": "Value used for extrapolation, when applicable.",
        "default": 0.0
      }
    ],
    "inputs": [
      {
        "name": "image",
        "description": "A 4-D tensor of shape `[batch, image_height, image_width, depth]`.\nBoth `image_height` and `image_width` need to be positive.",
        "typeAttr": "T"
      },
      {
        "name": "boxes",
        "description": "A 2-D tensor of shape `[num_boxes, 4]`. The `i`-th row of the tensor\nspecifies the coordinates of a box in the `box_ind[i]` image and is specified\nin normalized coordinates `[y1, x1, y2, x2]`. A normalized coordinate value of\n`y` is mapped to the image coordinate at `y * (image_height - 1)`, so as the\n`[0, 1]` interval of normalized image height is mapped to\n`[0, image_height - 1]` in image height coordinates. We do allow `y1` > `y2`, in\nwhich case the sampled crop is an up-down flipped version of the original\nimage. The width dimension is treated similarly. Normalized coordinates\noutside the `[0, 1]` range are allowed, in which case we use\n`extrapolation_value` to extrapolate the input image values.",
        "type": 1
      },
      {
        "name": "box_ind",
        "description": "A 1-D tensor of shape `[num_boxes]` with int32 values in `[0, batch)`.\nThe value of `box_ind[i]` specifies the image that the `i`-th box refers to.",
        "type": 3
      },
      {
        "name": "crop_size",
        "description": "A 1-D tensor of 2 elements, `size = [crop_height, crop_width]`. All\ncropped image patches are resized to this size. The aspect ratio of the image\ncontent is not preserved. Both `crop_height` and `crop_width` need to be\npositive.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "crops",
        "description": "A 4-D tensor of shape `[num_boxes, crop_height, crop_width, depth]`.",
        "type": 1
      }
    ]
  },
  {
    "name": "CropAndResizeGradBoxes",
    "summary": "Computes the gradient of the crop_and_resize op wrt the input boxes tensor.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `uint8`, `uint16`, `int8`, `int16`, `int32`, `int64`, `float16`, `float32`, `float64`."
      },
      {
        "name": "method",
        "type": "string",
        "description": "A string specifying the interpolation method. Only 'bilinear' is\nsupported for now. Must be one of the following: `bilinear`.",
        "default": "bilinear"
      }
    ],
    "inputs": [
      {
        "name": "grads",
        "description": "A 4-D tensor of shape `[num_boxes, crop_height, crop_width, depth]`.",
        "type": 1
      },
      {
        "name": "image",
        "description": "A 4-D tensor of shape `[batch, image_height, image_width, depth]`.\nBoth `image_height` and `image_width` need to be positive.",
        "typeAttr": "T"
      },
      {
        "name": "boxes",
        "description": "A 2-D tensor of shape `[num_boxes, 4]`. The `i`-th row of the tensor\nspecifies the coordinates of a box in the `box_ind[i]` image and is specified\nin normalized coordinates `[y1, x1, y2, x2]`. A normalized coordinate value of\n`y` is mapped to the image coordinate at `y * (image_height - 1)`, so as the\n`[0, 1]` interval of normalized image height is mapped to\n`[0, image_height - 1] in image height coordinates. We do allow y1 > y2, in\nwhich case the sampled crop is an up-down flipped version of the original\nimage. The width dimension is treated similarly. Normalized coordinates\noutside the `[0, 1]` range are allowed, in which case we use\n`extrapolation_value` to extrapolate the input image values.",
        "type": 1
      },
      {
        "name": "box_ind",
        "description": "A 1-D tensor of shape `[num_boxes]` with int32 values in `[0, batch)`.\nThe value of `box_ind[i]` specifies the image that the `i`-th box refers to.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A 2-D tensor of shape `[num_boxes, 4]`.",
        "type": 1
      }
    ]
  },
  {
    "name": "CropAndResizeGradImage",
    "summary": "Computes the gradient of the crop_and_resize op wrt the input image tensor.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float16`, `float64`."
      },
      {
        "name": "method",
        "type": "string",
        "description": "A string specifying the interpolation method. Only 'bilinear' is\nsupported for now. Must be one of the following: `bilinear`, `nearest`.",
        "default": "bilinear"
      }
    ],
    "inputs": [
      {
        "name": "grads",
        "description": "A 4-D tensor of shape `[num_boxes, crop_height, crop_width, depth]`.",
        "type": 1
      },
      {
        "name": "boxes",
        "description": "A 2-D tensor of shape `[num_boxes, 4]`. The `i`-th row of the tensor\nspecifies the coordinates of a box in the `box_ind[i]` image and is specified\nin normalized coordinates `[y1, x1, y2, x2]`. A normalized coordinate value of\n`y` is mapped to the image coordinate at `y * (image_height - 1)`, so as the\n`[0, 1]` interval of normalized image height is mapped to\n`[0, image_height - 1] in image height coordinates. We do allow y1 > y2, in\nwhich case the sampled crop is an up-down flipped version of the original\nimage. The width dimension is treated similarly. Normalized coordinates\noutside the `[0, 1]` range are allowed, in which case we use\n`extrapolation_value` to extrapolate the input image values.",
        "type": 1
      },
      {
        "name": "box_ind",
        "description": "A 1-D tensor of shape `[num_boxes]` with int32 values in `[0, batch)`.\nThe value of `box_ind[i]` specifies the image that the `i`-th box refers to.",
        "type": 3
      },
      {
        "name": "image_size",
        "description": "A 1-D tensor with value `[batch, image_height, image_width, depth]`\ncontaining the original image size. Both `image_height` and `image_width` need\nto be positive.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A 4-D tensor of shape `[batch, image_height, image_width, depth]`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Cross",
    "summary": "Compute the pairwise cross product.",
    "description": "`a` and `b` must be the same shape; they can either be simple 3-element vectors,\nor any shape where the innermost dimension is 3. In the latter case, each pair\nof corresponding 3-element vectors is cross-multiplied independently.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "a",
        "description": "A tensor containing 3-element vectors.",
        "typeAttr": "T"
      },
      {
        "name": "b",
        "description": "Another tensor, of same type and shape as `a`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "product",
        "description": "Pairwise cross product of the vectors in `a` and `b`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CrossReplicaSum",
    "summary": "An Op to sum inputs across replicated TPU instances.",
    "description": "Each instance supplies its own input.\n\nFor example, suppose there are 8 TPU instances: `[A, B, C, D, E, F, G, H]`.\nPassing group_assignment=`[[0,2,4,6],[1,3,5,7]]` sets `A, C, E, G` as group 0,\nand `B, D, F, H` as group 1. Thus we get the outputs:\n`[A+C+E+G, B+D+F+H, A+C+E+G, B+D+F+H, A+C+E+G, B+D+F+H, A+C+E+G, B+D+F+H]`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "The type of elements to be summed. Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`, `int32`, `uint32`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The local input to the sum.",
        "typeAttr": "T"
      },
      {
        "name": "group_assignment",
        "description": "An int32 tensor with shape\n[num_groups, num_replicas_per_group]. `group_assignment[i]` represents the\nreplica ids in the ith subgroup.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The sum of all the distributed inputs.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CudnnRNN",
    "summary": "A RNN backed by cuDNN.",
    "description": "Computes the RNN from the input and initial states, with respect to the params\nbuffer.\n\nrnn_mode: Indicates the type of the RNN model.\ninput_mode: Indicate whether there is a linear projection between the input and\n  the actual computation before the first layer. 'skip_input' is only allowed\n  when input_size == num_units; 'auto_select' implies 'skip_input' when\n  input_size == num_units; otherwise, it implies 'linear_input'.\ndirection: Indicates whether a bidirectional model will be used. Should be\n  \"unidirectional\" or \"bidirectional\".\ndropout: Dropout probability. When set to 0., dropout is disabled.\nseed: The 1st part of a seed to initialize dropout.\nseed2: The 2nd part of a seed to initialize dropout.\ninput: A 3-D tensor with the shape of [seq_length, batch_size, input_size].\ninput_h: A 3-D tensor with the shape of [num_layer * dir, batch_size,\n    num_units].\ninput_c: For LSTM, a 3-D tensor with the shape of\n    [num_layer * dir, batch, num_units]. For other models, it is ignored.\nparams: A 1-D tensor that contains the weights and biases in an opaque layout.\n    The size must be created through CudnnRNNParamsSize, and initialized\n    separately. Note that they might not be compatible across different\n    generations. So it is a good idea to save and restore\noutput: A 3-D tensor with the shape of [seq_length, batch_size,\n    dir * num_units].\noutput_h: The same shape has input_h.\noutput_c: The same shape as input_c for LSTM. An empty tensor for other models.\nis_training: Indicates whether this operation is used for inference or\n  training.\nreserve_space: An opaque tensor that can be used in backprop calculation. It\n  is only produced if is_training is false.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "rnn_mode",
        "type": "string",
        "description": "Must be one of the following: `rnn_relu`, `rnn_tanh`, `lstm`, `gru`.",
        "default": "lstm"
      },
      {
        "name": "input_mode",
        "type": "string",
        "description": "Must be one of the following: `linear_input`, `skip_input`, `auto_select`.",
        "default": "linear_input"
      },
      {
        "name": "direction",
        "type": "string",
        "description": "Must be one of the following: `unidirectional`, `bidirectional`.",
        "default": "unidirectional"
      },
      {
        "name": "dropout",
        "type": "float32",
        "default": 0.0
      },
      {
        "name": "seed",
        "type": "int64",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "default": 0
      },
      {
        "name": "is_training",
        "type": "boolean",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "input_h",
        "typeAttr": "T"
      },
      {
        "name": "input_c",
        "typeAttr": "T"
      },
      {
        "name": "params",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      },
      {
        "name": "output_h",
        "typeAttr": "T"
      },
      {
        "name": "output_c",
        "typeAttr": "T"
      },
      {
        "name": "reserve_space",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CudnnRNNBackprop",
    "summary": "Backprop step of CudnnRNN.",
    "description": "Compute the backprop of both data and weights in a RNN.\n\nrnn_mode: Indicates the type of the RNN model.\ninput_mode: Indicate whether there is a linear projection between the input and\n    the actual computation before the first layer. 'skip_input' is only allowed\n    when input_size == num_units; 'auto_select' implies 'skip_input' when\n    input_size == num_units; otherwise, it implies 'linear_input'.\ndirection: Indicates whether a bidirectional model will be used. Should be\n  \"unidirectional\" or \"bidirectional\".\ndropout: Dropout probability. When set to 0., dropout is disabled.\nseed: The 1st part of a seed to initialize dropout.\nseed2: The 2nd part of a seed to initialize dropout.\ninput: A 3-D tensor with the shape of [seq_length, batch_size, input_size].\ninput_h: A 3-D tensor with the shape of [num_layer * dir, batch_size,\n    num_units].\ninput_c: For LSTM, a 3-D tensor with the shape of\n    [num_layer * dir, batch, num_units]. For other models, it is ignored.\nparams: A 1-D tensor that contains the weights and biases in an opaque layout.\n    The size must be created through CudnnRNNParamsSize, and initialized\n    separately. Note that they might not be compatible across different\n    generations. So it is a good idea to save and restore\noutput: A 3-D tensor with the shape of [seq_length, batch_size,\n    dir * num_units].\noutput_h: The same shape has input_h.\noutput_c: The same shape as input_c for LSTM. An empty tensor for other models.\noutput_backprop: A 3-D tensor with the same shape as output in the forward pass.\noutput_h_backprop: A 3-D tensor with the same shape as output_h in the forward\n    pass.\noutput_c_backprop: A 3-D tensor with the same shape as output_c in the forward\n    pass.\nreserve_space: The same reserve_space produced in for forward operation.\ninput_backprop: The backprop to input in the forward pass. Has the same shape\n    as input.\ninput_h_backprop: The backprop to input_h in the forward pass. Has the same\n    shape as input_h.\ninput_c_backprop: The backprop to input_c in the forward pass. Has the same\n    shape as input_c.\nparams_backprop: The backprop to the params buffer in the forward pass. Has the\n    same shape as params.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "rnn_mode",
        "type": "string",
        "description": "Must be one of the following: `rnn_relu`, `rnn_tanh`, `lstm`, `gru`.",
        "default": "lstm"
      },
      {
        "name": "input_mode",
        "type": "string",
        "description": "Must be one of the following: `linear_input`, `skip_input`, `auto_select`.",
        "default": "linear_input"
      },
      {
        "name": "direction",
        "type": "string",
        "description": "Must be one of the following: `unidirectional`, `bidirectional`.",
        "default": "unidirectional"
      },
      {
        "name": "dropout",
        "type": "float32",
        "default": 0.0
      },
      {
        "name": "seed",
        "type": "int64",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "input_h",
        "typeAttr": "T"
      },
      {
        "name": "input_c",
        "typeAttr": "T"
      },
      {
        "name": "params",
        "typeAttr": "T"
      },
      {
        "name": "output",
        "typeAttr": "T"
      },
      {
        "name": "output_h",
        "typeAttr": "T"
      },
      {
        "name": "output_c",
        "typeAttr": "T"
      },
      {
        "name": "output_backprop",
        "typeAttr": "T"
      },
      {
        "name": "output_h_backprop",
        "typeAttr": "T"
      },
      {
        "name": "output_c_backprop",
        "typeAttr": "T"
      },
      {
        "name": "reserve_space",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "input_backprop",
        "typeAttr": "T"
      },
      {
        "name": "input_h_backprop",
        "typeAttr": "T"
      },
      {
        "name": "input_c_backprop",
        "typeAttr": "T"
      },
      {
        "name": "params_backprop",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CudnnRNNBackpropV2",
    "summary": "Backprop step of CudnnRNN.",
    "description": "Compute the backprop of both data and weights in a RNN. Takes an extra\n    \"host_reserved\" inupt than CudnnRNNBackprop, which is used to determine RNN\n    cudnnRNNAlgo_t and cudnnMathType_t.\n\nrnn_mode: Indicates the type of the RNN model.\ninput_mode: Indicates whether there is a linear projection between the input and\n    the actual computation before the first layer. 'skip_input' is only allowed\n    when input_size == num_units; 'auto_select' implies 'skip_input' when\n    input_size == num_units; otherwise, it implies 'linear_input'.\ndirection: Indicates whether a bidirectional model will be used. Should be\n  \"unidirectional\" or \"bidirectional\".\ndropout: Dropout probability. When set to 0., dropout is disabled.\nseed: The 1st part of a seed to initialize dropout.\nseed2: The 2nd part of a seed to initialize dropout.\ninput: A 3-D tensor with the shape of [seq_length, batch_size, input_size].\ninput_h: A 3-D tensor with the shape of [num_layer * dir, batch_size,\n    num_units].\ninput_c: For LSTM, a 3-D tensor with the shape of\n    [num_layer * dir, batch, num_units]. For other models, it is ignored.\nparams: A 1-D tensor that contains the weights and biases in an opaque layout.\n    The size must be created through CudnnRNNParamsSize, and initialized\n    separately. Note that they might not be compatible across different\n    generations. So it is a good idea to save and restore\noutput: A 3-D tensor with the shape of [seq_length, batch_size,\n    dir * num_units].\noutput_h: The same shape has input_h.\noutput_c: The same shape as input_c for LSTM. An empty tensor for other models.\noutput_backprop: A 3-D tensor with the same shape as output in the forward pass.\noutput_h_backprop: A 3-D tensor with the same shape as output_h in the forward\n    pass.\noutput_c_backprop: A 3-D tensor with the same shape as output_c in the forward\n    pass.\nreserve_space: The same reserve_space produced in the forward operation.\nhost_reserved: The same host_reserved produced in the forward operation.\ninput_backprop: The backprop to input in the forward pass. Has the same shape\n    as input.\ninput_h_backprop: The backprop to input_h in the forward pass. Has the same\n    shape as input_h.\ninput_c_backprop: The backprop to input_c in the forward pass. Has the same\n    shape as input_c.\nparams_backprop: The backprop to the params buffer in the forward pass. Has the\n    same shape as params.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "rnn_mode",
        "type": "string",
        "description": "Must be one of the following: `rnn_relu`, `rnn_tanh`, `lstm`, `gru`.",
        "default": "lstm"
      },
      {
        "name": "input_mode",
        "type": "string",
        "description": "Must be one of the following: `linear_input`, `skip_input`, `auto_select`.",
        "default": "linear_input"
      },
      {
        "name": "direction",
        "type": "string",
        "description": "Must be one of the following: `unidirectional`, `bidirectional`.",
        "default": "unidirectional"
      },
      {
        "name": "dropout",
        "type": "float32",
        "default": 0.0
      },
      {
        "name": "seed",
        "type": "int64",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "input_h",
        "typeAttr": "T"
      },
      {
        "name": "input_c",
        "typeAttr": "T"
      },
      {
        "name": "params",
        "typeAttr": "T"
      },
      {
        "name": "output",
        "typeAttr": "T"
      },
      {
        "name": "output_h",
        "typeAttr": "T"
      },
      {
        "name": "output_c",
        "typeAttr": "T"
      },
      {
        "name": "output_backprop",
        "typeAttr": "T"
      },
      {
        "name": "output_h_backprop",
        "typeAttr": "T"
      },
      {
        "name": "output_c_backprop",
        "typeAttr": "T"
      },
      {
        "name": "reserve_space",
        "typeAttr": "T"
      },
      {
        "name": "host_reserved",
        "type": 6
      }
    ],
    "outputs": [
      {
        "name": "input_backprop",
        "typeAttr": "T"
      },
      {
        "name": "input_h_backprop",
        "typeAttr": "T"
      },
      {
        "name": "input_c_backprop",
        "typeAttr": "T"
      },
      {
        "name": "params_backprop",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CudnnRNNBackpropV3",
    "summary": "Backprop step of CudnnRNNV3.",
    "description": "Compute the backprop of both data and weights in a RNN. Takes an extra\n    \"sequence_lengths\" input than CudnnRNNBackprop.\n\nrnn_mode: Indicates the type of the RNN model.\ninput_mode: Indicates whether there is a linear projection between the input and\n    the actual computation before the first layer. 'skip_input' is only allowed\n    when input_size == num_units; 'auto_select' implies 'skip_input' when\n    input_size == num_units; otherwise, it implies 'linear_input'.\ndirection: Indicates whether a bidirectional model will be used. Should be\n  \"unidirectional\" or \"bidirectional\".\ndropout: Dropout probability. When set to 0., dropout is disabled.\nseed: The 1st part of a seed to initialize dropout.\nseed2: The 2nd part of a seed to initialize dropout.\ninput: If time_major is true, this is a 3-D tensor with the shape of\n    [seq_length, batch_size, input_size]. If time_major is false, the shape is\n    [batch_size, seq_length, input_size].\ninput_h: If time_major is true, this is a 3-D tensor with the shape of\n    [num_layer * dir, batch_size, num_units]. If time_major is false, the shape\n    is [batch_size, num_layer * dir, num_units].\ninput_c: For LSTM, a 3-D tensor with the shape of\n    [num_layer * dir, batch, num_units]. For other models, it is ignored.\nparams: A 1-D tensor that contains the weights and biases in an opaque layout.\n    The size must be created through CudnnRNNParamsSize, and initialized\n    separately. Note that they might not be compatible across different\n    generations. So it is a good idea to save and restore\nsequence_lengths: a vector of lengths of each input sequence.\noutput: If time_major is true, this is a 3-D tensor with the shape of\n    [seq_length, batch_size, dir * num_units]. If time_major is false, the\n    shape is [batch_size, seq_length, dir * num_units].\noutput_h: The same shape has input_h.\noutput_c: The same shape as input_c for LSTM. An empty tensor for other models.\noutput_backprop: A 3-D tensor with the same shape as output in the forward pass.\noutput_h_backprop: A 3-D tensor with the same shape as output_h in the forward\n    pass.\noutput_c_backprop: A 3-D tensor with the same shape as output_c in the forward\n    pass.\ntime_major: Indicates whether the input/output format is time major or batch\n    major.\nreserve_space: The same reserve_space produced in the forward operation.\ninput_backprop: The backprop to input in the forward pass. Has the same shape\n    as input.\ninput_h_backprop: The backprop to input_h in the forward pass. Has the same\n    shape as input_h.\ninput_c_backprop: The backprop to input_c in the forward pass. Has the same\n    shape as input_c.\nparams_backprop: The backprop to the params buffer in the forward pass. Has the\n    same shape as params.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "rnn_mode",
        "type": "string",
        "description": "Must be one of the following: `rnn_relu`, `rnn_tanh`, `lstm`, `gru`.",
        "default": "lstm"
      },
      {
        "name": "input_mode",
        "type": "string",
        "description": "Must be one of the following: `linear_input`, `skip_input`, `auto_select`.",
        "default": "linear_input"
      },
      {
        "name": "direction",
        "type": "string",
        "description": "Must be one of the following: `unidirectional`, `bidirectional`.",
        "default": "unidirectional"
      },
      {
        "name": "dropout",
        "type": "float32",
        "default": 0.0
      },
      {
        "name": "seed",
        "type": "int64",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "default": 0
      },
      {
        "name": "num_proj",
        "type": "int64",
        "default": 0
      },
      {
        "name": "time_major",
        "type": "boolean",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "input_h",
        "typeAttr": "T"
      },
      {
        "name": "input_c",
        "typeAttr": "T"
      },
      {
        "name": "params",
        "typeAttr": "T"
      },
      {
        "name": "sequence_lengths",
        "type": 3
      },
      {
        "name": "output",
        "typeAttr": "T"
      },
      {
        "name": "output_h",
        "typeAttr": "T"
      },
      {
        "name": "output_c",
        "typeAttr": "T"
      },
      {
        "name": "output_backprop",
        "typeAttr": "T"
      },
      {
        "name": "output_h_backprop",
        "typeAttr": "T"
      },
      {
        "name": "output_c_backprop",
        "typeAttr": "T"
      },
      {
        "name": "reserve_space",
        "typeAttr": "T"
      },
      {
        "name": "host_reserved",
        "type": 6
      }
    ],
    "outputs": [
      {
        "name": "input_backprop",
        "typeAttr": "T"
      },
      {
        "name": "input_h_backprop",
        "typeAttr": "T"
      },
      {
        "name": "input_c_backprop",
        "typeAttr": "T"
      },
      {
        "name": "params_backprop",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CudnnRNNCanonicalToParams",
    "summary": "Converts CudnnRNN params from canonical form to usable form.",
    "description": "Writes a set of weights into the opaque params buffer so they can be used in\nupcoming training or inferences.\n\nNote that the params buffer may not be compatible across different GPUs. So any\nsave and restoration should be converted to and from the canonical weights and\nbiases.\n\nnum_layers: Specifies the number of layers in the RNN model.\nnum_units: Specifies the size of the hidden state.\ninput_size: Specifies the size of the input state.\nweights: the canonical form of weights that can be used for saving\n    and restoration. They are more likely to be compatible across different\n    generations.\nbiases: the canonical form of biases that can be used for saving\n    and restoration. They are more likely to be compatible across different\n    generations.\nnum_params: number of parameter sets for all layers.\n    Each layer may contain multiple parameter sets, with each set consisting of\n    a weight matrix and a bias vector.\nrnn_mode: Indicates the type of the RNN model.\ninput_mode: Indicate whether there is a linear projection between the input and\n    The actual computation before the first layer. 'skip_input' is only allowed\n    when input_size == num_units; 'auto_select' implies 'skip_input' when\n    input_size == num_units; otherwise, it implies 'linear_input'.\ndirection: Indicates whether a bidirectional model will be used.\n    dir = (direction == bidirectional) ? 2 : 1\ndropout: dropout probability. When set to 0., dropout is disabled.\nseed: the 1st part of a seed to initialize dropout.\nseed2: the 2nd part of a seed to initialize dropout.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "num_params",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "rnn_mode",
        "type": "string",
        "description": "Must be one of the following: `rnn_relu`, `rnn_tanh`, `lstm`, `gru`.",
        "default": "lstm"
      },
      {
        "name": "input_mode",
        "type": "string",
        "description": "Must be one of the following: `linear_input`, `skip_input`, `auto_select`.",
        "default": "linear_input"
      },
      {
        "name": "direction",
        "type": "string",
        "description": "Must be one of the following: `unidirectional`, `bidirectional`.",
        "default": "unidirectional"
      },
      {
        "name": "dropout",
        "type": "float32",
        "default": 0.0
      },
      {
        "name": "seed",
        "type": "int64",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "num_layers",
        "type": 3
      },
      {
        "name": "num_units",
        "type": 3
      },
      {
        "name": "input_size",
        "type": 3
      },
      {
        "name": "weights",
        "numberAttr": "num_params",
        "typeAttr": "T"
      },
      {
        "name": "biases",
        "numberAttr": "num_params",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "params",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CudnnRNNCanonicalToParamsV2",
    "summary": "Converts CudnnRNN params from canonical form to usable form. It supports the projection in LSTM.",
    "description": "Writes a set of weights into the opaque params buffer so they can be used in\nupcoming training or inferences.\n\nNote that the params buffer may not be compatible across different GPUs. So any\nsave and restoration should be converted to and from the canonical weights and\nbiases.\n\nnum_layers: Specifies the number of layers in the RNN model.\nnum_units: Specifies the size of the hidden state.\ninput_size: Specifies the size of the input state.\nweights: the canonical form of weights that can be used for saving\n    and restoration. They are more likely to be compatible across different\n    generations.\nbiases: the canonical form of biases that can be used for saving\n    and restoration. They are more likely to be compatible across different\n    generations.\nnum_params_weights: number of weight parameter matrix for all layers.\nnum_params_biases: number of bias parameter vector for all layers.\nrnn_mode: Indicates the type of the RNN model.\ninput_mode: Indicate whether there is a linear projection between the input and\n    The actual computation before the first layer. 'skip_input' is only allowed\n    when input_size == num_units; 'auto_select' implies 'skip_input' when\n    input_size == num_units; otherwise, it implies 'linear_input'.\ndirection: Indicates whether a bidirectional model will be used.\n    dir = (direction == bidirectional) ? 2 : 1\ndropout: dropout probability. When set to 0., dropout is disabled.\nseed: the 1st part of a seed to initialize dropout.\nseed2: the 2nd part of a seed to initialize dropout.\nnum_proj: The output dimensionality for the projection matrices. If None or 0,\n    no projection is performed.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "num_params_weights",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "num_params_biases",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "rnn_mode",
        "type": "string",
        "description": "Must be one of the following: `rnn_relu`, `rnn_tanh`, `lstm`, `gru`.",
        "default": "lstm"
      },
      {
        "name": "input_mode",
        "type": "string",
        "description": "Must be one of the following: `linear_input`, `skip_input`, `auto_select`.",
        "default": "linear_input"
      },
      {
        "name": "direction",
        "type": "string",
        "description": "Must be one of the following: `unidirectional`, `bidirectional`.",
        "default": "unidirectional"
      },
      {
        "name": "dropout",
        "type": "float32",
        "default": 0.0
      },
      {
        "name": "seed",
        "type": "int64",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "default": 0
      },
      {
        "name": "num_proj",
        "type": "int64",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "num_layers",
        "type": 3
      },
      {
        "name": "num_units",
        "type": 3
      },
      {
        "name": "input_size",
        "type": 3
      },
      {
        "name": "weights",
        "numberAttr": "num_params_weights",
        "typeAttr": "T"
      },
      {
        "name": "biases",
        "numberAttr": "num_params_biases",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "params",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CudnnRNNParamsSize",
    "summary": "Computes size of weights that can be used by a Cudnn RNN model.",
    "description": "Return the params size that can be used by the Cudnn RNN model. Subsequent\nweight allocation and initialization should use this size.\n\nnum_layers: Specifies the number of layers in the RNN model.\nnum_units: Specifies the size of the hidden state.\ninput_size: Specifies the size of the input state.\nrnn_mode: Indicates the type of the RNN model.\ninput_mode: Indicate whether there is a linear projection between the input and\n  The actual computation before the first layer. 'skip_input' is only allowed\n  when input_size == num_units; 'auto_select' implies 'skip_input' when\n  input_size == num_units; otherwise, it implies 'linear_input'.\ndirection: Indicates whether a bidirectional model will be used.\n  dir = (direction == bidirectional) ? 2 : 1\ndropout: dropout probability. When set to 0., dropout is disabled.\nseed: the 1st part of a seed to initialize dropout.\nseed2: the 2nd part of a seed to initialize dropout.\nparams_size: The size of the params buffer that should be allocated and\n  initialized for this RNN model. Note that this params buffer may not be\n  compatible across GPUs. Please use CudnnRNNParamsWeights and\n  CudnnRNNParamsBiases to save and restore them in a way that is compatible\n  across different runs.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "S",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "rnn_mode",
        "type": "string",
        "description": "Must be one of the following: `rnn_relu`, `rnn_tanh`, `lstm`, `gru`.",
        "default": "lstm"
      },
      {
        "name": "input_mode",
        "type": "string",
        "description": "Must be one of the following: `linear_input`, `skip_input`, `auto_select`.",
        "default": "linear_input"
      },
      {
        "name": "direction",
        "type": "string",
        "description": "Must be one of the following: `unidirectional`, `bidirectional`.",
        "default": "unidirectional"
      },
      {
        "name": "dropout",
        "type": "float32",
        "default": 0.0
      },
      {
        "name": "seed",
        "type": "int64",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "default": 0
      },
      {
        "name": "num_proj",
        "type": "int64",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "num_layers",
        "type": 3
      },
      {
        "name": "num_units",
        "type": 3
      },
      {
        "name": "input_size",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "params_size",
        "typeAttr": "S"
      }
    ]
  },
  {
    "name": "CudnnRNNParamsToCanonical",
    "summary": "Retrieves CudnnRNN params in canonical form.",
    "description": "Retrieves a set of weights from the opaque params buffer that can be saved and\nrestored in a way compatible with future runs.\n\nNote that the params buffer may not be compatible across different GPUs. So any\nsave and restoration should be converted to and from the canonical weights and\nbiases.\n\nnum_layers: Specifies the number of layers in the RNN model.\nnum_units: Specifies the size of the hidden state.\ninput_size: Specifies the size of the input state.\nnum_params: number of parameter sets for all layers.\n    Each layer may contain multiple parameter sets, with each set consisting of\n    a weight matrix and a bias vector.\nweights: the canonical form of weights that can be used for saving\n    and restoration. They are more likely to be compatible across different\n    generations.\nbiases: the canonical form of biases that can be used for saving\n    and restoration. They are more likely to be compatible across different\n    generations.\nrnn_mode: Indicates the type of the RNN model.\ninput_mode: Indicate whether there is a linear projection between the input and\n    The actual computation before the first layer. 'skip_input' is only allowed\n    when input_size == num_units; 'auto_select' implies 'skip_input' when\n    input_size == num_units; otherwise, it implies 'linear_input'.\ndirection: Indicates whether a bidirectional model will be used.\n    dir = (direction == bidirectional) ? 2 : 1\ndropout: dropout probability. When set to 0., dropout is disabled.\nseed: the 1st part of a seed to initialize dropout.\nseed2: the 2nd part of a seed to initialize dropout.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "num_params",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "rnn_mode",
        "type": "string",
        "description": "Must be one of the following: `rnn_relu`, `rnn_tanh`, `lstm`, `gru`.",
        "default": "lstm"
      },
      {
        "name": "input_mode",
        "type": "string",
        "description": "Must be one of the following: `linear_input`, `skip_input`, `auto_select`.",
        "default": "linear_input"
      },
      {
        "name": "direction",
        "type": "string",
        "description": "Must be one of the following: `unidirectional`, `bidirectional`.",
        "default": "unidirectional"
      },
      {
        "name": "dropout",
        "type": "float32",
        "default": 0.0
      },
      {
        "name": "seed",
        "type": "int64",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "num_layers",
        "type": 3
      },
      {
        "name": "num_units",
        "type": 3
      },
      {
        "name": "input_size",
        "type": 3
      },
      {
        "name": "params",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "weights",
        "numberAttr": "num_params",
        "typeAttr": "T"
      },
      {
        "name": "biases",
        "numberAttr": "num_params",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CudnnRNNParamsToCanonicalV2",
    "summary": "Retrieves CudnnRNN params in canonical form. It supports the projection in LSTM.",
    "description": "Retrieves a set of weights from the opaque params buffer that can be saved and\nrestored in a way compatible with future runs.\n\nNote that the params buffer may not be compatible across different GPUs. So any\nsave and restoration should be converted to and from the canonical weights and\nbiases.\n\nnum_layers: Specifies the number of layers in the RNN model.\nnum_units: Specifies the size of the hidden state.\ninput_size: Specifies the size of the input state.\nnum_params_weights: number of weight parameter matrix for all layers.\nnum_params_biases: number of bias parameter vector for all layers.\nweights: the canonical form of weights that can be used for saving\n    and restoration. They are more likely to be compatible across different\n    generations.\nbiases: the canonical form of biases that can be used for saving\n    and restoration. They are more likely to be compatible across different\n    generations.\nrnn_mode: Indicates the type of the RNN model.\ninput_mode: Indicate whether there is a linear projection between the input and\n    The actual computation before the first layer. 'skip_input' is only allowed\n    when input_size == num_units; 'auto_select' implies 'skip_input' when\n    input_size == num_units; otherwise, it implies 'linear_input'.\ndirection: Indicates whether a bidirectional model will be used.\n    dir = (direction == bidirectional) ? 2 : 1\ndropout: dropout probability. When set to 0., dropout is disabled.\nseed: the 1st part of a seed to initialize dropout.\nseed2: the 2nd part of a seed to initialize dropout.\nnum_proj: The output dimensionality for the projection matrices. If None or 0,\n    no projection is performed.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "num_params_weights",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "num_params_biases",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "rnn_mode",
        "type": "string",
        "description": "Must be one of the following: `rnn_relu`, `rnn_tanh`, `lstm`, `gru`.",
        "default": "lstm"
      },
      {
        "name": "input_mode",
        "type": "string",
        "description": "Must be one of the following: `linear_input`, `skip_input`, `auto_select`.",
        "default": "linear_input"
      },
      {
        "name": "direction",
        "type": "string",
        "description": "Must be one of the following: `unidirectional`, `bidirectional`.",
        "default": "unidirectional"
      },
      {
        "name": "dropout",
        "type": "float32",
        "default": 0.0
      },
      {
        "name": "seed",
        "type": "int64",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "default": 0
      },
      {
        "name": "num_proj",
        "type": "int64",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "num_layers",
        "type": 3
      },
      {
        "name": "num_units",
        "type": 3
      },
      {
        "name": "input_size",
        "type": 3
      },
      {
        "name": "params",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "weights",
        "numberAttr": "num_params_weights",
        "typeAttr": "T"
      },
      {
        "name": "biases",
        "numberAttr": "num_params_biases",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CudnnRNNV2",
    "summary": "A RNN backed by cuDNN.",
    "description": "Computes the RNN from the input and initial states, with respect to the params\nbuffer. Produces one extra output \"host_reserved\" than CudnnRNN.\n\nrnn_mode: Indicates the type of the RNN model.\ninput_mode: Indicates whether there is a linear projection between the input and\n  the actual computation before the first layer. 'skip_input' is only allowed\n  when input_size == num_units; 'auto_select' implies 'skip_input' when\n  input_size == num_units; otherwise, it implies 'linear_input'.\ndirection: Indicates whether a bidirectional model will be used. Should be\n  \"unidirectional\" or \"bidirectional\".\ndropout: Dropout probability. When set to 0., dropout is disabled.\nseed: The 1st part of a seed to initialize dropout.\nseed2: The 2nd part of a seed to initialize dropout.\ninput: A 3-D tensor with the shape of [seq_length, batch_size, input_size].\ninput_h: A 3-D tensor with the shape of [num_layer * dir, batch_size,\n    num_units].\ninput_c: For LSTM, a 3-D tensor with the shape of\n    [num_layer * dir, batch, num_units]. For other models, it is ignored.\nparams: A 1-D tensor that contains the weights and biases in an opaque layout.\n    The size must be created through CudnnRNNParamsSize, and initialized\n    separately. Note that they might not be compatible across different\n    generations. So it is a good idea to save and restore\noutput: A 3-D tensor with the shape of [seq_length, batch_size,\n    dir * num_units].\noutput_h: The same shape has input_h.\noutput_c: The same shape as input_c for LSTM. An empty tensor for other models.\nis_training: Indicates whether this operation is used for inference or\n  training.\nreserve_space: An opaque tensor that can be used in backprop calculation. It\n  is only produced if is_training is true.\nhost_reserved: An opaque tensor that can be used in backprop calculation. It is\n  only produced if is_training is true. It is output on host memory rather than\n  device memory.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "rnn_mode",
        "type": "string",
        "description": "Must be one of the following: `rnn_relu`, `rnn_tanh`, `lstm`, `gru`.",
        "default": "lstm"
      },
      {
        "name": "input_mode",
        "type": "string",
        "description": "Must be one of the following: `linear_input`, `skip_input`, `auto_select`.",
        "default": "linear_input"
      },
      {
        "name": "direction",
        "type": "string",
        "description": "Must be one of the following: `unidirectional`, `bidirectional`.",
        "default": "unidirectional"
      },
      {
        "name": "dropout",
        "type": "float32",
        "default": 0.0
      },
      {
        "name": "seed",
        "type": "int64",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "default": 0
      },
      {
        "name": "is_training",
        "type": "boolean",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "input_h",
        "typeAttr": "T"
      },
      {
        "name": "input_c",
        "typeAttr": "T"
      },
      {
        "name": "params",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      },
      {
        "name": "output_h",
        "typeAttr": "T"
      },
      {
        "name": "output_c",
        "typeAttr": "T"
      },
      {
        "name": "reserve_space",
        "typeAttr": "T"
      },
      {
        "name": "host_reserved",
        "type": 6
      }
    ]
  },
  {
    "name": "CudnnRNNV3",
    "summary": "A RNN backed by cuDNN.",
    "description": "Computes the RNN from the input and initial states, with respect to the params\nbuffer. Accepts one extra input \"sequence_lengths\" than CudnnRNN.\n\nrnn_mode: Indicates the type of the RNN model.\ninput_mode: Indicates whether there is a linear projection between the input and\n  the actual computation before the first layer. 'skip_input' is only allowed\n  when input_size == num_units; 'auto_select' implies 'skip_input' when\n  input_size == num_units; otherwise, it implies 'linear_input'.\ndirection: Indicates whether a bidirectional model will be used. Should be\n  \"unidirectional\" or \"bidirectional\".\ndropout: Dropout probability. When set to 0., dropout is disabled.\nseed: The 1st part of a seed to initialize dropout.\nseed2: The 2nd part of a seed to initialize dropout.\ninput: If time_major is true, this is a 3-D tensor with the shape of\n    [seq_length, batch_size, input_size]. If time_major is false, the shape is\n    [batch_size, seq_length, input_size].\ninput_h: If time_major is true, this is a 3-D tensor with the shape of\n    [num_layer * dir, batch_size, num_units]. If time_major is false, the shape\n    is [batch_size, num_layer * dir, num_units].\ninput_c: For LSTM, a 3-D tensor with the shape of\n    [num_layer * dir, batch, num_units]. For other models, it is ignored.\nparams: A 1-D tensor that contains the weights and biases in an opaque layout.\n    The size must be created through CudnnRNNParamsSize, and initialized\n    separately. Note that they might not be compatible across different\n    generations. So it is a good idea to save and restore\nsequence_lengths: a vector of lengths of each input sequence.\noutput: If time_major is true, this is a 3-D tensor with the shape of\n    [seq_length, batch_size, dir * num_units]. If time_major is false, the\n    shape is [batch_size, seq_length, dir * num_units].\noutput_h: The same shape has input_h.\noutput_c: The same shape as input_c for LSTM. An empty tensor for other models.\nis_training: Indicates whether this operation is used for inference or\n  training.\ntime_major: Indicates whether the input/output format is time major or batch\n    major.\nreserve_space: An opaque tensor that can be used in backprop calculation. It\n  is only produced if is_training is true.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "rnn_mode",
        "type": "string",
        "description": "Must be one of the following: `rnn_relu`, `rnn_tanh`, `lstm`, `gru`.",
        "default": "lstm"
      },
      {
        "name": "input_mode",
        "type": "string",
        "description": "Must be one of the following: `linear_input`, `skip_input`, `auto_select`.",
        "default": "linear_input"
      },
      {
        "name": "direction",
        "type": "string",
        "description": "Must be one of the following: `unidirectional`, `bidirectional`.",
        "default": "unidirectional"
      },
      {
        "name": "dropout",
        "type": "float32",
        "default": 0.0
      },
      {
        "name": "seed",
        "type": "int64",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "default": 0
      },
      {
        "name": "num_proj",
        "type": "int64",
        "default": 0
      },
      {
        "name": "is_training",
        "type": "boolean",
        "default": true
      },
      {
        "name": "time_major",
        "type": "boolean",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "input_h",
        "typeAttr": "T"
      },
      {
        "name": "input_c",
        "typeAttr": "T"
      },
      {
        "name": "params",
        "typeAttr": "T"
      },
      {
        "name": "sequence_lengths",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      },
      {
        "name": "output_h",
        "typeAttr": "T"
      },
      {
        "name": "output_c",
        "typeAttr": "T"
      },
      {
        "name": "reserve_space",
        "typeAttr": "T"
      },
      {
        "name": "host_reserved",
        "type": 6
      }
    ]
  },
  {
    "name": "Cumprod",
    "summary": "Compute the cumulative product of the tensor `x` along `axis`.",
    "description": "By default, this op performs an inclusive cumprod, which means that the first\nelement of the input is identical to the first element of the output:\n\n```python\ntf.cumprod([a, b, c])  # => [a, a * b, a * b * c]\n```\n\nBy setting the `exclusive` kwarg to `True`, an exclusive cumprod is\nperformed instead:\n\n```python\ntf.cumprod([a, b, c], exclusive=True)  # => [1, a, a * b]\n```\n\nBy setting the `reverse` kwarg to `True`, the cumprod is performed in the\nopposite direction:\n\n```python\ntf.cumprod([a, b, c], reverse=True)  # => [a * b * c, b * c, c]\n```\n\nThis is more efficient than using separate `tf.reverse` ops.\n\nThe `reverse` and `exclusive` kwargs can also be combined:\n\n```python\ntf.cumprod([a, b, c], exclusive=True, reverse=True)  # => [b * c, c, 1]\n```",
    "attributes": [
      {
        "name": "exclusive",
        "type": "boolean",
        "description": "If `True`, perform exclusive cumprod.",
        "default": false
      },
      {
        "name": "reverse",
        "type": "boolean",
        "description": "A `bool` (default: False).",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "A `Tensor`. Must be one of the following types: `float32`, `float64`,\n`int64`, `int32`, `uint8`, `uint16`, `int16`, `int8`, `complex64`,\n`complex128`, `qint8`, `quint8`, `qint32`, `half`.",
        "typeAttr": "T"
      },
      {
        "name": "axis",
        "description": "A `Tensor` of type `int32` (default: 0). Must be in the range\n`[-rank(x), rank(x))`.",
        "typeAttr": "Tidx"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Cumsum",
    "summary": "Compute the cumulative sum of the tensor `x` along `axis`.",
    "description": "By default, this op performs an inclusive cumsum, which means that the first\nelement of the input is identical to the first element of the output:\n\n```python\ntf.cumsum([a, b, c])  # => [a, a + b, a + b + c]\n```\n\nBy setting the `exclusive` kwarg to `True`, an exclusive cumsum is\nperformed instead:\n\n```python\ntf.cumsum([a, b, c], exclusive=True)  # => [0, a, a + b]\n```\n\nBy setting the `reverse` kwarg to `True`, the cumsum is performed in the\nopposite direction:\n\n```python\ntf.cumsum([a, b, c], reverse=True)  # => [a + b + c, b + c, c]\n```\n\nThis is more efficient than using separate `tf.reverse` ops.\n\nThe `reverse` and `exclusive` kwargs can also be combined:\n\n```python\ntf.cumsum([a, b, c], exclusive=True, reverse=True)  # => [b + c, c, 0]\n```",
    "attributes": [
      {
        "name": "exclusive",
        "type": "boolean",
        "description": "If `True`, perform exclusive cumsum.",
        "default": false
      },
      {
        "name": "reverse",
        "type": "boolean",
        "description": "A `bool` (default: False).",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "A `Tensor`. Must be one of the following types: `float32`, `float64`,\n`int64`, `int32`, `uint8`, `uint16`, `int16`, `int8`, `complex64`,\n`complex128`, `qint8`, `quint8`, `qint32`, `half`.",
        "typeAttr": "T"
      },
      {
        "name": "axis",
        "description": "A `Tensor` of type `int32` (default: 0). Must be in the range\n`[-rank(x), rank(x))`.",
        "typeAttr": "Tidx"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "CumulativeLogsumexp",
    "summary": "Compute the cumulative product of the tensor `x` along `axis`.",
    "description": "By default, this op performs an inclusive cumulative log-sum-exp,\nwhich means that the first\nelement of the input is identical to the first element of the output:\n```python\ntf.math.cumulative_logsumexp([a, b, c])  # => [a, log(exp(a) + exp(b)), log(exp(a) + exp(b) + exp(c))]\n```\n\nBy setting the `exclusive` kwarg to `True`, an exclusive cumulative log-sum-exp is\nperformed instead:\n```python\ntf.cumulative_logsumexp([a, b, c], exclusive=True)  # => [-inf, a, log(exp(a) * exp(b))]\n```\nNote that the neutral element of the log-sum-exp operation is `-inf`,\nhowever, for performance reasons, the minimal value representable by the\nfloating point type is used instead.\n\nBy setting the `reverse` kwarg to `True`, the cumulative log-sum-exp is performed in the\nopposite direction.",
    "attributes": [
      {
        "name": "exclusive",
        "type": "boolean",
        "description": "If `True`, perform exclusive cumulative log-sum-exp.",
        "default": false
      },
      {
        "name": "reverse",
        "type": "boolean",
        "description": "A `bool` (default: False).",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "A `Tensor`. Must be one of the following types: `float16`, `float32`, `float64`.",
        "typeAttr": "T"
      },
      {
        "name": "axis",
        "description": "A `Tensor` of type `int32` (default: 0). Must be in the range\n`[-rank(x), rank(x))`.",
        "typeAttr": "Tidx"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "DTensorRestoreV2",
    "attributes": [
      {
        "name": "input_shapes",
        "type": "shape[]"
      },
      {
        "name": "input_layouts",
        "type": "string[]"
      },
      {
        "name": "dtypes",
        "type": "type[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "prefix",
        "type": 7
      },
      {
        "name": "tensor_names",
        "type": 7
      },
      {
        "name": "shape_and_slices",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "tensors",
        "typeListAttr": "dtypes"
      }
    ]
  },
  {
    "name": "DTensorSetGlobalTPUArray",
    "summary": "An op that informs a host of the global ids of all the of TPUs in the system.",
    "inputs": [
      {
        "name": "topology",
        "description": "A serialized tensorflow.tpu.TopologyProto that describes the TPU topology.",
        "type": 7
      }
    ]
  },
  {
    "name": "DataFormatDimMap",
    "summary": "Returns the dimension index in the destination data format given the one in",
    "description": "the source data format.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "src_format",
        "type": "string",
        "description": "source data format.",
        "default": "NHWC"
      },
      {
        "name": "dst_format",
        "type": "string",
        "description": "destination data format.",
        "default": "NCHW"
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "A Tensor with each element as a dimension index in source data format.\nMust be in the range [-4, 4).",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "description": "A Tensor with each element as a dimension index in destination data format.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "DataFormatVecPermute",
    "summary": "Permute input tensor from `src_format` to `dst_format`.",
    "description": "Given source and destination format strings of length n=4 or 5, the input\ntensor must be a vector of size n or n-2, or a 2D tensor of shape\n(n, 2) or (n-2, 2).\n\nIf the first dimension of the input tensor is n-2, it is assumed that\nnon-spatial dimensions are omitted (i.e `N`, `C`).\n\nFor example, with `src_format` of `NHWC`, `dst_format` of `NCHW`, and input:\n```\n[1, 2, 3, 4]\n```\n, the output will be:\n```\n[1, 4, 2, 3]\n```\nWith `src_format` of `NDHWC`, `dst_format` of `NCDHW`, and input:\n```\n[[1, 6], [2, 7], [3, 8], [4, 9], [5, 10]]\n```\n, the output will be:\n```\n[[1, 6], [5, 10], [2, 7], [3, 8], [4, 9]]\n```\nWith `src_format` of `NHWC`, `dst_format` of `NCHW`, and input:\n```\n[1, 2]\n```\n, the output will be:\n```\n[1, 2]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "src_format",
        "type": "string",
        "description": "source data format.",
        "default": "NHWC"
      },
      {
        "name": "dst_format",
        "type": "string",
        "description": "destination data format.",
        "default": "NCHW"
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "Tensor of rank 1 or 2 in source data format.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "description": "Tensor of rank 1 or 2 in destination data format.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "DataServiceDataset",
    "summary": "Creates a dataset that reads data from the tf.data service.",
    "attributes": [
      {
        "name": "task_refresh_interval_hint_ms",
        "type": "int64",
        "default": -1
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "data_transfer_protocol",
        "type": "string",
        "default": ""
      },
      {
        "name": "target_workers",
        "type": "string",
        "default": "AUTO"
      },
      {
        "name": "cross_trainer_cache_options",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "dataset_id",
        "type": 9
      },
      {
        "name": "processing_mode",
        "type": 7
      },
      {
        "name": "address",
        "type": 7
      },
      {
        "name": "protocol",
        "type": 7
      },
      {
        "name": "job_name",
        "type": 7
      },
      {
        "name": "max_outstanding_requests",
        "type": 9
      },
      {
        "name": "iteration_counter",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "DataServiceDatasetV2",
    "summary": "Creates a dataset that reads data from the tf.data service.",
    "attributes": [
      {
        "name": "task_refresh_interval_hint_ms",
        "type": "int64",
        "default": -1
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "data_transfer_protocol",
        "type": "string",
        "default": ""
      },
      {
        "name": "target_workers",
        "type": "string",
        "default": "AUTO"
      },
      {
        "name": "cross_trainer_cache_options",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "dataset_id",
        "type": 9
      },
      {
        "name": "processing_mode",
        "type": 7
      },
      {
        "name": "address",
        "type": 7
      },
      {
        "name": "protocol",
        "type": 7
      },
      {
        "name": "job_name",
        "type": 7
      },
      {
        "name": "consumer_index",
        "type": 9
      },
      {
        "name": "num_consumers",
        "type": 9
      },
      {
        "name": "max_outstanding_requests",
        "type": 9
      },
      {
        "name": "iteration_counter",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "DataServiceDatasetV3",
    "summary": "Creates a dataset that reads data from the tf.data service.",
    "attributes": [
      {
        "name": "task_refresh_interval_hint_ms",
        "type": "int64",
        "default": -1
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "data_transfer_protocol",
        "type": "string",
        "default": ""
      },
      {
        "name": "target_workers",
        "type": "string",
        "default": "AUTO"
      },
      {
        "name": "uncompress",
        "type": "boolean",
        "default": false
      },
      {
        "name": "uncompress_fn",
        "type": "function"
      },
      {
        "name": "cross_trainer_cache_options",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "dataset_id",
        "type": 9
      },
      {
        "name": "processing_mode",
        "type": 7
      },
      {
        "name": "address",
        "type": 7
      },
      {
        "name": "protocol",
        "type": 7
      },
      {
        "name": "job_name",
        "type": 7
      },
      {
        "name": "consumer_index",
        "type": 9
      },
      {
        "name": "num_consumers",
        "type": 9
      },
      {
        "name": "max_outstanding_requests",
        "type": 9
      },
      {
        "name": "iteration_counter",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "DataServiceDatasetV4",
    "summary": "Creates a dataset that reads data from the tf.data service.",
    "attributes": [
      {
        "name": "task_refresh_interval_hint_ms",
        "type": "int64",
        "default": -1
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "data_transfer_protocol",
        "type": "string",
        "default": ""
      },
      {
        "name": "target_workers",
        "type": "string",
        "default": "AUTO"
      },
      {
        "name": "uncompress",
        "type": "boolean",
        "default": false
      },
      {
        "name": "uncompress_fn",
        "type": "function"
      },
      {
        "name": "cross_trainer_cache_options",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "dataset_id",
        "type": 7
      },
      {
        "name": "processing_mode",
        "type": 7
      },
      {
        "name": "address",
        "type": 7
      },
      {
        "name": "protocol",
        "type": 7
      },
      {
        "name": "job_name",
        "type": 7
      },
      {
        "name": "consumer_index",
        "type": 9
      },
      {
        "name": "num_consumers",
        "type": 9
      },
      {
        "name": "max_outstanding_requests",
        "type": 9
      },
      {
        "name": "iteration_counter",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "DatasetCardinality",
    "summary": "Returns the cardinality of `input_dataset`.",
    "description": "Returns the cardinality of `input_dataset`.",
    "attributes": [
      {
        "name": "cardinality_options",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the dataset to return cardinality for.",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "cardinality",
        "description": "The cardinality of `input_dataset`. Named constants are used to represent\ninfinite and unknown cardinality.",
        "type": 9
      }
    ]
  },
  {
    "name": "DatasetFingerprint",
    "summary": "Returns the fingerprint of `input_dataset`.",
    "description": "Returns the fingerprint of `input_dataset`.",
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the dataset to return fingerprint for.",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "fingerprint",
        "description": "The fingerprint of `input_dataset` in `uint64`",
        "type": 23
      }
    ]
  },
  {
    "name": "DatasetFromGraph",
    "summary": "Creates a dataset from the given `graph_def`.",
    "description": "Creates a dataset from the provided `graph_def`.",
    "inputs": [
      {
        "name": "graph_def",
        "description": "The graph representation of the dataset (as serialized GraphDef).",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "A variant tensor representing the dataset.",
        "type": 21
      }
    ]
  },
  {
    "name": "DatasetToGraph",
    "summary": "Returns a serialized GraphDef representing `input_dataset`.",
    "description": "Returns a graph representation for `input_dataset`.",
    "attributes": [
      {
        "name": "stateful_whitelist",
        "type": "string[]",
        "minimum": 0,
        "default": []
      },
      {
        "name": "allow_stateful",
        "type": "boolean",
        "default": false
      },
      {
        "name": "strip_device_assignment",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the dataset to return the graph representation for.",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "graph",
        "description": "The graph representation of the dataset (as serialized GraphDef).",
        "type": 7
      }
    ]
  },
  {
    "name": "DatasetToGraphV2",
    "summary": "Returns a serialized GraphDef representing `input_dataset`.",
    "description": "Returns a graph representation for `input_dataset`.",
    "attributes": [
      {
        "name": "external_state_policy",
        "type": "int64",
        "default": 0
      },
      {
        "name": "strip_device_assignment",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the dataset to return the graph representation for.",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "graph",
        "description": "The graph representation of the dataset (as serialized GraphDef).",
        "type": 7
      }
    ]
  },
  {
    "name": "DatasetToSingleElement",
    "summary": "Outputs the single element from the given dataset.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "dataset",
        "description": "A handle to a dataset that contains a single element.",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "components",
        "description": "The components of the single element of `input`.",
        "typeListAttr": "output_types"
      }
    ]
  },
  {
    "name": "DatasetToTFRecord",
    "summary": "Writes the given dataset to the given file using the TFRecord format.",
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the dataset to write.",
        "type": 21
      },
      {
        "name": "filename",
        "description": "A scalar string tensor representing the filename to use.",
        "type": 7
      },
      {
        "name": "compression_type",
        "description": "A scalar string tensor containing either (i) the empty string (no\ncompression), (ii) \"ZLIB\", or (iii) \"GZIP\".",
        "type": 7
      }
    ]
  },
  {
    "name": "Dawsn",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "DebugGradientIdentity",
    "summary": "Identity op for gradient debugging.",
    "description": "This op is hidden from public in Python. It is used by TensorFlow Debugger to\nregister gradient tensors for gradient debugging.\nThis op operates on non-reference-type tensors.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "DebugGradientRefIdentity",
    "summary": "Identity op for gradient debugging.",
    "description": "This op is hidden from public in Python. It is used by TensorFlow Debugger to\nregister gradient tensors for gradient debugging.\nThis op operates on reference-type tensors.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T",
        "isRef": true
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "DebugIdentity",
    "summary": "Provides an identity mapping of the non-Ref type input tensor for debugging.",
    "description": "Provides an identity mapping of the non-Ref type input tensor for debugging.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "device_name",
        "type": "string",
        "description": "Name of the device on which the tensor resides.",
        "default": ""
      },
      {
        "name": "tensor_name",
        "type": "string",
        "description": "Name of the input tensor.",
        "default": ""
      },
      {
        "name": "debug_urls",
        "type": "string[]",
        "description": "List of URLs to debug targets, e.g.,\n  file:///foo/tfdbg_dump, grpc:://localhost:11011",
        "default": []
      },
      {
        "name": "gated_grpc",
        "type": "boolean",
        "description": "Whether this op will be gated. If any of the debug_urls of this\n  debug node is of the grpc:// scheme, when the value of this attribute is set\n  to True, the data will not actually be sent via the grpc stream unless this\n  debug op has been enabled at the debug_url. If all of the debug_urls of this\n  debug node are of the grpc:// scheme and the debug op is enabled at none of\n  them, the output will be an empty Tensor.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Input tensor, non-Reference type",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "DebugIdentityV2",
    "summary": "Debug Identity V2 Op.",
    "description": "Provides an identity mapping from input to output, while writing the content of\nthe input tensor by calling DebugEventsWriter.\n\nThe semantics of the input tensor depends on tensor_debug_mode. In typical\nusage, the input tensor comes directly from the user computation only when\ngraph_debug_mode is FULL_TENSOR (see protobuf/debug_event.proto for a\nlist of all the possible values of graph_debug_mode). For the other debug modes,\nthe input tensor should be produced by an additional op or subgraph that\ncomputes summary information about one or more tensors.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "tfdbg_context_id",
        "type": "string",
        "description": "A tfdbg-generated ID for the context that the op belongs to,\n  e.g., a concrete compiled tf.function.",
        "default": ""
      },
      {
        "name": "op_name",
        "type": "string",
        "description": "Optional. Name of the op that the debug op is concerned with.\n  Used only for single-tensor trace.",
        "default": ""
      },
      {
        "name": "output_slot",
        "type": "int64",
        "description": "Optional. Output slot index of the tensor that the debug op\n  is concerned with. Used only for single-tensor trace.",
        "default": -1
      },
      {
        "name": "tensor_debug_mode",
        "type": "int64",
        "description": "TensorDebugMode enum value. See debug_event.proto for details.",
        "default": -1
      },
      {
        "name": "debug_urls",
        "type": "string[]",
        "description": "List of URLs to debug targets, e.g., file:///foo/tfdbg_dump.",
        "default": []
      },
      {
        "name": "circular_buffer_size",
        "type": "int64",
        "default": 1000
      },
      {
        "name": "tfdbg_run_id",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Input tensor, non-Reference type",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "DebugIdentityV3",
    "summary": "Provides an identity mapping of the non-Ref type input tensor for debugging.",
    "description": "Provides an identity mapping of the non-Ref type input tensor for debugging.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "device_name",
        "type": "string",
        "description": "Name of the device on which the tensor resides.",
        "default": ""
      },
      {
        "name": "tensor_name",
        "type": "string",
        "description": "Name of the input tensor.",
        "default": ""
      },
      {
        "name": "io_of_node",
        "type": "string",
        "description": "Name of the node of which the tensor is an input or output.",
        "default": ""
      },
      {
        "name": "is_input",
        "type": "boolean",
        "description": "If true, the tensor is an input of the node; otherwise the output.",
        "default": false
      },
      {
        "name": "io_index",
        "type": "int64",
        "description": "The index of which the tensor is an input or output of the node.",
        "default": -1
      },
      {
        "name": "debug_urls",
        "type": "string[]",
        "description": "List of URLs to debug targets, e.g.,\n  file:///foo/tfdbg_dump, grpc:://localhost:11011",
        "default": []
      },
      {
        "name": "gated_grpc",
        "type": "boolean",
        "description": "Whether this op will be gated. If any of the debug_urls of this\n  debug node is of the grpc:// scheme, when the value of this attribute is set\n  to True, the data will not actually be sent via the grpc stream unless this\n  debug op has been enabled at the debug_url. If all of the debug_urls of this\n  debug node are of the grpc:// scheme and the debug op is enabled at none of\n  them, the output will be an empty Tensor.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Input tensor, non-Reference type",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "DebugNanCount",
    "summary": "Debug NaN Value Counter Op.",
    "description": "Counts number of NaNs in the input tensor, for debugging.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "device_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "tensor_name",
        "type": "string",
        "description": "Name of the input tensor.",
        "default": ""
      },
      {
        "name": "debug_urls",
        "type": "string[]",
        "description": "List of URLs to debug targets, e.g.,\n  file:///foo/tfdbg_dump, grpc:://localhost:11011.",
        "default": []
      },
      {
        "name": "gated_grpc",
        "type": "boolean",
        "description": " Whether this op will be gated. If any of the debug_urls of this\n  debug node is of the grpc:// scheme, when the value of this attribute is set\n  to True, the data will not actually be sent via the grpc stream unless this\n  debug op has been enabled at the debug_url. If all of the debug_urls of this\n  debug node are of the grpc:// scheme and the debug op is enabled at none of\n  them, the output will be an empty Tensor.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Input tensor, non-Reference type.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 9
      }
    ]
  },
  {
    "name": "DebugNumericSummary",
    "summary": "Debug Numeric Summary Op.",
    "description": "Provide a basic summary of numeric value types, range and distribution.\n\noutput: A double tensor of shape [14 + nDimensions], where nDimensions is the\n  number of dimensions of the tensor's shape. The elements of output are:\n  [0]: is initialized (1.0) or not (0.0).\n  [1]: total number of elements\n  [2]: NaN element count\n  [3]: generalized -inf count: elements <= lower_bound. lower_bound is -inf by\n    default.\n  [4]: negative element count (excluding -inf), if lower_bound is the default\n    -inf. Otherwise, this is the count of elements > lower_bound and < 0.\n  [5]: zero element count\n  [6]: positive element count (excluding +inf), if upper_bound is the default\n    +inf. Otherwise, this is the count of elements < upper_bound and > 0.\n  [7]: generalized +inf count, elements >= upper_bound. upper_bound is +inf by\n    default.\nOutput elements [1:8] are all zero, if the tensor is uninitialized.\n  [8]: minimum of all non-inf and non-NaN elements.\n       If uninitialized or no such element exists: +inf.\n  [9]: maximum of all non-inf and non-NaN elements.\n       If uninitialized or no such element exists: -inf.\n  [10]: mean of all non-inf and non-NaN elements.\n        If uninitialized or no such element exists: NaN.\n  [11]: variance of all non-inf and non-NaN elements.\n        If uninitialized or no such element exists: NaN.\n  [12]: Data type of the tensor encoded as an enum integer. See the DataType\n        proto for more details.\n  [13]: Number of dimensions of the tensor (ndims).\n  [14+]: Sizes of the dimensions.\n",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "device_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "tensor_name",
        "type": "string",
        "description": "Name of the input tensor.",
        "default": ""
      },
      {
        "name": "debug_urls",
        "type": "string[]",
        "description": "List of URLs to debug targets, e.g.,\n  file:///foo/tfdbg_dump, grpc:://localhost:11011.",
        "default": []
      },
      {
        "name": "lower_bound",
        "type": "float32",
        "description": "(float) The lower bound <= which values will be included in the\n  generalized -inf count. Default: -inf.",
        "default": "-NaN"
      },
      {
        "name": "upper_bound",
        "type": "float32",
        "description": "(float) The upper bound >= which values will be included in the\n  generalized +inf count. Default: +inf.",
        "default": "NaN"
      },
      {
        "name": "mute_if_healthy",
        "type": "boolean",
        "description": "(bool) Do not send data to the debug URLs unless at least one\n  of elements [2], [3] and [7] (i.e., the nan count and the generalized -inf and\n  inf counts) is non-zero.",
        "default": false
      },
      {
        "name": "gated_grpc",
        "type": "boolean",
        "description": "Whether this op will be gated. If any of the debug_urls of this\n  debug node is of the grpc:// scheme, when the value of this attribute is set\n  to True, the data will not actually be sent via the grpc stream unless this\n  debug op has been enabled at the debug_url. If all of the debug_urls of this\n  debug node are of the grpc:// scheme and the debug op is enabled at none of\n  them, the output will be an empty Tensor.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Input tensor, non-Reference type.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 2
      }
    ]
  },
  {
    "name": "DebugNumericSummaryV2",
    "summary": "Debug Numeric Summary V2 Op.",
    "description": "Computes a numeric summary of the input tensor. The shape of the output\ndepends on the tensor_debug_mode attribute.\nThis op is used internally by TensorFlow Debugger (tfdbg) v2.",
    "attributes": [
      {
        "name": "output_dtype",
        "type": "type",
        "description": "Optional. The type of the output. Can be float32 or float64 (default: float32). Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "tensor_debug_mode",
        "type": "int64",
        "description": "Tensor debug mode: the mode in which the input tensor is summarized\n  by the op. See the TensorDebugMode enum in\n  tensorflow/core/protobuf/debug_event.proto for details.\n\nSupported values:\n  2 (CURT_HEALTH): Output a float32/64 tensor of shape [2]. The 1st\n  element is the tensor_id, if provided, and -1 otherwise. The 2nd\n  element is a bit which is set to 1 if the input tensor has an\n  infinity or nan value, or zero otherwise.\n\n  3 (CONCISE_HEALTH): Output a float32/64 tensor of shape [5]. The 1st\n  element is the tensor_id, if provided, and -1 otherwise. The\n  remaining four slots are the total number of elements, -infs,\n  +infs, and nans in the input tensor respectively.\n\n  4 (FULL_HEALTH): Output a float32/64 tensor of shape [11]. The 1st\n  element is the tensor_id, if provided, and -1 otherwise. The 2nd\n  element is the device_id, if provided, and -1 otherwise. The 3rd\n  element holds the datatype value of the input tensor as according\n  to the enumerated type in tensorflow/core/framework/types.proto.\n  The remaining elements hold the total number of elements, -infs,\n  +infs, nans, negative finite numbers, zeros, and positive finite\n  numbers in the input tensor respectively.\n\n  5 (SHAPE): Output a float32/64 tensor of shape [10]. The 1st\n  element is the tensor_id, if provided, and -1 otherwise. The 2nd\n  element holds the datatype value of the input tensor as according\n  to the enumerated type in tensorflow/core/framework/types.proto.\n  The 3rd element holds the rank of the tensor. The 4th element holds\n  the number of elements within the tensor. Finally the remaining 6\n  elements hold the shape of the tensor. If the rank of the tensor\n  is lower than 6, the shape is right padded with zeros. If the rank\n  is greater than 6, the head of the shape is truncated.\n\n  6 (FULL_NUMERICS): Output a float32/64 tensor of shape [22]. The 1st\n  element is the tensor_id, if provided, and -1 otherwise. The 2nd\n  element is the device_id, if provided, and -1 otherwise. The 3rd\n  element holds the datatype value of the input tensor as according\n  to the enumerated type in tensorflow/core/framework/types.proto.\n  The 4th element holds the rank of the tensor. The 5th to 11th\n  elements hold the shape of the tensor. If the rank of the tensor\n  is lower than 6, the shape is right padded with zeros. If the rank\n  is greater than 6, the head of the shape is truncated. The 12th to\n  18th elements hold the number of elements, -infs, +infs, nans,\n  denormal floats, negative finite numbers, zeros, and positive\n  finite numbers in the input tensor respectively. The final four\n  elements hold the min value, max value, mean, and variance of the\n  input tensor.\n\n  8 (REDUCE_INF_NAN_THREE_SLOTS): Output a float32/64 tensor of shape\n  [3]. The 1st element is -inf if any elements of the input tensor\n  is -inf, or zero otherwise. The 2nd element is +inf if any elements\n  of the input tensor is +inf, or zero otherwise.  The 3rd element is\n  nan if any element of the input tensor is nan, or zero otherwise.",
        "default": -1
      },
      {
        "name": "tensor_id",
        "type": "int64",
        "description": "Optional. An integer identifier for the tensor being summarized by this op.",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Input tensor, to be summarized by the op.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "output_dtype"
      }
    ]
  },
  {
    "name": "DecodeAndCropJpeg",
    "summary": "Decode and Crop a JPEG-encoded image to a uint8 tensor.",
    "description": "The attr `channels` indicates the desired number of color channels for the\ndecoded image.\n\nAccepted values are:\n\n*   0: Use the number of channels in the JPEG-encoded image.\n*   1: output a grayscale image.\n*   3: output an RGB image.\n\nIf needed, the JPEG-encoded image is transformed to match the requested number\nof color channels.\n\nThe attr `ratio` allows downscaling the image by an integer factor during\ndecoding.  Allowed values are: 1, 2, 4, and 8.  This is much faster than\ndownscaling the image later.\n\n\nIt is equivalent to a combination of decode and crop, but much faster by only\ndecoding partial jpeg image.",
    "attributes": [
      {
        "name": "channels",
        "type": "int64",
        "description": "Number of color channels for the decoded image.",
        "default": 0
      },
      {
        "name": "ratio",
        "type": "int64",
        "description": "Downscaling ratio.",
        "default": 1
      },
      {
        "name": "fancy_upscaling",
        "type": "boolean",
        "description": "If true use a slower but nicer upscaling of the\nchroma planes (yuv420/422 only).",
        "default": true
      },
      {
        "name": "try_recover_truncated",
        "type": "boolean",
        "description": "If true try to recover an image from truncated input.",
        "default": false
      },
      {
        "name": "acceptable_fraction",
        "type": "float32",
        "description": "The minimum required fraction of lines before a truncated\ninput is accepted.",
        "default": 1.0
      },
      {
        "name": "dct_method",
        "type": "string",
        "description": "string specifying a hint about the algorithm used for\ndecompression.  Defaults to \"\" which maps to a system-specific\ndefault.  Currently valid values are [\"INTEGER_FAST\",\n\"INTEGER_ACCURATE\"].  The hint may be ignored (e.g., the internal\njpeg library changes to a version that does not have that specific\noption.)",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "contents",
        "description": "0-D.  The JPEG-encoded image.",
        "type": 7
      },
      {
        "name": "crop_window",
        "description": "1-D.  The crop window: [crop_y, crop_x, crop_height, crop_width].",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "image",
        "description": "3-D with shape `[height, width, channels]`..",
        "type": 4
      }
    ]
  },
  {
    "name": "DecodeBase64",
    "summary": "Decode web-safe base64-encoded strings.",
    "description": "Input may or may not have padding at the end. See\n[EncodeBase64](https://www.tensorflow.org/api_docs/python/tf/io/encode_base64)\nfor padding. Web-safe means that input must use - and _ instead of + and /.",
    "inputs": [
      {
        "name": "input",
        "description": "Base64 strings to decode.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Decoded strings.",
        "type": 7
      }
    ]
  },
  {
    "name": "DecodeBmp",
    "summary": "Decode the first frame of a BMP-encoded image to a uint8 tensor.",
    "description": "The attr `channels` indicates the desired number of color channels for the\ndecoded image.\n\nAccepted values are:\n\n*   0: Use the number of channels in the BMP-encoded image.\n*   3: output an RGB image.\n*   4: output an RGBA image.",
    "attributes": [
      {
        "name": "channels",
        "type": "int64",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "contents",
        "description": "0-D.  The BMP-encoded image.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "image",
        "description": "3-D with shape `[height, width, channels]`. RGB order",
        "type": 4
      }
    ]
  },
  {
    "name": "DecodeCSV",
    "summary": "Convert CSV records to tensors. Each column maps to one tensor.",
    "description": "RFC 4180 format is expected for the CSV records.\n(https://tools.ietf.org/html/rfc4180)\nNote that we allow leading and trailing spaces with int or float field.",
    "attributes": [
      {
        "name": "OUT_TYPE",
        "type": "type[]",
        "minimum": 1,
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `int64`, `string`."
      },
      {
        "name": "field_delim",
        "type": "string",
        "description": "char delimiter to separate fields in a record.",
        "default": ","
      },
      {
        "name": "use_quote_delim",
        "type": "boolean",
        "description": "If false, treats double quotation marks as regular\ncharacters inside of the string fields (ignoring RFC 4180, Section 2,\nBullet 5).",
        "default": true
      },
      {
        "name": "na_value",
        "type": "string",
        "description": "Additional string to recognize as NA/NaN.",
        "default": ""
      },
      {
        "name": "select_cols",
        "type": "int64[]",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "records",
        "description": "Each string is a record/row in the csv and all records should have\nthe same format.",
        "type": 7
      },
      {
        "name": "record_defaults",
        "description": "One tensor per column of the input record, with either a\nscalar default value for that column or an empty vector if the column is\nrequired.",
        "typeListAttr": "OUT_TYPE"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Each tensor will have the same shape as records.",
        "typeListAttr": "OUT_TYPE"
      }
    ]
  },
  {
    "name": "DecodeCompressed",
    "summary": "Decompress strings.",
    "description": "This op decompresses each element of the `bytes` input `Tensor`, which\nis assumed to be compressed using the given `compression_type`.\n\nThe `output` is a string `Tensor` of the same shape as `bytes`,\neach element containing the decompressed data from the corresponding\nelement in `bytes`.",
    "attributes": [
      {
        "name": "compression_type",
        "type": "string",
        "description": "A scalar containing either (i) the empty string (no\ncompression), (ii) \"ZLIB\", or (iii) \"GZIP\".",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "bytes",
        "description": "A Tensor of string which is compressed.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A Tensor with the same shape as input `bytes`, uncompressed\nfrom bytes.",
        "type": 7
      }
    ]
  },
  {
    "name": "DecodeGif",
    "summary": "Decode the frame(s) of a GIF-encoded image to a uint8 tensor.",
    "description": "GIF images with frame or transparency compression are not supported.\nOn Linux and MacOS systems, convert animated GIFs from compressed to\nuncompressed by running:\n\n    convert $src.gif -coalesce $dst.gif\n\nThis op also supports decoding JPEGs and PNGs, though it is cleaner to use\n`tf.io.decode_image`.",
    "inputs": [
      {
        "name": "contents",
        "description": "0-D.  The GIF-encoded image.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "image",
        "description": "4-D with shape `[num_frames, height, width, 3]`. RGB channel order.",
        "type": 4
      }
    ]
  },
  {
    "name": "DecodeImage",
    "summary": "Function for decode_bmp, decode_gif, decode_jpeg, and decode_png.",
    "description": "Detects whether an image is a BMP, GIF, JPEG, or PNG, and performs the\nappropriate operation to convert the input bytes string into a Tensor of type\ndtype.\n\n*NOTE*: decode_gif returns a 4-D array [num_frames, height, width, 3], as\nopposed to decode_bmp, decode_jpeg and decode_png, which return 3-D arrays\n[height, width, num_channels]. Make sure to take this into account when\nconstructing your graph if you are intermixing GIF files with BMP, JPEG, and/or\nPNG files. Alternately, set the expand_animations argument of this function to\nFalse, in which case the op will return 3-dimensional tensors and will truncate\nanimated GIF files to the first frame.\n\n*NOTE*: If the first frame of an animated GIF does not occupy the entire\ncanvas (maximum frame width x maximum frame height), then it fills the\nunoccupied areas (in the first frame) with zeros (black). For frames after the\nfirst frame that does not occupy the entire canvas, it uses the previous\nframe to fill the unoccupied areas.",
    "attributes": [
      {
        "name": "channels",
        "type": "int64",
        "description": "Number of color channels for the decoded image.",
        "default": 0
      },
      {
        "name": "dtype",
        "type": "type",
        "description": "The desired DType of the returned Tensor. Must be one of the following: `uint8`, `uint16`, `float32`.",
        "default": {
          "type": "type",
          "value": 4
        }
      },
      {
        "name": "expand_animations",
        "type": "boolean",
        "description": "Controls the output shape of the returned op. If True, the returned op will\nproduce a 3-D tensor for PNG, JPEG, and BMP files; and a 4-D tensor for all\nGIFs, whether animated or not. If, False, the returned op will produce a 3-D\ntensor for all file types and will truncate animated GIFs to the first frame.",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "contents",
        "description": "0-D. The encoded image bytes.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "image",
        "description": "3-D with shape `[height, width, channels]` or 4-D with shape\n`[frame, height, width, channels]`..",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "DecodeJSONExample",
    "summary": "Convert JSON-encoded Example records to binary protocol buffer strings.",
    "description": "\nNote: This is **not** a general purpose JSON parsing op.\n\nThis op converts JSON-serialized\n`tf.train.Example` (created with `json_format.MessageToJson`, following the\n[standard JSON mapping](https://developers.google.com/protocol-buffers/docs/proto3#json))\nto a binary-serialized `tf.train.Example` (equivalent to\n`Example.SerializeToString()`) suitable for conversion to tensors with\n`tf.io.parse_example`.",
    "inputs": [
      {
        "name": "json_examples",
        "description": "Each string is a JSON object serialized according to the JSON\nmapping of the Example proto.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "binary_examples",
        "description": "Each string is a binary Example protocol buffer corresponding\nto the respective element of `json_examples`.",
        "type": 7
      }
    ]
  },
  {
    "name": "DecodeJpeg",
    "summary": "Decode a JPEG-encoded image to a uint8 tensor.",
    "description": "The attr `channels` indicates the desired number of color channels for the\ndecoded image.\n\nAccepted values are:\n\n*   0: Use the number of channels in the JPEG-encoded image.\n*   1: output a grayscale image.\n*   3: output an RGB image.\n\nIf needed, the JPEG-encoded image is transformed to match the requested number\nof color channels.\n\nThe attr `ratio` allows downscaling the image by an integer factor during\ndecoding.  Allowed values are: 1, 2, 4, and 8.  This is much faster than\ndownscaling the image later.\n\n\nThis op also supports decoding PNGs and non-animated GIFs since the interface is\nthe same, though it is cleaner to use `tf.io.decode_image`.",
    "attributes": [
      {
        "name": "channels",
        "type": "int64",
        "description": "Number of color channels for the decoded image.",
        "default": 0
      },
      {
        "name": "ratio",
        "type": "int64",
        "description": "Downscaling ratio.",
        "default": 1
      },
      {
        "name": "fancy_upscaling",
        "type": "boolean",
        "description": "If true use a slower but nicer upscaling of the\nchroma planes (yuv420/422 only).",
        "default": true
      },
      {
        "name": "try_recover_truncated",
        "type": "boolean",
        "description": "If true try to recover an image from truncated input.",
        "default": false
      },
      {
        "name": "acceptable_fraction",
        "type": "float32",
        "description": "The minimum required fraction of lines before a truncated\ninput is accepted.",
        "default": 1.0
      },
      {
        "name": "dct_method",
        "type": "string",
        "description": "string specifying a hint about the algorithm used for\ndecompression.  Defaults to \"\" which maps to a system-specific\ndefault.  Currently valid values are [\"INTEGER_FAST\",\n\"INTEGER_ACCURATE\"].  The hint may be ignored (e.g., the internal\njpeg library changes to a version that does not have that specific\noption.)",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "contents",
        "description": "0-D.  The JPEG-encoded image.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "image",
        "description": "3-D with shape `[height, width, channels]`..",
        "type": 4
      }
    ]
  },
  {
    "name": "DecodePaddedRaw",
    "summary": "Reinterpret the bytes of a string as a vector of numbers.",
    "attributes": [
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`, `float64`, `int32`, `uint16`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`."
      },
      {
        "name": "little_endian",
        "type": "boolean",
        "description": "Whether the input `input_bytes` is in little-endian order. Ignored for\n`out_type` values that are stored in a single byte, like `uint8`",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "input_bytes",
        "description": "Tensor of string to be decoded.",
        "type": 7
      },
      {
        "name": "fixed_length",
        "description": "Length in bytes for each element of the decoded output. Must be a multiple\nof the size of the output type.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A Tensor with one more dimension than the input `bytes`. The added dimension\nwill have size equal to the length of the elements of `bytes` divided by the\nnumber of bytes to represent `out_type`.",
        "typeAttr": "out_type"
      }
    ]
  },
  {
    "name": "DecodePng",
    "summary": "Decode a PNG-encoded image to a uint8 or uint16 tensor.",
    "description": "The attr `channels` indicates the desired number of color channels for the\ndecoded image.\n\nAccepted values are:\n\n*   0: Use the number of channels in the PNG-encoded image.\n*   1: output a grayscale image.\n*   3: output an RGB image.\n*   4: output an RGBA image.\n\nIf needed, the PNG-encoded image is transformed to match the requested number\nof color channels.\n\nThis op also supports decoding JPEGs and non-animated GIFs since the interface\nis the same, though it is cleaner to use `tf.io.decode_image`.",
    "attributes": [
      {
        "name": "channels",
        "type": "int64",
        "description": "Number of color channels for the decoded image.",
        "default": 0
      },
      {
        "name": "dtype",
        "type": "type",
        "description": "Must be one of the following: `uint8`, `uint16`.",
        "default": {
          "type": "type",
          "value": 4
        }
      }
    ],
    "inputs": [
      {
        "name": "contents",
        "description": "0-D.  The PNG-encoded image.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "image",
        "description": "3-D with shape `[height, width, channels]`.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "DecodeProtoV2",
    "summary": "The op extracts fields from a serialized protocol buffers message into tensors.",
    "description": "Note: This API is designed for orthogonality rather than human-friendliness. It\ncan be used to parse input protos by hand, but it is intended for use in\ngenerated code.\n\nThe `decode_proto` op extracts fields from a serialized protocol buffers\nmessage into tensors.  The fields in `field_names` are decoded and converted\nto the corresponding `output_types` if possible.\n\nA `message_type` name must be provided to give context for the field names.\nThe actual message descriptor can be looked up either in the linked-in\ndescriptor pool or a filename provided by the caller using the\n`descriptor_source` attribute.\n\nEach output tensor is a dense tensor. This means that it is padded to hold\nthe largest number of repeated elements seen in the input minibatch. (The\nshape is also padded by one to prevent zero-sized dimensions). The actual\nrepeat counts for each example in the minibatch can be found in the `sizes`\noutput. In many cases the output of `decode_proto` is fed immediately into\ntf.squeeze if missing values are not a concern. When using tf.squeeze, always\npass the squeeze dimension explicitly to avoid surprises.\n\nFor the most part, the mapping between Proto field types and TensorFlow dtypes\nis straightforward. However, there are a few special cases:\n\n- A proto field that contains a submessage or group can only be converted\nto `DT_STRING` (the serialized submessage). This is to reduce the complexity\nof the API. The resulting string can be used as input to another instance of\nthe decode_proto op.\n\n- TensorFlow lacks support for unsigned integers. The ops represent uint64\ntypes as a `DT_INT64` with the same twos-complement bit pattern (the obvious\nway). Unsigned int32 values can be represented exactly by specifying type\n`DT_INT64`, or using twos-complement if the caller specifies `DT_INT32` in\nthe `output_types` attribute.\n\n- `map` fields are not directly decoded. They are treated as `repeated` fields,\nof the appropriate entry type. The proto-compiler defines entry types for each\nmap field. The type-name is the field name, converted to \"CamelCase\" with\n\"Entry\" appended. The `tf.train.Features.FeatureEntry` message is an example of\none of these implicit `Entry` types.\n\n- `enum` fields should be read as int32.\n\nBoth binary and text proto serializations are supported, and can be\nchosen using the `format` attribute.\n\nThe `descriptor_source` attribute selects the source of protocol\ndescriptors to consult when looking up `message_type`. This may be:\n\n- An empty string  or \"local://\", in which case protocol descriptors are\ncreated for C++ (not Python) proto definitions linked to the binary.\n\n- A file, in which case protocol descriptors are created from the file,\nwhich is expected to contain a `FileDescriptorSet` serialized as a string.\nNOTE: You can build a `descriptor_source` file using the `--descriptor_set_out`\nand `--include_imports` options to the protocol compiler `protoc`.\n\n- A \"bytes://<bytes>\", in which protocol descriptors are created from `<bytes>`,\nwhich is expected to be a `FileDescriptorSet` serialized as a string.",
    "attributes": [
      {
        "name": "message_type",
        "type": "string",
        "description": "Name of the proto message type to decode."
      },
      {
        "name": "field_names",
        "type": "string[]",
        "description": "List of strings containing proto field names. An extension field can be decoded\nby using its full name, e.g. EXT_PACKAGE.EXT_FIELD_NAME."
      },
      {
        "name": "output_types",
        "type": "type[]",
        "description": "List of TF types to use for the respective field in field_names.",
        "minimum": 0
      },
      {
        "name": "descriptor_source",
        "type": "string",
        "description": "Either the special value `local://` or a path to a file containing\na serialized `FileDescriptorSet`.",
        "default": "local://"
      },
      {
        "name": "message_format",
        "type": "string",
        "description": "Either `binary` or `text`.",
        "default": "binary"
      },
      {
        "name": "sanitize",
        "type": "boolean",
        "description": "Whether to sanitize the result or not.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "bytes",
        "description": "Tensor of serialized protos with shape `batch_shape`.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "sizes",
        "description": "Tensor of int32 with shape `[batch_shape, len(field_names)]`.\nEach entry is the number of values found for the corresponding field.\nOptional fields may have 0 or 1 values.",
        "type": 3
      },
      {
        "name": "values",
        "description": "List of tensors containing values for the corresponding field.\n`values[i]` has datatype `output_types[i]`\nand shape `[batch_shape, max(sizes[...,i])]`.",
        "typeListAttr": "output_types"
      }
    ]
  },
  {
    "name": "DecodeRaw",
    "summary": "Reinterpret the bytes of a string as a vector of numbers.",
    "attributes": [
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`, `float64`, `int32`, `uint16`, `uint8`, `int16`, `int8`, `int64`, `complex64`, `complex128`, `bool`, `bfloat16`."
      },
      {
        "name": "little_endian",
        "type": "boolean",
        "description": "Whether the input `bytes` are in little-endian order.\nIgnored for `out_type` values that are stored in a single byte like\n`uint8`.",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "bytes",
        "description": "All the elements must have the same length.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A Tensor with one more dimension than the input `bytes`.  The\nadded dimension will have size equal to the length of the elements\nof `bytes` divided by the number of bytes to represent `out_type`.",
        "typeAttr": "out_type"
      }
    ]
  },
  {
    "name": "DecodeWav",
    "summary": "Decode a 16-bit PCM WAV file to a float tensor.",
    "description": "The -32768 to 32767 signed 16-bit values will be scaled to -1.0 to 1.0 in float.\n\nWhen desired_channels is set, if the input contains fewer channels than this\nthen the last channel will be duplicated to give the requested number, else if\nthe input has more channels than requested then the additional channels will be\nignored.\n\nIf desired_samples is set, then the audio will be cropped or padded with zeroes\nto the requested length.\n\nThe first output contains a Tensor with the content of the audio samples. The\nlowest dimension will be the number of channels, and the second will be the\nnumber of samples. For example, a ten-sample-long stereo WAV file should give an\noutput shape of [10, 2].",
    "attributes": [
      {
        "name": "desired_channels",
        "type": "int64",
        "description": "Number of sample channels wanted.",
        "default": -1
      },
      {
        "name": "desired_samples",
        "type": "int64",
        "description": "Length of audio requested.",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "contents",
        "description": "The WAV-encoded audio, usually from a file.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "audio",
        "description": "2-D with shape `[length, channels]`.",
        "type": 1
      },
      {
        "name": "sample_rate",
        "description": "Scalar holding the sample rate found in the WAV header.",
        "type": 3
      }
    ]
  },
  {
    "name": "DeepCopy",
    "summary": "Makes a copy of `x`.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "The source tensor of type `T`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "description": "    y: A `Tensor` of type `T`. A copy of `x`. Guaranteed that `y`\n      is not an alias of `x`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "DeleteIterator",
    "summary": "A container for an iterator resource.",
    "inputs": [
      {
        "name": "handle",
        "description": "A handle to the iterator to delete.",
        "type": 20
      },
      {
        "name": "deleter",
        "description": "A variant deleter.",
        "type": 21
      }
    ]
  },
  {
    "name": "DeleteMemoryCache",
    "inputs": [
      {
        "name": "handle",
        "type": 20
      },
      {
        "name": "deleter",
        "type": 21
      }
    ]
  },
  {
    "name": "DeleteMultiDeviceIterator",
    "summary": "A container for an iterator resource.",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "multi_device_iterator",
        "description": "A handle to the multi device iterator to delete.",
        "type": 20
      },
      {
        "name": "iterators",
        "description": "A list of iterator handles (unused). This is added so that automatic control dependencies get added during function tracing that ensure this op runs after all the dependent iterators are deleted.",
        "numberAttr": "N",
        "type": 20
      },
      {
        "name": "deleter",
        "description": "A variant deleter.",
        "type": 21
      }
    ]
  },
  {
    "name": "DeleteRandomSeedGenerator",
    "inputs": [
      {
        "name": "handle",
        "type": 20
      },
      {
        "name": "deleter",
        "type": 21
      }
    ]
  },
  {
    "name": "DeleteSeedGenerator",
    "inputs": [
      {
        "name": "handle",
        "type": 20
      },
      {
        "name": "deleter",
        "type": 21
      }
    ]
  },
  {
    "name": "DeleteSessionTensor",
    "summary": "Delete the tensor specified by its handle in the session.",
    "inputs": [
      {
        "name": "handle",
        "description": "The handle for a tensor stored in the session state.",
        "type": 7
      }
    ]
  },
  {
    "name": "DenseBincount",
    "summary": "Counts the number of occurrences of each value in an integer array.",
    "description": "Outputs a vector with length `size` and the same dtype as `weights`. If\n`weights` are empty, then index `i` stores the number of times the value `i` is\ncounted in `arr`. If `weights` are non-empty, then index `i` stores the sum of\nthe value in `weights` at each index where the corresponding value in `arr` is\n`i`.\n\nValues in `arr` outside of the range [0, size) are ignored.",
    "attributes": [
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`, `float32`, `float64`."
      },
      {
        "name": "binary_output",
        "type": "boolean",
        "description": "bool; Whether the kernel should count the appearance or number of occurrences.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "1D or 2D int `Tensor`.",
        "typeAttr": "Tidx"
      },
      {
        "name": "size",
        "description": "non-negative int scalar `Tensor`.",
        "typeAttr": "Tidx"
      },
      {
        "name": "weights",
        "description": "is an int32, int64, float32, or float64 `Tensor` with the same\nshape as `arr`, or a length-0 `Tensor`, in which case it acts as all weights\nequal to 1.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "1D `Tensor` with length equal to `size` or 2D `Tensor` with [batch_size, `size`].\nThe counts or summed weights for each value in the range [0, size).",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "DenseCountSparseOutput",
    "summary": "Performs sparse-output bin counting for a tf.tensor input.",
    "description": "  Counts the number of times each value occurs in the input.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Dtype of the input values tensor. Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "minlength",
        "type": "int64",
        "description": "Minimum value to count. Can be set to -1 for no minimum.",
        "minimum": -1,
        "default": -1
      },
      {
        "name": "maxlength",
        "type": "int64",
        "description": "Maximum value to count. Can be set to -1 for no maximum.",
        "minimum": -1,
        "default": -1
      },
      {
        "name": "binary_output",
        "type": "boolean",
        "description": "Whether to output the number of occurrences of each value or 1."
      },
      {
        "name": "output_type",
        "type": "type",
        "description": "Dtype of the output values tensor. Must be one of the following: `int32`, `int64`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "values",
        "description": "Tensor containing data to count.",
        "typeAttr": "T"
      },
      {
        "name": "weights",
        "description": "A Tensor of the same shape as indices containing per-index weight values. May\nalso be the empty tensor if no weights are used.",
        "typeAttr": "output_type"
      }
    ],
    "outputs": [
      {
        "name": "output_indices",
        "description": "Indices tensor for the resulting sparse tensor object.",
        "type": 9
      },
      {
        "name": "output_values",
        "description": "Values tensor for the resulting sparse tensor object.",
        "typeAttr": "output_type"
      },
      {
        "name": "output_dense_shape",
        "description": "Shape tensor for the resulting sparse tensor object.",
        "type": 9
      }
    ]
  },
  {
    "name": "DenseToCSRSparseMatrix",
    "summary": "Converts a dense tensor to a (possibly batched) CSRSparseMatrix.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "dense_input",
        "description": "A Dense tensor.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "Indices of nonzero elements.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "sparse_output",
        "description": "A (possibly batched) CSRSparseMatrix.",
        "type": 21
      }
    ]
  },
  {
    "name": "DenseToDenseSetOperation",
    "summary": "Applies set operation along last dimension of 2 `Tensor` inputs.",
    "description": "See SetOperationOp::SetOperationFromContext for values of `set_operation`.\n\nOutput `result` is a `SparseTensor` represented by `result_indices`,\n`result_values`, and `result_shape`. For `set1` and `set2` ranked `n`, this\nhas rank `n` and the same 1st `n-1` dimensions as `set1` and `set2`. The `nth`\ndimension contains the result of `set_operation` applied to the corresponding\n`[0...n-1]` dimension of `set`.",
    "attributes": [
      {
        "name": "set_operation",
        "type": "string"
      },
      {
        "name": "validate_indices",
        "type": "boolean",
        "default": true
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `string`."
      }
    ],
    "inputs": [
      {
        "name": "set1",
        "description": "`Tensor` with rank `n`. 1st `n-1` dimensions must be the same as `set2`.\nDimension `n` contains values in a set, duplicates are allowed but ignored.",
        "typeAttr": "T"
      },
      {
        "name": "set2",
        "description": "`Tensor` with rank `n`. 1st `n-1` dimensions must be the same as `set1`.\nDimension `n` contains values in a set, duplicates are allowed but ignored.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "result_indices",
        "description": "2D indices of a `SparseTensor`.",
        "type": 9
      },
      {
        "name": "result_values",
        "description": "1D values of a `SparseTensor`.",
        "typeAttr": "T"
      },
      {
        "name": "result_shape",
        "description": "1D `Tensor` shape of a `SparseTensor`. `result_shape[0...n-1]` is\nthe same as the 1st `n-1` dimensions of `set1` and `set2`, `result_shape[n]`\nis the max result set size across all `0...n-1` dimensions.",
        "type": 9
      }
    ]
  },
  {
    "name": "DenseToSparseBatchDataset",
    "summary": "Creates a dataset that batches input elements into a SparseTensor.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A handle to an input dataset. Must have a single component.",
        "type": 21
      },
      {
        "name": "batch_size",
        "description": "A scalar representing the number of elements to accumulate in a\nbatch.",
        "type": 9
      },
      {
        "name": "row_shape",
        "description": "A vector representing the dense shape of each row in the produced\nSparseTensor. The shape may be partially specified, using `-1` to indicate\nthat a particular dimension should use the maximum size of all batch elements.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "DenseToSparseSetOperation",
    "summary": "Applies set operation along last dimension of `Tensor` and `SparseTensor`.",
    "description": "See SetOperationOp::SetOperationFromContext for values of `set_operation`.\n\nInput `set2` is a `SparseTensor` represented by `set2_indices`, `set2_values`,\nand `set2_shape`. For `set2` ranked `n`, 1st `n-1` dimensions must be the same\nas `set1`. Dimension `n` contains values in a set, duplicates are allowed but\nignored.\n\nIf `validate_indices` is `True`, this op validates the order and range of `set2`\nindices.\n\nOutput `result` is a `SparseTensor` represented by `result_indices`,\n`result_values`, and `result_shape`. For `set1` and `set2` ranked `n`, this\nhas rank `n` and the same 1st `n-1` dimensions as `set1` and `set2`. The `nth`\ndimension contains the result of `set_operation` applied to the corresponding\n`[0...n-1]` dimension of `set`.",
    "attributes": [
      {
        "name": "set_operation",
        "type": "string"
      },
      {
        "name": "validate_indices",
        "type": "boolean",
        "default": true
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `string`."
      }
    ],
    "inputs": [
      {
        "name": "set1",
        "description": "`Tensor` with rank `n`. 1st `n-1` dimensions must be the same as `set2`.\nDimension `n` contains values in a set, duplicates are allowed but ignored.",
        "typeAttr": "T"
      },
      {
        "name": "set2_indices",
        "description": "2D `Tensor`, indices of a `SparseTensor`. Must be in row-major\norder.",
        "type": 9
      },
      {
        "name": "set2_values",
        "description": "1D `Tensor`, values of a `SparseTensor`. Must be in row-major\norder.",
        "typeAttr": "T"
      },
      {
        "name": "set2_shape",
        "description": "1D `Tensor`, shape of a `SparseTensor`. `set2_shape[0...n-1]` must\nbe the same as the 1st `n-1` dimensions of `set1`, `result_shape[n]` is the\nmax set size across `n-1` dimensions.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "result_indices",
        "description": "2D indices of a `SparseTensor`.",
        "type": 9
      },
      {
        "name": "result_values",
        "description": "1D values of a `SparseTensor`.",
        "typeAttr": "T"
      },
      {
        "name": "result_shape",
        "description": "1D `Tensor` shape of a `SparseTensor`. `result_shape[0...n-1]` is\nthe same as the 1st `n-1` dimensions of `set1` and `set2`, `result_shape[n]`\nis the max result set size across all `0...n-1` dimensions.",
        "type": 9
      }
    ]
  },
  {
    "name": "DepthToSpace",
    "summary": "DepthToSpace for tensors of type T.",
    "description": "Rearranges data from depth into blocks of spatial data.\nThis is the reverse transformation of SpaceToDepth. More specifically,\nthis op outputs a copy of the input tensor where values from the `depth`\ndimension are moved in spatial blocks to the `height` and `width` dimensions.\nThe attr `block_size` indicates the input block size and how the data is moved.\n\n  * Chunks of data of size `block_size * block_size` from depth are rearranged\n    into non-overlapping blocks of size `block_size x block_size`\n  * The width of the output tensor is `input_depth * block_size`, whereas the\n    height is `input_height * block_size`.\n  * The Y, X coordinates within each block of the output image are determined\n    by the high order component of the input channel index.\n  * The depth of the input tensor must be divisible by\n    `block_size * block_size`.\n\nThe `data_format` attr specifies the layout of the input and output tensors\nwith the following options:\n  \"NHWC\": `[ batch, height, width, channels ]`\n  \"NCHW\": `[ batch, channels, height, width ]`\n  \"NCHW_VECT_C\":\n      `qint8 [ batch, channels / 4, height, width, 4 ]`\n\nIt is useful to consider the operation as transforming a 6-D Tensor.\ne.g. for data_format = NHWC,\n     Each element in the input tensor can be specified via 6 coordinates,\n     ordered by decreasing memory layout significance as:\n     n,iY,iX,bY,bX,oC  (where n=batch index, iX, iY means X or Y coordinates\n                        within the input image, bX, bY means coordinates\n                        within the output block, oC means output channels).\n     The output would be the input transposed to the following layout:\n     n,iY,bY,iX,bX,oC\n\nThis operation is useful for resizing the activations between convolutions\n(but keeping all data), e.g. instead of pooling. It is also useful for training\npurely convolutional models.\n\nFor example, given an input of shape `[1, 1, 1, 4]`, data_format = \"NHWC\" and\nblock_size = 2:\n\n```\nx = [[[[1, 2, 3, 4]]]]\n\n```\n\nThis operation will output a tensor of shape `[1, 2, 2, 1]`:\n\n```\n   [[[[1], [2]],\n     [[3], [4]]]]\n```\n\nHere, the input has a batch of 1 and each batch element has shape `[1, 1, 4]`,\nthe corresponding output will have 2x2 elements and will have a depth of\n1 channel (1 = `4 / (block_size * block_size)`).\nThe output element shape is `[2, 2, 1]`.\n\nFor an input tensor with larger depth, here of shape `[1, 1, 1, 12]`, e.g.\n\n```\nx = [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]\n```\n\nThis operation, for block size of 2, will return the following tensor of shape\n`[1, 2, 2, 3]`\n\n```\n   [[[[1, 2, 3], [4, 5, 6]],\n     [[7, 8, 9], [10, 11, 12]]]]\n\n```\n\nSimilarly, for the following input of shape `[1 2 2 4]`, and a block size of 2:\n\n```\nx =  [[[[1, 2, 3, 4],\n       [5, 6, 7, 8]],\n      [[9, 10, 11, 12],\n       [13, 14, 15, 16]]]]\n```\n\nthe operator will return the following tensor of shape `[1 4 4 1]`:\n\n```\nx = [[[ [1],   [2],  [5],  [6]],\n      [ [3],   [4],  [7],  [8]],\n      [ [9],  [10], [13],  [14]],\n      [ [11], [12], [15],  [16]]]]\n\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "block_size",
        "type": "int64",
        "description": "The size of the spatial block, same as in Space2Depth.",
        "minimum": 2
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "Must be one of the following: `NHWC`, `NCHW`, `NCHW_VECT_C`.",
        "default": "NHWC"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "DepthwiseConv2dNative",
    "category": "Layer",
    "summary": "Computes a 2-D depthwise convolution given 4-D `input` and `filter` tensors.",
    "description": "Given an input tensor of shape `[batch, in_height, in_width, in_channels]`\nand a filter / kernel tensor of shape\n`[filter_height, filter_width, in_channels, channel_multiplier]`, containing\n`in_channels` convolutional filters of depth 1, `depthwise_conv2d` applies\na different filter to each input channel (expanding from 1 channel to\n`channel_multiplier` channels for each), then concatenates the results\ntogether. Thus, the output has `in_channels * channel_multiplier` channels.\n\n```\nfor k in 0..in_channels-1\n  for q in 0..channel_multiplier-1\n    output[b, i, j, k * channel_multiplier + q] =\n      sum_{di, dj} input[b, strides[1] * i + di, strides[2] * j + dj, k] *\n                        filter[di, dj, k, q]\n```\n\nMust have `strides[0] = strides[3] = 1`.  For the most common case of the same\nhorizontal and vertices strides, `strides = [1, stride, stride, 1]`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "1-D of length 4.  The stride of the sliding window for each dimension\nof `input`."
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`, `EXPLICIT`."
      },
      {
        "name": "explicit_paddings",
        "type": "int64[]",
        "default": []
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, height, width, channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, channels, height, width]. Must be one of the following: `NHWC`, `NCHW`.",
        "default": "NHWC"
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "description": "1-D tensor of length 4.  The dilation factor for each dimension of\n`input`. If set to k > 1, there will be k-1 skipped cells between each filter\nelement on that dimension. The dimension order is determined by the value of\n`data_format`, see above for details. Dilations in the batch and depth\ndimensions must be 1.",
        "default": [
          1,
          1,
          1,
          1
        ]
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "filter",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "DepthwiseConv2dNativeBackpropFilter",
    "summary": "Computes the gradients of depthwise convolution with respect to the filter.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "The stride of the sliding window for each dimension of the input\nof the convolution."
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`, `EXPLICIT`."
      },
      {
        "name": "explicit_paddings",
        "type": "int64[]",
        "default": []
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, height, width, channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, channels, height, width]. Must be one of the following: `NHWC`, `NCHW`.",
        "default": "NHWC"
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "description": "1-D tensor of length 4.  The dilation factor for each dimension of\n`input`. If set to k > 1, there will be k-1 skipped cells between each filter\nelement on that dimension. The dimension order is determined by the value of\n`data_format`, see above for details. Dilations in the batch and depth\ndimensions must be 1.",
        "default": [
          1,
          1,
          1,
          1
        ]
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "4-D with shape based on `data_format`.  For example, if\n`data_format` is 'NHWC' then `input` is a 4-D `[batch, in_height,\nin_width, in_channels]` tensor.",
        "typeAttr": "T"
      },
      {
        "name": "filter_sizes",
        "description": "An integer vector representing the tensor shape of `filter`,\nwhere `filter` is a 4-D\n`[filter_height, filter_width, in_channels, depthwise_multiplier]` tensor.",
        "type": 3
      },
      {
        "name": "out_backprop",
        "description": "4-D with shape  based on `data_format`.\nFor example, if `data_format` is 'NHWC' then\nout_backprop shape is `[batch, out_height, out_width, out_channels]`.\nGradients w.r.t. the output of the convolution.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "4-D with shape\n`[filter_height, filter_width, in_channels, out_channels]`.  Gradient w.r.t.\nthe `filter` input of the convolution.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "DepthwiseConv2dNativeBackpropInput",
    "summary": "Computes the gradients of depthwise convolution with respect to the input.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "The stride of the sliding window for each dimension of the input\nof the convolution."
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`, `EXPLICIT`."
      },
      {
        "name": "explicit_paddings",
        "type": "int64[]",
        "default": []
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, height, width, channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, channels, height, width]. Must be one of the following: `NHWC`, `NCHW`.",
        "default": "NHWC"
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "description": "1-D tensor of length 4.  The dilation factor for each dimension of\n`input`. If set to k > 1, there will be k-1 skipped cells between each filter\nelement on that dimension. The dimension order is determined by the value of\n`data_format`, see above for details. Dilations in the batch and depth\ndimensions must be 1.",
        "default": [
          1,
          1,
          1,
          1
        ]
      }
    ],
    "inputs": [
      {
        "name": "input_sizes",
        "description": "An integer vector representing the shape of `input`, based\non `data_format`.  For example, if `data_format` is 'NHWC' then\n `input` is a 4-D `[batch, height, width, channels]` tensor.",
        "type": 3
      },
      {
        "name": "filter",
        "description": "4-D with shape\n`[filter_height, filter_width, in_channels, depthwise_multiplier]`.",
        "typeAttr": "T"
      },
      {
        "name": "out_backprop",
        "description": "4-D with shape  based on `data_format`.\nFor example, if `data_format` is 'NHWC' then\nout_backprop shape is `[batch, out_height, out_width, out_channels]`.\nGradients w.r.t. the output of the convolution.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "4-D with shape according to `data_format`.  For example, if\n`data_format` is 'NHWC', output shape is `[batch, in_height,\nin_width, in_channels]`.  Gradient w.r.t. the input of the\nconvolution.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Dequantize",
    "category": "Quantization",
    "summary": "Dequantize the 'input' tensor into a float or bfloat16 Tensor.",
    "description": "[min_range, max_range] are scalar floats that specify the range for\nthe output. The 'mode' attribute controls exactly which calculations are\nused to convert the float values to their quantized equivalents.\n\nIn 'MIN_COMBINED' mode, each value of the tensor will undergo the following:\n\n```\nif T == qint8: in[i] += (range(T) + 1)/ 2.0\nout[i] = min_range + (in[i]* (max_range - min_range) / range(T))\n```\nhere `range(T) = numeric_limits<T>::max() - numeric_limits<T>::min()`\n\n*MIN_COMBINED Mode Example*\n\nIf the input comes from a QuantizedRelu6, the output type is\nquint8 (range of 0-255) but the possible range of QuantizedRelu6 is\n0-6.  The min_range and max_range values are therefore 0.0 and 6.0.\nDequantize on quint8 will take each value, cast to float, and multiply\nby 6 / 255.\nNote that if quantizedtype is qint8, the operation will additionally add\neach value by 128 prior to casting.\n\nIf the mode is 'MIN_FIRST', then this approach is used:\n\n```c++\nnum_discrete_values = 1 << (# of bits in T)\nrange_adjust = num_discrete_values / (num_discrete_values - 1)\nrange = (range_max - range_min) * range_adjust\nrange_scale = range / num_discrete_values\nconst double offset_input = static_cast<double>(input) - lowest_quantized;\nresult = range_min + ((input - numeric_limits<T>::min()) * range_scale)\n```\n\nIf the mode is `SCALED`, dequantization is performed by multiplying each\ninput value by a scaling_factor. (Thus an input of 0 always maps to 0.0).\n\nThe scaling_factor is determined from `min_range`, `max_range`, and\n`narrow_range` in a way that is compatible with `QuantizeAndDequantize{V2|V3}`\nand `QuantizeV2`, using the following algorithm:\n\n```c++\n\n  const int min_expected_T = std::numeric_limits<T>::min() +\n    (narrow_range ? 1 : 0);\n  const int max_expected_T = std::numeric_limits<T>::max();\n  const float max_expected_T = std::numeric_limits<float>::max();\n\n  const float scale_factor =\n    (std::numeric_limits<T>::min() == 0) ? (max_range / max_expected_T)\n                                         : std::max(min_range / min_expected_T,\n                                                    max_range / max_expected_T);\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "mode",
        "type": "string",
        "description": "Must be one of the following: `MIN_COMBINED`, `MIN_FIRST`, `SCALED`.",
        "default": "MIN_COMBINED"
      },
      {
        "name": "narrow_range",
        "type": "boolean",
        "default": false
      },
      {
        "name": "axis",
        "type": "int64",
        "default": -1
      },
      {
        "name": "dtype",
        "type": "type",
        "description": "Type of the output tensor. Currently Dequantize supports float and bfloat16.\nIf 'dtype' is 'bfloat16', it only supports 'MIN_COMBINED' mode. Must be one of the following: `bfloat16`, `float32`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "min_range",
        "description": "The minimum scalar value possibly produced for the input.",
        "type": 1
      },
      {
        "name": "max_range",
        "description": "The maximum scalar value possibly produced for the input.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "DeserializeIterator",
    "summary": "Converts the given variant tensor to an iterator and stores it in the given resource.",
    "inputs": [
      {
        "name": "resource_handle",
        "description": "A handle to an iterator resource.",
        "type": 20
      },
      {
        "name": "serialized",
        "description": "A variant tensor storing the state of the iterator contained in the\nresource.",
        "type": 21
      }
    ]
  },
  {
    "name": "DeserializeManySparse",
    "summary": "Deserialize and concatenate `SparseTensors` from a serialized minibatch.",
    "description": "The input `serialized_sparse` must be a string matrix of shape `[N x 3]` where\n`N` is the minibatch size and the rows correspond to packed outputs of\n`SerializeSparse`.  The ranks of the original `SparseTensor` objects\nmust all match.  When the final `SparseTensor` is created, it has rank one\nhigher than the ranks of the incoming `SparseTensor` objects\n(they have been concatenated along a new row dimension).\n\nThe output `SparseTensor` object's shape values for all dimensions but the\nfirst are the max across the input `SparseTensor` objects' shape values\nfor the corresponding dimensions.  Its first shape value is `N`, the minibatch\nsize.\n\nThe input `SparseTensor` objects' indices are assumed ordered in\nstandard lexicographic order.  If this is not the case, after this\nstep run `SparseReorder` to restore index ordering.\n\nFor example, if the serialized input is a `[2 x 3]` matrix representing two\noriginal `SparseTensor` objects:\n\n    index = [ 0]\n            [10]\n            [20]\n    values = [1, 2, 3]\n    shape = [50]\n\nand\n\n    index = [ 2]\n            [10]\n    values = [4, 5]\n    shape = [30]\n\nthen the final deserialized `SparseTensor` will be:\n\n    index = [0  0]\n            [0 10]\n            [0 20]\n            [1  2]\n            [1 10]\n    values = [1, 2, 3, 4, 5]\n    shape = [2 50]",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The `dtype` of the serialized `SparseTensor` objects."
      }
    ],
    "inputs": [
      {
        "name": "serialized_sparse",
        "description": "2-D, The `N` serialized `SparseTensor` objects.\nMust have 3 columns.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "sparse_indices",
        "type": 9
      },
      {
        "name": "sparse_values",
        "typeAttr": "dtype"
      },
      {
        "name": "sparse_shape",
        "type": 9
      }
    ]
  },
  {
    "name": "DeserializeSparse",
    "summary": "Deserialize `SparseTensor` objects.",
    "description": "The input `serialized_sparse` must have the shape `[?, ?, ..., ?, 3]` where\nthe last dimension stores serialized `SparseTensor` objects and the other N\ndimensions (N >= 0) correspond to a batch. The ranks of the original\n`SparseTensor` objects must all match. When the final `SparseTensor` is\ncreated, its rank is the rank of the incoming `SparseTensor` objects plus N;\nthe sparse tensors have been concatenated along new dimensions, one for each\nbatch.\n\nThe output `SparseTensor` object's shape values for the original dimensions\nare the max across the input `SparseTensor` objects' shape values for the\ncorresponding dimensions. The new dimensions match the size of the batch.\n\nThe input `SparseTensor` objects' indices are assumed ordered in\nstandard lexicographic order.  If this is not the case, after this\nstep run `SparseReorder` to restore index ordering.\n\nFor example, if the serialized input is a `[2 x 3]` matrix representing two\noriginal `SparseTensor` objects:\n\n    index = [ 0]\n            [10]\n            [20]\n    values = [1, 2, 3]\n    shape = [50]\n\nand\n\n    index = [ 2]\n            [10]\n    values = [4, 5]\n    shape = [30]\n\nthen the final deserialized `SparseTensor` will be:\n\n    index = [0  0]\n            [0 10]\n            [0 20]\n            [1  2]\n            [1 10]\n    values = [1, 2, 3, 4, 5]\n    shape = [2 50]",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The `dtype` of the serialized `SparseTensor` objects."
      },
      {
        "name": "Tserialized",
        "type": "type",
        "description": "Must be one of the following: `string`, `variant`.",
        "default": {
          "type": "type",
          "value": 7
        }
      }
    ],
    "inputs": [
      {
        "name": "serialized_sparse",
        "description": "The serialized `SparseTensor` objects. The last dimension\nmust have 3 columns.",
        "typeAttr": "Tserialized"
      }
    ],
    "outputs": [
      {
        "name": "sparse_indices",
        "type": 9
      },
      {
        "name": "sparse_values",
        "typeAttr": "dtype"
      },
      {
        "name": "sparse_shape",
        "type": 9
      }
    ]
  },
  {
    "name": "DestroyResourceOp",
    "summary": "Deletes the resource specified by the handle.",
    "description": "All subsequent operations using the resource will result in a NotFound\nerror status.",
    "attributes": [
      {
        "name": "ignore_lookup_error",
        "type": "boolean",
        "description": "whether to ignore the error when the resource\ndoesn't exist.",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "description": "handle to the resource to delete.",
        "type": 20
      }
    ]
  },
  {
    "name": "DestroyTemporaryVariable",
    "summary": "Destroys the temporary variable and returns its final value.",
    "description": "Sets output to the value of the Tensor pointed to by 'ref', then destroys\nthe temporary variable called 'var_name'.\nAll other uses of 'ref' *must* have executed before this op.\nThis is typically achieved by chaining the ref through each assign op, or by\nusing control dependencies.\n\nOutputs the final value of the tensor pointed to by 'ref'.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "var_name",
        "type": "string",
        "description": "Name of the temporary variable, usually the name of the matching\n'TemporaryVariable' op."
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "description": "A reference to the temporary variable tensor.",
        "typeAttr": "T",
        "isRef": true
      }
    ],
    "outputs": [
      {
        "name": "value",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "DeviceIndex",
    "summary": "Return the index of device the op runs.",
    "description": "Given a list of device names, this operation returns the index of the device\nthis op runs. The length of the list is returned in two cases:\n(1) Device does not exist in the given device list.\n(2) It is in XLA compilation.",
    "attributes": [
      {
        "name": "device_names",
        "type": "string[]"
      }
    ],
    "outputs": [
      {
        "name": "index",
        "type": 3
      }
    ]
  },
  {
    "name": "Diag",
    "summary": "Returns a diagonal tensor with a given diagonal values.",
    "description": "Given a `diagonal`, this operation returns a tensor with the `diagonal` and\neverything else padded with zeros. The diagonal is computed as follows:\n\nAssume `diagonal` has dimensions [D1,..., Dk], then the output is a tensor of\nrank 2k with dimensions [D1,..., Dk, D1,..., Dk] where:\n\n`output[i1,..., ik, i1,..., ik] = diagonal[i1, ..., ik]` and 0 everywhere else.\n\nFor example:\n\n```\n# 'diagonal' is [1, 2, 3, 4]\ntf.diag(diagonal) ==> [[1, 0, 0, 0]\n                       [0, 2, 0, 0]\n                       [0, 0, 3, 0]\n                       [0, 0, 0, 4]]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `int32`, `int64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "diagonal",
        "description": "Rank k tensor where k is at most 1.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "DiagPart",
    "summary": "Returns the diagonal part of the tensor.",
    "description": "This operation returns a tensor with the `diagonal` part\nof the `input`. The `diagonal` part is computed as follows:\n\nAssume `input` has dimensions `[D1,..., Dk, D1,..., Dk]`, then the output is a\ntensor of rank `k` with dimensions `[D1,..., Dk]` where:\n\n`diagonal[i1,..., ik] = input[i1, ..., ik, i1,..., ik]`.\n\nFor example:\n\n```\n# 'input' is [[1, 0, 0, 0]\n              [0, 2, 0, 0]\n              [0, 0, 3, 0]\n              [0, 0, 0, 4]]\n\ntf.diag_part(input) ==> [1, 2, 3, 4]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `int32`, `int64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Rank k tensor where k is even and not zero.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "diagonal",
        "description": "The extracted diagonal.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Digamma",
    "summary": "Computes Psi, the derivative of Lgamma (the log of the absolute value of",
    "description": "`Gamma(x)`), element-wise.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Dilation2D",
    "summary": "Computes the grayscale dilation of 4-D `input` and 3-D `filter` tensors.",
    "description": "The `input` tensor has shape `[batch, in_height, in_width, depth]` and the\n`filter` tensor has shape `[filter_height, filter_width, depth]`, i.e., each\ninput channel is processed independently of the others with its own structuring\nfunction. The `output` tensor has shape\n`[batch, out_height, out_width, depth]`. The spatial dimensions of the output\ntensor depend on the `padding` algorithm. We currently only support the default\n\"NHWC\" `data_format`.\n\nIn detail, the grayscale morphological 2-D dilation is the max-sum correlation\n(for consistency with `conv2d`, we use unmirrored filters):\n\n    output[b, y, x, c] =\n       max_{dy, dx} input[b,\n                          strides[1] * y + rates[1] * dy,\n                          strides[2] * x + rates[2] * dx,\n                          c] +\n                    filter[dy, dx, c]\n\nMax-pooling is a special case when the filter has size equal to the pooling\nkernel size and contains all zeros.\n\nNote on duality: The dilation of `input` by the `filter` is equal to the\nnegation of the erosion of `-input` by the reflected `filter`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "The stride of the sliding window for each dimension of the input\ntensor. Must be: `[1, stride_height, stride_width, 1]`.",
        "minimum": 4
      },
      {
        "name": "rates",
        "type": "int64[]",
        "description": "The input stride for atrous morphological dilation. Must be:\n`[1, rate_height, rate_width, 1]`.",
        "minimum": 4
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "4-D with shape `[batch, in_height, in_width, depth]`.",
        "typeAttr": "T"
      },
      {
        "name": "filter",
        "description": "3-D with shape `[filter_height, filter_width, depth]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "4-D with shape `[batch, out_height, out_width, depth]`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Dilation2DBackpropFilter",
    "summary": "Computes the gradient of morphological 2-D dilation with respect to the filter.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "1-D of length 4. The stride of the sliding window for each dimension of\nthe input tensor. Must be: `[1, stride_height, stride_width, 1]`.",
        "minimum": 4
      },
      {
        "name": "rates",
        "type": "int64[]",
        "description": "1-D of length 4. The input stride for atrous morphological dilation.\nMust be: `[1, rate_height, rate_width, 1]`.",
        "minimum": 4
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "4-D with shape `[batch, in_height, in_width, depth]`.",
        "typeAttr": "T"
      },
      {
        "name": "filter",
        "description": "3-D with shape `[filter_height, filter_width, depth]`.",
        "typeAttr": "T"
      },
      {
        "name": "out_backprop",
        "description": "4-D with shape `[batch, out_height, out_width, depth]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "filter_backprop",
        "description": "3-D with shape `[filter_height, filter_width, depth]`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Dilation2DBackpropInput",
    "summary": "Computes the gradient of morphological 2-D dilation with respect to the input.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "1-D of length 4. The stride of the sliding window for each dimension of\nthe input tensor. Must be: `[1, stride_height, stride_width, 1]`.",
        "minimum": 4
      },
      {
        "name": "rates",
        "type": "int64[]",
        "description": "1-D of length 4. The input stride for atrous morphological dilation.\nMust be: `[1, rate_height, rate_width, 1]`.",
        "minimum": 4
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "4-D with shape `[batch, in_height, in_width, depth]`.",
        "typeAttr": "T"
      },
      {
        "name": "filter",
        "description": "3-D with shape `[filter_height, filter_width, depth]`.",
        "typeAttr": "T"
      },
      {
        "name": "out_backprop",
        "description": "4-D with shape `[batch, out_height, out_width, depth]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "in_backprop",
        "description": "4-D with shape `[batch, in_height, in_width, depth]`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "DirectedInterleaveDataset",
    "summary": "A substitute for `InterleaveDataset` on a fixed list of `N` datasets.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "stop_on_empty_dataset",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "selector_input_dataset",
        "description": "A dataset of scalar `DT_INT64` elements that determines which of the\n`N` data inputs should produce the next output element.",
        "type": 21
      },
      {
        "name": "data_input_datasets",
        "description": "`N` datasets with the same type that will be interleaved according to\nthe values of `selector_input_dataset`.",
        "numberAttr": "N",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "DisableCopyOnRead",
    "summary": "Turns off the copy-on-read mode.",
    "description": "Turns off the copy-on-read mode of a resource variable. If the variable is not in copy-on-read mode, this op has no effect.  ",
    "inputs": [
      {
        "name": "resource",
        "description": "The resource handle of the resource variable.",
        "type": 20
      }
    ]
  },
  {
    "name": "DistributedSave",
    "attributes": [
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "dataset",
        "type": 21
      },
      {
        "name": "directory",
        "type": 7
      },
      {
        "name": "address",
        "type": 7
      }
    ]
  },
  {
    "name": "Div",
    "summary": "Returns x / y element-wise.",
    "description": "*NOTE*: `Div` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `uint8`, `int8`, `uint16`, `int16`, `int32`, `uint32`, `uint64`, `int64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "DivNoNan",
    "summary": "Returns 0 if the denominator is zero.",
    "description": "\n*NOTE*: `DivNoNan` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`, `bfloat16`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "DrawBoundingBoxes",
    "summary": "Draw bounding boxes on a batch of images.",
    "description": "Outputs a copy of `images` but draws on top of the pixels zero or more bounding\nboxes specified by the locations in `boxes`. The coordinates of the each\nbounding box in `boxes` are encoded as `[y_min, x_min, y_max, x_max]`. The\nbounding box coordinates are floats in `[0.0, 1.0]` relative to the width and\nheight of the underlying image.\n\nFor example, if an image is 100 x 200 pixels (height x width) and the bounding\nbox is `[0.1, 0.2, 0.5, 0.9]`, the upper-left and bottom-right coordinates of\nthe bounding box will be `(40, 10)` to `(180, 50)` (in (x,y) coordinates).\n\nParts of the bounding box may fall outside the image.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float16`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "images",
        "description": "4-D with shape `[batch, height, width, depth]`. A batch of images.",
        "typeAttr": "T"
      },
      {
        "name": "boxes",
        "description": "3-D with shape `[batch, num_bounding_boxes, 4]` containing bounding\nboxes.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "4-D with the same shape as `images`. The batch of input images with\nbounding boxes drawn on the images.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "DrawBoundingBoxesV2",
    "summary": "Draw bounding boxes on a batch of images.",
    "description": "Outputs a copy of `images` but draws on top of the pixels zero or more bounding\nboxes specified by the locations in `boxes`. The coordinates of the each\nbounding box in `boxes` are encoded as `[y_min, x_min, y_max, x_max]`. The\nbounding box coordinates are floats in `[0.0, 1.0]` relative to the width and\nheight of the underlying image.\n\nFor example, if an image is 100 x 200 pixels (height x width) and the bounding\nbox is `[0.1, 0.2, 0.5, 0.9]`, the upper-left and bottom-right coordinates of\nthe bounding box will be `(40, 10)` to `(100, 50)` (in (x,y) coordinates).\n\nParts of the bounding box may fall outside the image.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float16`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "images",
        "description": "4-D with shape `[batch, height, width, depth]`. A batch of images.",
        "typeAttr": "T"
      },
      {
        "name": "boxes",
        "description": "3-D with shape `[batch, num_bounding_boxes, 4]` containing bounding\nboxes.",
        "type": 1
      },
      {
        "name": "colors",
        "description": "2-D. A list of RGBA colors to cycle through for the boxes.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "4-D with the same shape as `images`. The batch of input images with\nbounding boxes drawn on the images.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "DummyIterationCounter",
    "outputs": [
      {
        "name": "handle",
        "type": 20
      }
    ]
  },
  {
    "name": "DummyMemoryCache",
    "outputs": [
      {
        "name": "handle",
        "type": 20
      }
    ]
  },
  {
    "name": "DummySeedGenerator",
    "outputs": [
      {
        "name": "handle",
        "type": 20
      }
    ]
  },
  {
    "name": "DynamicEnqueueTPUEmbeddingArbitraryTensorBatch",
    "summary": "Eases the porting of code that uses tf.nn.embedding_lookup_sparse().",
    "description": "embedding_indices[i] and aggregation_weights[i] correspond\nto the ith feature.\n\nThe tensors at corresponding positions in the three input lists (sample_indices,\nembedding_indices and aggregation_weights) must have the same shape, i.e. rank 1\nwith dim_size() equal to the total number of lookups into the table described by\nthe corresponding feature.",
    "attributes": [
      {
        "name": "T1",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "T2",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "T3",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "combiners",
        "type": "string[]",
        "description": "A list of string scalars, one for each embedding table that specify\nhow to normalize the embedding activations after weighted summation.\nSupported combiners are 'mean', 'sum', or 'sqrtn'. It is invalid to have\nthe sum of the weights be 0 for 'mean' or the sum of the squared weights be\n0 for 'sqrtn'. If combiners isn't passed, the default is to use 'sum' for\nall tables.",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "sample_indices_or_row_splits",
        "description": "A list of rank 2 Tensors specifying the training example to which the\ncorresponding embedding_indices and aggregation_weights values belong.\nIf the size of its first dimension is 0, we assume each embedding_indices\nbelongs to a different sample. Both int32 and int64 are allowed and will\nbe converted to int32 internally.\n\nOr a list of rank 1 Tensors specifying the row splits for splitting\nembedding_indices and aggregation_weights into rows. It corresponds to\nids.row_splits in embedding_lookup(), when ids is a RaggedTensor. When\nenqueuing N-D ragged tensor, only the last dimension is allowed to be ragged.\nthe row splits is 1-D dense tensor. When empty, we assume a dense tensor is\npassed to the op Both int32 and int64 are allowed and will be converted to\nint32 internally.",
        "numberAttr": "N",
        "typeAttr": "T1"
      },
      {
        "name": "embedding_indices",
        "description": "A list of rank 1 Tensors, indices into the embedding\ntables. Both int32 and int64 are allowed and will be converted to\nint32 internally.",
        "numberAttr": "N",
        "typeAttr": "T2"
      },
      {
        "name": "aggregation_weights",
        "description": "A list of rank 1 Tensors containing per training\nexample aggregation weights. Both float32 and float64 are allowed and will\nbe converted to float32 internally.",
        "numberAttr": "N",
        "typeAttr": "T3"
      },
      {
        "name": "mode_override",
        "description": "A string input that overrides the mode specified in the\nTPUEmbeddingConfiguration. Supported values are {'unspecified', 'inference',\n'training', 'backward_pass_only'}. When set to 'unspecified', the mode set\nin TPUEmbeddingConfiguration is used, otherwise mode_override is used.",
        "type": 7
      },
      {
        "name": "device_ordinal",
        "description": "The TPU device to use. Should be >= 0 and less than the number\nof TPU cores in the task on which the node is placed.",
        "type": 3
      }
    ]
  },
  {
    "name": "DynamicEnqueueTPUEmbeddingRaggedTensorBatch",
    "attributes": [
      {
        "name": "T1",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "T2",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "T3",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "combiners",
        "type": "string[]",
        "default": []
      },
      {
        "name": "table_ids",
        "type": "int64[]"
      },
      {
        "name": "max_sequence_lengths",
        "type": "int64[]",
        "default": []
      },
      {
        "name": "num_features",
        "type": "int64[]",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "sample_splits",
        "numberAttr": "N",
        "typeAttr": "T1"
      },
      {
        "name": "embedding_indices",
        "numberAttr": "N",
        "typeAttr": "T2"
      },
      {
        "name": "aggregation_weights",
        "numberAttr": "N",
        "typeAttr": "T3"
      },
      {
        "name": "mode_override",
        "type": 7
      },
      {
        "name": "device_ordinal",
        "type": 3
      }
    ]
  },
  {
    "name": "DynamicPartition",
    "summary": "Partitions `data` into `num_partitions` tensors using indices from `partitions`.",
    "description": "For each index tuple `js` of size `partitions.ndim`, the slice `data[js, ...]`\nbecomes part of `outputs[partitions[js]]`.  The slices with `partitions[js] = i`\nare placed in `outputs[i]` in lexicographic order of `js`, and the first\ndimension of `outputs[i]` is the number of entries in `partitions` equal to `i`.\nIn detail,\n\n```python\n    outputs[i].shape = [sum(partitions == i)] + data.shape[partitions.ndim:]\n\n    outputs[i] = pack([data[js, ...] for js if partitions[js] == i])\n```\n\n`data.shape` must start with `partitions.shape`.\n\nFor example:\n\n```python\n    # Scalar partitions.\n    partitions = 1\n    num_partitions = 2\n    data = [10, 20]\n    outputs[0] = []  # Empty with shape [0, 2]\n    outputs[1] = [[10, 20]]\n\n    # Vector partitions.\n    partitions = [0, 0, 1, 1, 0]\n    num_partitions = 2\n    data = [10, 20, 30, 40, 50]\n    outputs[0] = [10, 20, 50]\n    outputs[1] = [30, 40]\n```\n\nSee `dynamic_stitch` for an example on how to merge partitions back.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/DynamicPartition.png\" alt>\n</div>\n\n\nRaises:\n  * `InvalidArgumentError` in following cases:\n    - If partitions is not in range `[0, num_partiions)`\n    - If `partitions.shape` does not match prefix of `data.shape` argument.\n",
    "attributes": [
      {
        "name": "num_partitions",
        "type": "int64",
        "description": "The number of partitions to output.",
        "minimum": 1
      },
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "data",
        "typeAttr": "T"
      },
      {
        "name": "partitions",
        "description": "Any shape.  Indices in the range `[0, num_partitions)`.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "outputs",
        "numberAttr": "num_partitions",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "DynamicStitch",
    "summary": "Interleave the values from the `data` tensors into a single tensor.",
    "description": "Builds a merged tensor such that\n\n```python\n    merged[indices[m][i, ..., j], ...] = data[m][i, ..., j, ...]\n```\n\nFor example, if each `indices[m]` is scalar or vector, we have\n\n```python\n    # Scalar indices:\n    merged[indices[m], ...] = data[m][...]\n\n    # Vector indices:\n    merged[indices[m][i], ...] = data[m][i, ...]\n```\n\nEach `data[i].shape` must start with the corresponding `indices[i].shape`,\nand the rest of `data[i].shape` must be constant w.r.t. `i`.  That is, we\nmust have `data[i].shape = indices[i].shape + constant`.  In terms of this\n`constant`, the output shape is\n\n    merged.shape = [max(indices) + 1] + constant\n\nValues are merged in order, so if an index appears in both `indices[m][i]` and\n`indices[n][j]` for `(m,i) < (n,j)` the slice `data[n][j]` will appear in the\nmerged result. If you do not need this guarantee, ParallelDynamicStitch might\nperform better on some devices.\n\nFor example:\n\n```python\n    indices[0] = 6\n    indices[1] = [4, 1]\n    indices[2] = [[5, 2], [0, 3]]\n    data[0] = [61, 62]\n    data[1] = [[41, 42], [11, 12]]\n    data[2] = [[[51, 52], [21, 22]], [[1, 2], [31, 32]]]\n    merged = [[1, 2], [11, 12], [21, 22], [31, 32], [41, 42],\n              [51, 52], [61, 62]]\n```\n\nThis method can be used to merge partitions created by `dynamic_partition`\nas illustrated on the following example:\n\n```python\n    # Apply function (increments x_i) on elements for which a certain condition\n    # apply (x_i != -1 in this example).\n    x=tf.constant([0.1, -1., 5.2, 4.3, -1., 7.4])\n    condition_mask=tf.not_equal(x,tf.constant(-1.))\n    partitioned_data = tf.dynamic_partition(\n        x, tf.cast(condition_mask, tf.int32) , 2)\n    partitioned_data[1] = partitioned_data[1] + 1.0\n    condition_indices = tf.dynamic_partition(\n        tf.range(tf.shape(x)[0]), tf.cast(condition_mask, tf.int32) , 2)\n    x = tf.dynamic_stitch(condition_indices, partitioned_data)\n    # Here x=[1.1, -1., 6.2, 5.3, -1, 8.4], the -1. values remain\n    # unchanged.\n```\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/DynamicStitch.png\" alt>\n</div>",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "indices",
        "numberAttr": "N",
        "type": 3
      },
      {
        "name": "data",
        "numberAttr": "N",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "merged",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "EagerPyFunc",
    "summary": "Eagerly executes a python function to compute func(input)->output. The",
    "description": "semantics of the input, output, and attributes are the same as those for\nPyFunc.",
    "attributes": [
      {
        "name": "token",
        "type": "string"
      },
      {
        "name": "is_async",
        "type": "boolean",
        "default": false
      },
      {
        "name": "Tin",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "Tout",
        "type": "type[]",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeListAttr": "Tin"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeListAttr": "Tout"
      }
    ]
  },
  {
    "name": "EditDistance",
    "summary": "Computes the (possibly normalized) Levenshtein Edit Distance.",
    "description": "The inputs are variable-length sequences provided by SparseTensors\n  (hypothesis_indices, hypothesis_values, hypothesis_shape)\nand\n  (truth_indices, truth_values, truth_shape).\n\nThe inputs are:",
    "attributes": [
      {
        "name": "normalize",
        "type": "boolean",
        "description": "boolean (if true, edit distances are normalized by length of truth).\n\nThe output is:",
        "default": true
      },
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "hypothesis_indices",
        "description": "The indices of the hypothesis list SparseTensor.\nThis is an N x R int64 matrix.",
        "type": 9
      },
      {
        "name": "hypothesis_values",
        "description": "The values of the hypothesis list SparseTensor.\nThis is an N-length vector.",
        "typeAttr": "T"
      },
      {
        "name": "hypothesis_shape",
        "description": "The shape of the hypothesis list SparseTensor.\nThis is an R-length vector.",
        "type": 9
      },
      {
        "name": "truth_indices",
        "description": "The indices of the truth list SparseTensor.\nThis is an M x R int64 matrix.",
        "type": 9
      },
      {
        "name": "truth_values",
        "description": "The values of the truth list SparseTensor.\nThis is an M-length vector.",
        "typeAttr": "T"
      },
      {
        "name": "truth_shape",
        "description": "truth indices, vector.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A dense float tensor with rank R - 1.\n\nFor the example input:\n\n    // hypothesis represents a 2x1 matrix with variable-length values:\n    //   (0,0) = [\"a\"]\n    //   (1,0) = [\"b\"]\n    hypothesis_indices = [[0, 0, 0],\n                          [1, 0, 0]]\n    hypothesis_values = [\"a\", \"b\"]\n    hypothesis_shape = [2, 1, 1]\n\n    // truth represents a 2x2 matrix with variable-length values:\n    //   (0,0) = []\n    //   (0,1) = [\"a\"]\n    //   (1,0) = [\"b\", \"c\"]\n    //   (1,1) = [\"a\"]\n    truth_indices = [[0, 1, 0],\n                     [1, 0, 0],\n                     [1, 0, 1],\n                     [1, 1, 0]]\n    truth_values = [\"a\", \"b\", \"c\", \"a\"]\n    truth_shape = [2, 2, 2]\n    normalize = true\n\nThe output will be:\n\n    // output is a 2x2 matrix with edit distances normalized by truth lengths.\n    output = [[inf, 1.0],  // (0,0): no truth, (0,1): no hypothesis\n              [0.5, 1.0]]  // (1,0): addition, (1,1): no hypothesis",
        "type": 1
      }
    ]
  },
  {
    "name": "Eig",
    "summary": "Computes the eigen decomposition of one or more square matrices.",
    "description": "Computes the eigenvalues and (optionally) right eigenvectors of each inner matrix in\n`input` such that `input[..., :, :] = v[..., :, :] * diag(e[..., :])`. The eigenvalues\nare sorted in non-decreasing order.\n\n```python\n# a is a tensor.\n# e is a tensor of eigenvalues.\n# v is a tensor of eigenvectors.\ne, v = eig(a)\ne = eig(a, compute_v=False)\n```",
    "attributes": [
      {
        "name": "compute_v",
        "type": "boolean",
        "description": "If `True` then eigenvectors will be computed and returned in `v`.\nOtherwise, only the eigenvalues will be computed.",
        "default": true
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `complex64`, `complex128`."
      },
      {
        "name": "Tout",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "`Tensor` input of shape `[N, N]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "e",
        "description": "Eigenvalues. Shape is `[N]`.",
        "typeAttr": "Tout"
      },
      {
        "name": "v",
        "description": "Eigenvectors. Shape is `[N, N]`.",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "Einsum",
    "summary": "Tensor contraction according to Einstein summation convention.",
    "description": "Implements generalized Tensor contraction and reduction. Each input Tensor must\nhave a corresponding input subscript appearing in the comma-separated left-hand\nside of the equation. The right-hand side of the equation consists of the\noutput subscript. The input subscripts and the output subscript should consist\nof zero or more named axis labels and at most one ellipsis (`...`).\n\nThe named axis labels may be any single character other than those having\nspecial meaning, namely `,.->`. The behavior of this Op is undefined if it\nreceives an ill-formatted equation; since the validation is done at\ngraph-building time, we omit format validation checks at runtime.\n\nNote: This Op is *not* intended to be called by the user; instead users should\ncall `tf.einsum` directly. It is a hidden Op used by `tf.einsum`.\n\nOperations are applied to the input(s) according to the following rules:\n\n (a) Generalized Diagonals: For input dimensions corresponding to axis labels\n     appearing more than once in the same input subscript, we take the\n     generalized (`k`-dimensional) diagonal.\n     For example, in the equation `iii->i` with input shape `[3, 3, 3]`, the\n     generalized diagonal would consist of `3` elements at indices `(0, 0, 0)`,\n     `(1, 1, 1)` and `(2, 2, 2)` to create a Tensor of shape `[3]`.\n\n (b) Reduction: Axes corresponding to labels appearing only in one input\n     subscript but not in the output subscript are summed over prior to Tensor\n     contraction.\n     For example, in the equation `ab,bc->b`, the axis labels `a` and `c` are\n     the reduction axis labels.\n\n (c) Batch Dimensions: Axes corresponding to labels appearing in each of the\n     input subscripts and also in the output subscript make up the batch\n     dimensions in Tensor contraction. Unnamed axis labels corresponding to\n     ellipsis (`...`) also correspond to batch dimensions.\n     For example, for the equation denoting batch matrix multiplication,\n     `bij,bjk->bik`, the axis label `b` corresponds to a batch dimension.\n\n (d) Contraction: In case of binary einsum, axes corresponding to labels\n     appearing in two different inputs (and not in the output) are contracted\n     against each other.\n     Considering the batch matrix multiplication equation again\n     (`bij,bjk->bik`), the contracted axis label is `j`.\n\n (e) Expand Diagonal: If the output subscripts contain repeated (explicit) axis\n     labels, the opposite operation of (a) is applied. For example, in the\n     equation `i->iii`, and input shape `[3]`, the output of shape `[3, 3, 3]`\n     are all zeros, except for the (generalized) diagonal which is populated\n     with values from the input.\n     Note: This operation is not supported by `np.einsum` or `tf.einsum`; it is\n     provided to enable computing the symbolic gradient of `tf.einsum`.\n\nThe output subscripts must contain only labels appearing in at least one of the\ninput subscripts. Furthermore, all dimensions mapping to the same axis label\nmust be equal.\n\nAny of the input and output subscripts may contain at most a single ellipsis\n(`...`). These ellipsis are mapped against dimensions not corresponding to any\nnamed axis label. If two inputs contain ellipsis, then they are broadcasted\naccording to standard NumPy broadcasting\n[rules](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html).\n\nThe broadcasted dimensions are placed in the corresponding location of the\nellipsis in the output subscript. If the broadcasted dimensions are non-empty\nand the output subscripts do not contain ellipsis, then an InvalidArgument error\nis raised.\n\n@compatibility(numpy)\nSimilar to [`numpy.einsum`](https://docs.scipy.org/doc/numpy/reference/generated/numpy.einsum.html).\n\nComparison with `numpy.einsum`:\n\n * This Op only supports unary and binary forms of `numpy.einsum`.\n * This Op does not support implicit form. (i.e. equations without `->`).\n * This Op also supports repeated indices in the output subscript, which is not\n   supported by `numpy.einsum`.\n@end_compatibility\n",
    "attributes": [
      {
        "name": "equation",
        "type": "string",
        "description": "String describing the Einstein Summation operation; in the format of np.einsum."
      },
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "description": "List of 1 or 2 Tensors.",
        "numberAttr": "N",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Output Tensor with shape depending upon `equation`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Elu",
    "category": "Activation",
    "summary": "Computes the exponential linear function.",
    "description": "The ELU function is defined as:\n\n * $ e ^ x - 1 $ if $ x < 0 $\n * $ x $ if $ x >= 0 $\n\nExamples:\n\n>>> tf.nn.elu(1.0)\n<tf.Tensor: shape=(), dtype=float32, numpy=1.0>\n>>> tf.nn.elu(0.0)\n<tf.Tensor: shape=(), dtype=float32, numpy=0.0>\n>>> tf.nn.elu(-1000.0)\n<tf.Tensor: shape=(), dtype=float32, numpy=-1.0>\n\nSee [Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs)\n](http://arxiv.org/abs/1511.07289)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "features",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "activations",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "EluGrad",
    "summary": "Computes gradients for the exponential linear (Elu) operation.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "gradients",
        "description": "The backpropagated gradients to the corresponding Elu operation.",
        "typeAttr": "T"
      },
      {
        "name": "outputs",
        "description": "The outputs of the corresponding Elu operation.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "backprops",
        "description": "The gradients: `gradients * (outputs + 1)` if outputs < 0,\n`gradients` otherwise.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Empty",
    "summary": "Creates a tensor with the given shape.\n\nThis operation creates a tensor of `shape` and `dtype`.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type"
      },
      {
        "name": "init",
        "type": "boolean",
        "description": "If True, initialize the returned tensor with the default value of dtype.  Otherwise, the implementation is free not to initializethe tensor's content.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "1-D. Represents the shape of the output tensor.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A `Tensor` of type `T`.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "EmptyTensorList",
    "summary": "Creates and returns an empty tensor list.",
    "description": "All list elements must be tensors of dtype element_dtype and shape compatible\nwith element_shape.\n\nhandle: an empty tensor list.\nelement_dtype: the type of elements in the list.\nelement_shape: a shape compatible with that of elements in the list.",
    "attributes": [
      {
        "name": "element_dtype",
        "type": "type"
      },
      {
        "name": "shape_type",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "element_shape",
        "typeAttr": "shape_type"
      },
      {
        "name": "max_num_elements",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "EmptyTensorMap",
    "summary": "Creates and returns an empty tensor map.",
    "description": "handle: an empty tensor map",
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "EncodeBase64",
    "summary": "Encode strings into web-safe base64 format.",
    "description": "Refer to [this article](https://en.wikipedia.org/wiki/Base64) for more information on\nbase64 format. Base64 strings may have padding with '=' at the\nend so that the encoded has length multiple of 4. See Padding section of the\nlink above.\n\nWeb-safe means that the encoder uses - and _ instead of + and /.",
    "attributes": [
      {
        "name": "pad",
        "type": "boolean",
        "description": "Bool whether padding is applied at the ends.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Strings to be encoded.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Input strings encoded in base64.",
        "type": 7
      }
    ]
  },
  {
    "name": "EncodeJpeg",
    "summary": "JPEG-encode an image.",
    "description": "`image` is a 3-D uint8 Tensor of shape `[height, width, channels]`.\n\nThe attr `format` can be used to override the color format of the encoded\noutput.  Values can be:\n\n*   `''`: Use a default format based on the number of channels in the image.\n*   `grayscale`: Output a grayscale JPEG image.  The `channels` dimension\n    of `image` must be 1.\n*   `rgb`: Output an RGB JPEG image. The `channels` dimension\n    of `image` must be 3.\n\nIf `format` is not specified or is the empty string, a default format is picked\nin function of the number of channels in `image`:\n\n*   1: Output a grayscale image.\n*   3: Output an RGB image.",
    "attributes": [
      {
        "name": "format",
        "type": "string",
        "description": "Per pixel image format. Must be one of the following: ``, `grayscale`, `rgb`.",
        "default": ""
      },
      {
        "name": "quality",
        "type": "int64",
        "description": "Quality of the compression from 0 to 100 (higher is better and slower).",
        "default": 95
      },
      {
        "name": "progressive",
        "type": "boolean",
        "description": "If True, create a JPEG that loads progressively (coarse to fine).",
        "default": false
      },
      {
        "name": "optimize_size",
        "type": "boolean",
        "description": "If True, spend CPU/RAM to reduce size with no quality change.",
        "default": false
      },
      {
        "name": "chroma_downsampling",
        "type": "boolean",
        "description": "See http://en.wikipedia.org/wiki/Chroma_subsampling.",
        "default": true
      },
      {
        "name": "density_unit",
        "type": "string",
        "description": "Unit used to specify `x_density` and `y_density`:\npixels per inch (`'in'`) or centimeter (`'cm'`). Must be one of the following: `in`, `cm`.",
        "default": "in"
      },
      {
        "name": "x_density",
        "type": "int64",
        "description": "Horizontal pixels per density unit.",
        "default": 300
      },
      {
        "name": "y_density",
        "type": "int64",
        "description": "Vertical pixels per density unit.",
        "default": 300
      },
      {
        "name": "xmp_metadata",
        "type": "string",
        "description": "If not empty, embed this XMP metadata in the image header.",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "image",
        "description": "3-D with shape `[height, width, channels]`.",
        "type": 4
      }
    ],
    "outputs": [
      {
        "name": "contents",
        "description": "0-D. JPEG-encoded image.",
        "type": 7
      }
    ]
  },
  {
    "name": "EncodeJpegVariableQuality",
    "summary": "JPEG encode input image with provided compression quality.",
    "description": "`image` is a 3-D uint8 Tensor of shape `[height, width, channels]`.\n`quality` is an int32 jpeg compression quality value between 0 and 100.\n",
    "inputs": [
      {
        "name": "images",
        "description": "Images to adjust.  At least 3-D.",
        "type": 4
      },
      {
        "name": "quality",
        "description": "An int quality to encode to.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "contents",
        "description": "0-D. JPEG-encoded image.",
        "type": 7
      }
    ]
  },
  {
    "name": "EncodePng",
    "summary": "PNG-encode an image.",
    "description": "`image` is a 3-D uint8 or uint16 Tensor of shape `[height, width, channels]`\nwhere `channels` is:\n\n*   1: for grayscale.\n*   2: for grayscale + alpha.\n*   3: for RGB.\n*   4: for RGBA.\n\nThe ZLIB compression level, `compression`, can be -1 for the PNG-encoder\ndefault or a value from 0 to 9.  9 is the highest compression level, generating\nthe smallest output, but is slower.",
    "attributes": [
      {
        "name": "compression",
        "type": "int64",
        "description": "Compression level.",
        "default": -1
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `uint8`, `uint16`.",
        "default": {
          "type": "type",
          "value": 4
        }
      }
    ],
    "inputs": [
      {
        "name": "image",
        "description": "3-D with shape `[height, width, channels]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "contents",
        "description": "0-D. PNG-encoded image.",
        "type": 7
      }
    ]
  },
  {
    "name": "EncodeProto",
    "summary": "The op serializes protobuf messages provided in the input tensors.",
    "description": "The types of the tensors in `values` must match the schema for the fields\nspecified in `field_names`. All the tensors in `values` must have a common\nshape prefix, *batch_shape*.\n\nThe `sizes` tensor specifies repeat counts for each field.  The repeat count\n(last dimension) of a each tensor in `values` must be greater than or equal\nto corresponding repeat count in `sizes`.\n\nA `message_type` name must be provided to give context for the field names.\nThe actual message descriptor can be looked up either in the linked-in\ndescriptor pool or a filename provided by the caller using the\n`descriptor_source` attribute.\n\nFor the most part, the mapping between Proto field types and TensorFlow dtypes\nis straightforward. However, there are a few special cases:\n\n- A proto field that contains a submessage or group can only be converted\nto `DT_STRING` (the serialized submessage). This is to reduce the complexity\nof the API. The resulting string can be used as input to another instance of\nthe decode_proto op.\n\n- TensorFlow lacks support for unsigned integers. The ops represent uint64\ntypes as a `DT_INT64` with the same twos-complement bit pattern (the obvious\nway). Unsigned int32 values can be represented exactly by specifying type\n`DT_INT64`, or using twos-complement if the caller specifies `DT_INT32` in\nthe `output_types` attribute.\n\nThe `descriptor_source` attribute selects the source of protocol\ndescriptors to consult when looking up `message_type`. This may be:\n\n- An empty string  or \"local://\", in which case protocol descriptors are\ncreated for C++ (not Python) proto definitions linked to the binary.\n\n- A file, in which case protocol descriptors are created from the file,\nwhich is expected to contain a `FileDescriptorSet` serialized as a string.\nNOTE: You can build a `descriptor_source` file using the `--descriptor_set_out`\nand `--include_imports` options to the protocol compiler `protoc`.\n\n- A \"bytes://<bytes>\", in which protocol descriptors are created from `<bytes>`,\nwhich is expected to be a `FileDescriptorSet` serialized as a string.",
    "attributes": [
      {
        "name": "field_names",
        "type": "string[]",
        "description": "List of strings containing proto field names."
      },
      {
        "name": "message_type",
        "type": "string",
        "description": "Name of the proto message type to decode."
      },
      {
        "name": "descriptor_source",
        "type": "string",
        "default": "local://"
      },
      {
        "name": "Tinput_types",
        "type": "type[]",
        "description": "The input types.",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "sizes",
        "description": "Tensor of int32 with shape `[batch_shape, len(field_names)]`.",
        "type": 3
      },
      {
        "name": "values",
        "description": "List of tensors containing values for the corresponding field.",
        "typeListAttr": "Tinput_types"
      }
    ],
    "outputs": [
      {
        "name": "bytes",
        "description": "Tensor of serialized protos with shape `batch_shape`.",
        "type": 7
      }
    ]
  },
  {
    "name": "EncodeWav",
    "summary": "Encode audio data using the WAV file format.",
    "description": "This operation will generate a string suitable to be saved out to create a .wav\naudio file. It will be encoded in the 16-bit PCM format. It takes in float\nvalues in the range -1.0f to 1.0f, and any outside that value will be clamped to\nthat range.\n\n`audio` is a 2-D float Tensor of shape `[length, channels]`.\n`sample_rate` is a scalar Tensor holding the rate to use (e.g. 44100).",
    "inputs": [
      {
        "name": "audio",
        "description": "2-D with shape `[length, channels]`.",
        "type": 1
      },
      {
        "name": "sample_rate",
        "description": "Scalar containing the sample frequency.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "contents",
        "description": "0-D. WAV-encoded file contents.",
        "type": 7
      }
    ]
  },
  {
    "name": "EnqueueTPUEmbeddingArbitraryTensorBatch",
    "summary": "Eases the porting of code that uses tf.nn.embedding_lookup_sparse().",
    "description": "embedding_indices[i] and aggregation_weights[i] correspond\nto the ith feature.\n\nThe tensors at corresponding positions in the three input lists (sample_indices,\nembedding_indices and aggregation_weights) must have the same shape, i.e. rank 1\nwith dim_size() equal to the total number of lookups into the table described by\nthe corresponding feature.",
    "attributes": [
      {
        "name": "T1",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "T2",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "T3",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "device_ordinal",
        "type": "int64",
        "description": "The TPU device to use. Should be >= 0 and less than the number\nof TPU cores in the task on which the node is placed.",
        "default": -1
      },
      {
        "name": "combiners",
        "type": "string[]",
        "description": "A list of string scalars, one for each embedding table that specify\nhow to normalize the embedding activations after weighted summation.\nSupported combiners are 'mean', 'sum', or 'sqrtn'. It is invalid to have\nthe sum of the weights be 0 for 'mean' or the sum of the squared weights be\n0 for 'sqrtn'. If combiners isn't passed, the default is to use 'sum' for\nall tables.",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "sample_indices_or_row_splits",
        "description": "A list of rank 2 Tensors specifying the training example to which the\ncorresponding embedding_indices and aggregation_weights values belong.\nIf the size of its first dimension is 0, we assume each embedding_indices\nbelongs to a different sample. Both int32 and int64 are allowed and will\nbe converted to int32 internally.\n\nOr a list of rank 1 Tensors specifying the row splits for splitting\nembedding_indices and aggregation_weights into rows. It corresponds to\nids.row_splits in embedding_lookup(), when ids is a RaggedTensor. When\nenqueuing N-D ragged tensor, only the last dimension is allowed to be ragged.\nthe row splits is 1-D dense tensor. When empty, we assume a dense tensor is\npassed to the op Both int32 and int64 are allowed and will be converted to\nint32 internally.",
        "numberAttr": "N",
        "typeAttr": "T1"
      },
      {
        "name": "embedding_indices",
        "description": "A list of rank 1 Tensors, indices into the embedding\ntables. Both int32 and int64 are allowed and will be converted to\nint32 internally.",
        "numberAttr": "N",
        "typeAttr": "T2"
      },
      {
        "name": "aggregation_weights",
        "description": "A list of rank 1 Tensors containing per training\nexample aggregation weights. Both float32 and float64 are allowed and will\nbe converted to float32 internally.",
        "numberAttr": "N",
        "typeAttr": "T3"
      },
      {
        "name": "mode_override",
        "description": "A string input that overrides the mode specified in the\nTPUEmbeddingConfiguration. Supported values are {'unspecified', 'inference',\n'training', 'backward_pass_only'}. When set to 'unspecified', the mode set\nin TPUEmbeddingConfiguration is used, otherwise mode_override is used.",
        "type": 7
      }
    ]
  },
  {
    "name": "EnqueueTPUEmbeddingBatch",
    "summary": "An op that enqueues a list of input batch tensors to TPUEmbedding.",
    "description": "An op that enqueues a list of input batch tensors to TPUEmbedding.",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "device_ordinal",
        "type": "int64",
        "description": "The TPU device to use. This should be -1 when the Op\nis running on a TPU device, and >= 0 when the Op is running on the CPU\ndevice.",
        "default": -1
      },
      {
        "name": "combiners",
        "type": "string[]",
        "description": "A list of string scalars, one for each embedding table that specify\nhow to normalize the embedding activations after weighted summation.\nSupported combiners are 'mean', 'sum', or 'sqrtn'. It is invalid to have\nthe sum of the weights be 0 for 'mean' or the sum of the squared weights be\n0 for 'sqrtn'. If combiners isn't passed, the default is to use 'sum' for\nall tables.",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "batch",
        "description": "A list of 1D tensors, one for each embedding table, containing the\nbatch inputs encoded as dist_belief.SparseFeatures protos. If the weight\nfield in the SparseFeatures proto is not populated for an ID, a weight of\n1.0 is assumed.",
        "numberAttr": "N",
        "type": 7
      },
      {
        "name": "mode_override",
        "description": "A string input that overrides the mode specified in the\nTPUEmbeddingConfiguration. Supported values are {'unspecified', 'inference',\n'training', 'backward_pass_only'}. When set to 'unspecified', the mode set\nin TPUEmbeddingConfiguration is used, otherwise mode_override is used.",
        "type": 7
      }
    ]
  },
  {
    "name": "EnqueueTPUEmbeddingIntegerBatch",
    "summary": "An op that enqueues a list of input batch tensors to TPUEmbedding.",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "device_ordinal",
        "type": "int64",
        "description": "The TPU device to use. Should be >= 0 and less than the number\nof TPU cores in the task on which the node is placed.",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "batch",
        "description": "A list of 1D tensors, one for each embedding table, containing the\nindices into the tables.",
        "numberAttr": "N",
        "type": 3
      },
      {
        "name": "mode_override",
        "description": "A string input that overrides the mode specified in the\nTPUEmbeddingConfiguration. Supported values are {'unspecified', 'inference',\n'training', 'backward_pass_only'}. When set to 'unspecified', the mode set\nin TPUEmbeddingConfiguration is used, otherwise mode_override is used.",
        "type": 7
      }
    ]
  },
  {
    "name": "EnqueueTPUEmbeddingRaggedTensorBatch",
    "summary": "Eases the porting of code that uses tf.nn.embedding_lookup().",
    "description": "sample_splits[i], embedding_indices[i] and aggregation_weights[i] correspond\nto the ith feature. table_ids[i] indicates which embedding table to look up ith\nfeature.\n\nThe tensors at corresponding positions in two of the input lists,\nembedding_indices and aggregation_weights, must have the same shape, i.e. rank 1\nwith dim_size() equal to the total number of lookups into the table described by\nthe corresponding feature.",
    "attributes": [
      {
        "name": "T1",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "T2",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "T3",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "device_ordinal",
        "type": "int64",
        "description": "The TPU device to use. Should be >= 0 and less than the number\nof TPU cores in the task on which the node is placed.",
        "default": -1
      },
      {
        "name": "combiners",
        "type": "string[]",
        "description": "A list of string scalars, one for each embedding table that specify\nhow to normalize the embedding activations after weighted summation.\nSupported combiners are 'mean', 'sum', or 'sqrtn'. It is invalid to have\nthe sum of the weights be 0 for 'mean' or the sum of the squared weights be\n0 for 'sqrtn'. If combiners isn't passed, the default is to use 'sum' for\nall tables.",
        "default": []
      },
      {
        "name": "table_ids",
        "type": "int64[]",
        "description": "A list of integers specifying the identifier of the embedding table\n(offset of TableDescriptor in the TPUEmbeddingConfiguration) to lookup the\ncorresponding input. The ith input is looked up using table_ids[i]. The size\nof the table_ids list must be equal to that of sample_indices,\nembedding_indices and aggregation_weights."
      },
      {
        "name": "max_sequence_lengths",
        "type": "int64[]",
        "default": []
      },
      {
        "name": "num_features",
        "type": "int64[]",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "sample_splits",
        "description": "A list of rank 1 Tensors specifying the break points for splitting\nembedding_indices and aggregation_weights into rows.\nIt corresponds to ids.row_splits in embedding_lookup(), when ids is a\nRaggedTensor.",
        "numberAttr": "N",
        "typeAttr": "T1"
      },
      {
        "name": "embedding_indices",
        "description": "A list of rank 1 Tensors, indices into the embedding tables.\nIt corresponds to ids.values in embedding_lookup(), when ids is a RaggedTensor.",
        "numberAttr": "N",
        "typeAttr": "T2"
      },
      {
        "name": "aggregation_weights",
        "description": "A list of rank 1 Tensors containing per training example\naggregation weights. It corresponds to the values field of a RaggedTensor\nwith the same row_splits as ids in embedding_lookup(), when ids is a\nRaggedTensor.",
        "numberAttr": "N",
        "typeAttr": "T3"
      },
      {
        "name": "mode_override",
        "description": "A string input that overrides the mode specified in the\nTPUEmbeddingConfiguration. Supported values are {'unspecified', 'inference',\n'training', 'backward_pass_only'}. When set to 'unspecified', the mode set\nin TPUEmbeddingConfiguration is used, otherwise mode_override is used.",
        "type": 7
      }
    ]
  },
  {
    "name": "EnqueueTPUEmbeddingSparseBatch",
    "summary": "An op that enqueues TPUEmbedding input indices from a SparseTensor.",
    "description": "This Op eases the porting of code that uses embedding_lookup_sparse(),\nalthough some Python preprocessing of the SparseTensor arguments to\nembedding_lookup_sparse() is required to produce the arguments to this Op,\nsince only a single EnqueueTPUEmbeddingSparseBatch Op is allowed per training\nstep.\n\nThe tensors at corresponding positions in the three input lists\nmust have the same shape, i.e. rank 1 with dim_size() equal to the total\nnumber of lookups into the table described by the corresponding table_id.",
    "attributes": [
      {
        "name": "T1",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "T2",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "T3",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "device_ordinal",
        "type": "int64",
        "description": "The TPU device to use. Should be >= 0 and less than the number\nof TPU cores in the task on which the node is placed.",
        "default": -1
      },
      {
        "name": "combiners",
        "type": "string[]",
        "description": "A list of string scalars, one for each embedding table that specify\nhow to normalize the embedding activations after weighted summation.\nSupported combiners are 'mean', 'sum', or 'sqrtn'. It is invalid to have\nthe sum of the weights be 0 for 'mean' or the sum of the squared weights be\n0 for 'sqrtn'. If combiners isn't passed, the default is to use 'sum' for\nall tables.",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "sample_indices",
        "description": "A list of rank 1 Tensors specifying the training example and\nfeature to which the corresponding embedding_indices and aggregation_weights\nvalues belong. sample_indices[i] must equal b * nf + f, where nf is the\nnumber of features from the corresponding table, f is in [0, nf), and\nb is in [0, batch size).",
        "numberAttr": "N",
        "typeAttr": "T1"
      },
      {
        "name": "embedding_indices",
        "description": "A list of rank 1 Tensors, indices into the embedding tables.",
        "numberAttr": "N",
        "typeAttr": "T2"
      },
      {
        "name": "aggregation_weights",
        "description": "A list of rank 1 Tensors containing per sample -- i.e. per\n(training example, feature) -- aggregation weights.",
        "numberAttr": "N",
        "typeAttr": "T3"
      },
      {
        "name": "mode_override",
        "description": "A string input that overrides the mode specified in the\nTPUEmbeddingConfiguration. Supported values are {'unspecified', 'inference',\n'training', 'backward_pass_only'}. When set to 'unspecified', the mode set\nin TPUEmbeddingConfiguration is used, otherwise mode_override is used.",
        "type": 7
      }
    ]
  },
  {
    "name": "EnqueueTPUEmbeddingSparseTensorBatch",
    "summary": "Eases the porting of code that uses tf.nn.embedding_lookup_sparse().",
    "description": "sample_indices[i], embedding_indices[i] and aggregation_weights[i] correspond\nto the ith feature. table_ids[i] indicates which embedding table to look up ith\nfeature.\n\nThe tensors at corresponding positions in the three input lists (sample_indices,\nembedding_indices and aggregation_weights) must have the same shape, i.e. rank 1\nwith dim_size() equal to the total number of lookups into the table described by\nthe corresponding feature.",
    "attributes": [
      {
        "name": "T1",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "T2",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "T3",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "device_ordinal",
        "type": "int64",
        "description": "The TPU device to use. Should be >= 0 and less than the number\nof TPU cores in the task on which the node is placed.",
        "default": -1
      },
      {
        "name": "combiners",
        "type": "string[]",
        "description": "A list of string scalars, one for each embedding table that specify\nhow to normalize the embedding activations after weighted summation.\nSupported combiners are 'mean', 'sum', or 'sqrtn'. It is invalid to have\nthe sum of the weights be 0 for 'mean' or the sum of the squared weights be\n0 for 'sqrtn'. If combiners isn't passed, the default is to use 'sum' for\nall tables.",
        "default": []
      },
      {
        "name": "table_ids",
        "type": "int64[]",
        "description": "A list of integers specifying the identifier of the embedding table\n(offset of TableDescriptor in the TPUEmbeddingConfiguration) to lookup the\ncorresponding input. The ith input is looked up using table_ids[i]. The size\nof the table_ids list must be equal to that of sample_indices,\nembedding_indices and aggregation_weights."
      },
      {
        "name": "max_sequence_lengths",
        "type": "int64[]",
        "default": []
      },
      {
        "name": "num_features",
        "type": "int64[]",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "sample_indices",
        "description": "A list of rank 1 Tensors specifying the training example to\nwhich the corresponding embedding_indices and aggregation_weights values\nbelong. It corresponds to sp_ids.indices[:,0] in  embedding_lookup_sparse().",
        "numberAttr": "N",
        "typeAttr": "T1"
      },
      {
        "name": "embedding_indices",
        "description": "A list of rank 1 Tensors, indices into the embedding tables.\nIt corresponds to sp_ids.values in embedding_lookup_sparse().",
        "numberAttr": "N",
        "typeAttr": "T2"
      },
      {
        "name": "aggregation_weights",
        "description": "A list of rank 1 Tensors containing per training example\naggregation weights. It corresponds to sp_weights.values in\nembedding_lookup_sparse().",
        "numberAttr": "N",
        "typeAttr": "T3"
      },
      {
        "name": "mode_override",
        "description": "A string input that overrides the mode specified in the\nTPUEmbeddingConfiguration. Supported values are {'unspecified', 'inference',\n'training', 'backward_pass_only'}. When set to 'unspecified', the mode set\nin TPUEmbeddingConfiguration is used, otherwise mode_override is used.",
        "type": 7
      }
    ]
  },
  {
    "name": "EnsureShape",
    "summary": "Ensures that the tensor's shape matches the expected shape.",
    "description": "Raises an error if the input tensor's shape does not match the specified shape.\nReturns the input tensor otherwise.",
    "attributes": [
      {
        "name": "shape",
        "type": "shape",
        "description": "The expected (possibly partially specified) shape of the input tensor."
      },
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A tensor, whose shape is to be validated.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A tensor with the same shape and contents as the input tensor or value.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Enter",
    "summary": "Creates or finds a child frame, and makes `data` available to the child frame.",
    "description": "This op is used together with `Exit` to create loops in the graph.\nThe unique `frame_name` is used by the `Executor` to identify frames. If\n`is_constant` is true, `output` is a constant in the child frame; otherwise\nit may be changed in the child frame. At most `parallel_iterations` iterations\nare run in parallel in the child frame.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "frame_name",
        "type": "string",
        "description": "The name of the child frame."
      },
      {
        "name": "is_constant",
        "type": "boolean",
        "description": "If true, the output is constant within the child frame.",
        "default": false
      },
      {
        "name": "parallel_iterations",
        "type": "int64",
        "description": "The number of iterations allowed to run in parallel.",
        "default": 10
      }
    ],
    "inputs": [
      {
        "name": "data",
        "description": "The tensor to be made available to the child frame.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The same tensor as `data`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Equal",
    "summary": "Returns the truth value of (x == y) element-wise.",
    "description": "*NOTE*: `Equal` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)\n\n```python\nx = tf.constant([2, 4])\ny = tf.constant(2)\ntf.math.equal(x, y) ==> array([True, False])\n\nx = tf.constant([2, 4])\ny = tf.constant([2, 4])\ntf.math.equal(x, y) ==> array([True,  True])\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "incompatible_shape_error",
        "type": "boolean",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "type": 10
      }
    ]
  },
  {
    "name": "Erf",
    "summary": "Computes the [Gauss error function](https://en.wikipedia.org/wiki/Error_function) of `x` element-wise. In statistics, for non-negative values of $x$, the error function has the following interpretation: for a random variable $Y$ that is normally distributed with mean 0 and variance $1/\\sqrt{2}$, $erf(x)$ is the probability that $Y$ falls in the range $[\u2212x, x]$.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Erfc",
    "summary": "Computes the complementary error function of `x` element-wise.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Erfinv",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "EuclideanNorm",
    "summary": "Computes the euclidean norm of elements across dimensions of a tensor.",
    "description": "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1.",
    "attributes": [
      {
        "name": "keep_dims",
        "type": "boolean",
        "description": "If true, retain reduced dimensions with length 1.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The tensor to reduce.",
        "typeAttr": "T"
      },
      {
        "name": "reduction_indices",
        "description": "The dimensions to reduce. Must be in the range\n`[-rank(input), rank(input))`.",
        "typeAttr": "Tidx"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The reduced tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ExecuteTPUEmbeddingPartitioner",
    "summary": "An op that executes the TPUEmbedding partitioner on the central configuration",
    "description": "device and computes the HBM size (in bytes) required for TPUEmbedding operation.",
    "attributes": [
      {
        "name": "config",
        "type": "string",
        "description": "An TPUEmbeddingConfiguration proto serialized to a string,\ndescribing the desired TPUEmbedding configuration."
      }
    ],
    "outputs": [
      {
        "name": "common_config",
        "description": "A string-encoded common configuration proto\ncontaining metadata about the TPUEmbedding partitioner output and\nthe HBM size (in bytes) required for operation.",
        "type": 7
      }
    ]
  },
  {
    "name": "Exit",
    "summary": "Exits the current frame to its parent frame.",
    "description": "Exit makes its input `data` available to the parent frame.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "data",
        "description": "The tensor to be made available to the parent frame.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The same tensor as `data`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Exp",
    "summary": "Computes exponential of x element-wise.  \\\\(y = e^x\\\\).",
    "description": "  This function computes the exponential of every element in the input tensor.\n  i.e. `exp(x)` or `e^(x)`, where `x` is the input tensor.\n  `e` denotes Euler's number and is approximately equal to 2.718281.\n  Output is positive for any real input.\n\n  ```python\n  x = tf.constant(2.0)\n  tf.math.exp(x) ==> 7.389056\n\n  x = tf.constant([2.0, 8.0])\n  tf.math.exp(x) ==> array([7.389056, 2980.958], dtype=float32)\n  ```\n\n  For complex numbers, the exponential value is calculated as follows:\n\n  ```\n  e^(x+iy) = e^x * e^iy = e^x * (cos y + i sin y)\n  ```\n\n  Let's consider complex number 1+1j as an example.\n  e^1 * (cos 1 + i sin 1) = 2.7182818284590 * (0.54030230586+0.8414709848j)\n\n  ```python\n  x = tf.constant(1 + 1j)\n  tf.math.exp(x) ==> 1.4686939399158851+2.2873552871788423j\n  ```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ExpandDims",
    "summary": "Inserts a dimension of 1 into a tensor's shape.",
    "description": "Given a tensor `input`, this operation inserts a dimension of 1 at the\ndimension index `dim` of `input`'s shape. The dimension index `dim` starts at\nzero; if you specify a negative number for `dim` it is counted backward from\nthe end.\n\nThis operation is useful if you want to add a batch dimension to a single\nelement. For example, if you have a single image of shape `[height, width,\nchannels]`, you can make it a batch of 1 image with `expand_dims(image, 0)`,\nwhich will make the shape `[1, height, width, channels]`.\n\nOther examples:\n\n```\n# 't' is a tensor of shape [2]\nshape(expand_dims(t, 0)) ==> [1, 2]\nshape(expand_dims(t, 1)) ==> [2, 1]\nshape(expand_dims(t, -1)) ==> [2, 1]\n\n# 't2' is a tensor of shape [2, 3, 5]\nshape(expand_dims(t2, 0)) ==> [1, 2, 3, 5]\nshape(expand_dims(t2, 2)) ==> [2, 3, 1, 5]\nshape(expand_dims(t2, 3)) ==> [2, 3, 5, 1]\n```\n\nThis operation requires that:\n\n`-1-input.dims() <= dim <= input.dims()`\n\nThis operation is related to `squeeze()`, which removes dimensions of\nsize 1.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tdim",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "dim",
        "description": "0-D (scalar). Specifies the dimension index at which to\nexpand the shape of `input`. Must be in the range\n`[-rank(input) - 1, rank(input)]`.",
        "typeAttr": "Tdim"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Contains the same data as `input`, but its shape has an additional\ndimension of size 1 added.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ExperimentalAssertNextDataset",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "transformations",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalAutoShardDataset",
    "summary": "Creates a dataset that shards the input dataset.",
    "description": "Creates a dataset that shards the input dataset by num_workers, returning a\nsharded dataset for the index-th worker. This attempts to automatically shard\na dataset by examining the Dataset graph and inserting a shard op before the\ninputs to a reader Dataset (e.g. CSVDataset, TFRecordDataset).\n\nThis dataset will throw a NotFound error if we cannot shard the dataset\nautomatically.",
    "attributes": [
      {
        "name": "auto_shard_policy",
        "type": "int64",
        "default": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the input dataset.",
        "type": 21
      },
      {
        "name": "num_workers",
        "description": "A scalar representing the number of workers to distribute this dataset across.",
        "type": 9
      },
      {
        "name": "index",
        "description": "A scalar representing the index of the current worker out of num_workers.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalBytesProducedStatsDataset",
    "summary": "Records the bytes size of each element of `input_dataset` in a StatsAggregator.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "tag",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalCSVDataset",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1,
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `int64`, `string`."
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "filenames",
        "type": 7
      },
      {
        "name": "compression_type",
        "type": 7
      },
      {
        "name": "buffer_size",
        "type": 9
      },
      {
        "name": "header",
        "type": 10
      },
      {
        "name": "field_delim",
        "type": 7
      },
      {
        "name": "use_quote_delim",
        "type": 10
      },
      {
        "name": "na_value",
        "type": 7
      },
      {
        "name": "select_cols",
        "type": 9
      },
      {
        "name": "record_defaults",
        "typeListAttr": "output_types"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalChooseFastestDataset",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 2
      },
      {
        "name": "num_experiments",
        "type": "int64"
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_datasets",
        "numberAttr": "N",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalDatasetCardinality",
    "summary": "Returns the cardinality of `input_dataset`.",
    "description": "Returns the cardinality of `input_dataset`.",
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the dataset to return cardinality for.",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "cardinality",
        "description": "The cardinality of `input_dataset`. Named constants are used to represent\ninfinite and unknown cardinality.",
        "type": 9
      }
    ]
  },
  {
    "name": "ExperimentalDatasetToTFRecord",
    "summary": "Writes the given dataset to the given file using the TFRecord format.",
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the dataset to write.",
        "type": 21
      },
      {
        "name": "filename",
        "description": "A scalar string tensor representing the filename to use.",
        "type": 7
      },
      {
        "name": "compression_type",
        "description": "A scalar string tensor containing either (i) the empty string (no\ncompression), (ii) \"ZLIB\", or (iii) \"GZIP\".",
        "type": 7
      }
    ]
  },
  {
    "name": "ExperimentalDenseToSparseBatchDataset",
    "summary": "Creates a dataset that batches input elements into a SparseTensor.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A handle to an input dataset. Must have a single component.",
        "type": 21
      },
      {
        "name": "batch_size",
        "description": "A scalar representing the number of elements to accumulate in a\nbatch.",
        "type": 9
      },
      {
        "name": "row_shape",
        "description": "A vector representing the dense shape of each row in the produced\nSparseTensor. The shape may be partially specified, using `-1` to indicate\nthat a particular dimension should use the maximum size of all batch elements.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalDirectedInterleaveDataset",
    "summary": "A substitute for `InterleaveDataset` on a fixed list of `N` datasets.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "selector_input_dataset",
        "description": "A dataset of scalar `DT_INT64` elements that determines which of the\n`N` data inputs should produce the next output element.",
        "type": 21
      },
      {
        "name": "data_input_datasets",
        "description": "`N` datasets with the same type that will be interleaved according to\nthe values of `selector_input_dataset`.",
        "numberAttr": "N",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalGroupByReducerDataset",
    "summary": "Creates a dataset that computes a group-by on `input_dataset`.",
    "description": "Creates a dataset that computes a group-by on `input_dataset`.",
    "attributes": [
      {
        "name": "key_func",
        "type": "function",
        "description": "A function mapping an element of `input_dataset`, concatenated\nwith `key_func_other_arguments` to a scalar value of type DT_INT64."
      },
      {
        "name": "init_func",
        "type": "function",
        "description": "A function mapping a key of type DT_INT64, concatenated with\n`init_func_other_arguments` to the initial reducer state."
      },
      {
        "name": "reduce_func",
        "type": "function",
        "description": "A function mapping the current reducer state and an element of `input_dataset`,\nconcatenated with `reduce_func_other_arguments` to a new reducer state."
      },
      {
        "name": "finalize_func",
        "type": "function",
        "description": "A function mapping the final reducer state to an output element."
      },
      {
        "name": "Tkey_func_other_arguments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "Tinit_func_other_arguments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "Treduce_func_other_arguments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "Tfinalize_func_other_arguments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the input dataset.",
        "type": 21
      },
      {
        "name": "key_func_other_arguments",
        "description": "A list of tensors, typically values that were captured when\nbuilding a closure for `key_func`.",
        "typeListAttr": "Tkey_func_other_arguments"
      },
      {
        "name": "init_func_other_arguments",
        "description": "A list of tensors, typically values that were captured when\nbuilding a closure for `init_func`.",
        "typeListAttr": "Tinit_func_other_arguments"
      },
      {
        "name": "reduce_func_other_arguments",
        "description": "A list of tensors, typically values that were captured when\nbuilding a closure for `reduce_func`.",
        "typeListAttr": "Treduce_func_other_arguments"
      },
      {
        "name": "finalize_func_other_arguments",
        "description": "A list of tensors, typically values that were captured when\nbuilding a closure for `finalize_func`.",
        "typeListAttr": "Tfinalize_func_other_arguments"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalGroupByWindowDataset",
    "summary": "Creates a dataset that computes a windowed group-by on `input_dataset`.",
    "description": "// TODO(mrry): Support non-int64 keys.",
    "attributes": [
      {
        "name": "key_func",
        "type": "function",
        "description": "A function mapping an element of `input_dataset`, concatenated\nwith `key_func_other_arguments` to a scalar value of type DT_INT64."
      },
      {
        "name": "reduce_func",
        "type": "function"
      },
      {
        "name": "window_size_func",
        "type": "function"
      },
      {
        "name": "Tkey_func_other_arguments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "Treduce_func_other_arguments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "Twindow_size_func_other_arguments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "key_func_other_arguments",
        "typeListAttr": "Tkey_func_other_arguments"
      },
      {
        "name": "reduce_func_other_arguments",
        "typeListAttr": "Treduce_func_other_arguments"
      },
      {
        "name": "window_size_func_other_arguments",
        "typeListAttr": "Twindow_size_func_other_arguments"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalIgnoreErrorsDataset",
    "summary": "Creates a dataset that contains the elements of `input_dataset` ignoring errors.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "log_warning",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalIteratorGetDevice",
    "summary": "Returns the name of the device on which `resource` has been placed.",
    "inputs": [
      {
        "name": "resource",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "device",
        "type": 7
      }
    ]
  },
  {
    "name": "ExperimentalLMDBDataset",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "filenames",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalLatencyStatsDataset",
    "summary": "Records the latency of producing `input_dataset` elements in a StatsAggregator.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "tag",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalMapAndBatchDataset",
    "summary": "Creates a dataset that fuses mapping with batching.",
    "description": "Creates a dataset that applies `f` to the outputs of `input_dataset` and then\nbatches `batch_size` of them.\n\nUnlike a \"MapDataset\", which applies `f` sequentially, this dataset invokes up\nto `batch_size * num_parallel_batches` copies of `f` in parallel.",
    "attributes": [
      {
        "name": "f",
        "type": "function",
        "description": "A function to apply to the outputs of `input_dataset`."
      },
      {
        "name": "Targuments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "preserve_cardinality",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the input dataset.",
        "type": 21
      },
      {
        "name": "other_arguments",
        "description": "A list of tensors, typically values that were captured when building a closure\nfor `f`.",
        "typeListAttr": "Targuments"
      },
      {
        "name": "batch_size",
        "description": "A scalar representing the number of elements to accumulate in a\nbatch. It determines the number of concurrent invocations of `f` that process\nelements from `input_dataset` in parallel.",
        "type": 9
      },
      {
        "name": "num_parallel_calls",
        "description": "A scalar representing the maximum number of parallel invocations of the `map_fn`\nfunction. Applying the `map_fn` on consecutive input elements in parallel has\nthe potential to improve input pipeline throughput.",
        "type": 9
      },
      {
        "name": "drop_remainder",
        "description": "A scalar representing whether the last batch should be dropped in case its size\nis smaller than desired.",
        "type": 10
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalMapDataset",
    "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`.",
    "attributes": [
      {
        "name": "f",
        "type": "function"
      },
      {
        "name": "Targuments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "use_inter_op_parallelism",
        "type": "boolean",
        "default": true
      },
      {
        "name": "preserve_cardinality",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "other_arguments",
        "typeListAttr": "Targuments"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalMatchingFilesDataset",
    "inputs": [
      {
        "name": "patterns",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalMaxIntraOpParallelismDataset",
    "summary": "Creates a dataset that overrides the maximum intra-op parallelism.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "max_intra_op_parallelism",
        "description": "Identifies the maximum intra-op parallelism to use.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalNonSerializableDataset",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalParallelInterleaveDataset",
    "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`.",
    "description": "The resulting dataset is similar to the `InterleaveDataset`, with the exception\nthat if retrieving the next value from a dataset would cause the requester to\nblock, it will skip that input dataset. This dataset is especially useful\nwhen loading data from a variable-latency datastores (e.g. HDFS, GCS), as it\nallows the training step to proceed so long as some data is available.\n\n!! WARNING !! This dataset is not deterministic!",
    "attributes": [
      {
        "name": "f",
        "type": "function",
        "description": "A function mapping elements of `input_dataset`, concatenated with\n`other_arguments`, to a Dataset variant that contains elements matching\n`output_types` and `output_shapes`."
      },
      {
        "name": "Targuments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "other_arguments",
        "typeListAttr": "Targuments"
      },
      {
        "name": "cycle_length",
        "type": 9
      },
      {
        "name": "block_length",
        "type": 9
      },
      {
        "name": "sloppy",
        "type": 10
      },
      {
        "name": "buffer_output_elements",
        "type": 9
      },
      {
        "name": "prefetch_input_elements",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalParseExampleDataset",
    "summary": "Transforms `input_dataset` containing `Example` protos as vectors of DT_STRING into a dataset of `Tensor` or `SparseTensor` objects representing the parsed features.",
    "attributes": [
      {
        "name": "sparse_keys",
        "type": "string[]",
        "description": "A list of string keys in the examples features.\nThe results for these keys will be returned as `SparseTensor` objects.",
        "minimum": 0
      },
      {
        "name": "dense_keys",
        "type": "string[]",
        "description": "A list of Ndense string Tensors (scalars).\nThe keys expected in the Examples features associated with dense values.",
        "minimum": 0
      },
      {
        "name": "sparse_types",
        "type": "type[]",
        "description": "A list of `DTypes` of the same length as `sparse_keys`.\nOnly `tf.float32` (`FloatList`), `tf.int64` (`Int64List`),\nand `tf.string` (`BytesList`) are supported. Must be one of the following: `float32`, `int64`, `string`.",
        "minimum": 0
      },
      {
        "name": "Tdense",
        "type": "type[]",
        "description": "A list of DTypes of the same length as `dense_keys`.\nOnly `tf.float32` (`FloatList`), `tf.int64` (`Int64List`),\nand `tf.string` (`BytesList`) are supported.\n Must be one of the following: `float32`, `int64`, `string`.",
        "minimum": 0
      },
      {
        "name": "dense_shapes",
        "type": "shape[]",
        "description": "List of tuples with the same length as `dense_keys`.\nThe shape of the data for each dense feature referenced by `dense_keys`.\nRequired for any input tensors identified by `dense_keys`.  Must be\neither fully defined, or may contain an unknown first dimension.\nAn unknown first dimension means the feature is treated as having\na variable number of blocks, and the output shape along this dimension\nis considered unknown at graph build time.  Padding is applied for\nminibatch elements smaller than the maximum number of blocks for the\ngiven feature along this dimension.",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "description": "The type list for the return values.",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "description": "The list of shapes being produced.",
        "minimum": 1
      },
      {
        "name": "sloppy",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "num_parallel_calls",
        "type": 9
      },
      {
        "name": "dense_defaults",
        "description": "A dict mapping string keys to `Tensor`s.\nThe keys of the dict must match the dense_keys of the feature.",
        "typeListAttr": "Tdense"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalPrivateThreadPoolDataset",
    "summary": "Creates a dataset that uses a custom thread pool to compute `input_dataset`.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "num_threads",
        "description": "Identifies the number of threads to use for the private threadpool.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalRandomDataset",
    "summary": "Creates a Dataset that returns pseudorandom numbers.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "seed",
        "description": "A scalar seed for the random number generator. If either seed or\nseed2 is set to be non-zero, the random number generator is seeded\nby the given seed.  Otherwise, a random seed is used.",
        "type": 9
      },
      {
        "name": "seed2",
        "description": "A second scalar seed to avoid seed collision.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalRebatchDataset",
    "summary": "Creates a dataset that changes the batch size.",
    "description": "Creates a dataset that changes the batch size of the dataset to current batch\nsize // num_replicas.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "use_fallback",
        "type": "boolean",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the input dataset.",
        "type": 21
      },
      {
        "name": "num_replicas",
        "description": "A scalar representing the number of replicas to distribute this batch across. As\na result of this transformation the current batch size would end up being\ndivided  by this parameter.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalScanDataset",
    "summary": "Creates a dataset successively reduces `f` over the elements of `input_dataset`.",
    "attributes": [
      {
        "name": "f",
        "type": "function"
      },
      {
        "name": "Tstate",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "Targuments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "preserve_cardinality",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "initial_state",
        "typeListAttr": "Tstate"
      },
      {
        "name": "other_arguments",
        "typeListAttr": "Targuments"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalSetStatsAggregatorDataset",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "stats_aggregator",
        "type": 20
      },
      {
        "name": "tag",
        "type": 7
      },
      {
        "name": "counter_prefix",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalSleepDataset",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "sleep_microseconds",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalSlidingWindowDataset",
    "summary": "Creates a dataset that passes a sliding window over `input_dataset`.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "window_size",
        "description": "A scalar representing the number of elements in the\nsliding window.",
        "type": 9
      },
      {
        "name": "window_shift",
        "description": "A scalar representing the steps moving the sliding window\nforward in one iteration. It must be positive.",
        "type": 9
      },
      {
        "name": "window_stride",
        "description": "A scalar representing the stride of the input elements of the sliding window.\nIt must be positive.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalSqlDataset",
    "summary": "Creates a dataset that executes a SQL query and emits rows of the result set.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "driver_name",
        "description": "The database type. Currently, the only supported type is 'sqlite'.",
        "type": 7
      },
      {
        "name": "data_source_name",
        "description": "A connection string to connect to the database.",
        "type": 7
      },
      {
        "name": "query",
        "description": "A SQL query to execute.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalStatsAggregatorHandle",
    "summary": "Creates a statistics manager resource.",
    "attributes": [
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 20
      }
    ]
  },
  {
    "name": "ExperimentalStatsAggregatorSummary",
    "summary": "Produces a summary of any statistics recorded by the given statistics manager.",
    "inputs": [
      {
        "name": "iterator",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "summary",
        "type": 7
      }
    ]
  },
  {
    "name": "ExperimentalTakeWhileDataset",
    "summary": "Creates a dataset that stops iteration when predicate` is false.",
    "description": "The `predicate` function must return a scalar boolean and accept the\nfollowing arguments:\n\n* One tensor for each component of an element of `input_dataset`.\n* One tensor for each value in `other_arguments`.",
    "attributes": [
      {
        "name": "predicate",
        "type": "function",
        "description": "A function returning a scalar boolean."
      },
      {
        "name": "Targuments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "other_arguments",
        "description": "A list of tensors, typically values that were captured when\nbuilding a closure for `predicate`.",
        "typeListAttr": "Targuments"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalThreadPoolDataset",
    "summary": "Creates a dataset that uses a custom thread pool to compute `input_dataset`.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "thread_pool",
        "description": "A resource produced by the ThreadPoolHandle op.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalThreadPoolHandle",
    "summary": "Creates a dataset that uses a custom thread pool to compute `input_dataset`.",
    "attributes": [
      {
        "name": "num_threads",
        "type": "int64",
        "description": "The number of threads in the thread pool."
      },
      {
        "name": "max_intra_op_parallelism",
        "type": "int64",
        "description": "The maximum degree of parallelism to use within operations that execute on this\nthreadpool.",
        "default": 1
      },
      {
        "name": "display_name",
        "type": "string",
        "description": "A human-readable name for the threads that may be visible in some\nvisualizations.\nthreadpool."
      },
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "A resource that can be consumed by one or more ExperimentalThreadPoolDataset\nops.",
        "type": 20
      }
    ]
  },
  {
    "name": "ExperimentalUnbatchDataset",
    "summary": "A dataset that splits the elements of its input into multiple elements.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ExperimentalUniqueDataset",
    "summary": "Creates a dataset that contains the unique elements of `input_dataset`.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "Expint",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Expm1",
    "summary": "Computes `exp(x) - 1` element-wise.",
    "description": "  i.e. `exp(x) - 1` or `e^(x) - 1`, where `x` is the input tensor.\n  `e` denotes Euler's number and is approximately equal to 2.718281.\n\n  ```python\n  x = tf.constant(2.0)\n  tf.math.expm1(x) ==> 6.389056\n\n  x = tf.constant([2.0, 8.0])\n  tf.math.expm1(x) ==> array([6.389056, 2979.958], dtype=float32)\n\n  x = tf.constant(1 + 1j)\n  tf.math.expm1(x) ==> (0.46869393991588515+2.2873552871788423j)\n  ```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ExtractGlimpse",
    "summary": "Extracts a glimpse from the input tensor.",
    "description": "Returns a set of windows called glimpses extracted at location\n`offsets` from the input tensor. If the windows only partially\noverlaps the inputs, the non overlapping areas will be filled with\nrandom noise.\n\nThe result is a 4-D tensor of shape `[batch_size, glimpse_height,\nglimpse_width, channels]`. The channels and batch dimensions are the\nsame as that of the input tensor. The height and width of the output\nwindows are specified in the `size` parameter.\n\nThe argument `normalized` and `centered` controls how the windows are built:\n\n* If the coordinates are normalized but not centered, 0.0 and 1.0\n  correspond to the minimum and maximum of each height and width\n  dimension.\n* If the coordinates are both normalized and centered, they range from\n  -1.0 to 1.0. The coordinates (-1.0, -1.0) correspond to the upper\n  left corner, the lower right corner is located at (1.0, 1.0) and the\n  center is at (0, 0).\n* If the coordinates are not normalized they are interpreted as\n  numbers of pixels.",
    "attributes": [
      {
        "name": "centered",
        "type": "boolean",
        "description": "indicates if the offset coordinates are centered relative to\nthe image, in which case the (0, 0) offset is relative to the center\nof the input images. If false, the (0,0) offset corresponds to the\nupper left corner of the input images.",
        "default": true
      },
      {
        "name": "normalized",
        "type": "boolean",
        "description": "indicates if the offset coordinates are normalized.",
        "default": true
      },
      {
        "name": "uniform_noise",
        "type": "boolean",
        "description": "indicates if the noise should be generated using a\nuniform distribution or a Gaussian distribution.",
        "default": true
      },
      {
        "name": "noise",
        "type": "string",
        "description": "indicates if the noise should `uniform`, `gaussian`, or\n`zero`. The default is `uniform` which means the noise type\nwill be decided by `uniform_noise`.",
        "default": "uniform"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A 4-D float tensor of shape `[batch_size, height, width, channels]`.",
        "type": 1
      },
      {
        "name": "size",
        "description": "A 1-D tensor of 2 elements containing the size of the glimpses\nto extract.  The glimpse height must be specified first, following\nby the glimpse width.",
        "type": 3
      },
      {
        "name": "offsets",
        "description": "A 2-D integer tensor of shape `[batch_size, 2]` containing\nthe y, x locations of the center of each window.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "glimpse",
        "description": "A tensor representing the glimpses `[batch_size,\nglimpse_height, glimpse_width, channels]`.",
        "type": 1
      }
    ]
  },
  {
    "name": "ExtractGlimpseV2",
    "summary": "Extracts a glimpse from the input tensor.",
    "description": "Returns a set of windows called glimpses extracted at location\n`offsets` from the input tensor. If the windows only partially\noverlaps the inputs, the non overlapping areas will be filled with\nrandom noise.\n\nThe result is a 4-D tensor of shape `[batch_size, glimpse_height,\nglimpse_width, channels]`. The channels and batch dimensions are the\nsame as that of the input tensor. The height and width of the output\nwindows are specified in the `size` parameter.\n\nThe argument `normalized` and `centered` controls how the windows are built:\n\n* If the coordinates are normalized but not centered, 0.0 and 1.0\n  correspond to the minimum and maximum of each height and width\n  dimension.\n* If the coordinates are both normalized and centered, they range from\n  -1.0 to 1.0. The coordinates (-1.0, -1.0) correspond to the upper\n  left corner, the lower right corner is located at (1.0, 1.0) and the\n  center is at (0, 0).\n* If the coordinates are not normalized they are interpreted as\n  numbers of pixels.",
    "attributes": [
      {
        "name": "centered",
        "type": "boolean",
        "description": "indicates if the offset coordinates are centered relative to\nthe image, in which case the (0, 0) offset is relative to the center\nof the input images. If false, the (0,0) offset corresponds to the\nupper left corner of the input images.",
        "default": true
      },
      {
        "name": "normalized",
        "type": "boolean",
        "description": "indicates if the offset coordinates are normalized.",
        "default": true
      },
      {
        "name": "uniform_noise",
        "type": "boolean",
        "description": "indicates if the noise should be generated using a\nuniform distribution or a Gaussian distribution.",
        "default": true
      },
      {
        "name": "noise",
        "type": "string",
        "description": "indicates if the noise should `uniform`, `gaussian`, or\n`zero`. The default is `uniform` which means the noise type\nwill be decided by `uniform_noise`.",
        "default": "uniform"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A 4-D float tensor of shape `[batch_size, height, width, channels]`.",
        "type": 1
      },
      {
        "name": "size",
        "description": "A 1-D tensor of 2 elements containing the size of the glimpses\nto extract.  The glimpse height must be specified first, following\nby the glimpse width.",
        "type": 3
      },
      {
        "name": "offsets",
        "description": "A 2-D integer tensor of shape `[batch_size, 2]` containing\nthe y, x locations of the center of each window.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "glimpse",
        "description": "A tensor representing the glimpses `[batch_size,\nglimpse_height, glimpse_width, channels]`.",
        "type": 1
      }
    ]
  },
  {
    "name": "ExtractImagePatches",
    "summary": "Extract `patches` from `images` and put them in the \"depth\" output dimension.",
    "attributes": [
      {
        "name": "ksizes",
        "type": "int64[]",
        "description": "The size of the sliding window for each dimension of `images`.",
        "minimum": 4
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "How far the centers of two consecutive patches are in\nthe images. Must be: `[1, stride_rows, stride_cols, 1]`.",
        "minimum": 4
      },
      {
        "name": "rates",
        "type": "int64[]",
        "description": "Must be: `[1, rate_rows, rate_cols, 1]`. This is the\ninput stride, specifying how far two consecutive patch samples are in the\ninput. Equivalent to extracting patches with\n`patch_sizes_eff = patch_sizes + (patch_sizes - 1) * (rates - 1)`, followed by\nsubsampling them spatially by a factor of `rates`. This is equivalent to\n`rate` in dilated (a.k.a. Atrous) convolutions.",
        "minimum": 4
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `uint32`, `uint64`, `complex64`, `complex128`, `bool`."
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      }
    ],
    "inputs": [
      {
        "name": "images",
        "description": "4-D Tensor with shape `[batch, in_rows, in_cols, depth]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "patches",
        "description": "4-D Tensor with shape `[batch, out_rows, out_cols, ksize_rows *\nksize_cols * depth]` containing image patches with size\n`ksize_rows x ksize_cols x depth` vectorized in the \"depth\" dimension. Note\n`out_rows` and `out_cols` are the dimensions of the output patches.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ExtractJpegShape",
    "summary": "Extract the shape information of a JPEG-encoded image.",
    "description": "This op only parses the image header, so it is much faster than DecodeJpeg.",
    "attributes": [
      {
        "name": "output_type",
        "type": "type",
        "description": "(Optional) The output type of the operation (int32 or int64).\nDefaults to int32. Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "contents",
        "description": "0-D. The JPEG-encoded image.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "image_shape",
        "description": "1-D. The image shape with format [height, width, channels].",
        "typeAttr": "output_type"
      }
    ]
  },
  {
    "name": "ExtractVolumePatches",
    "summary": "Extract `patches` from `input` and put them in the `\"depth\"` output dimension. 3D extension of `extract_image_patches`.",
    "attributes": [
      {
        "name": "ksizes",
        "type": "int64[]",
        "description": "The size of the sliding window for each dimension of `input`.",
        "minimum": 5
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "1-D of length 5. How far the centers of two consecutive patches are in\n`input`. Must be: `[1, stride_planes, stride_rows, stride_cols, 1]`.",
        "minimum": 5
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use.\n\nThe size-related attributes are specified as follows:\n\n```python\nksizes = [1, ksize_planes, ksize_rows, ksize_cols, 1]\nstrides = [1, stride_planes, strides_rows, strides_cols, 1]\n``` Must be one of the following: `SAME`, `VALID`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "5-D Tensor with shape `[batch, in_planes, in_rows, in_cols, depth]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "patches",
        "description": "5-D Tensor with shape `[batch, out_planes, out_rows, out_cols,\nksize_planes * ksize_rows * ksize_cols * depth]` containing patches\nwith size `ksize_planes x ksize_rows x ksize_cols x depth` vectorized\nin the \"depth\" dimension. Note `out_planes`, `out_rows` and `out_cols`\nare the dimensions of the output patches.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "FFT",
    "summary": "Fast Fourier transform.",
    "description": "Computes the 1-dimensional discrete Fourier transform over the inner-most\ndimension of `input`.",
    "attributes": [
      {
        "name": "Tcomplex",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A complex tensor.",
        "typeAttr": "Tcomplex"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A complex tensor of the same shape as `input`. The inner-most\n  dimension of `input` is replaced with its 1D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.fft\n@end_compatibility",
        "typeAttr": "Tcomplex"
      }
    ]
  },
  {
    "name": "FFT2D",
    "summary": "2D fast Fourier transform.",
    "description": "Computes the 2-dimensional discrete Fourier transform over the inner-most\n2 dimensions of `input`.",
    "attributes": [
      {
        "name": "Tcomplex",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A complex tensor.",
        "typeAttr": "Tcomplex"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A complex tensor of the same shape as `input`. The inner-most 2\n  dimensions of `input` are replaced with their 2D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.fft2\n@end_compatibility",
        "typeAttr": "Tcomplex"
      }
    ]
  },
  {
    "name": "FFT3D",
    "summary": "3D fast Fourier transform.",
    "description": "Computes the 3-dimensional discrete Fourier transform over the inner-most 3\ndimensions of `input`.",
    "attributes": [
      {
        "name": "Tcomplex",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A complex tensor.",
        "typeAttr": "Tcomplex"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A complex tensor of the same shape as `input`. The inner-most 3\n  dimensions of `input` are replaced with their 3D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.fftn with 3 dimensions.\n@end_compatibility",
        "typeAttr": "Tcomplex"
      }
    ]
  },
  {
    "name": "FFTND",
    "summary": "ND fast Fourier transform.",
    "description": "Computes the n-dimensional discrete Fourier transform over\ndesignated dimensions of `input`. The designated dimensions of\n`input` are assumed to be the result of `FFTND`.\n\nIf fft_length[i]<shape(input)[i], the input is cropped. If\nfft_length[i]>shape(input)[i], the input is padded with zeros. If fft_length\nis not given, the default shape(input) is used.\n\nAxes mean the dimensions to perform the transform on. Default is to perform on\nall axes.",
    "attributes": [
      {
        "name": "Tcomplex",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A complex tensor.",
        "typeAttr": "Tcomplex"
      },
      {
        "name": "fft_length",
        "description": "An int32 tensor. The FFT length for each dimension.",
        "type": 3
      },
      {
        "name": "axes",
        "description": "An int32 tensor with a same shape as fft_length. Axes to perform the transform.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A complex tensor of the same shape as `input`. The designated\ndimensions of `input` are replaced with their Fourier transforms.\n\n@compatibility(numpy)\nEquivalent to np.fft.fftn.\n@end_compatibility",
        "typeAttr": "Tcomplex"
      }
    ]
  },
  {
    "name": "FIFOQueue",
    "summary": "A queue that produces elements in first-in first-out order.",
    "attributes": [
      {
        "name": "component_types",
        "type": "type[]",
        "description": "The type of each component in a value.",
        "minimum": 1
      },
      {
        "name": "shapes",
        "type": "shape[]",
        "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types. If the length of\nthis attr is 0, the shapes of queue elements are not constrained, and\nonly one element may be dequeued at a time.",
        "minimum": 0,
        "default": []
      },
      {
        "name": "capacity",
        "type": "int64",
        "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
        "default": -1
      },
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "The handle to the queue.",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "FIFOQueueV2",
    "summary": "A queue that produces elements in first-in first-out order.",
    "attributes": [
      {
        "name": "component_types",
        "type": "type[]",
        "description": "The type of each component in a value.",
        "minimum": 1
      },
      {
        "name": "shapes",
        "type": "shape[]",
        "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types. If the length of\nthis attr is 0, the shapes of queue elements are not constrained, and\nonly one element may be dequeued at a time.",
        "minimum": 0,
        "default": []
      },
      {
        "name": "capacity",
        "type": "int64",
        "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
        "default": -1
      },
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "The handle to the queue.",
        "type": 20
      }
    ]
  },
  {
    "name": "Fact",
    "summary": "Output a fact about factorials.",
    "outputs": [
      {
        "name": "fact",
        "type": 7
      }
    ]
  },
  {
    "name": "FakeParam",
    "summary": "  This op is used as a placeholder in If branch functions. It doesn't provide a\n  valid output when run, so must either be removed (e.g. replaced with a\n  function input) or guaranteed not to be used (e.g. if mirroring an\n  intermediate output needed for the gradient computation of the other branch).",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output."
      },
      {
        "name": "shape",
        "type": "shape",
        "description": "    The purported shape of the output. This is only used for shape inference;\n    the output will not necessarily have this shape. Can be a partial shape."
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "    \\\"Fake\\\" output value. This should not be consumed by another op.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "FakeQuantWithMinMaxArgs",
    "summary": "Fake-quantize the 'inputs' tensor, type float to 'outputs' tensor of same shape and type.",
    "description": "\n  Quantization is called fake since the output is still in floating point.\n  The API converts inputs into values within the range [min and max] and returns\n  as output.\n\nAttributes\n\n*   `[min; max]` define the clamping range for the `inputs` data.\n*   `inputs` values are quantized into the quantization range (\n`[0; 2^num_bits - 1]` when `narrow_range` is false and `[1; 2^num_bits - 1]`\nwhen it is true) and then de-quantized and output as floats in `[min; max]`\ninterval.\n*   `num_bits` is the bitwidth of the quantization; between 2 and 16, inclusive.\n\nBefore quantization, `min` and `max` values are adjusted with the following\nlogic.\nIt is suggested to have `min <= 0 <= max`. If `0` is not in the range of values,\nthe behavior can be unexpected:\n\n*   If `0 < min < max`: `min_adj = 0` and `max_adj = max - min`.\n*   If `min < max < 0`: `min_adj = min - max` and `max_adj = 0`.\n*   If `min <= 0 <= max`: `scale = (max - min) / (2^num_bits - 1) `,\n`min_adj = scale * round(min / scale)` and `max_adj = max + min_adj - min`.\n\n\nExamples\n\n```python\n\ninp = tf.constant ([10.03, -10.23, 3])\nout = tf.quantization.fake_quant_with_min_max_args(inp, min=-5, max=5,\n                                                   num_bits=16)\nprint(out)\n\n#  Output:\n#  tf.Tensor([ 4.9999237 -5.0000763  3.0000763], shape=(3,), dtype=float32)\n```\n\nRaises:\n  * InvalidArgumentError:\n    - If num_bits are outside of range [2, 16].\n    - If min >= max.\n  * ValueError: If `inputs` are of any other type than float32.\n",
    "attributes": [
      {
        "name": "min",
        "type": "float32",
        "default": -6.0
      },
      {
        "name": "max",
        "type": "float32",
        "default": 6.0
      },
      {
        "name": "num_bits",
        "type": "int64",
        "default": 8
      },
      {
        "name": "narrow_range",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "outputs",
        "type": 1
      }
    ]
  },
  {
    "name": "FakeQuantWithMinMaxArgsGradient",
    "summary": "Compute gradients for a FakeQuantWithMinMaxArgs operation.",
    "attributes": [
      {
        "name": "min",
        "type": "float32",
        "default": -6.0
      },
      {
        "name": "max",
        "type": "float32",
        "default": 6.0
      },
      {
        "name": "num_bits",
        "type": "int64",
        "default": 8
      },
      {
        "name": "narrow_range",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "gradients",
        "description": "Backpropagated gradients above the FakeQuantWithMinMaxArgs operation.",
        "type": 1
      },
      {
        "name": "inputs",
        "description": "Values passed as inputs to the FakeQuantWithMinMaxArgs operation.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "backprops",
        "description": "Backpropagated gradients below the FakeQuantWithMinMaxArgs operation:\n`gradients * (inputs >= min && inputs <= max)`.",
        "type": 1
      }
    ]
  },
  {
    "name": "FakeQuantWithMinMaxVars",
    "summary": "Fake-quantize the 'inputs' tensor of type float via global float scalars",
    "description": "Fake-quantize the `inputs` tensor of type float via global float scalars\n`min` and `max` to `outputs` tensor of same shape as `inputs`.\n\nAttributes\n\n*   `[min; max]` define the clamping range for the `inputs` data.\n*   `inputs` values are quantized into the quantization range (\n`[0; 2^num_bits - 1]` when `narrow_range` is false and `[1; 2^num_bits - 1]`\nwhen it is true) and then de-quantized and output as floats in `[min; max]`\ninterval.\n*   `num_bits` is the bitwidth of the quantization; between 2 and 16, inclusive.\n\nBefore quantization, `min` and `max` values are adjusted with the following\nlogic.\nIt is suggested to have `min <= 0 <= max`. If `0` is not in the range of values,\nthe behavior can be unexpected:\n\n*   If `0 < min < max`: `min_adj = 0` and `max_adj = max - min`.\n*   If `min < max < 0`: `min_adj = min - max` and `max_adj = 0`.\n*   If `min <= 0 <= max`: `scale = (max - min) / (2^num_bits - 1) `,\n`min_adj = scale * round(min / scale)` and `max_adj = max + min_adj - min`.\n\nThis operation has a gradient and thus allows for training `min` and `max`\nvalues.",
    "attributes": [
      {
        "name": "num_bits",
        "type": "int64",
        "default": 8
      },
      {
        "name": "narrow_range",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "type": 1
      },
      {
        "name": "min",
        "type": 1
      },
      {
        "name": "max",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "outputs",
        "type": 1
      }
    ]
  },
  {
    "name": "FakeQuantWithMinMaxVarsGradient",
    "summary": "Compute gradients for a FakeQuantWithMinMaxVars operation.",
    "attributes": [
      {
        "name": "num_bits",
        "type": "int64",
        "description": "The bitwidth of the quantization; between 2 and 8, inclusive.",
        "default": 8
      },
      {
        "name": "narrow_range",
        "type": "boolean",
        "description": "Whether to quantize into 2^num_bits - 1 distinct values.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "gradients",
        "description": "Backpropagated gradients above the FakeQuantWithMinMaxVars operation.",
        "type": 1
      },
      {
        "name": "inputs",
        "description": "Values passed as inputs to the FakeQuantWithMinMaxVars operation.\nmin, max: Quantization interval, scalar floats.",
        "type": 1
      },
      {
        "name": "min",
        "type": 1
      },
      {
        "name": "max",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "backprops_wrt_input",
        "description": "Backpropagated gradients w.r.t. inputs:\n`gradients * (inputs >= min && inputs <= max)`.",
        "type": 1
      },
      {
        "name": "backprop_wrt_min",
        "description": "Backpropagated gradients w.r.t. min parameter:\n`sum(gradients * (inputs < min))`.",
        "type": 1
      },
      {
        "name": "backprop_wrt_max",
        "description": "Backpropagated gradients w.r.t. max parameter:\n`sum(gradients * (inputs > max))`.",
        "type": 1
      }
    ]
  },
  {
    "name": "FakeQuantWithMinMaxVarsPerChannel",
    "summary": "Fake-quantize the 'inputs' tensor of type float via per-channel floats",
    "description": "Fake-quantize the `inputs` tensor of type float per-channel and one of the\nshapes: `[d]`, `[b, d]` `[b, h, w, d]` via per-channel floats `min` and `max`\nof shape `[d]` to `outputs` tensor of same shape as `inputs`.\n\nAttributes\n\n*   `[min; max]` define the clamping range for the `inputs` data.\n*   `inputs` values are quantized into the quantization range (\n`[0; 2^num_bits - 1]` when `narrow_range` is false and `[1; 2^num_bits - 1]`\nwhen it is true) and then de-quantized and output as floats in `[min; max]`\ninterval.\n*   `num_bits` is the bitwidth of the quantization; between 2 and 16, inclusive.\n\nBefore quantization, `min` and `max` values are adjusted with the following\nlogic.\nIt is suggested to have `min <= 0 <= max`. If `0` is not in the range of values,\nthe behavior can be unexpected:\n\n*   If `0 < min < max`: `min_adj = 0` and `max_adj = max - min`.\n*   If `min < max < 0`: `min_adj = min - max` and `max_adj = 0`.\n*   If `min <= 0 <= max`: `scale = (max - min) / (2^num_bits - 1) `,\n`min_adj = scale * round(min / scale)` and `max_adj = max + min_adj - min`.\n\nThis operation has a gradient and thus allows for training `min` and `max`\nvalues.",
    "attributes": [
      {
        "name": "num_bits",
        "type": "int64",
        "default": 8
      },
      {
        "name": "narrow_range",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "type": 1
      },
      {
        "name": "min",
        "type": 1
      },
      {
        "name": "max",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "outputs",
        "type": 1
      }
    ]
  },
  {
    "name": "FakeQuantWithMinMaxVarsPerChannelGradient",
    "summary": "Compute gradients for a FakeQuantWithMinMaxVarsPerChannel operation.",
    "attributes": [
      {
        "name": "num_bits",
        "type": "int64",
        "description": "The bitwidth of the quantization; between 2 and 16, inclusive.",
        "default": 8
      },
      {
        "name": "narrow_range",
        "type": "boolean",
        "description": "Whether to quantize into 2^num_bits - 1 distinct values.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "gradients",
        "description": "Backpropagated gradients above the FakeQuantWithMinMaxVars operation,\nshape one of: `[d]`, `[b, d]`,  `[b, h, w, d]`.",
        "type": 1
      },
      {
        "name": "inputs",
        "description": "Values passed as inputs to the FakeQuantWithMinMaxVars operation, shape\n  same as `gradients`.\nmin, max: Quantization interval, floats of shape `[d]`.",
        "type": 1
      },
      {
        "name": "min",
        "type": 1
      },
      {
        "name": "max",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "backprops_wrt_input",
        "description": "Backpropagated gradients w.r.t. inputs, shape same as\n`inputs`:\n  `gradients * (inputs >= min && inputs <= max)`.",
        "type": 1
      },
      {
        "name": "backprop_wrt_min",
        "description": "Backpropagated gradients w.r.t. min parameter, shape `[d]`:\n`sum_per_d(gradients * (inputs < min))`.",
        "type": 1
      },
      {
        "name": "backprop_wrt_max",
        "description": "Backpropagated gradients w.r.t. max parameter, shape `[d]`:\n`sum_per_d(gradients * (inputs > max))`.",
        "type": 1
      }
    ]
  },
  {
    "name": "FakeQueue",
    "summary": "Deprecated. Do not use.",
    "inputs": [
      {
        "name": "resource",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "FileSystemSetConfiguration",
    "summary": "Set configuration of the file system.",
    "inputs": [
      {
        "name": "scheme",
        "description": "File system scheme.",
        "type": 7
      },
      {
        "name": "key",
        "description": "The name of the configuration option.",
        "type": 7
      },
      {
        "name": "value",
        "description": "The value of the configuration option.",
        "type": 7
      }
    ]
  },
  {
    "name": "Fill",
    "summary": "Creates a tensor filled with a scalar value.",
    "description": "This operation creates a tensor of shape `dims` and fills it with `value`.\n\nFor example:\n\n```\n# Output tensor has shape [2, 3].\nfill([2, 3], 9) ==> [[9, 9, 9]\n                     [9, 9, 9]]\n```\n\n`tf.fill` differs from `tf.constant` in a few ways:\n\n*   `tf.fill` only supports scalar contents, whereas `tf.constant` supports\n    Tensor values.\n*   `tf.fill` creates an Op in the computation graph that constructs the actual\n    Tensor value at runtime. This is in contrast to `tf.constant` which embeds\n    the entire Tensor into the graph with a `Const` node.\n*   Because `tf.fill` evaluates at graph runtime, it supports dynamic shapes\n    based on other runtime Tensors, unlike `tf.constant`.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "index_type",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "dims",
        "description": "1-D. Represents the shape of the output tensor.",
        "typeAttr": "index_type"
      },
      {
        "name": "value",
        "description": "0-D (scalar). Value to fill the returned tensor.\n\n@compatibility(numpy)\nEquivalent to np.full\n@end_compatibility",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "FilterByLastComponentDataset",
    "summary": "Creates a dataset containing elements of first component of `input_dataset` having true in the last component.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 21
      }
    ]
  },
  {
    "name": "FilterDataset",
    "summary": "Creates a dataset containing elements of `input_dataset` matching `predicate`.",
    "description": "The `predicate` function must return a scalar boolean and accept the\nfollowing arguments:\n\n* One tensor for each component of an element of `input_dataset`.\n* One tensor for each value in `other_arguments`.",
    "attributes": [
      {
        "name": "predicate",
        "type": "function",
        "description": "A function returning a scalar boolean."
      },
      {
        "name": "Targuments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "other_arguments",
        "description": "A list of tensors, typically values that were captured when\nbuilding a closure for `predicate`.",
        "typeListAttr": "Targuments"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "FinalizeDataset",
    "summary": "Creates a dataset by applying `tf.data.Options` to `input_dataset`.",
    "attributes": [
      {
        "name": "has_captured_ref",
        "type": "boolean",
        "default": false
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the input dataset.",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "FinalizeTPUEmbedding",
    "summary": "An op that finalizes the TPUEmbedding configuration.",
    "inputs": [
      {
        "name": "common_config",
        "description": "A string-encoded common configuration proto containing metadata\nabout the TPUEmbedding partitioner output and the HBM size (in bytes) required\nfor operation.",
        "type": 7
      },
      {
        "name": "memory_config",
        "description": "A string-encoded memory config proto containing metadata about\nthe memory allocations reserved for TPUEmbedding.",
        "type": 7
      }
    ]
  },
  {
    "name": "FinalizeTPUEmbeddingV2",
    "summary": "An op that finalizes the TPUEmbedding configuration.",
    "inputs": [
      {
        "name": "common_config",
        "description": "A string-encoded common configuration proto containing metadata\nabout the TPUEmbedding partitioner output and the HBM size (in bytes) required\nfor operation.",
        "type": 7
      },
      {
        "name": "memory_config",
        "description": "A string-encoded memory config proto containing metadata about\nthe memory allocations reserved for TPUEmbedding.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "embedding_partitions",
        "description": "A string-encoded embedding partitions proto describing how embedding tables are\npartitioned along their feature and ID.",
        "type": 7
      },
      {
        "name": "hbm_buffers_config",
        "description": "A string-encoded HBM buffers config proto specifies where HBM buffers are\nlocated.",
        "type": 7
      }
    ]
  },
  {
    "name": "Fingerprint",
    "summary": "Generates fingerprint values.",
    "description": "Generates fingerprint values of `data`.\n\nFingerprint op considers the first dimension of `data` as the batch dimension,\nand `output[i]` contains the fingerprint value generated from contents in\n`data[i, ...]` for all `i`.\n\nFingerprint op writes fingerprint values as byte arrays. For example, the\ndefault method `farmhash64` generates a 64-bit fingerprint value at a time.\nThis 8-byte value is written out as an `uint8` array of size 8, in little-endian\norder.\n\nFor example, suppose that `data` has data type `DT_INT32` and shape (2, 3, 4),\nand that the fingerprint method is `farmhash64`. In this case, the output shape\nis (2, 8), where 2 is the batch dimension size of `data`, and 8 is the size of\neach fingerprint value in bytes. `output[0, :]` is generated from 12 integers in\n`data[0, :, :]` and similarly `output[1, :]` is generated from other 12 integers\nin `data[1, :, :]`.\n\nNote that this op fingerprints the raw underlying buffer, and it does not\nfingerprint Tensor's metadata such as data type and/or shape. For example, the\nfingerprint values are invariant under reshapes and bitcasts as long as the\nbatch dimension remain the same:\n\n```\nFingerprint(data) == Fingerprint(Reshape(data, ...))\nFingerprint(data) == Fingerprint(Bitcast(data, ...))\n```\n\nFor string data, one should expect `Fingerprint(data) !=\nFingerprint(ReduceJoin(data))` in general.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "This can be a POD-type or string type."
      }
    ],
    "inputs": [
      {
        "name": "data",
        "description": "Must have rank 1 or higher.",
        "typeAttr": "T"
      },
      {
        "name": "method",
        "description": "Fingerprint method used by this op. Currently available method is\n`farmhash::fingerprint64`.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "fingerprint",
        "description": "A two-dimensional `Tensor` of type `tf.uint8`. The first dimension equals to\n`data`'s first dimension, and the second dimension size depends on the\nfingerprint algorithm.",
        "type": 4
      }
    ]
  },
  {
    "name": "FixedLengthRecordDataset",
    "summary": "Creates a dataset that emits the records from one or more binary files.",
    "attributes": [
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "filenames",
        "description": "A scalar or a vector containing the name(s) of the file(s) to be\nread.",
        "type": 7
      },
      {
        "name": "header_bytes",
        "description": "A scalar representing the number of bytes to skip at the\nbeginning of a file.",
        "type": 9
      },
      {
        "name": "record_bytes",
        "description": "A scalar representing the number of bytes in each record.",
        "type": 9
      },
      {
        "name": "footer_bytes",
        "description": "A scalar representing the number of bytes to skip at the end\nof a file.",
        "type": 9
      },
      {
        "name": "buffer_size",
        "description": "A scalar representing the number of bytes to buffer. Must be > 0.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "FixedLengthRecordDatasetV2",
    "attributes": [
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "filenames",
        "type": 7
      },
      {
        "name": "header_bytes",
        "type": 9
      },
      {
        "name": "record_bytes",
        "type": 9
      },
      {
        "name": "footer_bytes",
        "type": 9
      },
      {
        "name": "buffer_size",
        "type": 9
      },
      {
        "name": "compression_type",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "FixedLengthRecordReader",
    "summary": "A Reader that outputs fixed-length records from a file.",
    "attributes": [
      {
        "name": "header_bytes",
        "type": "int64",
        "description": "Number of bytes in the header, defaults to 0.",
        "default": 0
      },
      {
        "name": "record_bytes",
        "type": "int64",
        "description": "Number of bytes in the record."
      },
      {
        "name": "footer_bytes",
        "type": "int64",
        "description": "Number of bytes in the footer, defaults to 0.",
        "default": 0
      },
      {
        "name": "hop_bytes",
        "type": "int64",
        "description": "Number of bytes to hop before each read. Default of 0 means using\nrecord_bytes.",
        "default": 0
      },
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "reader_handle",
        "description": "The handle to reference the Reader.",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "FixedLengthRecordReaderV2",
    "summary": "A Reader that outputs fixed-length records from a file.",
    "attributes": [
      {
        "name": "header_bytes",
        "type": "int64",
        "description": "Number of bytes in the header, defaults to 0.",
        "default": 0
      },
      {
        "name": "record_bytes",
        "type": "int64",
        "description": "Number of bytes in the record."
      },
      {
        "name": "footer_bytes",
        "type": "int64",
        "description": "Number of bytes in the footer, defaults to 0.",
        "default": 0
      },
      {
        "name": "hop_bytes",
        "type": "int64",
        "description": "Number of bytes to hop before each read. Default of 0 means using\nrecord_bytes.",
        "default": 0
      },
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
        "default": ""
      },
      {
        "name": "encoding",
        "type": "string",
        "description": "The type of encoding for the file. Currently ZLIB and GZIP\nare supported. Defaults to none.",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "reader_handle",
        "description": "The handle to reference the Reader.",
        "type": 20
      }
    ]
  },
  {
    "name": "FixedUnigramCandidateSampler",
    "summary": "Generates labels for candidate sampling with a learned unigram distribution.",
    "description": "A unigram sampler could use a fixed unigram distribution read from a\nfile or passed in as an in-memory array instead of building up the distribution\nfrom data on the fly. There is also an option to skew the distribution by\napplying a distortion power to the weights.\n\nThe vocabulary file should be in CSV-like format, with the last field\nbeing the weight associated with the word.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels.",
    "attributes": [
      {
        "name": "num_true",
        "type": "int64",
        "description": "Number of true labels per context.",
        "minimum": 1
      },
      {
        "name": "num_sampled",
        "type": "int64",
        "description": "Number of candidates to randomly sample.",
        "minimum": 1
      },
      {
        "name": "unique",
        "type": "boolean",
        "description": "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities."
      },
      {
        "name": "range_max",
        "type": "int64",
        "description": "The sampler will sample integers from the interval [0, range_max).",
        "minimum": 1
      },
      {
        "name": "vocab_file",
        "type": "string",
        "description": "Each valid line in this file (which should have a CSV-like format)\ncorresponds to a valid word ID. IDs are in sequential order, starting from\nnum_reserved_ids. The last entry in each line is expected to be a value\ncorresponding to the count or relative probability. Exactly one of vocab_file\nand unigrams needs to be passed to this op.",
        "default": ""
      },
      {
        "name": "distortion",
        "type": "float32",
        "description": "The distortion is used to skew the unigram probability distribution.\nEach weight is first raised to the distortion's power before adding to the\ninternal unigram distribution. As a result, distortion = 1.0 gives regular\nunigram sampling (as defined by the vocab file), and distortion = 0.0 gives\na uniform distribution.",
        "default": 1.0
      },
      {
        "name": "num_reserved_ids",
        "type": "int64",
        "description": "Optionally some reserved IDs can be added in the range [0,\n..., num_reserved_ids) by the users. One use case is that a special unknown\nword token is used as ID 0. These IDs will have a sampling probability of 0.",
        "default": 0
      },
      {
        "name": "num_shards",
        "type": "int64",
        "description": "A sampler can be used to sample from a subset of the original range\nin order to speed up the whole computation through parallelism. This parameter\n(together with 'shard') indicates the number of partitions that are being\nused in the overall computation.",
        "minimum": 1,
        "default": 1
      },
      {
        "name": "shard",
        "type": "int64",
        "description": "A sampler can be used to sample from a subset of the original range\nin order to speed up the whole computation through parallelism. This parameter\n(together with 'num_shards') indicates the particular partition number of a\nsampler op, when partitioning is being used.",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "unigrams",
        "type": "float32[]",
        "description": "A list of unigram counts or probabilities, one per ID in sequential\norder. Exactly one of vocab_file and unigrams should be passed to this op.",
        "default": []
      },
      {
        "name": "seed",
        "type": "int64",
        "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "description": "An second seed to avoid seed collision.",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "true_classes",
        "description": "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "sampled_candidates",
        "description": "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate.",
        "type": 9
      },
      {
        "name": "true_expected_count",
        "description": "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability.",
        "type": 1
      },
      {
        "name": "sampled_expected_count",
        "description": "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability.",
        "type": 1
      }
    ]
  },
  {
    "name": "FlatMapDataset",
    "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`.",
    "description": "Unlike MapDataset, the `f` in FlatMapDataset is expected to return a\nDataset variant, and FlatMapDataset will flatten successive results\ninto a single Dataset.",
    "attributes": [
      {
        "name": "f",
        "type": "function",
        "description": "A function mapping elements of `input_dataset`, concatenated with\n`other_arguments`, to a Dataset variant that contains elements matching\n`output_types` and `output_shapes`."
      },
      {
        "name": "Targuments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "other_arguments",
        "typeListAttr": "Targuments"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "Floor",
    "summary": "Returns element-wise largest integer not greater than x.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "FloorDiv",
    "summary": "Returns x // y element-wise.",
    "description": "*NOTE*: `FloorDiv` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `uint8`, `int8`, `uint16`, `int16`, `int32`, `uint32`, `uint64`, `int64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "FloorMod",
    "summary": "Returns element-wise remainder of division.",
    "description": "This follows Python semantics in that the\nresult here is consistent with a flooring divide. E.g.\n`floor(x / y) * y + floormod(x, y) = x`, regardless of the signs of x and y.\n\n*NOTE*: `FloorMod` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `uint32`, `uint64`, `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "FlushSummaryWriter",
    "inputs": [
      {
        "name": "writer",
        "type": 20
      }
    ]
  },
  {
    "name": "For",
    "summary": "Applies a for loop.",
    "description": "  ```python\n   output = input;\n   for i in range(start, limit, delta)\n     output = body(i, output);\n  ```",
    "attributes": [
      {
        "name": "T",
        "type": "type[]",
        "description": "A list of dtypes.",
        "minimum": 0
      },
      {
        "name": "body",
        "type": "function",
        "description": "    A function that takes a list of tensors (int32, T) and returns another\n    list of tensors (T)."
      }
    ],
    "inputs": [
      {
        "name": "start",
        "description": "The lower bound. An int32",
        "type": 3
      },
      {
        "name": "limit",
        "description": "The upper bound. An int32",
        "type": 3
      },
      {
        "name": "delta",
        "description": "The increment. An int32",
        "type": 3
      },
      {
        "name": "input",
        "description": "A list of input tensors whose types are T.",
        "typeListAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A list of output tensors whose types are T.",
        "typeListAttr": "T"
      }
    ]
  },
  {
    "name": "FractionalAvgPool",
    "summary": "Performs fractional average pooling on the input.",
    "description": "Fractional average pooling is similar to Fractional max pooling in the pooling\nregion generation step. The only difference is that after pooling regions are\ngenerated, a mean operation is performed instead of a max operation in each\npooling region.",
    "attributes": [
      {
        "name": "pooling_ratio",
        "type": "float32[]",
        "description": "Pooling ratio for each dimension of `value`, currently only\nsupports row and col dimension and should be >= 1.0. For example, a valid\npooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements\nmust be 1.0 because we don't allow pooling on batch and channels\ndimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions\nrespectively.",
        "minimum": 4
      },
      {
        "name": "pseudo_random",
        "type": "boolean",
        "description": "When set to True, generates the pooling sequence in a\npseudorandom fashion, otherwise, in a random fashion. Check paper [Benjamin\nGraham, Fractional Max-Pooling](http://arxiv.org/abs/1412.6071) for\ndifference between pseudorandom and random.",
        "default": false
      },
      {
        "name": "overlapping",
        "type": "boolean",
        "description": "When set to True, it means when pooling, the values at the boundary\nof adjacent pooling cells are used by both cells. For example:\n\n`index  0  1  2  3  4`\n\n`value  20 5  16 3  7`\n\nIf the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.\nThe result would be [41/3, 26/3] for fractional avg pooling.",
        "default": false
      },
      {
        "name": "deterministic",
        "type": "boolean",
        "description": "When set to True, a fixed pooling region will be used when\niterating over a FractionalAvgPool node in the computation graph. Mainly used\nin unit test to make FractionalAvgPool deterministic.",
        "default": false
      },
      {
        "name": "seed",
        "type": "int64",
        "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "description": "An second seed to avoid seed collision.",
        "default": 0
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "value",
        "description": "4-D with shape `[batch, height, width, channels]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "output tensor after fractional avg pooling.",
        "typeAttr": "T"
      },
      {
        "name": "row_pooling_sequence",
        "description": "row pooling sequence, needed to calculate gradient.",
        "type": 9
      },
      {
        "name": "col_pooling_sequence",
        "description": "column pooling sequence, needed to calculate gradient.",
        "type": 9
      }
    ]
  },
  {
    "name": "FractionalAvgPoolGrad",
    "summary": "Computes gradient of the FractionalAvgPool function.",
    "description": "Unlike FractionalMaxPoolGrad, we don't need to find arg_max for\nFractionalAvgPoolGrad, we just need to evenly back-propagate each element of\nout_backprop to those indices that form the same pooling cell. Therefore, we\njust need to know the shape of original input tensor, instead of the whole\ntensor.",
    "attributes": [
      {
        "name": "overlapping",
        "type": "boolean",
        "description": "When set to True, it means when pooling, the values at the boundary\nof adjacent pooling cells are used by both cells. For example:\n\n`index  0  1  2  3  4`\n\n`value  20 5  16 3  7`\n\nIf the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.\nThe result would be [41/3, 26/3] for fractional avg pooling.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "orig_input_tensor_shape",
        "description": "Original input tensor shape for `fractional_avg_pool`",
        "type": 9
      },
      {
        "name": "out_backprop",
        "description": "4-D with shape `[batch, height, width, channels]`.  Gradients\nw.r.t. the output of `fractional_avg_pool`.",
        "typeAttr": "T"
      },
      {
        "name": "row_pooling_sequence",
        "description": "row pooling sequence, form pooling region with\ncol_pooling_sequence.",
        "type": 9
      },
      {
        "name": "col_pooling_sequence",
        "description": "column pooling sequence, form pooling region with\nrow_pooling sequence.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "4-D.  Gradients w.r.t. the input of `fractional_avg_pool`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "FractionalMaxPool",
    "summary": "Performs fractional max pooling on the input.",
    "description": "Fractional max pooling is slightly different than regular max pooling.  In\nregular max pooling, you downsize an input set by taking the maximum value of\nsmaller N x N subsections of the set (often 2x2), and try to reduce the set by\na factor of N, where N is an integer.  Fractional max pooling, as you might\nexpect from the word \"fractional\", means that the overall reduction ratio N\ndoes not have to be an integer.\n\nThe sizes of the pooling regions are generated randomly but are fairly uniform.\nFor example, let's look at the height dimension, and the constraints on the\nlist of rows that will be pool boundaries.\n\nFirst we define the following:\n\n1.  input_row_length : the number of rows from the input set\n2.  output_row_length : which will be smaller than the input\n3.  alpha = input_row_length / output_row_length : our reduction ratio\n4.  K = floor(alpha)\n5.  row_pooling_sequence : this is the result list of pool boundary rows\n\nThen, row_pooling_sequence should satisfy:\n\n1.  a[0] = 0 : the first value of the sequence is 0\n2.  a[end] = input_row_length : the last value of the sequence is the size\n3.  K <= (a[i+1] - a[i]) <= K+1 : all intervals are K or K+1 size\n4.  length(row_pooling_sequence) = output_row_length+1\n\nFor more details on fractional max pooling, see this paper:\n[Benjamin Graham, Fractional Max-Pooling](http://arxiv.org/abs/1412.6071)",
    "attributes": [
      {
        "name": "pooling_ratio",
        "type": "float32[]",
        "description": "Pooling ratio for each dimension of `value`, currently only\nsupports row and col dimension and should be >= 1.0. For example, a valid\npooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements\nmust be 1.0 because we don't allow pooling on batch and channels\ndimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions\nrespectively.",
        "minimum": 4
      },
      {
        "name": "pseudo_random",
        "type": "boolean",
        "description": "When set to True, generates the pooling sequence in a\npseudorandom fashion, otherwise, in a random fashion. Check paper [Benjamin\nGraham, Fractional Max-Pooling](http://arxiv.org/abs/1412.6071) for\ndifference between pseudorandom and random.",
        "default": false
      },
      {
        "name": "overlapping",
        "type": "boolean",
        "description": "When set to True, it means when pooling, the values at the boundary\nof adjacent pooling cells are used by both cells. For example:\n\n`index  0  1  2  3  4`\n\n`value  20 5  16 3  7`\n\nIf the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.\nThe result would be [20, 16] for fractional max pooling.",
        "default": false
      },
      {
        "name": "deterministic",
        "type": "boolean",
        "description": "When set to True, a fixed pooling region will be used when\niterating over a FractionalMaxPool node in the computation graph. Mainly used\nin unit test to make FractionalMaxPool deterministic.",
        "default": false
      },
      {
        "name": "seed",
        "type": "int64",
        "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "description": "An second seed to avoid seed collision.",
        "default": 0
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "value",
        "description": "4-D with shape `[batch, height, width, channels]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "output tensor after fractional max pooling.",
        "typeAttr": "T"
      },
      {
        "name": "row_pooling_sequence",
        "description": "row pooling sequence, needed to calculate gradient.",
        "type": 9
      },
      {
        "name": "col_pooling_sequence",
        "description": "column pooling sequence, needed to calculate gradient.",
        "type": 9
      }
    ]
  },
  {
    "name": "FractionalMaxPoolGrad",
    "summary": "Computes gradient of the FractionalMaxPool function.",
    "attributes": [
      {
        "name": "overlapping",
        "type": "boolean",
        "description": "When set to True, it means when pooling, the values at the boundary\nof adjacent pooling cells are used by both cells. For example:\n\n`index  0  1  2  3  4`\n\n`value  20 5  16 3  7`\n\nIf the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.\nThe result would be [20, 16] for fractional max pooling.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "orig_input",
        "description": "Original input for `fractional_max_pool`",
        "typeAttr": "T"
      },
      {
        "name": "orig_output",
        "description": "Original output for `fractional_max_pool`",
        "typeAttr": "T"
      },
      {
        "name": "out_backprop",
        "description": "4-D with shape `[batch, height, width, channels]`.  Gradients\nw.r.t. the output of `fractional_max_pool`.",
        "typeAttr": "T"
      },
      {
        "name": "row_pooling_sequence",
        "description": "row pooling sequence, form pooling region with\ncol_pooling_sequence.",
        "type": 9
      },
      {
        "name": "col_pooling_sequence",
        "description": "column pooling sequence, form pooling region with\nrow_pooling sequence.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "4-D.  Gradients w.r.t. the input of `fractional_max_pool`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "FresnelCos",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "FresnelSin",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "FusedBatchNorm",
    "category": "Normalization",
    "summary": "Batch normalization.",
    "description": "Note that the size of 4D Tensors are defined by either \"NHWC\" or \"NCHW\".\nThe size of 1D Tensors matches the dimension C of the 4D Tensors.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "The data type for the elements of input and output Tensors. Must be one of the following: `float32`."
      },
      {
        "name": "epsilon",
        "type": "float32",
        "description": "A small float number added to the variance of x.",
        "default": 9.999999747378752e-05
      },
      {
        "name": "exponential_avg_factor",
        "type": "float32",
        "default": 1.0
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "The data format for x and y. Either \"NHWC\" (default) or \"NCHW\". Must be one of the following: `NHWC`, `NCHW`.",
        "default": "NHWC"
      },
      {
        "name": "is_training",
        "type": "boolean",
        "description": "A bool value to indicate the operation is for training (default)\nor inference.",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "A 4D Tensor for input data.",
        "typeAttr": "T"
      },
      {
        "name": "scale",
        "description": "A 1D Tensor for scaling factor, to scale the normalized x.",
        "typeAttr": "T"
      },
      {
        "name": "offset",
        "description": "A 1D Tensor for offset, to shift to the normalized x.",
        "typeAttr": "T"
      },
      {
        "name": "mean",
        "description": "A 1D Tensor for population mean. Used for inference only;\nmust be empty for training.",
        "typeAttr": "T"
      },
      {
        "name": "variance",
        "description": "A 1D Tensor for population variance. Used for inference only;\nmust be empty for training.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "description": "A 4D Tensor for output data.",
        "typeAttr": "T"
      },
      {
        "name": "batch_mean",
        "description": "A 1D Tensor for the computed batch mean, to be used by TensorFlow\nto compute the running mean.",
        "typeAttr": "T"
      },
      {
        "name": "batch_variance",
        "description": "A 1D Tensor for the computed batch variance, to be used by\nTensorFlow to compute the running variance.",
        "typeAttr": "T"
      },
      {
        "name": "reserve_space_1",
        "description": "A 1D Tensor for the computed batch mean, to be reused\nin the gradient computation.",
        "typeAttr": "T"
      },
      {
        "name": "reserve_space_2",
        "description": "A 1D Tensor for the computed batch variance (inverted variance\nin the cuDNN case), to be reused in the gradient computation.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "FusedBatchNormGrad",
    "summary": "Gradient for batch normalization.",
    "description": "Note that the size of 4D Tensors are defined by either \"NHWC\" or \"NCHW\".\nThe size of 1D Tensors matches the dimension C of the 4D Tensors.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "The data type for the elements of input and output Tensors. Must be one of the following: `float32`."
      },
      {
        "name": "epsilon",
        "type": "float32",
        "description": "A small float number added to the variance of x.",
        "default": 9.999999747378752e-05
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "The data format for y_backprop, x, x_backprop.\nEither \"NHWC\" (default) or \"NCHW\". Must be one of the following: `NHWC`, `NCHW`.",
        "default": "NHWC"
      },
      {
        "name": "is_training",
        "type": "boolean",
        "description": "A bool value to indicate the operation is for training (default)\nor inference.",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "y_backprop",
        "description": "A 4D Tensor for the gradient with respect to y.",
        "typeAttr": "T"
      },
      {
        "name": "x",
        "description": "A 4D Tensor for input data.",
        "typeAttr": "T"
      },
      {
        "name": "scale",
        "description": "A 1D Tensor for scaling factor, to scale the normalized x.",
        "typeAttr": "T"
      },
      {
        "name": "reserve_space_1",
        "description": "When is_training is True, a 1D Tensor for the computed batch\nmean to be reused in gradient computation. When is_training is\nFalse, a 1D Tensor for the population mean to be reused in both\n1st and 2nd order gradient computation.",
        "typeAttr": "T"
      },
      {
        "name": "reserve_space_2",
        "description": "When is_training is True, a 1D Tensor for the computed batch\nvariance (inverted variance in the cuDNN case) to be reused in\ngradient computation. When is_training is False, a 1D Tensor\nfor the population variance to be reused in both 1st and 2nd\norder gradient computation.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "x_backprop",
        "description": "A 4D Tensor for the gradient with respect to x.",
        "typeAttr": "T"
      },
      {
        "name": "scale_backprop",
        "description": "A 1D Tensor for the gradient with respect to scale.",
        "typeAttr": "T"
      },
      {
        "name": "offset_backprop",
        "description": "A 1D Tensor for the gradient with respect to offset.",
        "typeAttr": "T"
      },
      {
        "name": "reserve_space_3",
        "description": "Unused placeholder to match the mean input in FusedBatchNorm.",
        "typeAttr": "T"
      },
      {
        "name": "reserve_space_4",
        "description": "Unused placeholder to match the variance input\nin FusedBatchNorm.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "FusedBatchNormGradV2",
    "summary": "Gradient for batch normalization.",
    "description": "Note that the size of 4D Tensors are defined by either \"NHWC\" or \"NCHW\".\nThe size of 1D Tensors matches the dimension C of the 4D Tensors.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "The data type for the elements of input and output Tensors. Must be one of the following: `float16`, `bfloat16`, `float32`."
      },
      {
        "name": "U",
        "type": "type",
        "description": "The data type for the scale, offset, mean, and variance. Must be one of the following: `float32`."
      },
      {
        "name": "epsilon",
        "type": "float32",
        "description": "A small float number added to the variance of x.",
        "default": 9.999999747378752e-05
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "The data format for y_backprop, x, x_backprop.\nEither \"NHWC\" (default) or \"NCHW\". Must be one of the following: `NHWC`, `NCHW`.",
        "default": "NHWC"
      },
      {
        "name": "is_training",
        "type": "boolean",
        "description": "A bool value to indicate the operation is for training (default)\nor inference.",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "y_backprop",
        "description": "A 4D Tensor for the gradient with respect to y.",
        "typeAttr": "T"
      },
      {
        "name": "x",
        "description": "A 4D Tensor for input data.",
        "typeAttr": "T"
      },
      {
        "name": "scale",
        "description": "A 1D Tensor for scaling factor, to scale the normalized x.",
        "type": 1
      },
      {
        "name": "reserve_space_1",
        "description": "When is_training is True, a 1D Tensor for the computed batch\nmean to be reused in gradient computation. When is_training is\nFalse, a 1D Tensor for the population mean to be reused in both\n1st and 2nd order gradient computation.",
        "typeAttr": "U"
      },
      {
        "name": "reserve_space_2",
        "description": "When is_training is True, a 1D Tensor for the computed batch\nvariance (inverted variance in the cuDNN case) to be reused in\ngradient computation. When is_training is False, a 1D Tensor\nfor the population variance to be reused in both 1st and 2nd\norder gradient computation.",
        "typeAttr": "U"
      }
    ],
    "outputs": [
      {
        "name": "x_backprop",
        "description": "A 4D Tensor for the gradient with respect to x.",
        "typeAttr": "T"
      },
      {
        "name": "scale_backprop",
        "description": "A 1D Tensor for the gradient with respect to scale.",
        "typeAttr": "U"
      },
      {
        "name": "offset_backprop",
        "description": "A 1D Tensor for the gradient with respect to offset.",
        "typeAttr": "U"
      },
      {
        "name": "reserve_space_3",
        "description": "Unused placeholder to match the mean input in FusedBatchNorm.",
        "typeAttr": "U"
      },
      {
        "name": "reserve_space_4",
        "description": "Unused placeholder to match the variance input\nin FusedBatchNorm.",
        "typeAttr": "U"
      }
    ]
  },
  {
    "name": "FusedBatchNormGradV3",
    "summary": "Gradient for batch normalization.",
    "description": "Note that the size of 4D Tensors are defined by either \"NHWC\" or \"NCHW\".\nThe size of 1D Tensors matches the dimension C of the 4D Tensors.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "The data type for the elements of input and output Tensors. Must be one of the following: `float16`, `bfloat16`, `float32`."
      },
      {
        "name": "U",
        "type": "type",
        "description": "The data type for the scale, offset, mean, and variance. Must be one of the following: `float32`."
      },
      {
        "name": "epsilon",
        "type": "float32",
        "description": "A small float number added to the variance of x.",
        "default": 9.999999747378752e-05
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "The data format for y_backprop, x, x_backprop.\nEither \"NHWC\" (default) or \"NCHW\". Must be one of the following: `NHWC`, `NCHW`, `NDHWC`, `NCDHW`.",
        "default": "NHWC"
      },
      {
        "name": "is_training",
        "type": "boolean",
        "description": "A bool value to indicate the operation is for training (default)\nor inference.",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "y_backprop",
        "description": "A 4D Tensor for the gradient with respect to y.",
        "typeAttr": "T"
      },
      {
        "name": "x",
        "description": "A 4D Tensor for input data.",
        "typeAttr": "T"
      },
      {
        "name": "scale",
        "description": "A 1D Tensor for scaling factor, to scale the normalized x.",
        "type": 1
      },
      {
        "name": "reserve_space_1",
        "description": "When is_training is True, a 1D Tensor for the computed batch\nmean to be reused in gradient computation. When is_training is\nFalse, a 1D Tensor for the population mean to be reused in both\n1st and 2nd order gradient computation.",
        "typeAttr": "U"
      },
      {
        "name": "reserve_space_2",
        "description": "When is_training is True, a 1D Tensor for the computed batch\nvariance (inverted variance in the cuDNN case) to be reused in\ngradient computation. When is_training is False, a 1D Tensor\nfor the population variance to be reused in both 1st and 2nd\norder gradient computation.",
        "typeAttr": "U"
      },
      {
        "name": "reserve_space_3",
        "description": "When is_training is True, a 1D Tensor for some intermediate results to be reused\nin gradient computation. When is_training is False, a dummy empty Tensor will be\ncreated.",
        "typeAttr": "U"
      }
    ],
    "outputs": [
      {
        "name": "x_backprop",
        "description": "A 4D Tensor for the gradient with respect to x.",
        "typeAttr": "T"
      },
      {
        "name": "scale_backprop",
        "description": "A 1D Tensor for the gradient with respect to scale.",
        "typeAttr": "U"
      },
      {
        "name": "offset_backprop",
        "description": "A 1D Tensor for the gradient with respect to offset.",
        "typeAttr": "U"
      },
      {
        "name": "reserve_space_4",
        "description": "Unused placeholder to match the mean input in FusedBatchNorm.",
        "typeAttr": "U"
      },
      {
        "name": "reserve_space_5",
        "description": "Unused placeholder to match the variance input\nin FusedBatchNorm.",
        "typeAttr": "U"
      }
    ]
  },
  {
    "name": "FusedBatchNormV2",
    "category": "Normalization",
    "summary": "Batch normalization.",
    "description": "Note that the size of 4D Tensors are defined by either \"NHWC\" or \"NCHW\".\nThe size of 1D Tensors matches the dimension C of the 4D Tensors.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "The data type for the elements of input and output Tensors. Must be one of the following: `float16`, `bfloat16`, `float32`."
      },
      {
        "name": "U",
        "type": "type",
        "description": "The data type for the scale, offset, mean, and variance. Must be one of the following: `float32`."
      },
      {
        "name": "epsilon",
        "type": "float32",
        "description": "A small float number added to the variance of x.",
        "default": 9.999999747378752e-05
      },
      {
        "name": "exponential_avg_factor",
        "type": "float32",
        "default": 1.0
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "The data format for x and y. Either \"NHWC\" (default) or \"NCHW\". Must be one of the following: `NHWC`, `NCHW`.",
        "default": "NHWC"
      },
      {
        "name": "is_training",
        "type": "boolean",
        "description": "A bool value to indicate the operation is for training (default)\nor inference.",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "A 4D Tensor for input data.",
        "typeAttr": "T"
      },
      {
        "name": "scale",
        "description": "A 1D Tensor for scaling factor, to scale the normalized x.",
        "typeAttr": "U"
      },
      {
        "name": "offset",
        "description": "A 1D Tensor for offset, to shift to the normalized x.",
        "typeAttr": "U"
      },
      {
        "name": "mean",
        "description": "A 1D Tensor for population mean. Used for inference only;\nmust be empty for training.",
        "typeAttr": "U"
      },
      {
        "name": "variance",
        "description": "A 1D Tensor for population variance. Used for inference only;\nmust be empty for training.",
        "typeAttr": "U"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "description": "A 4D Tensor for output data.",
        "typeAttr": "T"
      },
      {
        "name": "batch_mean",
        "description": "A 1D Tensor for the computed batch mean, to be used by TensorFlow\nto compute the running mean.",
        "typeAttr": "U"
      },
      {
        "name": "batch_variance",
        "description": "A 1D Tensor for the computed batch variance, to be used by\nTensorFlow to compute the running variance.",
        "typeAttr": "U"
      },
      {
        "name": "reserve_space_1",
        "description": "A 1D Tensor for the computed batch mean, to be reused\nin the gradient computation.",
        "typeAttr": "U"
      },
      {
        "name": "reserve_space_2",
        "description": "A 1D Tensor for the computed batch variance (inverted variance\nin the cuDNN case), to be reused in the gradient computation.",
        "typeAttr": "U"
      }
    ]
  },
  {
    "name": "FusedBatchNormV3",
    "category": "Normalization",
    "summary": "Batch normalization.",
    "description": "Note that the size of 4D Tensors are defined by either \"NHWC\" or \"NCHW\".\nThe size of 1D Tensors matches the dimension C of the 4D Tensors.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "The data type for the elements of input and output Tensors. Must be one of the following: `float16`, `bfloat16`, `float32`."
      },
      {
        "name": "U",
        "type": "type",
        "description": "The data type for the scale, offset, mean, and variance. Must be one of the following: `bfloat16`, `float32`."
      },
      {
        "name": "epsilon",
        "type": "float32",
        "description": "A small float number added to the variance of x.",
        "default": 9.999999747378752e-05
      },
      {
        "name": "exponential_avg_factor",
        "type": "float32",
        "default": 1.0
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "The data format for x and y. Either \"NHWC\" (default) or \"NCHW\". Must be one of the following: `NHWC`, `NCHW`, `NDHWC`, `NCDHW`.",
        "default": "NHWC"
      },
      {
        "name": "is_training",
        "type": "boolean",
        "description": "A bool value to indicate the operation is for training (default)\nor inference.",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "A 4D Tensor for input data.",
        "typeAttr": "T"
      },
      {
        "name": "scale",
        "description": "A 1D Tensor for scaling factor, to scale the normalized x.",
        "typeAttr": "U"
      },
      {
        "name": "offset",
        "description": "A 1D Tensor for offset, to shift to the normalized x.",
        "typeAttr": "U"
      },
      {
        "name": "mean",
        "description": "A 1D Tensor for population mean. Used for inference only;\nmust be empty for training.",
        "typeAttr": "U"
      },
      {
        "name": "variance",
        "description": "A 1D Tensor for population variance. Used for inference only;\nmust be empty for training.",
        "typeAttr": "U"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "description": "A 4D Tensor for output data.",
        "typeAttr": "T"
      },
      {
        "name": "batch_mean",
        "description": "A 1D Tensor for the computed batch mean, to be used by TensorFlow\nto compute the running mean.",
        "typeAttr": "U"
      },
      {
        "name": "batch_variance",
        "description": "A 1D Tensor for the computed batch variance, to be used by\nTensorFlow to compute the running variance.",
        "typeAttr": "U"
      },
      {
        "name": "reserve_space_1",
        "description": "A 1D Tensor for the computed batch mean, to be reused\nin the gradient computation.",
        "typeAttr": "U"
      },
      {
        "name": "reserve_space_2",
        "description": "A 1D Tensor for the computed batch variance (inverted variance\nin the cuDNN case), to be reused in the gradient computation.",
        "typeAttr": "U"
      },
      {
        "name": "reserve_space_3",
        "description": "A 1D Tensor for some intermediate results, to be reused in the gradient\ncomputation for better efficiency.",
        "typeAttr": "U"
      }
    ]
  },
  {
    "name": "FusedPadConv2D",
    "summary": "Performs a padding as a preprocess during a convolution.",
    "description": "Similar to FusedResizeAndPadConv2d, this op allows for an optimized\nimplementation where the spatial padding transformation stage is fused with the\nim2col lookup, but in this case without the bilinear filtering required for\nresizing. Fusing the padding prevents the need to write out the intermediate\nresults as whole tensors, reducing memory pressure, and we can get some latency\ngains by merging the transformation calculations.\nThe data_format attribute for Conv2D isn't supported by this op, and 'NHWC'\norder is used instead.\nInternally this op uses a single per-graph scratch buffer, which means that it\nwill block if multiple versions are being run in parallel. This is because this\noperator is primarily an optimization to minimize memory usage.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      },
      {
        "name": "mode",
        "type": "string",
        "description": "Must be one of the following: `REFLECT`, `SYMMETRIC`."
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "1-D of length 4.  The stride of the sliding window for each dimension\nof `input`. Must be in the same order as the dimension specified with format."
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "4-D with shape `[batch, in_height, in_width, in_channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "paddings",
        "description": "A two-column matrix specifying the padding sizes. The number of\nrows must be the same as the rank of `input`.",
        "type": 3
      },
      {
        "name": "filter",
        "description": "4-D with shape\n`[filter_height, filter_width, in_channels, out_channels]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "FusedResizeAndPadConv2D",
    "summary": "Performs a resize and padding as a preprocess during a convolution.",
    "description": "It's often possible to do spatial transformations more efficiently as part of\nthe packing stage of a convolution, so this op allows for an optimized\nimplementation where these stages are fused together. This prevents the need to\nwrite out the intermediate results as whole tensors, reducing memory pressure,\nand we can get some latency gains by merging the transformation calculations.\nThe data_format attribute for Conv2D isn't supported by this op, and defaults to\n'NHWC' order.\nInternally this op uses a single per-graph scratch buffer, which means that it\nwill block if multiple versions are being run in parallel. This is because this\noperator is primarily an optimization to minimize memory usage.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`, `float64`."
      },
      {
        "name": "resize_align_corners",
        "type": "boolean",
        "description": "If true, the centers of the 4 corner pixels of the input and output tensors are\naligned, preserving the values at the corner pixels. Defaults to false.",
        "default": false
      },
      {
        "name": "mode",
        "type": "string",
        "description": "Must be one of the following: `REFLECT`, `SYMMETRIC`."
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "1-D of length 4.  The stride of the sliding window for each dimension\nof `input`. Must be in the same order as the dimension specified with format."
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "4-D with shape `[batch, in_height, in_width, in_channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "size",
        "description": "A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images.",
        "type": 3
      },
      {
        "name": "paddings",
        "description": "A two-column matrix specifying the padding sizes. The number of\nrows must be the same as the rank of `input`.",
        "type": 3
      },
      {
        "name": "filter",
        "description": "4-D with shape\n`[filter_height, filter_width, in_channels, out_channels]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "GRUBlockCell",
    "summary": "Computes the GRU cell forward propagation for 1 time step.",
    "description": "Args\n    x: Input to the GRU cell.\n    h_prev: State input from the previous GRU cell.\n    w_ru: Weight matrix for the reset and update gate.\n    w_c: Weight matrix for the cell connection gate.\n    b_ru: Bias vector for the reset and update gate.\n    b_c: Bias vector for the cell connection gate.\n\nReturns\n    r: Output of the reset gate.\n    u: Output of the update gate.\n    c: Output of the cell connection gate.\n    h: Current state of the GRU cell.\n\nNote on notation of the variables:\n\nConcatenation of a and b is represented by a_b\nElement-wise dot product of a and b is represented by ab\nElement-wise dot product is represented by \\circ\nMatrix multiplication is represented by *\n\nBiases are initialized with :\n`b_ru` - constant_initializer(1.0)\n`b_c` - constant_initializer(0.0)\n\nThis kernel op implements the following mathematical equations:\n\n```\nx_h_prev = [x, h_prev]\n\n[r_bar u_bar] = x_h_prev * w_ru + b_ru\n\nr = sigmoid(r_bar)\nu = sigmoid(u_bar)\n\nh_prevr = h_prev \\circ r\n\nx_h_prevr = [x h_prevr]\n\nc_bar = x_h_prevr * w_c + b_c\nc = tanh(c_bar)\n\nh = (1-u) \\circ c + u \\circ h_prev\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "h_prev",
        "typeAttr": "T"
      },
      {
        "name": "w_ru",
        "typeAttr": "T"
      },
      {
        "name": "w_c",
        "typeAttr": "T"
      },
      {
        "name": "b_ru",
        "typeAttr": "T"
      },
      {
        "name": "b_c",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "r",
        "typeAttr": "T"
      },
      {
        "name": "u",
        "typeAttr": "T"
      },
      {
        "name": "c",
        "typeAttr": "T"
      },
      {
        "name": "h",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "GRUBlockCellGrad",
    "summary": "Computes the GRU cell back-propagation for 1 time step.",
    "description": "Args\n    x: Input to the GRU cell.\n    h_prev: State input from the previous GRU cell.\n    w_ru: Weight matrix for the reset and update gate.\n    w_c: Weight matrix for the cell connection gate.\n    b_ru: Bias vector for the reset and update gate.\n    b_c: Bias vector for the cell connection gate.\n    r: Output of the reset gate.\n    u: Output of the update gate.\n    c: Output of the cell connection gate.\n    d_h: Gradients of the h_new wrt to objective function.\n\nReturns\n    d_x: Gradients of the x wrt to objective function.\n    d_h_prev: Gradients of the h wrt to objective function.\n    d_c_bar Gradients of the c_bar wrt to objective function.\n    d_r_bar_u_bar Gradients of the r_bar & u_bar wrt to objective function.\n\nThis kernel op implements the following mathematical equations:\n\nNote on notation of the variables:\n\nConcatenation of a and b is represented by a_b\nElement-wise dot product of a and b is represented by ab\nElement-wise dot product is represented by \\circ\nMatrix multiplication is represented by *\n\nAdditional notes for clarity:\n\n`w_ru` can be segmented into 4 different matrices.\n```\nw_ru = [w_r_x w_u_x\n        w_r_h_prev w_u_h_prev]\n```\nSimilarly, `w_c` can be segmented into 2 different matrices.\n```\nw_c = [w_c_x w_c_h_prevr]\n```\nSame goes for biases.\n```\nb_ru = [b_ru_x b_ru_h]\nb_c = [b_c_x b_c_h]\n```\nAnother note on notation:\n```\nd_x = d_x_component_1 + d_x_component_2\n\nwhere d_x_component_1 = d_r_bar * w_r_x^T + d_u_bar * w_r_x^T\nand d_x_component_2 = d_c_bar * w_c_x^T\n\nd_h_prev = d_h_prev_component_1 + d_h_prevr \\circ r + d_h \\circ u\nwhere d_h_prev_componenet_1 = d_r_bar * w_r_h_prev^T + d_u_bar * w_r_h_prev^T\n```\n\nMathematics behind the Gradients below:\n```\nd_c_bar = d_h \\circ (1-u) \\circ (1-c \\circ c)\nd_u_bar = d_h \\circ (h-c) \\circ u \\circ (1-u)\n\nd_r_bar_u_bar = [d_r_bar d_u_bar]\n\n[d_x_component_1 d_h_prev_component_1] = d_r_bar_u_bar * w_ru^T\n\n[d_x_component_2 d_h_prevr] = d_c_bar * w_c^T\n\nd_x = d_x_component_1 + d_x_component_2\n\nd_h_prev = d_h_prev_component_1 + d_h_prevr \\circ r + u\n```\nBelow calculation is performed in the python wrapper for the Gradients\n(not in the gradient kernel.)\n```\nd_w_ru = x_h_prevr^T * d_c_bar\n\nd_w_c = x_h_prev^T * d_r_bar_u_bar\n\nd_b_ru = sum of d_r_bar_u_bar along axis = 0\n\nd_b_c = sum of d_c_bar along axis = 0\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "h_prev",
        "typeAttr": "T"
      },
      {
        "name": "w_ru",
        "typeAttr": "T"
      },
      {
        "name": "w_c",
        "typeAttr": "T"
      },
      {
        "name": "b_ru",
        "typeAttr": "T"
      },
      {
        "name": "b_c",
        "typeAttr": "T"
      },
      {
        "name": "r",
        "typeAttr": "T"
      },
      {
        "name": "u",
        "typeAttr": "T"
      },
      {
        "name": "c",
        "typeAttr": "T"
      },
      {
        "name": "d_h",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "d_x",
        "typeAttr": "T"
      },
      {
        "name": "d_h_prev",
        "typeAttr": "T"
      },
      {
        "name": "d_c_bar",
        "typeAttr": "T"
      },
      {
        "name": "d_r_bar_u_bar",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Gather",
    "category": "Transform",
    "summary": "Gather slices from `params` according to `indices`.",
    "description": "`indices` must be an integer tensor of any dimension (usually 0-D or 1-D).\nProduces an output tensor with shape `indices.shape + params.shape[1:]` where:\n\n```python\n    # Scalar indices\n    output[:, ..., :] = params[indices, :, ... :]\n\n    # Vector indices\n    output[i, :, ..., :] = params[indices[i], :, ... :]\n\n    # Higher rank indices\n    output[i, ..., j, :, ... :] = params[indices[i, ..., j], :, ..., :]\n```\n\nIf `indices` is a permutation and `len(indices) == params.shape[0]` then\nthis operation will permute `params` accordingly.\n\n`validate_indices`: DEPRECATED. If this operation is assigned to CPU, values in\n`indices` are always validated to be within range. If assigned to GPU,\nout-of-bound indices result in safe but unspecified behavior, which may include\nraising an error.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/Gather.png\" alt>\n</div>",
    "attributes": [
      {
        "name": "validate_indices",
        "type": "boolean",
        "default": true
      },
      {
        "name": "Tparams",
        "type": "type"
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "params",
        "typeAttr": "Tparams"
      },
      {
        "name": "indices",
        "typeAttr": "Tindices"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "Tparams"
      }
    ]
  },
  {
    "name": "GatherNd",
    "summary": "Gather slices from `params` into a Tensor with shape specified by `indices`.",
    "description": "`indices` is a K-dimensional integer tensor, best thought of as a\n(K-1)-dimensional tensor of indices into `params`, where each element defines a\nslice of `params`:\n\n    output[\\\\(i_0, ..., i_{K-2}\\\\)] = params[indices[\\\\(i_0, ..., i_{K-2}\\\\)]]\n\nWhereas in `tf.gather` `indices` defines slices into the `axis`\ndimension of `params`, in `tf.gather_nd`, `indices` defines slices into the\nfirst `N` dimensions of `params`, where `N = indices.shape[-1]`.\n\nThe last dimension of `indices` can be at most the rank of\n`params`:\n\n    indices.shape[-1] <= params.rank\n\nThe last dimension of `indices` corresponds to elements\n(if `indices.shape[-1] == params.rank`) or slices\n(if `indices.shape[-1] < params.rank`) along dimension `indices.shape[-1]`\nof `params`.  The output tensor has shape\n\n    indices.shape[:-1] + params.shape[indices.shape[-1]:]\n\nNote that on CPU, if an out of bound index is found, an error is returned.\nOn GPU, if an out of bound index is found, a 0 is stored in the\ncorresponding output value.\n\nSome examples below.\n\nSimple indexing into a matrix:\n\n```python\n    indices = [[0, 0], [1, 1]]\n    params = [['a', 'b'], ['c', 'd']]\n    output = ['a', 'd']\n```\n\nSlice indexing into a matrix:\n\n```python\n    indices = [[1], [0]]\n    params = [['a', 'b'], ['c', 'd']]\n    output = [['c', 'd'], ['a', 'b']]\n```\n\nIndexing into a 3-tensor:\n\n```python\n    indices = [[1]]\n    params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n    output = [[['a1', 'b1'], ['c1', 'd1']]]\n\n\n    indices = [[0, 1], [1, 0]]\n    params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n    output = [['c0', 'd0'], ['a1', 'b1']]\n\n\n    indices = [[0, 0, 1], [1, 0, 1]]\n    params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n    output = ['b0', 'b1']\n```\n\nBatched indexing into a matrix:\n\n```python\n    indices = [[[0, 0]], [[0, 1]]]\n    params = [['a', 'b'], ['c', 'd']]\n    output = [['a'], ['b']]\n```\n\nBatched slice indexing into a matrix:\n\n```python\n    indices = [[[1]], [[0]]]\n    params = [['a', 'b'], ['c', 'd']]\n    output = [[['c', 'd']], [['a', 'b']]]\n```\n\nBatched indexing into a 3-tensor:\n\n```python\n    indices = [[[1]], [[0]]]\n    params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n    output = [[[['a1', 'b1'], ['c1', 'd1']]],\n              [[['a0', 'b0'], ['c0', 'd0']]]]\n\n    indices = [[[0, 1], [1, 0]], [[0, 0], [1, 1]]]\n    params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n    output = [[['c0', 'd0'], ['a1', 'b1']],\n              [['a0', 'b0'], ['c1', 'd1']]]\n\n\n    indices = [[[0, 0, 1], [1, 0, 1]], [[0, 1, 1], [1, 1, 0]]]\n    params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n    output = [['b0', 'b1'], ['d0', 'c1']]\n```\n\nSee also `tf.gather` and `tf.batch_gather`.",
    "attributes": [
      {
        "name": "Tparams",
        "type": "type"
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int16`, `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "params",
        "description": "The tensor from which to gather values.",
        "typeAttr": "Tparams"
      },
      {
        "name": "indices",
        "description": "Index tensor.",
        "typeAttr": "Tindices"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Values from `params` gathered from indices given by `indices`, with\nshape `indices.shape[:-1] + params.shape[indices.shape[-1]:]`.",
        "typeAttr": "Tparams"
      }
    ]
  },
  {
    "name": "GatherV2",
    "summary": "Gather slices from `params` axis `axis` according to `indices`.",
    "description": "`indices` must be an integer tensor of any dimension (usually 0-D or 1-D).\nProduces an output tensor with shape `params.shape[:axis] +\nindices.shape[batch_dims:] + params.shape[axis + 1:]` where:\n\n```python\n    # Scalar indices (output is rank(params) - 1).\n    output[a_0, ..., a_n, b_0, ..., b_n] =\n      params[a_0, ..., a_n, indices, b_0, ..., b_n]\n\n    # Vector indices (output is rank(params)).\n    output[a_0, ..., a_n, i, b_0, ..., b_n] =\n      params[a_0, ..., a_n, indices[i], b_0, ..., b_n]\n\n    # Higher rank indices (output is rank(params) + rank(indices) - 1).\n    output[a_0, ..., a_n, i, ..., j, b_0, ... b_n] =\n      params[a_0, ..., a_n, indices[i, ..., j], b_0, ..., b_n]\n```\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/Gather.png\" alt>\n</div>\n\nNote that on CPU, if an out of bound index is found, an error is returned.\nOn GPU, if an out of bound index is found, a 0 is stored in the\ncorresponding output value.\n\nSee also `tf.batch_gather` and `tf.gather_nd`.",
    "attributes": [
      {
        "name": "batch_dims",
        "type": "int64",
        "default": 0
      },
      {
        "name": "Tparams",
        "type": "type"
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int16`, `int32`, `int64`."
      },
      {
        "name": "Taxis",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "params",
        "description": "The tensor from which to gather values. Must be at least rank\n`axis + 1`.",
        "typeAttr": "Tparams"
      },
      {
        "name": "indices",
        "description": "Index tensor. Must be in range `[0, params.shape[axis])`.",
        "typeAttr": "Tindices"
      },
      {
        "name": "axis",
        "description": "The axis in `params` to gather `indices` from. Defaults to the first\ndimension. Supports negative indexes.",
        "typeAttr": "Taxis"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Values from `params` gathered from indices given by `indices`, with\nshape `params.shape[:axis] + indices.shape + params.shape[axis + 1:]`.",
        "typeAttr": "Tparams"
      }
    ]
  },
  {
    "name": "GenerateBoundingBoxProposals",
    "summary": "This op produces Region of Interests from given bounding boxes(bbox_deltas) encoded wrt anchors according to eq.2 in arXiv:1506.01497",
    "description": "      The op selects top `pre_nms_topn` scoring boxes, decodes them with respect to anchors,\n      applies non-maximal suppression on overlapping boxes with higher than\n      `nms_threshold` intersection-over-union (iou) value, discarding boxes where shorter\n      side is less than `min_size`.\n      Inputs:\n      `scores`: A 4D tensor of shape [Batch, Height, Width, Num Anchors] containing the scores per anchor at given position\n      `bbox_deltas`: is a tensor of shape [Batch, Height, Width, 4 x Num Anchors] boxes encoded to each anchor\n      `anchors`: A 1D tensor of shape [4 x Num Anchors], representing the anchors.\n      Outputs:\n      `rois`: output RoIs, a 3D tensor of shape [Batch, post_nms_topn, 4], padded by 0 if less than post_nms_topn candidates found.\n      `roi_probabilities`: probability scores of each roi in 'rois', a 2D tensor of shape [Batch,post_nms_topn], padded with 0 if needed, sorted by scores.",
    "attributes": [
      {
        "name": "post_nms_topn",
        "type": "int64",
        "description": "An integer. Maximum number of rois in the output.",
        "default": 300
      }
    ],
    "inputs": [
      {
        "name": "scores",
        "description": "A 4-D float tensor of shape `[num_images, height, width, num_achors]` containing scores of the boxes for given anchors, can be unsorted.",
        "type": 1
      },
      {
        "name": "bbox_deltas",
        "description": "A 4-D float tensor of shape `[num_images, height, width, 4 x num_anchors]`. encoding boxes with respec to each anchor.\nCoordinates are given in the form [dy, dx, dh, dw].",
        "type": 1
      },
      {
        "name": "image_info",
        "description": "A 2-D float tensor of shape `[num_images, 5]` containing image information Height, Width, Scale.",
        "type": 1
      },
      {
        "name": "anchors",
        "description": "A 2-D float tensor of shape `[num_anchors, 4]` describing the anchor boxes. Boxes are formatted in the form [y1, x1, y2, x2].",
        "type": 1
      },
      {
        "name": "nms_threshold",
        "description": "A scalar float tensor for non-maximal-suppression threshold.",
        "type": 1
      },
      {
        "name": "pre_nms_topn",
        "description": "A scalar int tensor for the number of top scoring boxes to be used as input.",
        "type": 3
      },
      {
        "name": "min_size",
        "description": "A scalar float tensor. Any box that has a smaller size than min_size will be discarded.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "rois",
        "description": "A 3-D float tensor of shape `[num_images,post_nms_topn,4]` representing the selected\nregion of interest boxes. Sorted in descending order in scores.",
        "type": 1
      },
      {
        "name": "roi_probabilities",
        "description": "A 2-D float tensor of shape `[num_images, post_nms_topn]` representing the score of the\nregion of interest box in `rois` tensor at the same index.",
        "type": 1
      }
    ]
  },
  {
    "name": "GenerateVocabRemapping",
    "summary": "Given a path to new and old vocabulary files, returns a remapping Tensor of",
    "description": "length `num_new_vocab`, where `remapping[i]` contains the row number in the old\nvocabulary that corresponds to row `i` in the new vocabulary (starting at line\n`new_vocab_offset` and up to `num_new_vocab` entities), or `-1` if entry `i`\nin the new vocabulary is not in the old vocabulary.  The old vocabulary is\nconstrained to the first `old_vocab_size` entries if `old_vocab_size` is not the\ndefault value of -1.\n\n`num_vocab_offset` enables\nuse in the partitioned variable case, and should generally be set through\nexamining partitioning info.  The format of the files should be a text file,\nwith each line containing a single entity within the vocabulary.\n\nFor example, with `new_vocab_file` a text file containing each of the following\nelements on a single line: `[f0, f1, f2, f3]`, old_vocab_file = [f1, f0, f3],\n`num_new_vocab = 3, new_vocab_offset = 1`, the returned remapping would be\n`[0, -1, 2]`.\n\nThe op also returns a count of how many entries in the new vocabulary\nwere present in the old vocabulary, which is used to calculate the number of\nvalues to initialize in a weight matrix remapping\n\nThis functionality can be used to remap both row vocabularies (typically,\nfeatures) and column vocabularies (typically, classes) from TensorFlow\ncheckpoints.  Note that the partitioning logic relies on contiguous vocabularies\ncorresponding to div-partitioned variables.  Moreover, the underlying remapping\nuses an IndexTable (as opposed to an inexact CuckooTable), so client code should\nuse the corresponding index_table_from_file() as the FeatureColumn framework\ndoes (as opposed to tf.feature_to_id(), which uses a CuckooTable).",
    "attributes": [
      {
        "name": "new_vocab_offset",
        "type": "int64",
        "description": "How many entries into the new vocab file to start reading.",
        "minimum": 0
      },
      {
        "name": "num_new_vocab",
        "type": "int64",
        "description": "Number of entries in the new vocab file to remap.",
        "minimum": 0
      },
      {
        "name": "old_vocab_size",
        "type": "int64",
        "description": "Number of entries in the old vocab file to consider.  If -1,\nuse the entire old vocabulary.",
        "minimum": -1,
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "new_vocab_file",
        "description": "Path to the new vocab file.",
        "type": 7
      },
      {
        "name": "old_vocab_file",
        "description": "Path to the old vocab file.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "remapping",
        "description": "A Tensor of length num_new_vocab where the element at index i\nis equal to the old ID that maps to the new ID i.  This element is -1 for any\nnew ID that is not found in the old vocabulary.",
        "type": 9
      },
      {
        "name": "num_present",
        "description": "Number of new vocab entries found in old vocab.",
        "type": 3
      }
    ]
  },
  {
    "name": "GeneratorDataset",
    "summary": "Creates a dataset that invokes a function to generate elements.",
    "attributes": [
      {
        "name": "init_func",
        "type": "function"
      },
      {
        "name": "next_func",
        "type": "function"
      },
      {
        "name": "finalize_func",
        "type": "function"
      },
      {
        "name": "Tinit_func_args",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "Tnext_func_args",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "Tfinalize_func_args",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "init_func_other_args",
        "typeListAttr": "Tinit_func_args"
      },
      {
        "name": "next_func_other_args",
        "typeListAttr": "Tnext_func_args"
      },
      {
        "name": "finalize_func_other_args",
        "typeListAttr": "Tfinalize_func_args"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "GetElementAtIndex",
    "summary": "Gets the element at the specified index in a dataset.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "dataset",
        "type": 21
      },
      {
        "name": "index",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "components",
        "typeListAttr": "output_types"
      }
    ]
  },
  {
    "name": "GetMinibatchSplitsWithPhysicalReplica",
    "attributes": [
      {
        "name": "sample_count",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "num_replica",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "table_vocab_size",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "feature_width",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "num_sc_per_chip",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "table_name",
        "type": "string"
      },
      {
        "name": "mini_batch_splits",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "name": "program_key",
        "type": 7
      },
      {
        "name": "row_ids",
        "type": 3
      },
      {
        "name": "col_ids",
        "type": 3
      },
      {
        "name": "gains",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "sorted_row_ids",
        "type": 3
      },
      {
        "name": "sorted_col_ids",
        "type": 3
      },
      {
        "name": "sorted_gains",
        "type": 1
      },
      {
        "name": "splits",
        "type": 9
      },
      {
        "name": "id_counts",
        "type": 3
      },
      {
        "name": "max_ids",
        "type": 3
      },
      {
        "name": "max_uniques",
        "type": 3
      }
    ]
  },
  {
    "name": "GetMinibatchesInCsrWithPhysicalReplica",
    "attributes": [
      {
        "name": "sample_count",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "num_replica",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "max_minibatches_per_sc",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "max_ids_per_chip_per_sample",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "table_vocab_size",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "feature_width",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "num_sc_per_chip",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "table_name",
        "type": "string"
      },
      {
        "name": "mini_batch_in_csr",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "name": "program_key",
        "type": 7
      },
      {
        "name": "row_ids",
        "type": 3
      },
      {
        "name": "col_ids",
        "type": 3
      },
      {
        "name": "gains",
        "type": 1
      },
      {
        "name": "splits",
        "type": 9
      },
      {
        "name": "id_counts",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "row_pointers",
        "type": 3
      },
      {
        "name": "sorted_sample_ids",
        "type": 3
      },
      {
        "name": "sorted_token_ids",
        "type": 3
      },
      {
        "name": "sorted_gains",
        "type": 1
      },
      {
        "name": "row_pointers_unpadded_size",
        "type": 3
      },
      {
        "name": "ids_unpadded_size",
        "type": 3
      },
      {
        "name": "num_minibatches_per_physical_sparse_core",
        "type": 3
      }
    ]
  },
  {
    "name": "GetOptions",
    "summary": "Returns the `tf.data.Options` attached to `input_dataset`.",
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the input dataset.",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "serialized_options",
        "type": 7
      }
    ]
  },
  {
    "name": "GetSessionHandle",
    "summary": "Store the input tensor in the state of the current session.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "value",
        "description": "The tensor to be stored.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "The handle for the tensor stored in the session state, represented\nas a string.",
        "type": 7
      }
    ]
  },
  {
    "name": "GetSessionHandleV2",
    "summary": "Store the input tensor in the state of the current session.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "value",
        "description": "The tensor to be stored.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "The handle for the tensor stored in the session state, represented\nas a ResourceHandle object.",
        "type": 20
      }
    ]
  },
  {
    "name": "GetSessionTensor",
    "summary": "Get the value of the tensor specified by its handle.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output value."
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle for a tensor stored in the session state.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "value",
        "description": "The tensor for the given handle.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "GetStatsFromListOfSparseCoreCooTensors",
    "attributes": [
      {
        "name": "sample_count_list",
        "type": "int64[]"
      },
      {
        "name": "col_offset_list",
        "type": "int64[]"
      },
      {
        "name": "num_replica",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "table_vocab_size",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "feature_width",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "num_sc_per_chip",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "table_name",
        "type": "string"
      },
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "row_ids_list",
        "numberAttr": "N",
        "type": 3
      },
      {
        "name": "col_ids_list",
        "numberAttr": "N",
        "type": 3
      },
      {
        "name": "gains_list",
        "numberAttr": "N",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "max_ids_per_sparse_core",
        "type": 3
      },
      {
        "name": "max_unique_ids_per_sparse_core",
        "type": 3
      }
    ]
  },
  {
    "name": "GlobalIterId",
    "outputs": [
      {
        "name": "iter_id",
        "type": 9
      }
    ]
  },
  {
    "name": "GlobalShuffleDataset",
    "attributes": [
      {
        "name": "reshuffle_each_iteration",
        "type": "boolean",
        "default": true
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "seed",
        "type": 9
      },
      {
        "name": "seed2",
        "type": 9
      },
      {
        "name": "seed_generator",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "Greater",
    "summary": "Returns the truth value of (x > y) element-wise.",
    "description": "*NOTE*: `Greater` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)\n\nExample:\n\n```python\nx = tf.constant([5, 4, 6])\ny = tf.constant([5, 2, 5])\ntf.math.greater(x, y) ==> [False, True, True]\n\nx = tf.constant([5, 4, 6])\ny = tf.constant([5])\ntf.math.greater(x, y) ==> [False, False, True]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "type": 10
      }
    ]
  },
  {
    "name": "GreaterEqual",
    "summary": "Returns the truth value of (x >= y) element-wise.",
    "description": "*NOTE*: `GreaterEqual` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)\n\nExample:\n\n```python\nx = tf.constant([5, 4, 6, 7])\ny = tf.constant([5, 2, 5, 10])\ntf.math.greater_equal(x, y) ==> [True, True, True, False]\n\nx = tf.constant([5, 4, 6, 7])\ny = tf.constant([5])\ntf.math.greater_equal(x, y) ==> [True, False, True, True]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "type": 10
      }
    ]
  },
  {
    "name": "GroupByReducerDataset",
    "summary": "Creates a dataset that computes a group-by on `input_dataset`.",
    "description": "Creates a dataset that computes a group-by on `input_dataset`.",
    "attributes": [
      {
        "name": "key_func",
        "type": "function",
        "description": "A function mapping an element of `input_dataset`, concatenated\nwith `key_func_other_arguments` to a scalar value of type DT_INT64."
      },
      {
        "name": "init_func",
        "type": "function",
        "description": "A function mapping a key of type DT_INT64, concatenated with\n`init_func_other_arguments` to the initial reducer state."
      },
      {
        "name": "reduce_func",
        "type": "function",
        "description": "A function mapping the current reducer state and an element of `input_dataset`,\nconcatenated with `reduce_func_other_arguments` to a new reducer state."
      },
      {
        "name": "finalize_func",
        "type": "function",
        "description": "A function mapping the final reducer state to an output element."
      },
      {
        "name": "Tkey_func_other_arguments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "Tinit_func_other_arguments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "Treduce_func_other_arguments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "Tfinalize_func_other_arguments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the input dataset.",
        "type": 21
      },
      {
        "name": "key_func_other_arguments",
        "description": "A list of tensors, typically values that were captured when\nbuilding a closure for `key_func`.",
        "typeListAttr": "Tkey_func_other_arguments"
      },
      {
        "name": "init_func_other_arguments",
        "description": "A list of tensors, typically values that were captured when\nbuilding a closure for `init_func`.",
        "typeListAttr": "Tinit_func_other_arguments"
      },
      {
        "name": "reduce_func_other_arguments",
        "description": "A list of tensors, typically values that were captured when\nbuilding a closure for `reduce_func`.",
        "typeListAttr": "Treduce_func_other_arguments"
      },
      {
        "name": "finalize_func_other_arguments",
        "description": "A list of tensors, typically values that were captured when\nbuilding a closure for `finalize_func`.",
        "typeListAttr": "Tfinalize_func_other_arguments"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "GroupByWindowDataset",
    "summary": "Creates a dataset that computes a windowed group-by on `input_dataset`.",
    "description": "// TODO(mrry): Support non-int64 keys.",
    "attributes": [
      {
        "name": "key_func",
        "type": "function",
        "description": "A function mapping an element of `input_dataset`, concatenated\nwith `key_func_other_arguments` to a scalar value of type DT_INT64."
      },
      {
        "name": "reduce_func",
        "type": "function"
      },
      {
        "name": "window_size_func",
        "type": "function"
      },
      {
        "name": "Tkey_func_other_arguments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "Treduce_func_other_arguments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "Twindow_size_func_other_arguments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "key_func_other_arguments",
        "typeListAttr": "Tkey_func_other_arguments"
      },
      {
        "name": "reduce_func_other_arguments",
        "typeListAttr": "Treduce_func_other_arguments"
      },
      {
        "name": "window_size_func_other_arguments",
        "typeListAttr": "Twindow_size_func_other_arguments"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "GuaranteeConst",
    "summary": "Gives a guarantee to the TF runtime that the input tensor is a constant.",
    "description": "The runtime is then free to make optimizations based on this.\n\nOnly accepts value typed tensors as inputs and rejects resource variable handles\nas input.\n\nReturns the input tensor without modification.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "HSVToRGB",
    "summary": "Convert one or more images from HSV to RGB.",
    "description": "Outputs a tensor of the same shape as the `images` tensor, containing the RGB\nvalue of the pixels. The output is only well defined if the value in `images`\nare in `[0,1]`.\n\nSee `rgb_to_hsv` for a description of the HSV encoding.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "images",
        "description": "1-D or higher rank. HSV data to convert. Last dimension must be size 3.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "`images` converted to RGB.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "HashTable",
    "summary": "Creates a non-initialized hash table.",
    "description": "This op creates a hash table, specifying the type of its keys and values.\nBefore using the table you will have to initialize it.  After initialization the\ntable will be immutable.",
    "attributes": [
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
        "default": ""
      },
      {
        "name": "use_node_name_sharing",
        "type": "boolean",
        "description": "If true and shared_name is empty, the table is shared\nusing the node name.",
        "default": false
      },
      {
        "name": "key_dtype",
        "type": "type",
        "description": "Type of the table keys."
      },
      {
        "name": "value_dtype",
        "type": "type",
        "description": "Type of the table values."
      }
    ],
    "outputs": [
      {
        "name": "table_handle",
        "description": "Handle to a table.",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "HashTableV2",
    "summary": "Creates a non-initialized hash table.",
    "description": "This op creates a hash table, specifying the type of its keys and values.\nBefore using the table you will have to initialize it.  After initialization the\ntable will be immutable.",
    "attributes": [
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
        "default": ""
      },
      {
        "name": "use_node_name_sharing",
        "type": "boolean",
        "description": "If true and shared_name is empty, the table is shared\nusing the node name.",
        "default": false
      },
      {
        "name": "key_dtype",
        "type": "type",
        "description": "Type of the table keys."
      },
      {
        "name": "value_dtype",
        "type": "type",
        "description": "Type of the table values."
      }
    ],
    "outputs": [
      {
        "name": "table_handle",
        "description": "Handle to a table.",
        "type": 20
      }
    ]
  },
  {
    "name": "HistogramFixedWidth",
    "summary": "Return histogram of values.",
    "description": "Given the tensor `values`, this operation returns a rank 1 histogram counting\nthe number of entries in `values` that fall into every bin.  The bins are\nequal width and determined by the arguments `value_range` and `nbins`.\n\n```python\n# Bins will be:  (-inf, 1), [1, 2), [2, 3), [3, 4), [4, inf)\nnbins = 5\nvalue_range = [0.0, 5.0]\nnew_values = [-1.0, 0.0, 1.5, 2.0, 5.0, 15]\n\nwith tf.get_default_session() as sess:\n  hist = tf.histogram_fixed_width(new_values, value_range, nbins=5)\n  variables.global_variables_initializer().run()\n  sess.run(hist) => [2, 1, 1, 0, 2]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`, `float32`, `float64`."
      },
      {
        "name": "dtype",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "values",
        "description": "Numeric `Tensor`.",
        "typeAttr": "T"
      },
      {
        "name": "value_range",
        "description": "Shape [2] `Tensor` of same `dtype` as `values`.\nvalues <= value_range[0] will be mapped to hist[0],\nvalues >= value_range[1] will be mapped to hist[-1].",
        "typeAttr": "T"
      },
      {
        "name": "nbins",
        "description": "Scalar `int32 Tensor`.  Number of histogram bins.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "A 1-D `Tensor` holding histogram of values.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "HistogramSummary",
    "summary": "Outputs a `Summary` protocol buffer with a histogram.",
    "description": "The generated\n[`Summary`](https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto)\nhas one summary value containing a histogram for `values`.\n\nThis op reports an `InvalidArgument` error if any value is not finite.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "tag",
        "description": "Scalar.  Tag to use for the `Summary.Value`.",
        "type": 7
      },
      {
        "name": "values",
        "description": "Any shape. Values to use to build the histogram.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "summary",
        "description": "Scalar. Serialized `Summary` protocol buffer.",
        "type": 7
      }
    ]
  },
  {
    "name": "HostConst",
    "summary": "Returns a constant tensor on the host. Only for writing C++ tests.",
    "attributes": [
      {
        "name": "value",
        "type": "tensor",
        "description": "Attr `value` is the tensor to return."
      },
      {
        "name": "dtype",
        "type": "type"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "IFFT",
    "summary": "Inverse fast Fourier transform.",
    "description": "Computes the inverse 1-dimensional discrete Fourier transform over the\ninner-most dimension of `input`.",
    "attributes": [
      {
        "name": "Tcomplex",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A complex tensor.",
        "typeAttr": "Tcomplex"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A complex tensor of the same shape as `input`. The inner-most\n  dimension of `input` is replaced with its inverse 1D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.ifft\n@end_compatibility",
        "typeAttr": "Tcomplex"
      }
    ]
  },
  {
    "name": "IFFT2D",
    "summary": "Inverse 2D fast Fourier transform.",
    "description": "Computes the inverse 2-dimensional discrete Fourier transform over the\ninner-most 2 dimensions of `input`.",
    "attributes": [
      {
        "name": "Tcomplex",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A complex tensor.",
        "typeAttr": "Tcomplex"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A complex tensor of the same shape as `input`. The inner-most 2\n  dimensions of `input` are replaced with their inverse 2D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.ifft2\n@end_compatibility",
        "typeAttr": "Tcomplex"
      }
    ]
  },
  {
    "name": "IFFT3D",
    "summary": "Inverse 3D fast Fourier transform.",
    "description": "Computes the inverse 3-dimensional discrete Fourier transform over the\ninner-most 3 dimensions of `input`.",
    "attributes": [
      {
        "name": "Tcomplex",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A complex tensor.",
        "typeAttr": "Tcomplex"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A complex tensor of the same shape as `input`. The inner-most 3\n  dimensions of `input` are replaced with their inverse 3D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.ifftn with 3 dimensions.\n@end_compatibility",
        "typeAttr": "Tcomplex"
      }
    ]
  },
  {
    "name": "IFFTND",
    "summary": "ND inverse fast Fourier transform.",
    "description": "Computes the n-dimensional inverse discrete Fourier transform over designated\ndimensions of `input`. The designated dimensions of `input` are assumed to be\nthe result of `IFFTND`.\n\nIf fft_length[i]<shape(input)[i], the input is cropped. If\nfft_length[i]>shape(input)[i], the input is padded with zeros. If fft_length\nis not given, the default shape(input) is used.\n\nAxes mean the dimensions to perform the transform on. Default is to perform on\nall axes.",
    "attributes": [
      {
        "name": "Tcomplex",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A complex tensor.",
        "typeAttr": "Tcomplex"
      },
      {
        "name": "fft_length",
        "description": "An int32 tensor. The FFT length for each dimension.",
        "type": 3
      },
      {
        "name": "axes",
        "description": "An int32 tensor with a same shape as fft_length. Axes to perform the transform.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A complex tensor of the same shape as `input`. The designated dimensions of\n`input` are replaced with their inverse Fourier\ntransforms.\n\n@compatibility(numpy)\nEquivalent to np.fft.fftn.\n@end_compatibility",
        "typeAttr": "Tcomplex"
      }
    ]
  },
  {
    "name": "IRFFT",
    "summary": "Inverse real-valued fast Fourier transform.",
    "description": "Computes the inverse 1-dimensional discrete Fourier transform of a real-valued\nsignal over the inner-most dimension of `input`.\n\nThe inner-most dimension of `input` is assumed to be the result of `RFFT`: the\n`fft_length / 2 + 1` unique components of the DFT of a real-valued signal. If\n`fft_length` is not provided, it is computed from the size of the inner-most\ndimension of `input` (`fft_length = 2 * (inner - 1)`). If the FFT length used to\ncompute `input` is odd, it should be provided since it cannot be inferred\nproperly.\n\nAlong the axis `IRFFT` is computed on, if `fft_length / 2 + 1` is smaller\nthan the corresponding dimension of `input`, the dimension is cropped. If it is\nlarger, the dimension is padded with zeros.",
    "attributes": [
      {
        "name": "Treal",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "Tcomplex",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A complex tensor.",
        "typeAttr": "Tcomplex"
      },
      {
        "name": "fft_length",
        "description": "An int32 tensor of shape [1]. The FFT length.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A float32 tensor of the same rank as `input`. The inner-most\n  dimension of `input` is replaced with the `fft_length` samples of its inverse\n  1D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.irfft\n@end_compatibility",
        "typeAttr": "Treal"
      }
    ]
  },
  {
    "name": "IRFFT2D",
    "summary": "Inverse 2D real-valued fast Fourier transform.",
    "description": "Computes the inverse 2-dimensional discrete Fourier transform of a real-valued\nsignal over the inner-most 2 dimensions of `input`.\n\nThe inner-most 2 dimensions of `input` are assumed to be the result of `RFFT2D`:\nThe inner-most dimension contains the `fft_length / 2 + 1` unique components of\nthe DFT of a real-valued signal. If `fft_length` is not provided, it is computed\nfrom the size of the inner-most 2 dimensions of `input`. If the FFT length used\nto compute `input` is odd, it should be provided since it cannot be inferred\nproperly.\n\nAlong each axis `IRFFT2D` is computed on, if `fft_length` (or\n`fft_length / 2 + 1` for the inner-most dimension) is smaller than the\ncorresponding dimension of `input`, the dimension is cropped. If it is larger,\nthe dimension is padded with zeros.",
    "attributes": [
      {
        "name": "Treal",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "Tcomplex",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A complex tensor.",
        "typeAttr": "Tcomplex"
      },
      {
        "name": "fft_length",
        "description": "An int32 tensor of shape [2]. The FFT length for each dimension.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A float32 tensor of the same rank as `input`. The inner-most 2\n  dimensions of `input` are replaced with the `fft_length` samples of their\n  inverse 2D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.irfft2\n@end_compatibility",
        "typeAttr": "Treal"
      }
    ]
  },
  {
    "name": "IRFFT3D",
    "summary": "Inverse 3D real-valued fast Fourier transform.",
    "description": "Computes the inverse 3-dimensional discrete Fourier transform of a real-valued\nsignal over the inner-most 3 dimensions of `input`.\n\nThe inner-most 3 dimensions of `input` are assumed to be the result of `RFFT3D`:\nThe inner-most dimension contains the `fft_length / 2 + 1` unique components of\nthe DFT of a real-valued signal. If `fft_length` is not provided, it is computed\nfrom the size of the inner-most 3 dimensions of `input`. If the FFT length used\nto compute `input` is odd, it should be provided since it cannot be inferred\nproperly.\n\nAlong each axis `IRFFT3D` is computed on, if `fft_length` (or\n`fft_length / 2 + 1` for the inner-most dimension) is smaller than the\ncorresponding dimension of `input`, the dimension is cropped. If it is larger,\nthe dimension is padded with zeros.",
    "attributes": [
      {
        "name": "Treal",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "Tcomplex",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A complex tensor.",
        "typeAttr": "Tcomplex"
      },
      {
        "name": "fft_length",
        "description": "An int32 tensor of shape [3]. The FFT length for each dimension.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A float32 tensor of the same rank as `input`. The inner-most 3\n  dimensions of `input` are replaced with the `fft_length` samples of their\n  inverse 3D real Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.irfftn with 3 dimensions.\n@end_compatibility",
        "typeAttr": "Treal"
      }
    ]
  },
  {
    "name": "IRFFTND",
    "summary": "ND inverse real fast Fourier transform.",
    "description": "Computes the n-dimensional inverse real discrete Fourier transform over\ndesignated dimensions of `input`. The designated dimensions of `input` are\nassumed to be the result of `IRFFTND`. The inner-most dimension contains the\n`fft_length / 2 + 1` unique components of the DFT of a real-valued signal. \n\nIf fft_length[i]<shape(input)[i], the input is cropped. If\nfft_length[i]>shape(input)[i], the input is padded with zeros. If fft_length\nis not given, the default shape(input) is used.\n\nAxes mean the dimensions to perform the transform on. Default is to perform on\nall axes.",
    "attributes": [
      {
        "name": "Treal",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "Tcomplex",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A complex tensor.",
        "typeAttr": "Tcomplex"
      },
      {
        "name": "fft_length",
        "description": "An int32 tensor. The FFT length for each dimension.",
        "type": 3
      },
      {
        "name": "axes",
        "description": "An int32 tensor with a same shape as fft_length. Axes to perform the transform.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A complex tensor of the same shape as `input`. The designated dimensions of\n`input` are replaced with their inverse real Fourier transforms.\n\n@compatibility(numpy)\nEquivalent to np.fft.irfftn.\n@end_compatibility",
        "typeAttr": "Treal"
      }
    ]
  },
  {
    "name": "Identity",
    "category": "Control",
    "summary": "Return a tensor with the same shape and contents as the input tensor or value.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "IdentityN",
    "summary": "Returns a list of tensors with the same shapes and contents as the input",
    "description": "tensors.\n\nThis op can be used to override the gradient for complicated functions. For\nexample, suppose y = f(x) and we wish to apply a custom function g for backprop\nsuch that dx = g(dy). In Python,\n\n```python\nwith tf.get_default_graph().gradient_override_map(\n    {'IdentityN': 'OverrideGradientWithG'}):\n  y, _ = identity_n([f(x), x])\n\n@tf.RegisterGradient('OverrideGradientWithG')\ndef ApplyG(op, dy, _):\n  return [None, g(dy)]  # Do not backprop to f(x).\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeListAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeListAttr": "T"
      }
    ]
  },
  {
    "name": "IdentityReader",
    "summary": "A Reader that outputs the queued work as both the key and value.",
    "description": "To use, enqueue strings in a Queue.  ReaderRead will take the front\nwork string and output (work, work).",
    "attributes": [
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "reader_handle",
        "description": "The handle to reference the Reader.",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "IdentityReaderV2",
    "summary": "A Reader that outputs the queued work as both the key and value.",
    "description": "To use, enqueue strings in a Queue.  ReaderRead will take the front\nwork string and output (work, work).",
    "attributes": [
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "reader_handle",
        "description": "The handle to reference the Reader.",
        "type": 20
      }
    ]
  },
  {
    "name": "If",
    "summary": "output = cond ? then_branch(input) : else_branch(input)",
    "attributes": [
      {
        "name": "Tcond",
        "type": "type"
      },
      {
        "name": "Tin",
        "type": "type[]",
        "description": "A list of input types.",
        "minimum": 0
      },
      {
        "name": "Tout",
        "type": "type[]",
        "description": "A list of output types.",
        "minimum": 0
      },
      {
        "name": "then_branch",
        "type": "function",
        "description": "      A function that takes 'inputs' and returns a list of tensors, whose\n      types are the same as what else_branch returns."
      },
      {
        "name": "else_branch",
        "type": "function",
        "description": "    A function that takes 'inputs' and returns a list of tensors, whose\n    types are the same as what then_branch returns."
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "cond",
        "description": "      A Tensor. If the tensor is a scalar of non-boolean type, the\n      scalar is converted to a boolean according to the\n      following rule: if the scalar is a numerical value, non-zero means\n      `True` and zero means False; if the scalar is a string, non-empty\n      means `True` and empty means `False`. If the tensor is not a scalar,\n      being empty means False and being non-empty means True.",
        "typeAttr": "Tcond"
      },
      {
        "name": "input",
        "description": "A list of input tensors.",
        "typeListAttr": "Tin"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A list of return values.",
        "typeListAttr": "Tout"
      }
    ]
  },
  {
    "name": "Igamma",
    "summary": "Compute the lower regularized incomplete Gamma function `P(a, x)`.",
    "description": "The lower regularized incomplete Gamma function is defined as:\n\n\n\\\\(P(a, x) = gamma(a, x) / Gamma(a) = 1 - Q(a, x)\\\\)\n\nwhere\n\n\\\\(gamma(a, x) = \\\\int_{0}^{x} t^{a-1} exp(-t) dt\\\\)\n\nis the lower incomplete Gamma function.\n\nNote, above `Q(a, x)` (`Igammac`) is the upper regularized complete\nGamma function.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "a",
        "typeAttr": "T"
      },
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "IgammaGradA",
    "summary": "Computes the gradient of `igamma(a, x)` wrt `a`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "a",
        "typeAttr": "T"
      },
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Igammac",
    "summary": "Compute the upper regularized incomplete Gamma function `Q(a, x)`.",
    "description": "The upper regularized incomplete Gamma function is defined as:\n\n\\\\(Q(a, x) = Gamma(a, x) / Gamma(a) = 1 - P(a, x)\\\\)\n\nwhere\n\n\\\\(Gamma(a, x) = \\int_{x}^{\\infty} t^{a-1} exp(-t) dt\\\\)\n\nis the upper incomplete Gamma function.\n\nNote, above `P(a, x)` (`Igamma`) is the lower regularized complete\nGamma function.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "a",
        "typeAttr": "T"
      },
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "IgnoreErrorsDataset",
    "summary": "Creates a dataset that contains the elements of `input_dataset` ignoring errors.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "log_warning",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "Imag",
    "summary": "Returns the imaginary part of a complex number.",
    "description": "Given a tensor `input` of complex numbers, this operation returns a tensor of\ntype `float` that is the imaginary part of each element in `input`. All\nelements in `input` must be complex numbers of the form \\\\(a + bj\\\\), where *a*\nis the real part and *b* is the imaginary part returned by this operation.\n\nFor example:\n\n```\n# tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]\ntf.imag(input) ==> [4.75, 5.75]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      },
      {
        "name": "Tout",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "ImageProjectiveTransformV2",
    "summary": "Applies the given transform to each of the images.",
    "description": "If one row of `transforms` is `[a0, a1, a2, b0, b1, b2, c0, c1]`, then it maps\nthe *output* point `(x, y)` to a transformed *input* point\n`(x', y') = ((a0 x + a1 y + a2) / k, (b0 x + b1 y + b2) / k)`, where\n`k = c0 x + c1 y + 1`. If the transformed point lays outside of the input\nimage, the output pixel is set to 0.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "Input dtype. Must be one of the following: `uint8`, `int32`, `int64`, `float16`, `bfloat16`, `float32`, `float64`."
      },
      {
        "name": "interpolation",
        "type": "string",
        "description": "Interpolation method, \"NEAREST\" or \"BILINEAR\"."
      },
      {
        "name": "fill_mode",
        "type": "string",
        "description": "Fill mode, \"REFLECT\", \"WRAP\", or \"CONSTANT\".",
        "default": "CONSTANT"
      }
    ],
    "inputs": [
      {
        "name": "images",
        "description": "4-D with shape `[batch, height, width, channels]`.",
        "typeAttr": "dtype"
      },
      {
        "name": "transforms",
        "description": "2-D Tensor, `[batch, 8]` or `[1, 8]` matrix, where each row corresponds to a 3 x 3\nprojective transformation matrix, with the last entry assumed to be 1. If there\nis one row, the same transformation will be applied to all images.",
        "type": 1
      },
      {
        "name": "output_shape",
        "description": "1-D Tensor [new_height, new_width].",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "transformed_images",
        "description": "4-D with shape\n`[batch, new_height, new_width, channels]`.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "ImageProjectiveTransformV3",
    "summary": "Applies the given transform to each of the images.",
    "description": "If one row of `transforms` is `[a0, a1, a2, b0, b1, b2, c0, c1]`, then it maps\nthe *output* point `(x, y)` to a transformed *input* point\n`(x', y') = ((a0 x + a1 y + a2) / k, (b0 x + b1 y + b2) / k)`, where\n`k = c0 x + c1 y + 1`. If the transformed point lays outside of the input\nimage, the output pixel is set to fill_value.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "Input dtype. Must be one of the following: `uint8`, `int32`, `int64`, `float16`, `bfloat16`, `float32`, `float64`."
      },
      {
        "name": "interpolation",
        "type": "string",
        "description": "Interpolation method, \"NEAREST\" or \"BILINEAR\"."
      },
      {
        "name": "fill_mode",
        "type": "string",
        "description": "Fill mode, \"REFLECT\", \"WRAP\", \"CONSTANT\", or \"NEAREST\".",
        "default": "CONSTANT"
      }
    ],
    "inputs": [
      {
        "name": "images",
        "description": "4-D with shape `[batch, height, width, channels]`.",
        "typeAttr": "dtype"
      },
      {
        "name": "transforms",
        "description": "2-D Tensor, `[batch, 8]` or `[1, 8]` matrix, where each row corresponds to a 3 x 3\nprojective transformation matrix, with the last entry assumed to be 1. If there\nis one row, the same transformation will be applied to all images.",
        "type": 1
      },
      {
        "name": "output_shape",
        "description": "1-D Tensor [new_height, new_width].",
        "type": 3
      },
      {
        "name": "fill_value",
        "description": "float, the value to be filled when fill_mode is constant\".",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "transformed_images",
        "description": "4-D with shape\n`[batch, new_height, new_width, channels]`.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "ImageSummary",
    "summary": "Outputs a `Summary` protocol buffer with images.",
    "description": "The summary has up to `max_images` summary values containing images. The\nimages are built from `tensor` which must be 4-D with shape `[batch_size,\nheight, width, channels]` and where `channels` can be:\n\n*  1: `tensor` is interpreted as Grayscale.\n*  3: `tensor` is interpreted as RGB.\n*  4: `tensor` is interpreted as RGBA.\n\nThe images have the same number of channels as the input tensor. For float\ninput, the values are normalized one image at a time to fit in the range\n`[0, 255]`.  `uint8` values are unchanged.  The op uses two different\nnormalization algorithms:\n\n*  If the input values are all positive, they are rescaled so the largest one\n   is 255.\n\n*  If any input value is negative, the values are shifted so input value 0.0\n   is at 127.  They are then rescaled so that either the smallest value is 0,\n   or the largest one is 255.\n\nThe `tag` argument is a scalar `Tensor` of type `string`.  It is used to\nbuild the `tag` of the summary values:\n\n*  If `max_images` is 1, the summary value tag is '*tag*/image'.\n*  If `max_images` is greater than 1, the summary value tags are\n   generated sequentially as '*tag*/image/0', '*tag*/image/1', etc.\n\nThe `bad_color` argument is the color to use in the generated images for\nnon-finite input values.  It is a `uint8` 1-D tensor of length `channels`.\nEach element must be in the range `[0, 255]` (It represents the value of a\npixel in the output image).  Non-finite values in the input tensor are\nreplaced by this tensor in the output image.  The default value is the color\nred.",
    "attributes": [
      {
        "name": "max_images",
        "type": "int64",
        "description": "Max number of batch elements to generate images for.",
        "minimum": 1,
        "default": 3
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `uint8`, `float32`, `float16`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "bad_color",
        "type": "tensor",
        "description": "Color to use for pixels with non-finite values.",
        "default": {
          "type": "tensor",
          "value": "?"
        }
      }
    ],
    "inputs": [
      {
        "name": "tag",
        "description": "Scalar. Used to build the `tag` attribute of the summary values.",
        "type": 7
      },
      {
        "name": "tensor",
        "description": "4-D of shape `[batch_size, height, width, channels]` where\n`channels` is 1, 3, or 4.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "summary",
        "description": "Scalar. Serialized `Summary` protocol buffer.",
        "type": 7
      }
    ]
  },
  {
    "name": "ImmutableConst",
    "summary": "Returns immutable tensor from memory region.",
    "description": "The current implementation memmaps the tensor from a file.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "Type of the returned tensor."
      },
      {
        "name": "shape",
        "type": "shape",
        "description": "Shape of the returned tensor."
      },
      {
        "name": "memory_region_name",
        "type": "string",
        "description": "Name of readonly memory region used by the tensor, see\nNewReadOnlyMemoryRegionFromFile in tensorflow::Env."
      }
    ],
    "outputs": [
      {
        "name": "tensor",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "ImportEvent",
    "inputs": [
      {
        "name": "writer",
        "type": 20
      },
      {
        "name": "event",
        "type": 7
      }
    ]
  },
  {
    "name": "InTopK",
    "summary": "Says whether the targets are in the top `K` predictions.",
    "description": "This outputs a `batch_size` bool array, an entry `out[i]` is `true` if the\nprediction for the target class is among the top `k` predictions among\nall predictions for example `i`. Note that the behavior of `InTopK` differs\nfrom the `TopK` op in its handling of ties; if multiple classes have the\nsame prediction value and straddle the top-`k` boundary, all of those\nclasses are considered to be in the top `k`.\n\nMore formally, let\n\n  \\\\(predictions_i\\\\) be the predictions for all classes for example `i`,\n  \\\\(targets_i\\\\) be the target class for example `i`,\n  \\\\(out_i\\\\) be the output for example `i`,\n\n$$out_i = predictions_{i, targets_i} \\in TopKIncludingTies(predictions_i)$$",
    "attributes": [
      {
        "name": "k",
        "type": "int64",
        "description": "Number of top elements to look at for computing precision."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "predictions",
        "description": "A `batch_size` x `classes` tensor.",
        "type": 1
      },
      {
        "name": "targets",
        "description": "A `batch_size` vector of class ids.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "precision",
        "description": "Computed Precision at `k` as a `bool Tensor`.",
        "type": 10
      }
    ]
  },
  {
    "name": "InTopKV2",
    "summary": "Says whether the targets are in the top `K` predictions.",
    "description": "This outputs a `batch_size` bool array, an entry `out[i]` is `true` if the\nprediction for the target class is among the top `k` predictions among\nall predictions for example `i`. Note that the behavior of `InTopK` differs\nfrom the `TopK` op in its handling of ties; if multiple classes have the\nsame prediction value and straddle the top-`k` boundary, all of those\nclasses are considered to be in the top `k`.\n\nMore formally, let\n\n  \\\\(predictions_i\\\\) be the predictions for all classes for example `i`,\n  \\\\(targets_i\\\\) be the target class for example `i`,\n  \\\\(out_i\\\\) be the output for example `i`,\n\n$$out_i = predictions_{i, targets_i} \\in TopKIncludingTies(predictions_i)$$",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "predictions",
        "description": "A `batch_size` x `classes` tensor.",
        "type": 1
      },
      {
        "name": "targets",
        "description": "A `batch_size` vector of class ids.",
        "typeAttr": "T"
      },
      {
        "name": "k",
        "description": "Number of top elements to look at for computing precision.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "precision",
        "description": "Computed precision at `k` as a `bool Tensor`.",
        "type": 10
      }
    ]
  },
  {
    "name": "IndexFlatMapDataset",
    "attributes": [
      {
        "name": "map_func",
        "type": "function"
      },
      {
        "name": "index_map_func",
        "type": "function"
      },
      {
        "name": "Tmap_func_args",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "Tindex_map_func_args",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "map_func_other_args",
        "typeListAttr": "Tmap_func_args"
      },
      {
        "name": "index_map_func_other_args",
        "typeListAttr": "Tindex_map_func_args"
      },
      {
        "name": "output_cardinality",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "InfeedDequeue",
    "summary": "A placeholder op for a value that will be fed into the computation.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of elements in the tensor."
      },
      {
        "name": "shape",
        "type": "shape",
        "description": "The shape of the tensor."
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A tensor that will be provided using the infeed mechanism.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "InfeedDequeueTuple",
    "summary": "Fetches multiple values from infeed as an XLA tuple.",
    "attributes": [
      {
        "name": "dtypes",
        "type": "type[]",
        "description": "The element types of each element in `outputs`.",
        "minimum": 1
      },
      {
        "name": "shapes",
        "type": "shape[]",
        "description": "The shapes of each tensor in `outputs`."
      }
    ],
    "outputs": [
      {
        "name": "outputs",
        "description": "A list of tensors that will be provided using the infeed mechanism.",
        "typeListAttr": "dtypes"
      }
    ]
  },
  {
    "name": "InfeedEnqueue",
    "summary": "An op which feeds a single Tensor value into the computation.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of elements in the tensor."
      },
      {
        "name": "shape",
        "type": "shape",
        "description": "The shape of the tensor.",
        "default": {
          "type": "shape",
          "value": "?"
        }
      },
      {
        "name": "layout",
        "type": "int64[]",
        "description": "A vector holding the requested layout in minor-to-major sequence.\nIf a layout attribute is passed, but its values are all -1, the layout will\nbe computed by the infeed operation.",
        "default": []
      },
      {
        "name": "device_ordinal",
        "type": "int64",
        "description": "The TPU device to use. This should be -1 when the Op\nis running on a TPU device, and >= 0 when the Op is running on the CPU\ndevice.",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A tensor that will be provided using the infeed mechanism.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "InfeedEnqueuePrelinearizedBuffer",
    "summary": "An op which enqueues prelinearized buffer into TPU infeed.",
    "attributes": [
      {
        "name": "device_ordinal",
        "type": "int64",
        "description": "The TPU device to use. This should be -1 when the Op is running on a TPU device\nand = 0 when the Op is running on the CPU device.",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A variant tensor representing linearized output.",
        "type": 21
      }
    ]
  },
  {
    "name": "InfeedEnqueueTuple",
    "summary": "Feeds multiple Tensor values into the computation as an XLA tuple.",
    "attributes": [
      {
        "name": "dtypes",
        "type": "type[]",
        "description": "The element types of each element in `inputs`.",
        "minimum": 1
      },
      {
        "name": "shapes",
        "type": "shape[]",
        "description": "The shapes of each tensor in `inputs`."
      },
      {
        "name": "layouts",
        "type": "int64[]",
        "description": "A vector holding the requested layout in minor-to-major sequence for\nall the tuple shapes, in the order the shapes appear in the \"shapes\" input.\nThe layout elements for a sub-shape can be set to -1, in which case the\ncorresponding layout will be computed by the infeed operation.",
        "default": []
      },
      {
        "name": "device_ordinal",
        "type": "int64",
        "description": "The TPU device to use. This should be -1 when the Op\nis running on a TPU device, and >= 0 when the Op is running on the CPU\ndevice.",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "description": "A list of tensors that will be provided using the infeed mechanism.",
        "typeListAttr": "dtypes"
      }
    ]
  },
  {
    "name": "InitializeTable",
    "summary": "Table initializer that takes two tensors for keys and values respectively.",
    "attributes": [
      {
        "name": "Tkey",
        "type": "type"
      },
      {
        "name": "Tval",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "table_handle",
        "description": "Handle to a table which will be initialized.",
        "type": 7,
        "isRef": true
      },
      {
        "name": "keys",
        "description": "Keys of type Tkey.",
        "typeAttr": "Tkey"
      },
      {
        "name": "values",
        "description": "Values of type Tval.",
        "typeAttr": "Tval"
      }
    ]
  },
  {
    "name": "InitializeTableFromDataset",
    "inputs": [
      {
        "name": "table_handle",
        "type": 20
      },
      {
        "name": "dataset",
        "type": 21
      }
    ]
  },
  {
    "name": "InitializeTableFromTextFile",
    "summary": "Initializes a table from a text file.",
    "description": "It inserts one key-value pair into the table for each line of the file.\nThe key and value is extracted from the whole line content, elements from the\nsplit line based on `delimiter` or the line number (starting from zero).\nWhere to extract the key and value from a line is specified by `key_index` and\n`value_index`.\n\n- A value of -1 means use the line number(starting from zero), expects `int64`.\n- A value of -2 means use the whole line content, expects `string`.\n- A value >= 0 means use the index (starting at zero) of the split line based\n  on `delimiter`.",
    "attributes": [
      {
        "name": "key_index",
        "type": "int64",
        "description": "Column index in a line to get the table `key` values from.",
        "minimum": -2
      },
      {
        "name": "value_index",
        "type": "int64",
        "description": "Column index that represents information of a line to get the table\n`value` values from.",
        "minimum": -2
      },
      {
        "name": "vocab_size",
        "type": "int64",
        "description": "Number of elements of the file, use -1 if unknown.",
        "minimum": -1,
        "default": -1
      },
      {
        "name": "delimiter",
        "type": "string",
        "description": "Delimiter to separate fields in a line.",
        "default": "\t"
      },
      {
        "name": "offset",
        "type": "int64",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "table_handle",
        "description": "Handle to a table which will be initialized.",
        "type": 7,
        "isRef": true
      },
      {
        "name": "filename",
        "description": "Filename of a vocabulary text file.",
        "type": 7
      }
    ]
  },
  {
    "name": "InitializeTableFromTextFileV2",
    "summary": "Initializes a table from a text file.",
    "description": "It inserts one key-value pair into the table for each line of the file.\nThe key and value is extracted from the whole line content, elements from the\nsplit line based on `delimiter` or the line number (starting from zero).\nWhere to extract the key and value from a line is specified by `key_index` and\n`value_index`.\n\n- A value of -1 means use the line number(starting from zero), expects `int64`.\n- A value of -2 means use the whole line content, expects `string`.\n- A value >= 0 means use the index (starting at zero) of the split line based\n  on `delimiter`.",
    "attributes": [
      {
        "name": "key_index",
        "type": "int64",
        "description": "Column index in a line to get the table `key` values from.",
        "minimum": -2
      },
      {
        "name": "value_index",
        "type": "int64",
        "description": "Column index that represents information of a line to get the table\n`value` values from.",
        "minimum": -2
      },
      {
        "name": "vocab_size",
        "type": "int64",
        "description": "Number of elements of the file, use -1 if unknown.",
        "minimum": -1,
        "default": -1
      },
      {
        "name": "delimiter",
        "type": "string",
        "description": "Delimiter to separate fields in a line.",
        "default": "\t"
      },
      {
        "name": "offset",
        "type": "int64",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "table_handle",
        "description": "Handle to a table which will be initialized.",
        "type": 20
      },
      {
        "name": "filename",
        "description": "Filename of a vocabulary text file.",
        "type": 7
      }
    ]
  },
  {
    "name": "InitializeTableV2",
    "summary": "Table initializer that takes two tensors for keys and values respectively.",
    "attributes": [
      {
        "name": "Tkey",
        "type": "type"
      },
      {
        "name": "Tval",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "table_handle",
        "description": "Handle to a table which will be initialized.",
        "type": 20
      },
      {
        "name": "keys",
        "description": "Keys of type Tkey.",
        "typeAttr": "Tkey"
      },
      {
        "name": "values",
        "description": "Values of type Tval.",
        "typeAttr": "Tval"
      }
    ]
  },
  {
    "name": "InplaceAdd",
    "summary": "Adds v into specified rows of x.",
    "description": "    Computes y = x; y[i, :] += v; return y.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "A `Tensor` of type T.",
        "typeAttr": "T"
      },
      {
        "name": "i",
        "description": "A vector. Indices into the left-most dimension of `x`.",
        "type": 3
      },
      {
        "name": "v",
        "description": "A `Tensor` of type T. Same dimension sizes as x except the first dimension, which must be the same as i's size.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "description": "A `Tensor` of type T. An alias of `x`. The content of `y` is undefined if there are duplicates in `i`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "InplaceSub",
    "summary": "    Subtracts `v` into specified rows of `x`.\n\n    Computes y = x; y[i, :] -= v; return y.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "A `Tensor` of type T.",
        "typeAttr": "T"
      },
      {
        "name": "i",
        "description": "A vector. Indices into the left-most dimension of `x`.",
        "type": 3
      },
      {
        "name": "v",
        "description": "A `Tensor` of type T. Same dimension sizes as x except the first dimension, which must be the same as i's size.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "description": "A `Tensor` of type T. An alias of `x`. The content of `y` is undefined if there are duplicates in `i`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "InplaceUpdate",
    "summary": "Updates specified rows 'i' with values 'v'.",
    "description": "Computes `x[i, :] = v; return x`.\n\nOriginally this function is mutative however for compilation we make this\noperation create / operate on a copy of `x`.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "A tensor of type `T`.",
        "typeAttr": "T"
      },
      {
        "name": "i",
        "description": "A vector. Indices into the left-most dimension of `x`.",
        "type": 3
      },
      {
        "name": "v",
        "description": "A `Tensor` of type T. Same dimension sizes as x except the first dimension, which must be the same as i's size.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "description": "A `Tensor` of type T. An alias of `x`. The content of `y` is undefined if there are duplicates in `i`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "InterleaveDataset",
    "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`.",
    "description": "Unlike MapDataset, the `f` in InterleaveDataset is expected to return\na Dataset variant, and InterleaveDataset will flatten successive\nresults into a single Dataset. Unlike FlatMapDataset,\nInterleaveDataset will interleave sequences of up to `block_length`\nconsecutive elements from `cycle_length` input elements.",
    "attributes": [
      {
        "name": "f",
        "type": "function",
        "description": "A function mapping elements of `input_dataset`, concatenated with\n`other_arguments`, to a Dataset variant that contains elements matching\n`output_types` and `output_shapes`."
      },
      {
        "name": "Targuments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "other_arguments",
        "typeListAttr": "Targuments"
      },
      {
        "name": "cycle_length",
        "type": 9
      },
      {
        "name": "block_length",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "Inv",
    "summary": "Computes the reciprocal of x element-wise.",
    "description": "I.e., \\\\(y = 1 / x\\\\).",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `int8`, `int16`, `int32`, `int64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "InvGrad",
    "summary": "Computes the gradient for the inverse of `x` wrt its input.",
    "description": "Specifically, `grad = -dy * y*y`, where `y = 1/x`, and `dy`\nis the corresponding input gradient.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "y",
        "typeAttr": "T"
      },
      {
        "name": "dy",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Invert",
    "summary": "Invert (flip) each bit of supported types; for example, type `uint8` value 01010101 becomes 10101010.",
    "description": "Flip each bit of supported types.  For example, type `int8` (decimal 2) binary 00000010 becomes (decimal -3) binary 11111101.\nThis operation is performed on each element of the tensor argument `x`.\n\nExample:\n```python\nimport tensorflow as tf\nfrom tensorflow.python.ops import bitwise_ops\n\n# flip 2 (00000010) to -3 (11111101)\ntf.assert_equal(-3, bitwise_ops.invert(2))\n\ndtype_list = [dtypes.int8, dtypes.int16, dtypes.int32, dtypes.int64,\n              dtypes.uint8, dtypes.uint16, dtypes.uint32, dtypes.uint64]\n\ninputs = [0, 5, 3, 14]\nfor dtype in dtype_list:\n  # Because of issues with negative numbers, let's test this indirectly.\n  # 1. invert(a) and a = 0\n  # 2. invert(a) or a = invert(0)\n  input_tensor = tf.constant([0, 5, 3, 14], dtype=dtype)\n  not_a_and_a, not_a_or_a, not_0 = [bitwise_ops.bitwise_and(\n                                      input_tensor, bitwise_ops.invert(input_tensor)),\n                                    bitwise_ops.bitwise_or(\n                                      input_tensor, bitwise_ops.invert(input_tensor)),\n                                    bitwise_ops.invert(\n                                      tf.constant(0, dtype=dtype))]\n\n  expected = tf.constant([0, 0, 0, 0], dtype=tf.float32)\n  tf.assert_equal(tf.cast(not_a_and_a, tf.float32), expected)\n\n  expected = tf.cast([not_0] * 4, tf.float32)\n  tf.assert_equal(tf.cast(not_a_or_a, tf.float32), expected)\n\n  # For unsigned dtypes let's also check the result directly.\n  if dtype.is_unsigned:\n    inverted = bitwise_ops.invert(input_tensor)\n    expected = tf.constant([dtype.max - x for x in inputs], dtype=tf.float32)\n    tf.assert_equal(tf.cast(inverted, tf.float32), tf.cast(expected, tf.float32))\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "InvertPermutation",
    "summary": "Computes the inverse permutation of a tensor.",
    "description": "This operation computes the inverse of an index permutation. It takes a 1-D\ninteger tensor `x`, which represents the indices of a zero-based array, and\nswaps each value with its index position. In other words, for an output tensor\n`y` and an input tensor `x`, this operation computes the following:\n\n`y[x[i]] = i for i in [0, 1, ..., len(x) - 1]`\n\nThe values must include 0. There can be no duplicate values or negative values.\n\nFor example:\n\n```\n# tensor `x` is [3, 4, 0, 2, 1]\ninvert_permutation(x) ==> [2, 4, 3, 0, 1]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "1-D.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "description": "1-D.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "IsBoostedTreesEnsembleInitialized",
    "summary": "Checks whether a tree ensemble has been initialized.",
    "inputs": [
      {
        "name": "tree_ensemble_handle",
        "description": "Handle to the tree ensemble resource.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "is_initialized",
        "description": "output boolean on whether it is initialized or not.",
        "type": 10
      }
    ]
  },
  {
    "name": "IsBoostedTreesQuantileStreamResourceInitialized",
    "summary": "Checks whether a quantile stream has been initialized.",
    "description": "An Op that checks if quantile stream resource is initialized.",
    "inputs": [
      {
        "name": "quantile_stream_resource_handle",
        "description": "resource; The reference to quantile stream resource handle.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "is_initialized",
        "description": "bool; True if the resource is initialized, False otherwise.",
        "type": 10
      }
    ]
  },
  {
    "name": "IsFinite",
    "summary": "Returns which elements of x are finite.",
    "description": "@compatibility(numpy)\nEquivalent to np.isfinite\n@end_compatibility\n\nExample:\n\n```python\nx = tf.constant([5.0, 4.8, 6.8, np.inf, np.nan])\ntf.math.is_finite(x) ==> [True, True, True, False, False]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "type": 10
      }
    ]
  },
  {
    "name": "IsInf",
    "summary": "Returns which elements of x are Inf.",
    "description": "@compatibility(numpy)\nEquivalent to np.isinf\n@end_compatibility\n\nExample:\n\n```python\nx = tf.constant([5.0, np.inf, 6.8, np.inf])\ntf.math.is_inf(x) ==> [False, True, False, True]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "type": 10
      }
    ]
  },
  {
    "name": "IsNan",
    "summary": "Returns which elements of x are NaN.",
    "description": "@compatibility(numpy)\nEquivalent to np.isnan\n@end_compatibility\n\nExample:\n\n```python\nx = tf.constant([5.0, np.nan, 6.8, np.nan, np.inf])\ntf.math.is_nan(x) ==> [False, True, False, True, False]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "type": 10
      }
    ]
  },
  {
    "name": "IsTPUEmbeddingInitialized",
    "summary": "Whether TPU Embedding is initialized in a distributed TPU system.",
    "attributes": [
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "is_tpu_embedding_initialized",
        "type": 10
      }
    ]
  },
  {
    "name": "IsVariableInitialized",
    "summary": "Checks whether a tensor has been initialized.",
    "description": "Outputs boolean scalar indicating whether the tensor has been initialized.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of elements in the variable tensor."
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "description": "Should be from a `Variable` node. May be uninitialized.",
        "typeAttr": "dtype",
        "isRef": true
      }
    ],
    "outputs": [
      {
        "name": "is_initialized",
        "type": 10
      }
    ]
  },
  {
    "name": "IsotonicRegression",
    "summary": "Solves a batch of isotonic regression problems.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "output_dtype",
        "type": "type",
        "description": "Dtype of output. Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A (batch_size, dim)-tensor holding a batch of inputs.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A (batch_size, dim)-tensor holding the per-batch element solutions.",
        "typeAttr": "output_dtype"
      },
      {
        "name": "segments",
        "description": "An int32 (batch_size, dim)-tensor with the segments.",
        "type": 3
      }
    ]
  },
  {
    "name": "Iterator",
    "summary": "A container for an iterator resource.",
    "attributes": [
      {
        "name": "shared_name",
        "type": "string"
      },
      {
        "name": "container",
        "type": "string"
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "A handle to the iterator that can be passed to a \"MakeIterator\"\nor \"IteratorGetNext\" op.",
        "type": 20
      }
    ]
  },
  {
    "name": "IteratorFromStringHandle",
    "summary": "Converts the given string representing a handle to an iterator to a resource.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "description": "If specified, defines the type of each tuple component in an\nelement produced by the resulting iterator.",
        "minimum": 0,
        "default": []
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "description": "If specified, defines the shape of each tuple component in an\nelement produced by the resulting iterator.",
        "minimum": 0,
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "string_handle",
        "description": "A string representation of the given handle.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "resource_handle",
        "description": "A handle to an iterator resource.",
        "type": 20
      }
    ]
  },
  {
    "name": "IteratorFromStringHandleV2",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 0,
        "default": []
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 0,
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "string_handle",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "resource_handle",
        "type": 20
      }
    ]
  },
  {
    "name": "IteratorGetDevice",
    "summary": "Returns the name of the device on which `resource` has been placed.",
    "inputs": [
      {
        "name": "resource",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "device",
        "type": 7
      }
    ]
  },
  {
    "name": "IteratorGetModelProto",
    "summary": "Returns the serialized model proto of an iterator resource.",
    "description": "Returns the serialized model proto of an iterator resource.",
    "inputs": [
      {
        "name": "iterator",
        "description": "An resource from an dataset iterator.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "model_proto",
        "description": "A serialized model proto.",
        "type": 7
      }
    ]
  },
  {
    "name": "IteratorGetNext",
    "summary": "Gets the next output from the given iterator .",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "iterator",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "components",
        "typeListAttr": "output_types"
      }
    ]
  },
  {
    "name": "IteratorGetNextAsOptional",
    "summary": "Gets the next output from the given iterator as an Optional variant.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "iterator",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "optional",
        "type": 21
      }
    ]
  },
  {
    "name": "IteratorGetNextSync",
    "summary": "Gets the next output from the given iterator.",
    "description": "This operation is a synchronous version IteratorGetNext. It should only be used\nin situations where the iterator does not block the calling thread, or where\nthe calling thread is not a member of the thread pool used to execute parallel\noperations (e.g. in eager mode).",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "iterator",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "components",
        "typeListAttr": "output_types"
      }
    ]
  },
  {
    "name": "IteratorToStringHandle",
    "summary": "Converts the given `resource_handle` representing an iterator to a string.",
    "inputs": [
      {
        "name": "resource_handle",
        "description": "A handle to an iterator resource.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "string_handle",
        "description": "A string representation of the given handle.",
        "type": 7
      }
    ]
  },
  {
    "name": "IteratorV2",
    "attributes": [
      {
        "name": "shared_name",
        "type": "string"
      },
      {
        "name": "container",
        "type": "string"
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 20
      }
    ]
  },
  {
    "name": "KMC2ChainInitialization",
    "summary": "Returns the index of a data point that should be added to the seed set.",
    "description": "Entries in distances are assumed to be squared distances of candidate points to\nthe already sampled centers in the seed set. The op constructs one Markov chain\nof the k-MC^2 algorithm and returns the index of one candidate point to be added\nas an additional cluster center.",
    "inputs": [
      {
        "name": "distances",
        "description": "Vector with squared distances to the closest previously sampled cluster center\nfor each candidate point.",
        "type": 1
      },
      {
        "name": "seed",
        "description": "Scalar. Seed for initializing the random number generator.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "index",
        "description": "Scalar with the index of the sampled point.",
        "type": 9
      }
    ]
  },
  {
    "name": "KmeansPlusPlusInitialization",
    "summary": "Selects num_to_sample rows of input using the KMeans++ criterion.",
    "description": "Rows of points are assumed to be input points. One row is selected at random.\nSubsequent rows are sampled with probability proportional to the squared L2\ndistance from the nearest row selected thus far till num_to_sample rows have\nbeen sampled.",
    "inputs": [
      {
        "name": "points",
        "description": "Matrix of shape (n, d). Rows are assumed to be input points.",
        "type": 1
      },
      {
        "name": "num_to_sample",
        "description": "Scalar. The number of rows to sample. This value must not be larger than n.",
        "type": 9
      },
      {
        "name": "seed",
        "description": "Scalar. Seed for initializing the random number generator.",
        "type": 9
      },
      {
        "name": "num_retries_per_sample",
        "description": "Scalar. For each row that is sampled, this parameter\nspecifies the number of additional points to draw from the current\ndistribution before selecting the best. If a negative value is specified, a\nheuristic is used to sample O(log(num_to_sample)) additional points.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "samples",
        "description": "Matrix of shape (num_to_sample, d). The sampled rows.",
        "type": 1
      }
    ]
  },
  {
    "name": "KthOrderStatistic",
    "summary": "Computes the Kth order statistic of a data set. The current",
    "description": "implementation uses a binary search requiring exactly 32 passes over\nthe input data. The running time is linear with respect to input\nsize. The median-of-medians algorithm is probably faster, but is\ndifficult to implement efficiently in XLA. The implementation imposes\na total ordering on floats. The ordering is consistent with the usual\npartial order.  Positive NaNs are greater than positive\ninfinity. Negative NaNs are less than negative infinity. NaNs with\ndistinct payloads are treated as distinct. Subnormal numbers are\npreserved (not flushed to zero). Positive infinity is greater than all\nnumbers. Negative infinity is less than all numbers. Positive is\ngreater than negative zero. There are less than k values greater than\nthe kth order statistic. There are at least k values greater than or\nequal to the Kth order statistic. The semantics are not the same as\ntop_k_unique.",
    "attributes": [
      {
        "name": "k",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 1
      }
    ]
  },
  {
    "name": "L2Loss",
    "summary": "L2 Loss.",
    "description": "Computes half the L2 norm of a tensor without the `sqrt`:\n\n    output = sum(t ** 2) / 2",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "t",
        "description": "Typically 2-D, but may have any dimensions.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "0-D.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "LMDBDataset",
    "summary": "Creates a dataset that emits the key-value pairs in one or more LMDB files.",
    "description": "The Lightning Memory-Mapped Database Manager, or LMDB, is an embedded binary\nkey-value database. This dataset can read the contents of LMDB database files,\nthe names of which generally have the `.mdb` suffix.\n\nEach output element consists of a key-value pair represented as a pair of\nscalar string `Tensor`s, where the first `Tensor` contains the key and the\nsecond `Tensor` contains the value.\n\nLMDB uses different file formats on big- and little-endian machines.\n`LMDBDataset` can only read files in the format of the host machine.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "filenames",
        "description": "A scalar or a vector containing the name(s) of the binary file(s) to be\nread.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "LMDBReader",
    "summary": "A Reader that outputs the records from a LMDB file.",
    "attributes": [
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "reader_handle",
        "description": "The handle to reference the Reader.",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "LRN",
    "category": "Normalization",
    "summary": "Local Response Normalization.",
    "description": "The 4-D `input` tensor is treated as a 3-D array of 1-D vectors (along the last\ndimension), and each vector is normalized independently.  Within a given vector,\neach component is divided by the weighted, squared sum of inputs within\n`depth_radius`.  In detail,\n\n    sqr_sum[a, b, c, d] =\n        sum(input[a, b, c, d - depth_radius : d + depth_radius + 1] ** 2)\n    output = input / (bias + alpha * sqr_sum) ** beta\n\nFor details, see [Krizhevsky et al., ImageNet classification with deep\nconvolutional neural networks (NIPS 2012)](http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks).",
    "attributes": [
      {
        "name": "depth_radius",
        "type": "int64",
        "description": "0-D.  Half-width of the 1-D normalization window.",
        "default": 5
      },
      {
        "name": "bias",
        "type": "float32",
        "description": "An offset (usually positive to avoid dividing by 0).",
        "default": 1.0
      },
      {
        "name": "alpha",
        "type": "float32",
        "description": "A scale factor, usually positive.",
        "default": 1.0
      },
      {
        "name": "beta",
        "type": "float32",
        "description": "An exponent.",
        "default": 0.5
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "4-D.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "LRNGrad",
    "summary": "Gradients for Local Response Normalization.",
    "attributes": [
      {
        "name": "depth_radius",
        "type": "int64",
        "description": "A depth radius.",
        "default": 5
      },
      {
        "name": "bias",
        "type": "float32",
        "description": "An offset (usually > 0 to avoid dividing by 0).",
        "default": 1.0
      },
      {
        "name": "alpha",
        "type": "float32",
        "description": "A scale factor, usually positive.",
        "default": 1.0
      },
      {
        "name": "beta",
        "type": "float32",
        "description": "An exponent.",
        "default": 0.5
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "input_grads",
        "description": "4-D with shape `[batch, height, width, channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "input_image",
        "description": "4-D with shape `[batch, height, width, channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "output_image",
        "description": "4-D with shape `[batch, height, width, channels]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The gradients for LRN.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "LSTMBlockCell",
    "category": "Layer",
    "summary": "Computes the LSTM cell forward propagation for 1 time step.",
    "description": "This implementation uses 1 weight matrix and 1 bias vector, and there's an\noptional peephole connection.\n\nThis kernel op implements the following mathematical equations:\n\n```python\nxh = [x, h_prev]\n[i, f, ci, o] = xh * w + b\nf = f + forget_bias\n\nif not use_peephole:\n  wci = wcf = wco = 0\n\ni = sigmoid(cs_prev * wci + i)\nf = sigmoid(cs_prev * wcf + f)\nci = tanh(ci)\n\ncs = ci .* i + cs_prev .* f\ncs = clip(cs, cell_clip)\n\no = sigmoid(cs * wco + o)\nco = tanh(cs)\nh = co .* o\n```",
    "attributes": [
      {
        "name": "forget_bias",
        "type": "float32",
        "description": "The forget gate bias.",
        "default": 1.0
      },
      {
        "name": "cell_clip",
        "type": "float32",
        "description": "Value to clip the 'cs' value to.",
        "default": 3.0
      },
      {
        "name": "use_peephole",
        "type": "boolean",
        "description": "Whether to use peephole weights.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "The input to the LSTM cell, shape (batch_size, num_inputs).",
        "typeAttr": "T"
      },
      {
        "name": "cs_prev",
        "description": "Value of the cell state at previous time step.",
        "typeAttr": "T"
      },
      {
        "name": "h_prev",
        "description": "Output of the previous cell at previous time step.",
        "typeAttr": "T"
      },
      {
        "name": "w",
        "description": "The weight matrix.",
        "typeAttr": "T"
      },
      {
        "name": "wci",
        "description": "The weight matrix for input gate peephole connection.",
        "typeAttr": "T"
      },
      {
        "name": "wcf",
        "description": "The weight matrix for forget gate peephole connection.",
        "typeAttr": "T"
      },
      {
        "name": "wco",
        "description": "The weight matrix for output gate peephole connection.",
        "typeAttr": "T"
      },
      {
        "name": "b",
        "description": "The bias vector.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "i",
        "description": "The input gate.",
        "typeAttr": "T"
      },
      {
        "name": "cs",
        "description": "The cell state before the tanh.",
        "typeAttr": "T"
      },
      {
        "name": "f",
        "description": "The forget gate.",
        "typeAttr": "T"
      },
      {
        "name": "o",
        "description": "The output gate.",
        "typeAttr": "T"
      },
      {
        "name": "ci",
        "description": "The cell input.",
        "typeAttr": "T"
      },
      {
        "name": "co",
        "description": "The cell after the tanh.",
        "typeAttr": "T"
      },
      {
        "name": "h",
        "description": "The output h vector.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "LSTMBlockCellGrad",
    "summary": "Computes the LSTM cell backward propagation for 1 timestep.",
    "description": "This implementation is to be used in conjunction of LSTMBlockCell.",
    "attributes": [
      {
        "name": "use_peephole",
        "type": "boolean",
        "description": "Whether the cell uses peephole connections."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "The input to the LSTM cell, shape (batch_size, num_inputs).",
        "typeAttr": "T"
      },
      {
        "name": "cs_prev",
        "description": "The previous cell state.",
        "typeAttr": "T"
      },
      {
        "name": "h_prev",
        "description": "The previous h state.",
        "typeAttr": "T"
      },
      {
        "name": "w",
        "description": "The weight matrix.",
        "typeAttr": "T"
      },
      {
        "name": "wci",
        "description": "The weight matrix for input gate peephole connection.",
        "typeAttr": "T"
      },
      {
        "name": "wcf",
        "description": "The weight matrix for forget gate peephole connection.",
        "typeAttr": "T"
      },
      {
        "name": "wco",
        "description": "The weight matrix for output gate peephole connection.",
        "typeAttr": "T"
      },
      {
        "name": "b",
        "description": "The bias vector.",
        "typeAttr": "T"
      },
      {
        "name": "i",
        "description": "The input gate.",
        "typeAttr": "T"
      },
      {
        "name": "cs",
        "description": "The cell state before the tanh.",
        "typeAttr": "T"
      },
      {
        "name": "f",
        "description": "The forget gate.",
        "typeAttr": "T"
      },
      {
        "name": "o",
        "description": "The output gate.",
        "typeAttr": "T"
      },
      {
        "name": "ci",
        "description": "The cell input.",
        "typeAttr": "T"
      },
      {
        "name": "co",
        "description": "The cell after the tanh.",
        "typeAttr": "T"
      },
      {
        "name": "cs_grad",
        "description": "The current gradient of cs.",
        "typeAttr": "T"
      },
      {
        "name": "h_grad",
        "description": "The gradient of h vector.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "cs_prev_grad",
        "description": "The gradient of cs to be back-propped.",
        "typeAttr": "T"
      },
      {
        "name": "dicfo",
        "description": "The derivative wrt to [i, cs, f, o].",
        "typeAttr": "T"
      },
      {
        "name": "wci_grad",
        "description": "The gradient for wci to be back-propped.",
        "typeAttr": "T"
      },
      {
        "name": "wcf_grad",
        "description": "The gradient for wcf to be back-propped.",
        "typeAttr": "T"
      },
      {
        "name": "wco_grad",
        "description": "The gradient for wco to be back-propped.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "LatencyStatsDataset",
    "summary": "Records the latency of producing `input_dataset` elements in a StatsAggregator.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "tag",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "LeakyRelu",
    "category": "Activation",
    "summary": "Computes rectified linear: `max(features, features * alpha)`.",
    "attributes": [
      {
        "name": "alpha",
        "type": "float32",
        "default": 0.20000000298023224
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "features",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "activations",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "LeakyReluGrad",
    "summary": "Computes rectified linear gradients for a LeakyRelu operation.",
    "attributes": [
      {
        "name": "alpha",
        "type": "float32",
        "default": 0.20000000298023224
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "gradients",
        "description": "The backpropagated gradients to the corresponding LeakyRelu operation.",
        "typeAttr": "T"
      },
      {
        "name": "features",
        "description": "The features passed as input to the corresponding LeakyRelu operation,\nOR the outputs of that operation (both work equivalently).",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "backprops",
        "description": "`gradients * (features > 0) + alpha * gradients * (features <= 0)`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "LearnedUnigramCandidateSampler",
    "summary": "Generates labels for candidate sampling with a learned unigram distribution.",
    "description": "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels.",
    "attributes": [
      {
        "name": "num_true",
        "type": "int64",
        "description": "Number of true labels per context.",
        "minimum": 1
      },
      {
        "name": "num_sampled",
        "type": "int64",
        "description": "Number of candidates to randomly sample.",
        "minimum": 1
      },
      {
        "name": "unique",
        "type": "boolean",
        "description": "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities."
      },
      {
        "name": "range_max",
        "type": "int64",
        "description": "The sampler will sample integers from the interval [0, range_max).",
        "minimum": 1
      },
      {
        "name": "seed",
        "type": "int64",
        "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "description": "An second seed to avoid seed collision.",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "true_classes",
        "description": "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "sampled_candidates",
        "description": "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate.",
        "type": 9
      },
      {
        "name": "true_expected_count",
        "description": "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability.",
        "type": 1
      },
      {
        "name": "sampled_expected_count",
        "description": "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability.",
        "type": 1
      }
    ]
  },
  {
    "name": "LeftShift",
    "summary": "Elementwise computes the bitwise left-shift of `x` and `y`.",
    "description": "If `y` is negative, or greater than or equal to the width of `x` in bits the\nresult is implementation defined.\n\nExample:\n\n```python\nimport tensorflow as tf\nfrom tensorflow.python.ops import bitwise_ops\nimport numpy as np\ndtype_list = [tf.int8, tf.int16, tf.int32, tf.int64]\n\nfor dtype in dtype_list:\n  lhs = tf.constant([-1, -5, -3, -14], dtype=dtype)\n  rhs = tf.constant([5, 0, 7, 11], dtype=dtype)\n\n  left_shift_result = bitwise_ops.left_shift(lhs, rhs)\n\n  print(left_shift_result)\n\n# This will print:\n# tf.Tensor([ -32   -5 -128    0], shape=(4,), dtype=int8)\n# tf.Tensor([   -32     -5   -384 -28672], shape=(4,), dtype=int16)\n# tf.Tensor([   -32     -5   -384 -28672], shape=(4,), dtype=int32)\n# tf.Tensor([   -32     -5   -384 -28672], shape=(4,), dtype=int64)\n\nlhs = np.array([-2, 64, 101, 32], dtype=np.int8)\nrhs = np.array([-1, -5, -3, -14], dtype=np.int8)\nbitwise_ops.left_shift(lhs, rhs)\n# <tf.Tensor: shape=(4,), dtype=int8, numpy=array([ -2,  64, 101,  32], dtype=int8)>\n```\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "LegacyParallelInterleaveDatasetV2",
    "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`.",
    "description": "The resulting dataset is similar to the `InterleaveDataset`, with the exception\nthat if retrieving the next value from a dataset would cause the requester to\nblock, it will skip that input dataset. This dataset is especially useful\nwhen loading data from a variable-latency datastores (e.g. HDFS, GCS), as it\nallows the training step to proceed so long as some data is available.\n\n!! WARNING !! This dataset is not deterministic!",
    "attributes": [
      {
        "name": "f",
        "type": "function",
        "description": "A function mapping elements of `input_dataset`, concatenated with\n`other_arguments`, to a Dataset variant that contains elements matching\n`output_types` and `output_shapes`."
      },
      {
        "name": "deterministic",
        "type": "string",
        "default": "default"
      },
      {
        "name": "Targuments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "other_arguments",
        "typeListAttr": "Targuments"
      },
      {
        "name": "cycle_length",
        "type": 9
      },
      {
        "name": "block_length",
        "type": 9
      },
      {
        "name": "buffer_output_elements",
        "type": 9
      },
      {
        "name": "prefetch_input_elements",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "Less",
    "summary": "Returns the truth value of (x < y) element-wise.",
    "description": "*NOTE*: `Less` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)\n\nExample:\n\n```python\nx = tf.constant([5, 4, 6])\ny = tf.constant([5])\ntf.math.less(x, y) ==> [False, True, False]\n\nx = tf.constant([5, 4, 6])\ny = tf.constant([5, 6, 7])\ntf.math.less(x, y) ==> [False, True, True]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "type": 10
      }
    ]
  },
  {
    "name": "LessEqual",
    "summary": "Returns the truth value of (x <= y) element-wise.",
    "description": "*NOTE*: `LessEqual` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)\n\nExample:\n\n```python\nx = tf.constant([5, 4, 6])\ny = tf.constant([5])\ntf.math.less_equal(x, y) ==> [True, True, False]\n\nx = tf.constant([5, 4, 6])\ny = tf.constant([5, 6, 6])\ntf.math.less_equal(x, y) ==> [True, True, True]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "type": 10
      }
    ]
  },
  {
    "name": "Lgamma",
    "summary": "Computes the log of the absolute value of `Gamma(x)` element-wise.",
    "description": "  For positive numbers, this function computes log((input - 1)!) for every element in the tensor.\n  `lgamma(5) = log((5-1)!) = log(4!) = log(24) = 3.1780539`\n\nExample:\n\n```python\nx = tf.constant([0, 0.5, 1, 4.5, -4, -5.6])\ntf.math.lgamma(x) ==> [inf, 0.5723649, 0., 2.4537368, inf, -4.6477685]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "LinSpace",
    "summary": "Generates values in an interval.",
    "description": "A sequence of `num` evenly-spaced values are generated beginning at `start`.\nIf `num > 1`, the values in the sequence increase by\n`(stop - start) / (num - 1)`, so that the last one is exactly `stop`.\n\nFor example:\n\n```\ntf.linspace(10.0, 12.0, 3, name=\"linspace\") => [ 10.0  11.0  12.0]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "start",
        "description": "0-D tensor. First entry in the range.",
        "typeAttr": "T"
      },
      {
        "name": "stop",
        "description": "0-D tensor. Last entry in the range.",
        "typeAttr": "T"
      },
      {
        "name": "num",
        "description": "0-D tensor. Number of values to generate.",
        "typeAttr": "Tidx"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "1-D. The generated values.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ListDataset",
    "summary": "Creates a dataset that emits each of `tensors` once.",
    "attributes": [
      {
        "name": "Tinput_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "tensors",
        "typeListAttr": "Tinput_types"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ListDiff",
    "summary": "Computes the difference between two lists of numbers or strings.",
    "description": "Given a list `x` and a list `y`, this operation returns a list `out` that\nrepresents all values that are in `x` but not in `y`. The returned list `out`\nis sorted in the same order that the numbers appear in `x` (duplicates are\npreserved). This operation also returns a list `idx` that represents the\nposition of each `out` element in `x`. In other words:\n\n`out[i] = x[idx[i]] for i in [0, 1, ..., len(out) - 1]`\n\nFor example, given this input:\n\n```\nx = [1, 2, 3, 4, 5, 6]\ny = [1, 3, 5]\n```\n\nThis operation would return:\n\n```\nout ==> [2, 4, 6]\nidx ==> [1, 3, 5]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "out_idx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "1-D. Values to keep.",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "description": "1-D. Values to remove.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "1-D. Values present in `x` but not in `y`.",
        "typeAttr": "T"
      },
      {
        "name": "idx",
        "description": "1-D. Positions of `x` values preserved in `out`.",
        "typeAttr": "out_idx"
      }
    ]
  },
  {
    "name": "ListSnapshotChunksDataset",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "snapshot_path",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "LoadAllTPUEmbeddingParameters",
    "summary": "An op that loads optimization parameters into embedding memory.",
    "description": "An op that loads optimization parameters into embedding memory. Must be\npreceded by a ConfigureTPUEmbeddingHost op that sets up the correct embedding\ntable configuration. For example, this op is used to install parameters that are\nloaded from a checkpoint before a training loop is executed.  For Adagrad,\nauxiliary1 should be the accumulators. For SGD, all of the auxiliary* values\nshould be empty. For FTRL, auxiliary1 should be the accumulators and auxiliary2\nshould be the linear terms. For ADAM, auxiliary1 should be the momenta and\nauxiliary2 should be the velocities.",
    "attributes": [
      {
        "name": "NumTables",
        "type": "int64",
        "description": "The number of embedding tables.",
        "minimum": 1
      },
      {
        "name": "config",
        "type": "string",
        "description": "An TPUEmbeddingConfiguration proto describing the\ntable parameters being loaded, serialized to a string."
      },
      {
        "name": "num_shards",
        "type": "int64",
        "description": "Number of shards into which the embedding tables are divided."
      },
      {
        "name": "shard_id",
        "type": "int64",
        "description": "Identifier of shard for this operation."
      }
    ],
    "inputs": [
      {
        "name": "parameters",
        "description": "A list of tensors, one for each embedding table,\ncontaining the initial embedding table parameters to use in embedding\nlookups.",
        "numberAttr": "NumTables",
        "type": 1
      },
      {
        "name": "auxiliary1",
        "description": "A list of tensors, one for each embedding table, containing the\ninitial values of the first auxiliary optimization parameter to use in embedding\ntraining loop updates. The shape of each entry is ignored (and thus can be\nempty) for those tables whose optimization algorithms do not have at least one\nauxiliary parameter.",
        "numberAttr": "NumTables",
        "type": 1
      },
      {
        "name": "auxiliary2",
        "description": "A list of tensors, one for each embedding table, containing the\ninitial values of the second auxiliary optimization parameter to use in\nembedding training loop updates. The shape of each entry is ignored (and thus\ncan be empty) for those tables whose optimization algorithms do not have at\nleast two auxiliary",
        "numberAttr": "NumTables",
        "type": 1
      },
      {
        "name": "auxiliary3",
        "description": "A list of tensors, one for each embedding table, containing the\ninitial values of the third auxiliary optimization parameter to use in embedding\ntraining loop updates. The shape of each entry is ignored (and thus can be\nempty) for those tables whose optimization algorithms do not have three\nauxiliary parameters.",
        "numberAttr": "NumTables",
        "type": 1
      },
      {
        "name": "auxiliary4",
        "description": "A list of tensors, one for each embedding table, containing the\ninitial values of the second auxiliary optimization parameter to use in\nembedding training loop updates. The shape of each entry is ignored (and thus\ncan be empty) for those tables whose optimization algorithms do not have at\nleast four auxiliary",
        "numberAttr": "NumTables",
        "type": 1
      },
      {
        "name": "auxiliary5",
        "description": "A list of tensors, one for each embedding table, containing the\ninitial values of the third auxiliary optimization parameter to use in embedding\ntraining loop updates. The shape of each entry is ignored (and thus can be\nempty) for those tables whose optimization algorithms do not have five\nauxiliary parameters.",
        "numberAttr": "NumTables",
        "type": 1
      },
      {
        "name": "auxiliary6",
        "description": "A list of tensors, one for each embedding table, containing the\ninitial values of the second auxiliary optimization parameter to use in\nembedding training loop updates. The shape of each entry is ignored (and thus\ncan be empty) for those tables whose optimization algorithms do not have at\nleast six auxiliary",
        "numberAttr": "NumTables",
        "type": 1
      },
      {
        "name": "auxiliary7",
        "description": "A list of tensors, one for each embedding table, containing the\ninitial values of the third auxiliary optimization parameter to use in embedding\ntraining loop updates. The shape of each entry is ignored (and thus can be\nempty) for those tables whose optimization algorithms do not have sevan\nauxiliary parameters.",
        "numberAttr": "NumTables",
        "type": 1
      }
    ]
  },
  {
    "name": "LoadAndRemapMatrix",
    "summary": "Loads a 2-D (matrix) `Tensor` with name `old_tensor_name` from the checkpoint",
    "description": "at `ckpt_path` and potentially reorders its rows and columns using the\nspecified remappings.\n\nMost users should use one of the wrapper initializers (such as\n`tf.contrib.framework.load_and_remap_matrix_initializer`) instead of this\nfunction directly.\n\nThe remappings are 1-D tensors with the following properties:\n\n* `row_remapping` must have exactly `num_rows` entries. Row `i` of the output\n  matrix will be initialized from the row corresponding to index\n  `row_remapping[i]` in the old `Tensor` from the checkpoint.\n* `col_remapping` must have either 0 entries (indicating that no column\n  reordering is needed) or `num_cols` entries. If specified, column `j` of the\n  output matrix will be initialized from the column corresponding to index\n  `col_remapping[j]` in the old `Tensor` from the checkpoint.\n* A value of -1 in either of the remappings signifies a \"missing\" entry. In that\n  case, values from the `initializing_values` tensor will be used to fill that\n  missing row or column. If `row_remapping` has `r` missing entries and\n  `col_remapping` has `c` missing entries, then the following condition must be\n  true:\n\n`(r * num_cols) + (c * num_rows) - (r * c) == len(initializing_values)`\n\nThe remapping tensors can be generated using the GenerateVocabRemapping op.\n\nAs an example, with row_remapping = [1, 0, -1], col_remapping = [0, 2, -1],\ninitializing_values = [0.5, -0.5, 0.25, -0.25, 42], and w(i, j) representing\nthe value from row i, column j of the old tensor in the checkpoint, the output\nmatrix will look like the following:\n\n[[w(1, 0),  w(1, 2),  0.5],\n [w(0, 0),  w(0, 2), -0.5],\n [0.25,    -0.25,      42]]",
    "attributes": [
      {
        "name": "num_rows",
        "type": "int64",
        "description": "Number of rows (length of the 1st dimension) in the output matrix.",
        "minimum": 0
      },
      {
        "name": "num_cols",
        "type": "int64",
        "description": "Number of columns (length of the 2nd dimension) in the output matrix.",
        "minimum": 1
      },
      {
        "name": "max_rows_in_memory",
        "type": "int64",
        "description": "The maximum number of rows to load from the checkpoint at\nonce. If less than or equal to 0, the entire matrix will be loaded into\nmemory. Setting this arg trades increased disk reads for lower memory usage.",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "ckpt_path",
        "description": "Path to the TensorFlow checkpoint (version 2, `TensorBundle`) from\nwhich the old matrix `Tensor` will be loaded.",
        "type": 7
      },
      {
        "name": "old_tensor_name",
        "description": "Name of the 2-D `Tensor` to load from checkpoint.",
        "type": 7
      },
      {
        "name": "row_remapping",
        "description": "An int `Tensor` of row remappings (generally created by\n`generate_vocab_remapping`).  Even if no row remapping is needed, this must\nstill be an index-valued Tensor (e.g. [0, 1, 2, ...]), or a shifted\nindex-valued `Tensor` (e.g. [8, 9, 10, ...], for partitioned `Variables`).",
        "type": 9
      },
      {
        "name": "col_remapping",
        "description": "An int `Tensor` of column remappings (generally created by\n`generate_vocab_remapping`).  May be a size-0 `Tensor` if only row remapping\nis to be done (e.g. column ordering is the same).",
        "type": 9
      },
      {
        "name": "initializing_values",
        "description": "A float `Tensor` containing  values to fill in for cells\nin the output matrix that are not loaded from the checkpoint. Length must be\nexactly the same as the number of missing / new cells.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output_matrix",
        "description": "Output matrix containing existing values loaded from the\ncheckpoint, and with any missing values filled in from initializing_values.",
        "type": 1
      }
    ]
  },
  {
    "name": "LoadDataset",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "compression",
        "type": "string",
        "default": ""
      },
      {
        "name": "reader_func",
        "type": "function"
      },
      {
        "name": "Treader_func_args",
        "type": "type[]",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "path",
        "type": 7
      },
      {
        "name": "reader_func_other_args",
        "typeListAttr": "Treader_func_args"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "LoadTPUEmbeddingADAMParameters",
    "summary": "Load ADAM embedding parameters.",
    "description": "An op that loads optimization parameters into HBM for embedding. Must be\npreceded by a ConfigureTPUEmbeddingHost op that sets up the correct\nembedding table configuration. For example, this op is used to install\nparameters that are loaded from a checkpoint before a training loop is\nexecuted.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "parameters",
        "description": "Value of parameters used in the ADAM optimization algorithm.",
        "type": 1
      },
      {
        "name": "momenta",
        "description": "Value of momenta used in the ADAM optimization algorithm.",
        "type": 1
      },
      {
        "name": "velocities",
        "description": "Value of velocities used in the ADAM optimization algorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "LoadTPUEmbeddingAdadeltaParameters",
    "summary": "Load Adadelta embedding parameters.",
    "description": "An op that loads optimization parameters into HBM for embedding. Must be\npreceded by a ConfigureTPUEmbeddingHost op that sets up the correct\nembedding table configuration. For example, this op is used to install\nparameters that are loaded from a checkpoint before a training loop is\nexecuted.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "parameters",
        "description": "Value of parameters used in the Adadelta optimization algorithm.",
        "type": 1
      },
      {
        "name": "accumulators",
        "description": "Value of accumulators used in the Adadelta optimization algorithm.",
        "type": 1
      },
      {
        "name": "updates",
        "description": "Value of updates used in the Adadelta optimization algorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "LoadTPUEmbeddingAdagradMomentumParameters",
    "summary": "Load Adagrad Momentum embedding parameters.",
    "description": "An op that loads optimization parameters into HBM for embedding. Must be\npreceded by a ConfigureTPUEmbeddingHost op that sets up the correct\nembedding table configuration. For example, this op is used to install\nparameters that are loaded from a checkpoint before a training loop is\nexecuted.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "parameters",
        "description": "Value of parameters used in the Adagrad Momentum optimization algorithm.",
        "type": 1
      },
      {
        "name": "accumulators",
        "description": "Value of accumulators used in the Adagrad Momentum optimization algorithm.",
        "type": 1
      },
      {
        "name": "momenta",
        "description": "Value of momenta used in the Adagrad Momentum optimization algorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "LoadTPUEmbeddingAdagradParameters",
    "summary": "Load Adagrad embedding parameters.",
    "description": "An op that loads optimization parameters into HBM for embedding. Must be\npreceded by a ConfigureTPUEmbeddingHost op that sets up the correct\nembedding table configuration. For example, this op is used to install\nparameters that are loaded from a checkpoint before a training loop is\nexecuted.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "parameters",
        "description": "Value of parameters used in the Adagrad optimization algorithm.",
        "type": 1
      },
      {
        "name": "accumulators",
        "description": "Value of accumulators used in the Adagrad optimization algorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "LoadTPUEmbeddingCenteredRMSPropParameters",
    "summary": "Load centered RMSProp embedding parameters.",
    "description": "An op that loads optimization parameters into HBM for embedding. Must be\npreceded by a ConfigureTPUEmbeddingHost op that sets up the correct\nembedding table configuration. For example, this op is used to install\nparameters that are loaded from a checkpoint before a training loop is\nexecuted.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "parameters",
        "description": "Value of parameters used in the centered RMSProp optimization algorithm.",
        "type": 1
      },
      {
        "name": "ms",
        "description": "Value of ms used in the centered RMSProp optimization algorithm.",
        "type": 1
      },
      {
        "name": "mom",
        "description": "Value of mom used in the centered RMSProp optimization algorithm.",
        "type": 1
      },
      {
        "name": "mg",
        "description": "Value of mg used in the centered RMSProp optimization algorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "LoadTPUEmbeddingFTRLParameters",
    "summary": "Load FTRL embedding parameters.",
    "description": "An op that loads optimization parameters into HBM for embedding. Must be\npreceded by a ConfigureTPUEmbeddingHost op that sets up the correct\nembedding table configuration. For example, this op is used to install\nparameters that are loaded from a checkpoint before a training loop is\nexecuted.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "parameters",
        "description": "Value of parameters used in the FTRL optimization algorithm.",
        "type": 1
      },
      {
        "name": "accumulators",
        "description": "Value of accumulators used in the FTRL optimization algorithm.",
        "type": 1
      },
      {
        "name": "linears",
        "description": "Value of linears used in the FTRL optimization algorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "LoadTPUEmbeddingFrequencyEstimatorParameters",
    "summary": "Load frequency estimator embedding parameters.",
    "description": "An op that loads optimization parameters into HBM for embedding. Must be\npreceded by a ConfigureTPUEmbeddingHost op that sets up the correct\nembedding table configuration. For example, this op is used to install\nparameters that are loaded from a checkpoint before a training loop is\nexecuted.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "parameters",
        "description": "Value of parameters used in the frequency estimator optimization algorithm.",
        "type": 1
      },
      {
        "name": "last_hit_step",
        "description": "Value of last_hit_step used in the frequency estimator optimization algorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "LoadTPUEmbeddingMDLAdagradLightParameters",
    "summary": "Load MDL Adagrad Light embedding parameters.",
    "description": "An op that loads optimization parameters into HBM for embedding. Must be\npreceded by a ConfigureTPUEmbeddingHost op that sets up the correct\nembedding table configuration. For example, this op is used to install\nparameters that are loaded from a checkpoint before a training loop is\nexecuted.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "parameters",
        "description": "Value of parameters used in the MDL Adagrad Light optimization algorithm.",
        "type": 1
      },
      {
        "name": "accumulators",
        "description": "Value of accumulators used in the MDL Adagrad Light optimization algorithm.",
        "type": 1
      },
      {
        "name": "weights",
        "description": "Value of weights used in the MDL Adagrad Light optimization algorithm.",
        "type": 1
      },
      {
        "name": "benefits",
        "description": "Value of benefits used in the MDL Adagrad Light optimization algorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "LoadTPUEmbeddingMomentumParameters",
    "summary": "Load Momentum embedding parameters.",
    "description": "An op that loads optimization parameters into HBM for embedding. Must be\npreceded by a ConfigureTPUEmbeddingHost op that sets up the correct\nembedding table configuration. For example, this op is used to install\nparameters that are loaded from a checkpoint before a training loop is\nexecuted.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "parameters",
        "description": "Value of parameters used in the Momentum optimization algorithm.",
        "type": 1
      },
      {
        "name": "momenta",
        "description": "Value of momenta used in the Momentum optimization algorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "LoadTPUEmbeddingProximalAdagradParameters",
    "summary": "Load proximal Adagrad embedding parameters.",
    "description": "An op that loads optimization parameters into HBM for embedding. Must be\npreceded by a ConfigureTPUEmbeddingHost op that sets up the correct\nembedding table configuration. For example, this op is used to install\nparameters that are loaded from a checkpoint before a training loop is\nexecuted.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "parameters",
        "description": "Value of parameters used in the proximal Adagrad optimization algorithm.",
        "type": 1
      },
      {
        "name": "accumulators",
        "description": "Value of accumulators used in the proximal Adagrad optimization algorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "LoadTPUEmbeddingProximalYogiParameters",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "parameters",
        "type": 1
      },
      {
        "name": "v",
        "type": 1
      },
      {
        "name": "m",
        "type": 1
      }
    ]
  },
  {
    "name": "LoadTPUEmbeddingRMSPropParameters",
    "summary": "Load RMSProp embedding parameters.",
    "description": "An op that loads optimization parameters into HBM for embedding. Must be\npreceded by a ConfigureTPUEmbeddingHost op that sets up the correct\nembedding table configuration. For example, this op is used to install\nparameters that are loaded from a checkpoint before a training loop is\nexecuted.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "parameters",
        "description": "Value of parameters used in the RMSProp optimization algorithm.",
        "type": 1
      },
      {
        "name": "ms",
        "description": "Value of ms used in the RMSProp optimization algorithm.",
        "type": 1
      },
      {
        "name": "mom",
        "description": "Value of mom used in the RMSProp optimization algorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "LoadTPUEmbeddingStochasticGradientDescentParameters",
    "summary": "Load SGD embedding parameters.",
    "description": "An op that loads optimization parameters into HBM for embedding. Must be\npreceded by a ConfigureTPUEmbeddingHost op that sets up the correct\nembedding table configuration. For example, this op is used to install\nparameters that are loaded from a checkpoint before a training loop is\nexecuted.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "parameters",
        "description": "Value of parameters used in the stochastic gradient descent optimization algorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "Log",
    "summary": "Computes natural logarithm of x element-wise.",
    "description": "I.e., \\\\(y = \\log_e x\\\\).\n\nExample:\n\n```python\nx = tf.constant([0, 0.5, 1, 5])\ntf.math.log(x) ==> [-inf, -0.6931472,  0. ,  1.609438]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Log1p",
    "summary": "Computes natural logarithm of (1 + x) element-wise.",
    "description": "I.e., \\\\(y = \\log_e (1 + x)\\\\).\n\nExample:\n\n```python\nx = tf.constant([0, 0.5, 1, 5])\ntf.math.log1p(x) ==> [0., 0.4054651, 0.6931472, 1.7917595]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "LogMatrixDeterminant",
    "summary": "Computes the sign and the log of the absolute value of the determinant of",
    "description": "one or more square matrices.\n\nThe input is a tensor of shape `[N, M, M]` whose inner-most 2 dimensions\nform square matrices. The outputs are two tensors containing the signs and\nabsolute values of the log determinants for all N input submatrices\n`[..., :, :]` such that `determinant = sign*exp(log_abs_determinant)`.\nThe `log_abs_determinant` is computed as `det(P)*sum(log(diag(LU)))` where `LU`\nis the `LU` decomposition of the input and `P` is the corresponding\npermutation matrix.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Shape is `[N, M, M]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "sign",
        "description": "The signs of the log determinants of the inputs. Shape is `[N]`.",
        "typeAttr": "T"
      },
      {
        "name": "log_abs_determinant",
        "description": "The logs of the absolute values of the determinants\nof the N input matrices.  Shape is `[N]`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "LogSoftmax",
    "summary": "Computes log softmax activations.",
    "description": "For each batch `i` and class `j` we have\n\n    logsoftmax[i, j] = logits[i, j] - log(sum(exp(logits[i])))",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "logits",
        "description": "2-D with shape `[batch_size, num_classes]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "logsoftmax",
        "description": "Same shape as `logits`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "LogUniformCandidateSampler",
    "summary": "Generates labels for candidate sampling with a log-uniform distribution.",
    "description": "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels.",
    "attributes": [
      {
        "name": "num_true",
        "type": "int64",
        "description": "Number of true labels per context.",
        "minimum": 1
      },
      {
        "name": "num_sampled",
        "type": "int64",
        "description": "Number of candidates to randomly sample.",
        "minimum": 1
      },
      {
        "name": "unique",
        "type": "boolean",
        "description": "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities."
      },
      {
        "name": "range_max",
        "type": "int64",
        "description": "The sampler will sample integers from the interval [0, range_max).",
        "minimum": 1
      },
      {
        "name": "seed",
        "type": "int64",
        "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "description": "An second seed to avoid seed collision.",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "true_classes",
        "description": "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "sampled_candidates",
        "description": "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate.",
        "type": 9
      },
      {
        "name": "true_expected_count",
        "description": "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability.",
        "type": 1
      },
      {
        "name": "sampled_expected_count",
        "description": "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability.",
        "type": 1
      }
    ]
  },
  {
    "name": "LogicalAnd",
    "summary": "Returns the truth value of x AND y element-wise.",
    "description": "*NOTE*: `LogicalAnd` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
    "inputs": [
      {
        "name": "x",
        "type": 10
      },
      {
        "name": "y",
        "type": 10
      }
    ],
    "outputs": [
      {
        "name": "z",
        "type": 10
      }
    ]
  },
  {
    "name": "LogicalNot",
    "summary": "Returns the truth value of `NOT x` element-wise.",
    "inputs": [
      {
        "name": "x",
        "description": "A `Tensor` of type `bool`.",
        "type": 10
      }
    ],
    "outputs": [
      {
        "name": "y",
        "description": "A `Tensor` of type `bool` with the same shape as `x`. The logical negation of `x`.",
        "type": 10
      }
    ]
  },
  {
    "name": "LogicalOr",
    "summary": "Returns the truth value of x OR y element-wise.",
    "description": "*NOTE*: `LogicalOr` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
    "inputs": [
      {
        "name": "x",
        "type": 10
      },
      {
        "name": "y",
        "type": 10
      }
    ],
    "outputs": [
      {
        "name": "z",
        "type": 10
      }
    ]
  },
  {
    "name": "LookupTableExport",
    "summary": "Outputs all keys and values in the table.",
    "attributes": [
      {
        "name": "Tkeys",
        "type": "type"
      },
      {
        "name": "Tvalues",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "table_handle",
        "description": "Handle to the table.",
        "type": 7,
        "isRef": true
      }
    ],
    "outputs": [
      {
        "name": "keys",
        "description": "Vector of all keys present in the table.",
        "typeAttr": "Tkeys"
      },
      {
        "name": "values",
        "description": "Tensor of all values in the table. Indexed in parallel with `keys`.",
        "typeAttr": "Tvalues"
      }
    ]
  },
  {
    "name": "LookupTableExportV2",
    "summary": "Outputs all keys and values in the table.",
    "attributes": [
      {
        "name": "Tkeys",
        "type": "type"
      },
      {
        "name": "Tvalues",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "table_handle",
        "description": "Handle to the table.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "keys",
        "description": "Vector of all keys present in the table.",
        "typeAttr": "Tkeys"
      },
      {
        "name": "values",
        "description": "Tensor of all values in the table. Indexed in parallel with `keys`.",
        "typeAttr": "Tvalues"
      }
    ]
  },
  {
    "name": "LookupTableFind",
    "summary": "Looks up keys in a table, outputs the corresponding values.",
    "description": "The tensor `keys` must of the same type as the keys of the table.\nThe output `values` is of the type of the table values.\n\nThe scalar `default_value` is the value output for keys not present in the\ntable. It must also be of the same type as the table values.",
    "attributes": [
      {
        "name": "Tin",
        "type": "type"
      },
      {
        "name": "Tout",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "table_handle",
        "description": "Handle to the table.",
        "type": 7,
        "isRef": true
      },
      {
        "name": "keys",
        "description": "Any shape.  Keys to look up.",
        "typeAttr": "Tin"
      },
      {
        "name": "default_value",
        "typeAttr": "Tout"
      }
    ],
    "outputs": [
      {
        "name": "values",
        "description": "Same shape as `keys`.  Values found in the table, or `default_values`\nfor missing keys.",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "LookupTableFindV2",
    "summary": "Looks up keys in a table, outputs the corresponding values.",
    "description": "The tensor `keys` must of the same type as the keys of the table.\nThe output `values` is of the type of the table values.\n\nThe scalar `default_value` is the value output for keys not present in the\ntable. It must also be of the same type as the table values.",
    "attributes": [
      {
        "name": "Tin",
        "type": "type"
      },
      {
        "name": "Tout",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "table_handle",
        "description": "Handle to the table.",
        "type": 20
      },
      {
        "name": "keys",
        "description": "Any shape.  Keys to look up.",
        "typeAttr": "Tin"
      },
      {
        "name": "default_value",
        "typeAttr": "Tout"
      }
    ],
    "outputs": [
      {
        "name": "values",
        "description": "Same shape as `keys`.  Values found in the table, or `default_values`\nfor missing keys.",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "LookupTableImport",
    "summary": "Replaces the contents of the table with the specified keys and values.",
    "description": "The tensor `keys` must be of the same type as the keys of the table.\nThe tensor `values` must be of the type of the table values.",
    "attributes": [
      {
        "name": "Tin",
        "type": "type"
      },
      {
        "name": "Tout",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "table_handle",
        "description": "Handle to the table.",
        "type": 7,
        "isRef": true
      },
      {
        "name": "keys",
        "description": "Any shape.  Keys to look up.",
        "typeAttr": "Tin"
      },
      {
        "name": "values",
        "description": "Values to associate with keys.",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "LookupTableImportV2",
    "summary": "Replaces the contents of the table with the specified keys and values.",
    "description": "The tensor `keys` must be of the same type as the keys of the table.\nThe tensor `values` must be of the type of the table values.",
    "attributes": [
      {
        "name": "Tin",
        "type": "type"
      },
      {
        "name": "Tout",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "table_handle",
        "description": "Handle to the table.",
        "type": 20
      },
      {
        "name": "keys",
        "description": "Any shape.  Keys to look up.",
        "typeAttr": "Tin"
      },
      {
        "name": "values",
        "description": "Values to associate with keys.",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "LookupTableInsert",
    "summary": "Updates the table to associates keys with values.",
    "description": "The tensor `keys` must be of the same type as the keys of the table.\nThe tensor `values` must be of the type of the table values.",
    "attributes": [
      {
        "name": "Tin",
        "type": "type"
      },
      {
        "name": "Tout",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "table_handle",
        "description": "Handle to the table.",
        "type": 7,
        "isRef": true
      },
      {
        "name": "keys",
        "description": "Any shape.  Keys to look up.",
        "typeAttr": "Tin"
      },
      {
        "name": "values",
        "description": "Values to associate with keys.",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "LookupTableInsertV2",
    "summary": "Updates the table to associates keys with values.",
    "description": "The tensor `keys` must be of the same type as the keys of the table.\nThe tensor `values` must be of the type of the table values.",
    "attributes": [
      {
        "name": "Tin",
        "type": "type"
      },
      {
        "name": "Tout",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "table_handle",
        "description": "Handle to the table.",
        "type": 20
      },
      {
        "name": "keys",
        "description": "Any shape.  Keys to look up.",
        "typeAttr": "Tin"
      },
      {
        "name": "values",
        "description": "Values to associate with keys.",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "LookupTableRemoveV2",
    "summary": "Removes keys and its associated values from a table.",
    "description": "The tensor `keys` must of the same type as the keys of the table. Keys not\nalready in the table are silently ignored.",
    "attributes": [
      {
        "name": "Tin",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "table_handle",
        "description": "Handle to the table.",
        "type": 20
      },
      {
        "name": "keys",
        "description": "Any shape.  Keys of the elements to remove.",
        "typeAttr": "Tin"
      }
    ]
  },
  {
    "name": "LookupTableSize",
    "summary": "Computes the number of elements in the given table.",
    "inputs": [
      {
        "name": "table_handle",
        "description": "Handle to the table.",
        "type": 7,
        "isRef": true
      }
    ],
    "outputs": [
      {
        "name": "size",
        "description": "Scalar that contains number of elements in the table.",
        "type": 9
      }
    ]
  },
  {
    "name": "LookupTableSizeV2",
    "summary": "Computes the number of elements in the given table.",
    "inputs": [
      {
        "name": "table_handle",
        "description": "Handle to the table.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "size",
        "description": "Scalar that contains number of elements in the table.",
        "type": 9
      }
    ]
  },
  {
    "name": "LoopCond",
    "summary": "Forwards the input to the output.",
    "description": "This operator represents the loop termination condition used by the\n\"pivot\" switches of a loop.",
    "inputs": [
      {
        "name": "input",
        "description": "A boolean scalar, representing the branch predicate of the Switch op.",
        "type": 10
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The same tensor as `input`.",
        "type": 10
      }
    ]
  },
  {
    "name": "LowerBound",
    "summary": "Applies lower_bound(sorted_search_values, values) along each row.",
    "description": "Each set of rows with the same index in (sorted_inputs, values) is treated\nindependently.  The resulting row is the equivalent of calling\n`np.searchsorted(sorted_inputs, values, side='left')`.\n\nThe result is not a global index to the entire\n`Tensor`, but rather just the index in the last dimension.\n\nA 2-D example:\n  sorted_sequence = [[0, 3, 9, 9, 10],\n                     [1, 2, 3, 4, 5]]\n  values = [[2, 4, 9],\n            [0, 2, 6]]\n\n  result = LowerBound(sorted_sequence, values)\n\n  result == [[1, 2, 2],\n             [0, 1, 5]]",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "sorted_inputs",
        "description": "2-D Tensor where each row is ordered.",
        "typeAttr": "T"
      },
      {
        "name": "values",
        "description": "2-D Tensor with the same numbers of rows as `sorted_search_values`. Contains\nthe values that will be searched for in `sorted_search_values`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A `Tensor` with the same shape as `values`.  It contains the first scalar index\ninto the last dimension where values can be inserted without changing the\nordered property.",
        "typeAttr": "out_type"
      }
    ]
  },
  {
    "name": "Lu",
    "summary": "Computes the LU decomposition of one or more square matrices.",
    "description": "The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices.\n\nThe input has to be invertible.\n\nThe output consists of two tensors LU and P containing the LU decomposition\nof all input submatrices `[..., :, :]`. LU encodes the lower triangular and\nupper triangular factors.\n\nFor each input submatrix of shape `[M, M]`, L is a lower triangular matrix of\nshape `[M, M]` with unit diagonal whose entries correspond to the strictly lower\ntriangular part of LU. U is a upper triangular matrix of shape `[M, M]` whose\nentries correspond to the upper triangular part, including the diagonal, of LU.\n\nP represents a permutation matrix encoded as a list of indices each between `0`\nand `M-1`, inclusive. If P_mat denotes the permutation matrix corresponding to\nP, then the L, U and P satisfies P_mat * input = L * U.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float64`, `float32`, `float16`, `complex64`, `complex128`."
      },
      {
        "name": "output_idx_type",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A tensor of shape `[..., M, M]` whose inner-most 2 dimensions form matrices of\nsize `[M, M]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "lu",
        "description": "A tensor of shape `[..., M, M]` whose strictly lower triangular part denotes the\nlower triangular factor `L` with unit diagonal, and whose upper triangular part\ndenotes the upper triangular factor `U`.",
        "typeAttr": "T"
      },
      {
        "name": "p",
        "description": "Permutation of the rows encoded as a list of indices in `0..M-1`. Shape is\n`[..., M]`.\n@compatibility(scipy)\nSimilar to `scipy.linalg.lu`, except the triangular factors `L` and `U` are\npacked into a single tensor, the permutation is applied to `input` instead of\nthe right hand side and the permutation `P` is returned as a list of indices\ninstead of a permutation matrix.\n@end_compatibility",
        "typeAttr": "output_idx_type"
      }
    ]
  },
  {
    "name": "MakeIterator",
    "summary": "Makes a new iterator from the given `dataset` and stores it in `iterator`.",
    "description": "This operation may be executed multiple times. Each execution will reset the\niterator in `iterator` to the first element of `dataset`.",
    "inputs": [
      {
        "name": "dataset",
        "type": 21
      },
      {
        "name": "iterator",
        "type": 20
      }
    ]
  },
  {
    "name": "MakeUnique",
    "summary": "Make all elements in the non-Batch dimension unique, but \\\"close\\\" to",
    "description": "their initial value. Never returns a sub-normal number. Never returns\nzero. The sign of each input element is always identical to the sign\nof the corresponding output element. Behavior for infinite elements is\nundefined. Behavior for subnormal elements is undefined.",
    "inputs": [
      {
        "name": "input",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 1
      }
    ]
  },
  {
    "name": "MapAndBatchDataset",
    "summary": "Creates a dataset that fuses mapping with batching.",
    "description": "Creates a dataset that applies `f` to the outputs of `input_dataset` and then\nbatches `batch_size` of them.\n\nUnlike a \"MapDataset\", which applies `f` sequentially, this dataset invokes up\nto `batch_size * num_parallel_batches` copies of `f` in parallel.",
    "attributes": [
      {
        "name": "f",
        "type": "function",
        "description": "A function to apply to the outputs of `input_dataset`."
      },
      {
        "name": "Targuments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "preserve_cardinality",
        "type": "boolean",
        "default": false
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the input dataset.",
        "type": 21
      },
      {
        "name": "other_arguments",
        "description": "A list of tensors, typically values that were captured when building a closure\nfor `f`.",
        "typeListAttr": "Targuments"
      },
      {
        "name": "batch_size",
        "description": "A scalar representing the number of elements to accumulate in a\nbatch. It determines the number of concurrent invocations of `f` that process\nelements from `input_dataset` in parallel.",
        "type": 9
      },
      {
        "name": "num_parallel_calls",
        "description": "A scalar representing the maximum number of parallel invocations of the `map_fn`\nfunction. Applying the `map_fn` on consecutive input elements in parallel has\nthe potential to improve input pipeline throughput.",
        "type": 9
      },
      {
        "name": "drop_remainder",
        "description": "A scalar representing whether the last batch should be dropped in case its size\nis smaller than desired.",
        "type": 10
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "MapClear",
    "summary": "Op removes all elements in the underlying container.",
    "attributes": [
      {
        "name": "capacity",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "memory_limit",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "dtypes",
        "type": "type[]"
      },
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ]
  },
  {
    "name": "MapDataset",
    "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`.",
    "attributes": [
      {
        "name": "f",
        "type": "function"
      },
      {
        "name": "Targuments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "use_inter_op_parallelism",
        "type": "boolean",
        "default": true
      },
      {
        "name": "preserve_cardinality",
        "type": "boolean",
        "default": false
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "other_arguments",
        "typeListAttr": "Targuments"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "MapDefun",
    "summary": "  Maps a function on the list of tensors unpacked from arguments on dimension 0.\n  The function given by `f` is assumed to be stateless, and is executed\n  concurrently on all the slices; up to batch_size (i.e. the size of the 0th\n  dimension of each argument) functions will be scheduled at once.\n\n  The `max_intra_op_parallelism` attr, which defaults to 1, can be used to\n  limit the intra op parallelism. To limit inter-op parallelism, a user can\n  set a private threadpool on the dataset using `tf.data.Options`'s\n  `ThreadingOptions`.\n\n  Note that this op is not exposed to users directly, but is invoked in tf.data\n  rewrites.",
    "attributes": [
      {
        "name": "Targuments",
        "type": "type[]",
        "description": "A list of types.",
        "minimum": 1
      },
      {
        "name": "Tcaptured",
        "type": "type[]",
        "description": "A list of types.",
        "minimum": 0,
        "default": []
      },
      {
        "name": "output_types",
        "type": "type[]",
        "description": "A list of types.",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "description": "A list of shapes.",
        "minimum": 1
      },
      {
        "name": "f",
        "type": "function"
      },
      {
        "name": "max_intra_op_parallelism",
        "type": "int64",
        "default": 1
      }
    ],
    "inputs": [
      {
        "name": "arguments",
        "description": "    A list of tensors whose types are `Targuments`, corresponding to the inputs\n    the function should be mapped over.",
        "typeListAttr": "Targuments"
      },
      {
        "name": "captured_inputs",
        "description": "    A list of tensors whose types are `Tcaptured`, corresponding to the captured\n    inputs of the defun.",
        "typeListAttr": "Tcaptured"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "    A list of output tensors whose types are `output_types` and whose dimensions\n    0 are the same as the dimensions 0 of the tensors in `arguments`, and whose\n    remaining dimensions correspond to those in `output_shapes`.",
        "typeListAttr": "output_types"
      }
    ]
  },
  {
    "name": "MapIncompleteSize",
    "summary": "Op returns the number of incomplete elements in the underlying container.",
    "attributes": [
      {
        "name": "capacity",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "memory_limit",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "dtypes",
        "type": "type[]"
      },
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "size",
        "type": 3
      }
    ]
  },
  {
    "name": "MapPeek",
    "summary": "Op peeks at the values at the specified key.  If the",
    "description": "underlying container does not contain this key\nthis op will block until it does.",
    "attributes": [
      {
        "name": "capacity",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "memory_limit",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "dtypes",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "key",
        "type": 9
      },
      {
        "name": "indices",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "values",
        "typeListAttr": "dtypes"
      }
    ]
  },
  {
    "name": "MapSize",
    "summary": "Op returns the number of elements in the underlying container.",
    "attributes": [
      {
        "name": "capacity",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "memory_limit",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "dtypes",
        "type": "type[]"
      },
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "size",
        "type": 3
      }
    ]
  },
  {
    "name": "MapStage",
    "summary": "Stage (key, values) in the underlying container which behaves like a hashtable.",
    "attributes": [
      {
        "name": "capacity",
        "type": "int64",
        "description": "Maximum number of elements in the Staging Area. If > 0, inserts\non the container will block when the capacity is reached.",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "memory_limit",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "dtypes",
        "type": "type[]"
      },
      {
        "name": "fake_dtypes",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this queue is placed in the given container. Otherwise,\na default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "It is necessary to match this name to the matching Unstage Op.",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "key",
        "description": "int64",
        "type": 9
      },
      {
        "name": "indices",
        "type": 3
      },
      {
        "name": "values",
        "description": "a list of tensors\ndtypes A list of data types that inserted values should adhere to.",
        "typeListAttr": "fake_dtypes"
      }
    ]
  },
  {
    "name": "MapUnstage",
    "summary": "Op removes and returns the values associated with the key",
    "description": "from the underlying container.   If the underlying container\ndoes not contain this key, the op will block until it does.",
    "attributes": [
      {
        "name": "capacity",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "memory_limit",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "dtypes",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "key",
        "type": 9
      },
      {
        "name": "indices",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "values",
        "typeListAttr": "dtypes"
      }
    ]
  },
  {
    "name": "MapUnstageNoKey",
    "summary": "Op removes and returns a random (key, value)",
    "description": "from the underlying container.   If the underlying container\ndoes not contain elements, the op will block until it does.",
    "attributes": [
      {
        "name": "capacity",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "memory_limit",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "dtypes",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "indices",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "key",
        "type": 9
      },
      {
        "name": "values",
        "typeListAttr": "dtypes"
      }
    ]
  },
  {
    "name": "MatMul",
    "summary": "Multiply the matrix \"a\" by the matrix \"b\".",
    "description": "The inputs must be two-dimensional matrices and the inner dimension of\n\"a\" (after being transposed if transpose_a is true) must match the\nouter dimension of \"b\" (after being transposed if transposed_b is\ntrue).\n\n*Note*: The default kernel implementation for MatMul on GPUs uses\ncublas.",
    "attributes": [
      {
        "name": "transpose_a",
        "type": "boolean",
        "description": "If true, \"a\" is transposed before multiplication.",
        "default": false
      },
      {
        "name": "transpose_b",
        "type": "boolean",
        "description": "If true, \"b\" is transposed before multiplication.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `int32`, `int64`, `uint8`, `uint16`, `uint32`, `uint64`, `complex64`, `complex128`."
      },
      {
        "name": "grad_a",
        "type": "boolean",
        "default": false
      },
      {
        "name": "grad_b",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "a",
        "typeAttr": "T"
      },
      {
        "name": "b",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "product",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MatchingFiles",
    "summary": "Returns the set of files matching one or more glob patterns.",
    "description": "Note that this routine only supports wildcard characters in the\nbasename portion of the pattern, not in the directory portion.\nNote also that the order of filenames returned is deterministic.",
    "inputs": [
      {
        "name": "pattern",
        "description": "Shell wildcard pattern(s). Scalar or vector of type string.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "filenames",
        "description": "A vector of matching filenames.",
        "type": 7
      }
    ]
  },
  {
    "name": "MatchingFilesDataset",
    "inputs": [
      {
        "name": "patterns",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "MatrixBandPart",
    "summary": "Copy a tensor setting everything outside a central band in each innermost matrix to zero.",
    "description": "The `band` part is computed as follows:\nAssume `input` has `k` dimensions `[I, J, K, ..., M, N]`, then the output is a\ntensor with the same shape where\n\n`band[i, j, k, ..., m, n] = in_band(m, n) * input[i, j, k, ..., m, n]`.\n\nThe indicator function\n\n`in_band(m, n) = (num_lower < 0 || (m-n) <= num_lower)) &&\n                 (num_upper < 0 || (n-m) <= num_upper)`.\n\nFor example:\n\n```\n# if 'input' is [[ 0,  1,  2, 3]\n#                [-1,  0,  1, 2]\n#                [-2, -1,  0, 1]\n#                [-3, -2, -1, 0]],\n\ntf.linalg.band_part(input, 1, -1) ==> [[ 0,  1,  2, 3]\n                                       [-1,  0,  1, 2]\n                                       [ 0, -1,  0, 1]\n                                       [ 0,  0, -1, 0]],\n\ntf.linalg.band_part(input, 2, 1) ==> [[ 0,  1,  0, 0]\n                                      [-1,  0,  1, 0]\n                                      [-2, -1,  0, 1]\n                                      [ 0, -2, -1, 0]]\n```\n\nUseful special cases:\n\n```\n tf.linalg.band_part(input, 0, -1) ==> Upper triangular part.\n tf.linalg.band_part(input, -1, 0) ==> Lower triangular part.\n tf.linalg.band_part(input, 0, 0) ==> Diagonal.\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tindex",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Rank `k` tensor.",
        "typeAttr": "T"
      },
      {
        "name": "num_lower",
        "description": "0-D tensor. Number of subdiagonals to keep. If negative, keep entire\nlower triangle.",
        "typeAttr": "Tindex"
      },
      {
        "name": "num_upper",
        "description": "0-D tensor. Number of superdiagonals to keep. If negative, keep\nentire upper triangle.",
        "typeAttr": "Tindex"
      }
    ],
    "outputs": [
      {
        "name": "band",
        "description": "Rank `k` tensor of the same shape as input. The extracted banded tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MatrixDeterminant",
    "summary": "Computes the determinant of one or more square matrices.",
    "description": "The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices. The output is a tensor containing the determinants\nfor all input submatrices `[..., :, :]`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Shape is `[..., M, M]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Shape is `[...]`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MatrixDiag",
    "summary": "Returns a batched diagonal tensor with a given batched diagonal values.",
    "description": "Given a `diagonal`, this operation returns a tensor with the `diagonal` and\neverything else padded with zeros. The diagonal is computed as follows:\n\nAssume `diagonal` has `k` dimensions `[I, J, K, ..., N]`, then the output is a\ntensor of rank `k+1` with dimensions [I, J, K, ..., N, N]` where:\n\n`output[i, j, k, ..., m, n] = 1{m=n} * diagonal[i, j, k, ..., n]`.\n\nFor example:\n\n```\n# 'diagonal' is [[1, 2, 3, 4], [5, 6, 7, 8]]\n\nand diagonal.shape = (2, 4)\n\ntf.matrix_diag(diagonal) ==> [[[1, 0, 0, 0]\n                                     [0, 2, 0, 0]\n                                     [0, 0, 3, 0]\n                                     [0, 0, 0, 4]],\n                                    [[5, 0, 0, 0]\n                                     [0, 6, 0, 0]\n                                     [0, 0, 7, 0]\n                                     [0, 0, 0, 8]]]\n\nwhich has shape (2, 4, 4)\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "diagonal",
        "description": "Rank `k`, where `k >= 1`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Rank `k+1`, with `output.shape = diagonal.shape + [diagonal.shape[-1]]`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MatrixDiagPart",
    "summary": "Returns the batched diagonal part of a batched tensor.",
    "description": "This operation returns a tensor with the `diagonal` part\nof the batched `input`. The `diagonal` part is computed as follows:\n\nAssume `input` has `k` dimensions `[I, J, K, ..., M, N]`, then the output is a\ntensor of rank `k - 1` with dimensions `[I, J, K, ..., min(M, N)]` where:\n\n`diagonal[i, j, k, ..., n] = input[i, j, k, ..., n, n]`.\n\nThe input must be at least a matrix.\n\nFor example:\n\n```\n# 'input' is [[[1, 0, 0, 0]\n               [0, 2, 0, 0]\n               [0, 0, 3, 0]\n               [0, 0, 0, 4]],\n              [[5, 0, 0, 0]\n               [0, 6, 0, 0]\n               [0, 0, 7, 0]\n               [0, 0, 0, 8]]]\n\nand input.shape = (2, 4, 4)\n\ntf.matrix_diag_part(input) ==> [[1, 2, 3, 4], [5, 6, 7, 8]]\n\nwhich has shape (2, 4)\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Rank `k` tensor where `k >= 2`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "diagonal",
        "description": "The extracted diagonal(s) having shape\n`diagonal.shape = input.shape[:-2] + [min(input.shape[-2:])]`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MatrixDiagPartV2",
    "summary": "Returns the batched diagonal part of a batched tensor.",
    "description": "Returns a tensor with the `k[0]`-th to `k[1]`-th diagonals of the batched\n`input`.\n\nAssume `input` has `r` dimensions `[I, J, ..., L, M, N]`.\nLet `max_diag_len` be the maximum length among all diagonals to be extracted,\n`max_diag_len = min(M + min(k[1], 0), N + min(-k[0], 0))`\nLet `num_diags` be the number of diagonals to extract,\n`num_diags = k[1] - k[0] + 1`.\n\nIf `num_diags == 1`, the output tensor is of rank `r - 1` with shape\n`[I, J, ..., L, max_diag_len]` and values:\n\n```\ndiagonal[i, j, ..., l, n]\n  = input[i, j, ..., l, n+y, n+x] ; if 0 <= n+y < M and 0 <= n+x < N,\n    padding_value                 ; otherwise.\n```\nwhere `y = max(-k[1], 0)`, `x = max(k[1], 0)`.\n\nOtherwise, the output tensor has rank `r` with dimensions\n`[I, J, ..., L, num_diags, max_diag_len]` with values:\n\n```\ndiagonal[i, j, ..., l, m, n]\n  = input[i, j, ..., l, n+y, n+x] ; if 0 <= n+y < M and 0 <= n+x < N,\n    padding_value                 ; otherwise.\n```\nwhere `d = k[1] - m`, `y = max(-d, 0)`, and `x = max(d, 0)`.\n\nThe input must be at least a matrix.\n\nFor example:\n\n```\ninput = np.array([[[1, 2, 3, 4],  # Input shape: (2, 3, 4)\n                   [5, 6, 7, 8],\n                   [9, 8, 7, 6]],\n                  [[5, 4, 3, 2],\n                   [1, 2, 3, 4],\n                   [5, 6, 7, 8]]])\n\n# A main diagonal from each batch.\ntf.matrix_diag_part(input) ==> [[1, 6, 7],  # Output shape: (2, 3)\n                                [5, 2, 7]]\n\n# A superdiagonal from each batch.\ntf.matrix_diag_part(input, k = 1)\n  ==> [[2, 7, 6],  # Output shape: (2, 3)\n       [4, 3, 8]]\n\n# A tridiagonal band from each batch.\ntf.matrix_diag_part(input, k = (-1, 1))\n  ==> [[[2, 7, 6],  # Output shape: (2, 3, 3)\n        [1, 6, 7],\n        [5, 8, 0]],\n       [[4, 3, 8],\n        [5, 2, 7],\n        [1, 6, 0]]]\n\n# Padding value = 9\ntf.matrix_diag_part(input, k = (1, 3), padding_value = 9)\n  ==> [[[4, 9, 9],  # Output shape: (2, 3, 3)\n        [3, 8, 9],\n        [2, 7, 6]],\n       [[2, 9, 9],\n        [3, 4, 9],\n        [4, 3, 8]]]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Rank `r` tensor where `r >= 2`.",
        "typeAttr": "T"
      },
      {
        "name": "k",
        "description": "Diagonal offset(s). Positive value means superdiagonal, 0 refers to the main\ndiagonal, and negative value means subdiagonals. `k` can be a single integer\n(for a single diagonal) or a pair of integers specifying the low and high ends\nof a matrix band. `k[0]` must not be larger than `k[1]`.",
        "type": 3
      },
      {
        "name": "padding_value",
        "description": "The value to fill the area outside the specified diagonal band with.\nDefault is 0.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "diagonal",
        "description": "The extracted diagonal(s).",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MatrixDiagPartV3",
    "summary": "Returns the batched diagonal part of a batched tensor.",
    "description": "Returns a tensor with the `k[0]`-th to `k[1]`-th diagonals of the batched\n`input`.\n\nAssume `input` has `r` dimensions `[I, J, ..., L, M, N]`.\nLet `max_diag_len` be the maximum length among all diagonals to be extracted,\n`max_diag_len = min(M + min(k[1], 0), N + min(-k[0], 0))`\nLet `num_diags` be the number of diagonals to extract,\n`num_diags = k[1] - k[0] + 1`.\n\nIf `num_diags == 1`, the output tensor is of rank `r - 1` with shape\n`[I, J, ..., L, max_diag_len]` and values:\n\n```\ndiagonal[i, j, ..., l, n]\n  = input[i, j, ..., l, n+y, n+x] ; if 0 <= n+y < M and 0 <= n+x < N,\n    padding_value                 ; otherwise.\n```\nwhere `y = max(-k[1], 0)`, `x = max(k[1], 0)`.\n\nOtherwise, the output tensor has rank `r` with dimensions\n`[I, J, ..., L, num_diags, max_diag_len]` with values:\n\n```\ndiagonal[i, j, ..., l, m, n]\n  = input[i, j, ..., l, n+y, n+x] ; if 0 <= n+y < M and 0 <= n+x < N,\n    padding_value                 ; otherwise.\n```\nwhere `d = k[1] - m`, `y = max(-d, 0) - offset`, and `x = max(d, 0) - offset`.\n\n`offset` is zero except when the alignment of the diagonal is to the right.\n```\noffset = max_diag_len - diag_len(d) ; if (`align` in {RIGHT_LEFT, RIGHT_RIGHT}\n                                           and `d >= 0`) or\n                                         (`align` in {LEFT_RIGHT, RIGHT_RIGHT}\n                                           and `d <= 0`)\n         0                          ; otherwise\n```\nwhere `diag_len(d) = min(cols - max(d, 0), rows + min(d, 0))`.\n\nThe input must be at least a matrix.\n\nFor example:\n\n```\ninput = np.array([[[1, 2, 3, 4],  # Input shape: (2, 3, 4)\n                   [5, 6, 7, 8],\n                   [9, 8, 7, 6]],\n                  [[5, 4, 3, 2],\n                   [1, 2, 3, 4],\n                   [5, 6, 7, 8]]])\n\n# A main diagonal from each batch.\ntf.matrix_diag_part(input) ==> [[1, 6, 7],  # Output shape: (2, 3)\n                                [5, 2, 7]]\n\n# A superdiagonal from each batch.\ntf.matrix_diag_part(input, k = 1)\n  ==> [[2, 7, 6],  # Output shape: (2, 3)\n       [4, 3, 8]]\n\n# A band from each batch.\ntf.matrix_diag_part(input, k = (-1, 2))\n  ==> [[[0, 3, 8],  # Output shape: (2, 4, 3)\n        [2, 7, 6],\n        [1, 6, 7],\n        [5, 8, 0]],\n       [[0, 3, 4],\n        [4, 3, 8],\n        [5, 2, 7],\n        [1, 6, 0]]]\n\n# LEFT_RIGHT alignment.\ntf.matrix_diag_part(input, k = (-1, 2), align=\"LEFT_RIGHT\")\n  ==> [[[3, 8, 0],  # Output shape: (2, 4, 3)\n        [2, 7, 6],\n        [1, 6, 7],\n        [0, 5, 8]],\n       [[3, 4, 0],\n        [4, 3, 8],\n        [5, 2, 7],\n        [0, 1, 6]]]\n\n# max_diag_len can be shorter than the main diagonal.\ntf.matrix_diag_part(input, k = (-2, -1))\n  ==> [[[5, 8],\n        [9, 0]],\n       [[1, 6],\n        [5, 0]]]\n\n# padding_value = 9\ntf.matrix_diag_part(input, k = (1, 3), padding_value = 9)\n  ==> [[[9, 9, 4],  # Output shape: (2, 3, 3)\n        [9, 3, 8],\n        [2, 7, 6]],\n       [[9, 9, 2],\n        [9, 3, 4],\n        [4, 3, 8]]]\n\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "align",
        "type": "string",
        "description": "Some diagonals are shorter than `max_diag_len` and need to be padded. `align` is\na string specifying how superdiagonals and subdiagonals should be aligned,\nrespectively. There are four possible alignments: \"RIGHT_LEFT\" (default),\n\"LEFT_RIGHT\", \"LEFT_LEFT\", and \"RIGHT_RIGHT\". \"RIGHT_LEFT\" aligns superdiagonals\nto the right (left-pads the row) and subdiagonals to the left (right-pads the\nrow). It is the packing format LAPACK uses. cuSPARSE uses \"LEFT_RIGHT\", which is\nthe opposite alignment. Must be one of the following: `LEFT_RIGHT`, `RIGHT_LEFT`, `LEFT_LEFT`, `RIGHT_RIGHT`.",
        "default": "RIGHT_LEFT"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Rank `r` tensor where `r >= 2`.",
        "typeAttr": "T"
      },
      {
        "name": "k",
        "description": "Diagonal offset(s). Positive value means superdiagonal, 0 refers to the main\ndiagonal, and negative value means subdiagonals. `k` can be a single integer\n(for a single diagonal) or a pair of integers specifying the low and high ends\nof a matrix band. `k[0]` must not be larger than `k[1]`.",
        "type": 3
      },
      {
        "name": "padding_value",
        "description": "The value to fill the area outside the specified diagonal band with.\nDefault is 0.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "diagonal",
        "description": "The extracted diagonal(s).",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MatrixDiagV2",
    "summary": "Returns a batched diagonal tensor with given batched diagonal values.",
    "description": "Returns a tensor with the contents in `diagonal` as `k[0]`-th to `k[1]`-th\ndiagonals of a matrix, with everything else padded with `padding`. `num_rows`\nand `num_cols` specify the dimension of the innermost matrix of the output. If\nboth are not specified, the op assumes the innermost matrix is square and infers\nits size from `k` and the innermost dimension of `diagonal`. If only one of them\nis specified, the op assumes the unspecified value is the smallest possible\nbased on other criteria.\n\nLet `diagonal` have `r` dimensions `[I, J, ..., L, M, N]`. The output tensor has\nrank `r+1` with shape `[I, J, ..., L, M, num_rows, num_cols]` when only one\ndiagonal is given (`k` is an integer or `k[0] == k[1]`). Otherwise, it has rank\n`r` with shape `[I, J, ..., L, num_rows, num_cols]`.\n\nThe second innermost dimension of `diagonal` has double meaning.\nWhen `k` is scalar or `k[0] == k[1]`, `M` is part of the batch size\n[I, J, ..., M], and the output tensor is:\n\n```\noutput[i, j, ..., l, m, n]\n  = diagonal[i, j, ..., l, n-max(d_upper, 0)] ; if n - m == d_upper\n    padding_value                             ; otherwise\n```\n\nOtherwise, `M` is treated as the number of diagonals for the matrix in the\nsame batch (`M = k[1]-k[0]+1`), and the output tensor is:\n\n```\noutput[i, j, ..., l, m, n]\n  = diagonal[i, j, ..., l, diag_index, index_in_diag] ; if k[0] <= d <= k[1]\n    padding_value                                     ; otherwise\n```\nwhere `d = n - m`, `diag_index = k[1] - d`, and `index_in_diag = n - max(d, 0)`.\n\nFor example:\n\n```\n# The main diagonal.\ndiagonal = np.array([[1, 2, 3, 4],            # Input shape: (2, 4)\n                     [5, 6, 7, 8]])\ntf.matrix_diag(diagonal) ==> [[[1, 0, 0, 0],  # Output shape: (2, 4, 4)\n                               [0, 2, 0, 0],\n                               [0, 0, 3, 0],\n                               [0, 0, 0, 4]],\n                              [[5, 0, 0, 0],\n                               [0, 6, 0, 0],\n                               [0, 0, 7, 0],\n                               [0, 0, 0, 8]]]\n\n# A superdiagonal (per batch).\ndiagonal = np.array([[1, 2, 3],  # Input shape: (2, 3)\n                     [4, 5, 6]])\ntf.matrix_diag(diagonal, k = 1)\n  ==> [[[0, 1, 0, 0],  # Output shape: (2, 4, 4)\n        [0, 0, 2, 0],\n        [0, 0, 0, 3],\n        [0, 0, 0, 0]],\n       [[0, 4, 0, 0],\n        [0, 0, 5, 0],\n        [0, 0, 0, 6],\n        [0, 0, 0, 0]]]\n\n# A band of diagonals.\ndiagonals = np.array([[[1, 2, 3],  # Input shape: (2, 2, 3)\n                       [4, 5, 0]],\n                      [[6, 7, 9],\n                       [9, 1, 0]]])\ntf.matrix_diag(diagonals, k = (-1, 0))\n  ==> [[[1, 0, 0],  # Output shape: (2, 3, 3)\n        [4, 2, 0],\n        [0, 5, 3]],\n       [[6, 0, 0],\n        [9, 7, 0],\n        [0, 1, 9]]]\n\n# Rectangular matrix.\ndiagonal = np.array([1, 2])  # Input shape: (2)\ntf.matrix_diag(diagonal, k = -1, num_rows = 3, num_cols = 4)\n  ==> [[0, 0, 0, 0],  # Output shape: (3, 4)\n       [1, 0, 0, 0],\n       [0, 2, 0, 0]]\n\n# Rectangular matrix with inferred num_cols and padding_value = 9.\ntf.matrix_diag(diagonal, k = -1, num_rows = 3, padding_value = 9)\n  ==> [[9, 9],  # Output shape: (3, 2)\n       [1, 9],\n       [9, 2]]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "diagonal",
        "description": "Rank `r`, where `r >= 1`",
        "typeAttr": "T"
      },
      {
        "name": "k",
        "description": "Diagonal offset(s). Positive value means superdiagonal, 0 refers to the main\ndiagonal, and negative value means subdiagonals. `k` can be a single integer\n(for a single diagonal) or a pair of integers specifying the low and high ends\nof a matrix band. `k[0]` must not be larger than `k[1]`.",
        "type": 3
      },
      {
        "name": "num_rows",
        "description": "The number of rows of the output matrix. If it is not provided, the op assumes\nthe output matrix is a square matrix and infers the matrix size from k and the\ninnermost dimension of `diagonal`.",
        "type": 3
      },
      {
        "name": "num_cols",
        "description": "The number of columns of the output matrix. If it is not provided, the op\nassumes the output matrix is a square matrix and infers the matrix size from\nk and the innermost dimension of `diagonal`.",
        "type": 3
      },
      {
        "name": "padding_value",
        "description": "The number to fill the area outside the specified diagonal band with.\nDefault is 0.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Has rank `r+1` when `k` is an integer or `k[0] == k[1]`, rank `r` otherwise.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MatrixDiagV3",
    "summary": "Returns a batched diagonal tensor with given batched diagonal values.",
    "description": "Returns a tensor with the contents in `diagonal` as `k[0]`-th to `k[1]`-th\ndiagonals of a matrix, with everything else padded with `padding`. `num_rows`\nand `num_cols` specify the dimension of the innermost matrix of the output. If\nboth are not specified, the op assumes the innermost matrix is square and infers\nits size from `k` and the innermost dimension of `diagonal`. If only one of them\nis specified, the op assumes the unspecified value is the smallest possible\nbased on other criteria.\n\nLet `diagonal` have `r` dimensions `[I, J, ..., L, M, N]`. The output tensor has\nrank `r+1` with shape `[I, J, ..., L, M, num_rows, num_cols]` when only one\ndiagonal is given (`k` is an integer or `k[0] == k[1]`). Otherwise, it has rank\n`r` with shape `[I, J, ..., L, num_rows, num_cols]`.\n\nThe second innermost dimension of `diagonal` has double meaning.\nWhen `k` is scalar or `k[0] == k[1]`, `M` is part of the batch size\n[I, J, ..., M], and the output tensor is:\n\n```\noutput[i, j, ..., l, m, n]\n  = diagonal[i, j, ..., l, n-max(d_upper, 0)] ; if n - m == d_upper\n    padding_value                             ; otherwise\n```\n\nOtherwise, `M` is treated as the number of diagonals for the matrix in the\nsame batch (`M = k[1]-k[0]+1`), and the output tensor is:\n\n```\noutput[i, j, ..., l, m, n]\n  = diagonal[i, j, ..., l, diag_index, index_in_diag] ; if k[0] <= d <= k[1]\n    padding_value                                     ; otherwise\n```\nwhere `d = n - m`, `diag_index = [k] - d`, and\n`index_in_diag = n - max(d, 0) + offset`.\n\n`offset` is zero except when the alignment of the diagonal is to the right.\n```\noffset = max_diag_len - diag_len(d) ; if (`align` in {RIGHT_LEFT, RIGHT_RIGHT}\n                                           and `d >= 0`) or\n                                         (`align` in {LEFT_RIGHT, RIGHT_RIGHT}\n                                           and `d <= 0`)\n         0                          ; otherwise\n```\nwhere `diag_len(d) = min(cols - max(d, 0), rows + min(d, 0))`.\n\nFor example:\n\n```\n# The main diagonal.\ndiagonal = np.array([[1, 2, 3, 4],            # Input shape: (2, 4)\n                     [5, 6, 7, 8]])\ntf.matrix_diag(diagonal) ==> [[[1, 0, 0, 0],  # Output shape: (2, 4, 4)\n                               [0, 2, 0, 0],\n                               [0, 0, 3, 0],\n                               [0, 0, 0, 4]],\n                              [[5, 0, 0, 0],\n                               [0, 6, 0, 0],\n                               [0, 0, 7, 0],\n                               [0, 0, 0, 8]]]\n\n# A superdiagonal (per batch).\ndiagonal = np.array([[1, 2, 3],  # Input shape: (2, 3)\n                     [4, 5, 6]])\ntf.matrix_diag(diagonal, k = 1)\n  ==> [[[0, 1, 0, 0],  # Output shape: (2, 4, 4)\n        [0, 0, 2, 0],\n        [0, 0, 0, 3],\n        [0, 0, 0, 0]],\n       [[0, 4, 0, 0],\n        [0, 0, 5, 0],\n        [0, 0, 0, 6],\n        [0, 0, 0, 0]]]\n\n# A tridiagonal band (per batch).\ndiagonals = np.array([[[0, 8, 9],  # Input shape: (2, 2, 3)\n                       [1, 2, 3],\n                       [4, 5, 0]],\n                      [[0, 2, 3],\n                       [6, 7, 9],\n                       [9, 1, 0]]])\ntf.matrix_diag(diagonals, k = (-1, 1))\n  ==> [[[1, 8, 0],  # Output shape: (2, 3, 3)\n        [4, 2, 9],\n        [0, 5, 3]],\n       [[6, 2, 0],\n        [9, 7, 3],\n        [0, 1, 9]]]\n\n# LEFT_RIGHT alignment.\ndiagonals = np.array([[[8, 9, 0],  # Input shape: (2, 2, 3)\n                       [1, 2, 3],\n                       [0, 4, 5]],\n                      [[2, 3, 0],\n                       [6, 7, 9],\n                       [0, 9, 1]]])\ntf.matrix_diag(diagonals, k = (-1, 1), align=\"LEFT_RIGHT\")\n  ==> [[[1, 8, 0],  # Output shape: (2, 3, 3)\n        [4, 2, 9],\n        [0, 5, 3]],\n       [[6, 2, 0],\n        [9, 7, 3],\n        [0, 1, 9]]]\n\n# Rectangular matrix.\ndiagonal = np.array([1, 2])  # Input shape: (2)\ntf.matrix_diag(diagonal, k = -1, num_rows = 3, num_cols = 4)\n  ==> [[0, 0, 0, 0],  # Output shape: (3, 4)\n       [1, 0, 0, 0],\n       [0, 2, 0, 0]]\n\n# Rectangular matrix with inferred num_cols and padding_value = 9.\ntf.matrix_diag(diagonal, k = -1, num_rows = 3, padding_value = 9)\n  ==> [[9, 9],  # Output shape: (3, 2)\n       [1, 9],\n       [9, 2]]\n\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "align",
        "type": "string",
        "description": "Some diagonals are shorter than `max_diag_len` and need to be padded. `align` is\na string specifying how superdiagonals and subdiagonals should be aligned,\nrespectively. There are four possible alignments: \"RIGHT_LEFT\" (default),\n\"LEFT_RIGHT\", \"LEFT_LEFT\", and \"RIGHT_RIGHT\". \"RIGHT_LEFT\" aligns superdiagonals\nto the right (left-pads the row) and subdiagonals to the left (right-pads the\nrow). It is the packing format LAPACK uses. cuSPARSE uses \"LEFT_RIGHT\", which is\nthe opposite alignment. Must be one of the following: `LEFT_RIGHT`, `RIGHT_LEFT`, `LEFT_LEFT`, `RIGHT_RIGHT`.",
        "default": "RIGHT_LEFT"
      }
    ],
    "inputs": [
      {
        "name": "diagonal",
        "description": "Rank `r`, where `r >= 1`",
        "typeAttr": "T"
      },
      {
        "name": "k",
        "description": "Diagonal offset(s). Positive value means superdiagonal, 0 refers to the main\ndiagonal, and negative value means subdiagonals. `k` can be a single integer\n(for a single diagonal) or a pair of integers specifying the low and high ends\nof a matrix band. `k[0]` must not be larger than `k[1]`.",
        "type": 3
      },
      {
        "name": "num_rows",
        "description": "The number of rows of the output matrix. If it is not provided, the op assumes\nthe output matrix is a square matrix and infers the matrix size from k and the\ninnermost dimension of `diagonal`.",
        "type": 3
      },
      {
        "name": "num_cols",
        "description": "The number of columns of the output matrix. If it is not provided, the op\nassumes the output matrix is a square matrix and infers the matrix size from\nk and the innermost dimension of `diagonal`.",
        "type": 3
      },
      {
        "name": "padding_value",
        "description": "The number to fill the area outside the specified diagonal band with.\nDefault is 0.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Has rank `r+1` when `k` is an integer or `k[0] == k[1]`, rank `r` otherwise.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MatrixExponential",
    "summary": "Deprecated, use python implementation tf.linalg.matrix_exponential.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float64`, `float32`, `float16`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MatrixInverse",
    "summary": "Computes the inverse of one or more square invertible matrices or their adjoints (conjugate transposes).",
    "description": "\nThe input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices. The output is a tensor of the same shape as the input\ncontaining the inverse for all input submatrices `[..., :, :]`.\n\nThe op uses LU decomposition with partial pivoting to compute the inverses.\n\nIf a matrix is not invertible there is no guarantee what the op does. It\nmay detect the condition and raise an exception or it may simply return a\ngarbage result.",
    "attributes": [
      {
        "name": "adjoint",
        "type": "boolean",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float64`, `float32`, `float16`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Shape is `[..., M, M]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Shape is `[..., M, M]`.\n\n@compatibility(numpy)\nEquivalent to np.linalg.inv\n@end_compatibility",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MatrixLogarithm",
    "summary": "Computes the matrix logarithm of one or more square matrices:",
    "description": "\n\\\\(log(exp(A)) = A\\\\)\n\nThis op is only defined for complex matrices. If A is positive-definite and\nreal, then casting to a complex matrix, taking the logarithm and casting back\nto a real matrix will give the correct result.\n\nThis function computes the matrix logarithm using the Schur-Parlett algorithm.\nDetails of the algorithm can be found in Section 11.6.2 of:\nNicholas J. Higham, Functions of Matrices: Theory and Computation, SIAM 2008.\nISBN 978-0-898716-46-7.\n\nThe input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices. The output is a tensor of the same shape as the input\ncontaining the exponential for all input submatrices `[..., :, :]`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Shape is `[..., M, M]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Shape is `[..., M, M]`.\n\n@compatibility(scipy)\nEquivalent to scipy.linalg.logm\n@end_compatibility",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MatrixSetDiag",
    "summary": "Returns a batched matrix tensor with new batched diagonal values.",
    "description": "Given `input` and `diagonal`, this operation returns a tensor with the\nsame shape and values as `input`, except for the main diagonal of the\ninnermost matrices.  These will be overwritten by the values in `diagonal`.\n\nThe output is computed as follows:\n\nAssume `input` has `k+1` dimensions `[I, J, K, ..., M, N]` and `diagonal` has\n`k` dimensions `[I, J, K, ..., min(M, N)]`.  Then the output is a\ntensor of rank `k+1` with dimensions `[I, J, K, ..., M, N]` where:\n\n  * `output[i, j, k, ..., m, n] = diagonal[i, j, k, ..., n]` for `m == n`.\n  * `output[i, j, k, ..., m, n] = input[i, j, k, ..., m, n]` for `m != n`.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Rank `k+1`, where `k >= 1`.",
        "typeAttr": "T"
      },
      {
        "name": "diagonal",
        "description": "Rank `k`, where `k >= 1`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Rank `k+1`, with `output.shape = input.shape`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MatrixSetDiagV2",
    "summary": "Returns a batched matrix tensor with new batched diagonal values.",
    "description": "Given `input` and `diagonal`, this operation returns a tensor with the\nsame shape and values as `input`, except for the specified diagonals of the\ninnermost matrices. These will be overwritten by the values in `diagonal`.\n\n`input` has `r+1` dimensions `[I, J, ..., L, M, N]`. When `k` is scalar or\n`k[0] == k[1]`, `diagonal` has `r` dimensions `[I, J, ..., L, max_diag_len]`.\nOtherwise, it has `r+1` dimensions `[I, J, ..., L, num_diags, max_diag_len]`.\n`num_diags` is the number of diagonals, `num_diags = k[1] - k[0] + 1`.\n`max_diag_len` is the longest diagonal in the range `[k[0], k[1]]`,\n`max_diag_len = min(M + min(k[1], 0), N + min(-k[0], 0))`\n\nThe output is a tensor of rank `k+1` with dimensions `[I, J, ..., L, M, N]`.\nIf `k` is scalar or `k[0] == k[1]`:\n\n```\noutput[i, j, ..., l, m, n]\n  = diagonal[i, j, ..., l, n-max(k[1], 0)] ; if n - m == k[1]\n    input[i, j, ..., l, m, n]              ; otherwise\n```\n\nOtherwise,\n\n```\noutput[i, j, ..., l, m, n]\n  = diagonal[i, j, ..., l, diag_index, index_in_diag] ; if k[0] <= d <= k[1]\n    input[i, j, ..., l, m, n]                         ; otherwise\n```\nwhere `d = n - m`, `diag_index = k[1] - d`, and `index_in_diag = n - max(d, 0)`.\n\nFor example:\n\n```\n# The main diagonal.\ninput = np.array([[[7, 7, 7, 7],              # Input shape: (2, 3, 4)\n                   [7, 7, 7, 7],\n                   [7, 7, 7, 7]],\n                  [[7, 7, 7, 7],\n                   [7, 7, 7, 7],\n                   [7, 7, 7, 7]]])\ndiagonal = np.array([[1, 2, 3],               # Diagonal shape: (2, 3)\n                     [4, 5, 6]])\ntf.matrix_set_diag(diagonal) ==> [[[1, 7, 7, 7],  # Output shape: (2, 3, 4)\n                                   [7, 2, 7, 7],\n                                   [7, 7, 3, 7]],\n                                  [[4, 7, 7, 7],\n                                   [7, 5, 7, 7],\n                                   [7, 7, 6, 7]]]\n\n# A superdiagonal (per batch).\ntf.matrix_set_diag(diagonal, k = 1)\n  ==> [[[7, 1, 7, 7],  # Output shape: (2, 3, 4)\n        [7, 7, 2, 7],\n        [7, 7, 7, 3]],\n       [[7, 4, 7, 7],\n        [7, 7, 5, 7],\n        [7, 7, 7, 6]]]\n\n# A band of diagonals.\ndiagonals = np.array([[[1, 2, 3],  # Diagonal shape: (2, 2, 3)\n                       [4, 5, 0]],\n                      [[6, 1, 2],\n                       [3, 4, 0]]])\ntf.matrix_set_diag(diagonals, k = (-1, 0))\n  ==> [[[1, 7, 7, 7],  # Output shape: (2, 3, 4)\n        [4, 2, 7, 7],\n        [0, 5, 3, 7]],\n       [[6, 7, 7, 7],\n        [3, 1, 7, 7],\n        [7, 4, 2, 7]]]\n\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Rank `r+1`, where `r >= 1`.",
        "typeAttr": "T"
      },
      {
        "name": "diagonal",
        "description": "Rank `r` when `k` is an integer or `k[0] == k[1]`. Otherwise, it has rank `r+1`.\n`k >= 1`.",
        "typeAttr": "T"
      },
      {
        "name": "k",
        "description": "Diagonal offset(s). Positive value means superdiagonal, 0 refers to the main\ndiagonal, and negative value means subdiagonals. `k` can be a single integer\n(for a single diagonal) or a pair of integers specifying the low and high ends\nof a matrix band. `k[0]` must not be larger than `k[1]`.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Rank `r+1`, with `output.shape = input.shape`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MatrixSetDiagV3",
    "summary": "Returns a batched matrix tensor with new batched diagonal values.",
    "description": "Given `input` and `diagonal`, this operation returns a tensor with the\nsame shape and values as `input`, except for the specified diagonals of the\ninnermost matrices. These will be overwritten by the values in `diagonal`.\n\n`input` has `r+1` dimensions `[I, J, ..., L, M, N]`. When `k` is scalar or\n`k[0] == k[1]`, `diagonal` has `r` dimensions `[I, J, ..., L, max_diag_len]`.\nOtherwise, it has `r+1` dimensions `[I, J, ..., L, num_diags, max_diag_len]`.\n`num_diags` is the number of diagonals, `num_diags = k[1] - k[0] + 1`.\n`max_diag_len` is the longest diagonal in the range `[k[0], k[1]]`,\n`max_diag_len = min(M + min(k[1], 0), N + min(-k[0], 0))`\n\nThe output is a tensor of rank `k+1` with dimensions `[I, J, ..., L, M, N]`.\nIf `k` is scalar or `k[0] == k[1]`:\n\n```\noutput[i, j, ..., l, m, n]\n  = diagonal[i, j, ..., l, n-max(k[1], 0)] ; if n - m == k[1]\n    input[i, j, ..., l, m, n]              ; otherwise\n```\n\nOtherwise,\n\n```\noutput[i, j, ..., l, m, n]\n  = diagonal[i, j, ..., l, diag_index, index_in_diag] ; if k[0] <= d <= k[1]\n    input[i, j, ..., l, m, n]                         ; otherwise\n```\nwhere `d = n - m`, `diag_index = k[1] - d`, and\n`index_in_diag = n - max(d, 0) + offset`.\n\n`offset` is zero except when the alignment of the diagonal is to the right.\n```\noffset = max_diag_len - diag_len(d) ; if (`align` in {RIGHT_LEFT, RIGHT_RIGHT}\n                                           and `d >= 0`) or\n                                         (`align` in {LEFT_RIGHT, RIGHT_RIGHT}\n                                           and `d <= 0`)\n         0                          ; otherwise\n```\nwhere `diag_len(d) = min(cols - max(d, 0), rows + min(d, 0))`.\n\nFor example:\n\n```\n# The main diagonal.\ninput = np.array([[[7, 7, 7, 7],              # Input shape: (2, 3, 4)\n                   [7, 7, 7, 7],\n                   [7, 7, 7, 7]],\n                  [[7, 7, 7, 7],\n                   [7, 7, 7, 7],\n                   [7, 7, 7, 7]]])\ndiagonal = np.array([[1, 2, 3],               # Diagonal shape: (2, 3)\n                     [4, 5, 6]])\ntf.matrix_set_diag(input, diagonal)\n  ==> [[[1, 7, 7, 7],  # Output shape: (2, 3, 4)\n        [7, 2, 7, 7],\n        [7, 7, 3, 7]],\n       [[4, 7, 7, 7],\n        [7, 5, 7, 7],\n        [7, 7, 6, 7]]]\n\n# A superdiagonal (per batch).\ntf.matrix_set_diag(input, diagonal, k = 1)\n  ==> [[[7, 1, 7, 7],  # Output shape: (2, 3, 4)\n        [7, 7, 2, 7],\n        [7, 7, 7, 3]],\n       [[7, 4, 7, 7],\n        [7, 7, 5, 7],\n        [7, 7, 7, 6]]]\n\n# A band of diagonals.\ndiagonals = np.array([[[0, 9, 1],  # Diagonal shape: (2, 4, 3)\n                       [6, 5, 8],\n                       [1, 2, 3],\n                       [4, 5, 0]],\n                      [[0, 1, 2],\n                       [5, 6, 4],\n                       [6, 1, 2],\n                       [3, 4, 0]]])\ntf.matrix_set_diag(input, diagonals, k = (-1, 2))\n  ==> [[[1, 6, 9, 7],  # Output shape: (2, 3, 4)\n        [4, 2, 5, 1],\n        [7, 5, 3, 8]],\n       [[6, 5, 1, 7],\n        [3, 1, 6, 2],\n        [7, 4, 2, 4]]]\n\n# LEFT_RIGHT alignment.\ndiagonals = np.array([[[9, 1, 0],  # Diagonal shape: (2, 4, 3)\n                       [6, 5, 8],\n                       [1, 2, 3],\n                       [0, 4, 5]],\n                      [[1, 2, 0],\n                       [5, 6, 4],\n                       [6, 1, 2],\n                       [0, 3, 4]]])\ntf.matrix_set_diag(input, diagonals, k = (-1, 2), align=\"LEFT_RIGHT\")\n  ==> [[[1, 6, 9, 7],  # Output shape: (2, 3, 4)\n        [4, 2, 5, 1],\n        [7, 5, 3, 8]],\n       [[6, 5, 1, 7],\n        [3, 1, 6, 2],\n        [7, 4, 2, 4]]]\n\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "align",
        "type": "string",
        "description": "Some diagonals are shorter than `max_diag_len` and need to be padded. `align` is\na string specifying how superdiagonals and subdiagonals should be aligned,\nrespectively. There are four possible alignments: \"RIGHT_LEFT\" (default),\n\"LEFT_RIGHT\", \"LEFT_LEFT\", and \"RIGHT_RIGHT\". \"RIGHT_LEFT\" aligns superdiagonals\nto the right (left-pads the row) and subdiagonals to the left (right-pads the\nrow). It is the packing format LAPACK uses. cuSPARSE uses \"LEFT_RIGHT\", which is\nthe opposite alignment. Must be one of the following: `LEFT_RIGHT`, `RIGHT_LEFT`, `LEFT_LEFT`, `RIGHT_RIGHT`.",
        "default": "RIGHT_LEFT"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Rank `r+1`, where `r >= 1`.",
        "typeAttr": "T"
      },
      {
        "name": "diagonal",
        "description": "Rank `r` when `k` is an integer or `k[0] == k[1]`. Otherwise, it has rank `r+1`.\n`k >= 1`.",
        "typeAttr": "T"
      },
      {
        "name": "k",
        "description": "Diagonal offset(s). Positive value means superdiagonal, 0 refers to the main\ndiagonal, and negative value means subdiagonals. `k` can be a single integer\n(for a single diagonal) or a pair of integers specifying the low and high ends\nof a matrix band. `k[0]` must not be larger than `k[1]`.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Rank `r+1`, with `output.shape = input.shape`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MatrixSolve",
    "summary": "Solves systems of linear equations.",
    "description": "`Matrix` is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices. `Rhs` is a tensor of shape `[..., M, K]`. The `output` is\na tensor shape `[..., M, K]`.  If `adjoint` is `False` then each output matrix\nsatisfies `matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]`.\nIf `adjoint` is `True` then each output matrix satisfies\n`adjoint(matrix[..., :, :]) * output[..., :, :] = rhs[..., :, :]`.",
    "attributes": [
      {
        "name": "adjoint",
        "type": "boolean",
        "description": "Boolean indicating whether to solve with `matrix` or its (block-wise)\nadjoint.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float64`, `float32`, `float16`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "matrix",
        "description": "Shape is `[..., M, M]`.",
        "typeAttr": "T"
      },
      {
        "name": "rhs",
        "description": "Shape is `[..., M, K]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Shape is `[..., M, K]`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MatrixSolveLs",
    "summary": "Solves one or more linear least-squares problems.",
    "description": "`matrix` is a tensor of shape `[..., M, N]` whose inner-most 2 dimensions\nform real or complex matrices of size `[M, N]`. `Rhs` is a tensor of the same\ntype as `matrix` and shape `[..., M, K]`.\nThe output is a tensor shape `[..., N, K]` where each output matrix solves\neach of the equations\n`matrix[..., :, :]` * `output[..., :, :]` = `rhs[..., :, :]`\nin the least squares sense.\n\nWe use the following notation for (complex) matrix and right-hand sides\nin the batch:\n\n`matrix`=\\\\(A \\in \\mathbb{C}^{m \\times n}\\\\),\n`rhs`=\\\\(B  \\in \\mathbb{C}^{m \\times k}\\\\),\n`output`=\\\\(X  \\in \\mathbb{C}^{n \\times k}\\\\),\n`l2_regularizer`=\\\\(\\lambda \\in \\mathbb{R}\\\\).\n\nIf `fast` is `True`, then the solution is computed by solving the normal\nequations using Cholesky decomposition. Specifically, if \\\\(m \\ge n\\\\) then\n\\\\(X = (A^H A + \\lambda I)^{-1} A^H B\\\\), which solves the least-squares\nproblem \\\\(X = \\mathrm{argmin}_{Z \\in \\Re^{n \\times k} } ||A Z - B||_F^2 + \\lambda ||Z||_F^2\\\\).\nIf \\\\(m \\lt n\\\\) then `output` is computed as\n\\\\(X = A^H (A A^H + \\lambda I)^{-1} B\\\\), which (for \\\\(\\lambda = 0\\\\)) is the\nminimum-norm solution to the under-determined linear system, i.e.\n\\\\(X = \\mathrm{argmin}_{Z \\in \\mathbb{C}^{n \\times k} } ||Z||_F^2 \\\\),\nsubject to \\\\(A Z = B\\\\). Notice that the fast path is only numerically stable\nwhen \\\\(A\\\\) is numerically full rank and has a condition number\n\\\\(\\mathrm{cond}(A) \\lt \\frac{1}{\\sqrt{\\epsilon_{mach} } }\\\\) or \\\\(\\lambda\\\\) is\nsufficiently large.\n\nIf `fast` is `False` an algorithm based on the numerically robust complete\northogonal decomposition is used. This computes the minimum-norm\nleast-squares solution, even when \\\\(A\\\\) is rank deficient. This path is\ntypically 6-7 times slower than the fast path. If `fast` is `False` then\n`l2_regularizer` is ignored.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float64`, `float32`, `float16`, `complex64`, `complex128`."
      },
      {
        "name": "fast",
        "type": "boolean",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "matrix",
        "description": "Shape is `[..., M, N]`.",
        "typeAttr": "T"
      },
      {
        "name": "rhs",
        "description": "Shape is `[..., M, K]`.",
        "typeAttr": "T"
      },
      {
        "name": "l2_regularizer",
        "description": "Scalar tensor.\n\n@compatibility(numpy)\nEquivalent to np.linalg.lstsq\n@end_compatibility",
        "type": 2
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Shape is `[..., N, K]`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MatrixSquareRoot",
    "summary": "Computes the matrix square root of one or more square matrices:",
    "description": "matmul(sqrtm(A), sqrtm(A)) = A\n\nThe input matrix should be invertible. If the input matrix is real, it should\nhave no eigenvalues which are real and negative (pairs of complex conjugate\neigenvalues are allowed).\n\nThe matrix square root is computed by first reducing the matrix to\nquasi-triangular form with the real Schur decomposition. The square root\nof the quasi-triangular matrix is then computed directly. Details of\nthe algorithm can be found in: Nicholas J. Higham, \"Computing real\nsquare roots of a real matrix\", Linear Algebra Appl., 1987.\n\nThe input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices. The output is a tensor of the same shape as the input\ncontaining the matrix square root for all input submatrices `[..., :, :]`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float64`, `float32`, `float16`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Shape is `[..., M, M]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Shape is `[..., M, M]`.\n\n@compatibility(scipy)\nEquivalent to scipy.linalg.sqrtm\n@end_compatibility",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MatrixTriangularSolve",
    "summary": "Solves systems of linear equations with upper or lower triangular matrices by backsubstitution.",
    "description": "\n`matrix` is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions form\nsquare matrices. If `lower` is `True` then the strictly upper triangular part\nof each inner-most matrix is assumed to be zero and not accessed.\nIf `lower` is False then the strictly lower triangular part of each inner-most\nmatrix is assumed to be zero and not accessed.\n`rhs` is a tensor of shape `[..., M, N]`.\n\nThe output is a tensor of shape `[..., M, N]`. If `adjoint` is\n`True` then the innermost matrices in `output` satisfy matrix equations\n`matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]`.\nIf `adjoint` is `False` then the strictly then the  innermost matrices in\n`output` satisfy matrix equations\n`adjoint(matrix[..., i, k]) * output[..., k, j] = rhs[..., i, j]`.\n\nNote, the batch shapes for the inputs only need to broadcast.\n\nExample:\n```python\n\na = tf.constant([[3,  0,  0,  0],\n                 [2,  1,  0,  0],\n                 [1,  0,  1,  0],\n                 [1,  1,  1,  1]], dtype=tf.float32)\n\nb = tf.constant([[4],\n                 [2],\n                 [4],\n                 [2]], dtype=tf.float32)\n\nx = tf.linalg.triangular_solve(a, b, lower=True)\nx\n# <tf.Tensor: shape=(4, 1), dtype=float32, numpy=\n# array([[ 1.3333334 ],\n#        [-0.66666675],\n#        [ 2.6666665 ],\n#        [-1.3333331 ]], dtype=float32)>\n\n# in python3 one can use `a@x`\ntf.matmul(a, x)\n# <tf.Tensor: shape=(4, 1), dtype=float32, numpy=\n# array([[4.       ],\n#        [2.       ],\n#        [4.       ],\n#        [1.9999999]], dtype=float32)>\n```",
    "attributes": [
      {
        "name": "lower",
        "type": "boolean",
        "description": "Boolean indicating whether the innermost matrices in `matrix` are\nlower or upper triangular.",
        "default": true
      },
      {
        "name": "adjoint",
        "type": "boolean",
        "description": "Boolean indicating whether to solve with `matrix` or its (block-wise)\n         adjoint.\n\n@compatibility(numpy)\nEquivalent to scipy.linalg.solve_triangular\n@end_compatibility",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float64`, `float32`, `float16`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "matrix",
        "description": "Shape is `[..., M, M]`.",
        "typeAttr": "T"
      },
      {
        "name": "rhs",
        "description": "Shape is `[..., M, K]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Shape is `[..., M, K]`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Max",
    "summary": "Computes the maximum of elements across dimensions of a tensor.",
    "description": "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1.",
    "attributes": [
      {
        "name": "keep_dims",
        "type": "boolean",
        "description": "If true, retain reduced dimensions with length 1.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`, `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The tensor to reduce.",
        "typeAttr": "T"
      },
      {
        "name": "reduction_indices",
        "description": "The dimensions to reduce. Must be in the range\n`[-rank(input), rank(input))`.",
        "typeAttr": "Tidx"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The reduced tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MaxIntraOpParallelismDataset",
    "summary": "Creates a dataset that overrides the maximum intra-op parallelism.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "max_intra_op_parallelism",
        "description": "Identifies the maximum intra-op parallelism to use.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "MaxPool",
    "category": "Pool",
    "summary": "Performs max pooling on the input.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`, `int32`, `int64`, `uint8`, `int16`, `int8`, `uint16`, `qint8`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "ksize",
        "type": "int64[]",
        "description": "The size of the window for each dimension of the input tensor.",
        "minimum": 4
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
        "minimum": 4
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`, `EXPLICIT`."
      },
      {
        "name": "explicit_paddings",
        "type": "int64[]",
        "default": []
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width]. Must be one of the following: `NHWC`, `NCHW`, `NCHW_VECT_C`.",
        "default": "NHWC"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "4-D input to pool over.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The max pooled output tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MaxPool3D",
    "summary": "Performs 3D max pooling on the input.",
    "attributes": [
      {
        "name": "ksize",
        "type": "int64[]",
        "description": "1-D tensor of length 5. The size of the window for each dimension of\nthe input tensor. Must have `ksize[0] = ksize[4] = 1`.",
        "minimum": 5
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
        "minimum": 5
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width]. Must be one of the following: `NDHWC`, `NCDHW`.",
        "default": "NDHWC"
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Shape `[batch, depth, rows, cols, channels]` tensor to pool over.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The max pooled output tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MaxPool3DGrad",
    "summary": "Computes gradients of 3D max pooling function.",
    "attributes": [
      {
        "name": "ksize",
        "type": "int64[]",
        "description": "1-D tensor of length 5. The size of the window for each dimension of\nthe input tensor. Must have `ksize[0] = ksize[4] = 1`.",
        "minimum": 5
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
        "minimum": 5
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width]. Must be one of the following: `NDHWC`, `NCDHW`.",
        "default": "NDHWC"
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "TInput",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "orig_input",
        "description": "The original input tensor.",
        "typeAttr": "TInput"
      },
      {
        "name": "orig_output",
        "description": "The original output tensor.",
        "typeAttr": "TInput"
      },
      {
        "name": "grad",
        "description": "Output backprop of shape `[batch, depth, rows, cols, channels]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MaxPool3DGradGrad",
    "summary": "Computes second-order gradients of the maxpooling function.",
    "attributes": [
      {
        "name": "ksize",
        "type": "int64[]",
        "description": "1-D tensor of length 5. The size of the window for each dimension of\nthe input tensor. Must have `ksize[0] = ksize[4] = 1`.",
        "minimum": 5
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
        "minimum": 5
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width]. Must be one of the following: `NDHWC`, `NCDHW`.",
        "default": "NDHWC"
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "orig_input",
        "description": "The original input tensor.",
        "typeAttr": "T"
      },
      {
        "name": "orig_output",
        "description": "The original output tensor.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "Output backprop of shape `[batch, depth, rows, cols, channels]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Gradients of gradients w.r.t. the input to `max_pool`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MaxPoolGrad",
    "summary": "Computes gradients of the maxpooling function.",
    "attributes": [
      {
        "name": "ksize",
        "type": "int64[]",
        "description": "The size of the window for each dimension of the input tensor.",
        "minimum": 4
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
        "minimum": 4
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`, `EXPLICIT`."
      },
      {
        "name": "explicit_paddings",
        "type": "int64[]",
        "default": []
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width]. Must be one of the following: `NHWC`, `NCHW`.",
        "default": "NHWC"
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "orig_input",
        "description": "The original input tensor.",
        "typeAttr": "T"
      },
      {
        "name": "orig_output",
        "description": "The original output tensor.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "4-D.  Gradients w.r.t. the output of `max_pool`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Gradients w.r.t. the input to `max_pool`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MaxPoolGradGrad",
    "summary": "Computes second-order gradients of the maxpooling function.",
    "attributes": [
      {
        "name": "ksize",
        "type": "int64[]",
        "description": "The size of the window for each dimension of the input tensor.",
        "minimum": 4
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
        "minimum": 4
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width]. Must be one of the following: `NHWC`, `NCHW`.",
        "default": "NHWC"
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "orig_input",
        "description": "The original input tensor.",
        "typeAttr": "T"
      },
      {
        "name": "orig_output",
        "description": "The original output tensor.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "4-D.  Gradients of gradients w.r.t. the input of `max_pool`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Gradients of gradients w.r.t. the input to `max_pool`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MaxPoolGradGradV2",
    "summary": "Computes second-order gradients of the maxpooling function.",
    "attributes": [
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width]. Must be one of the following: `NHWC`, `NCHW`.",
        "default": "NHWC"
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "orig_input",
        "description": "The original input tensor.",
        "typeAttr": "T"
      },
      {
        "name": "orig_output",
        "description": "The original output tensor.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "4-D.  Gradients of gradients w.r.t. the input of `max_pool`.",
        "typeAttr": "T"
      },
      {
        "name": "ksize",
        "description": "The size of the window for each dimension of the input tensor.",
        "type": 3
      },
      {
        "name": "strides",
        "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Gradients of gradients w.r.t. the input to `max_pool`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MaxPoolGradGradWithArgmax",
    "summary": "Computes second-order gradients of the maxpooling function.",
    "attributes": [
      {
        "name": "ksize",
        "type": "int64[]",
        "description": "The size of the window for each dimension of the input tensor.",
        "minimum": 4
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
        "minimum": 4
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "include_batch_in_index",
        "type": "boolean",
        "description": "Whether to include batch dimension in flattened index of `argmax`.",
        "default": false
      },
      {
        "name": "Targmax",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The original input.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "4-D with shape `[batch, height, width, channels]`.  Gradients w.r.t. the\ninput of `max_pool`.",
        "typeAttr": "T"
      },
      {
        "name": "argmax",
        "description": "The indices of the maximum values chosen for each output of `max_pool`.",
        "typeAttr": "Targmax"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Gradients of gradients w.r.t. the input of `max_pool`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MaxPoolGradV2",
    "summary": "Computes gradients of the maxpooling function.",
    "attributes": [
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width]. Must be one of the following: `NHWC`, `NCHW`.",
        "default": "NHWC"
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "orig_input",
        "description": "The original input tensor.",
        "typeAttr": "T"
      },
      {
        "name": "orig_output",
        "description": "The original output tensor.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "4-D.  Gradients w.r.t. the output of `max_pool`.",
        "typeAttr": "T"
      },
      {
        "name": "ksize",
        "description": "The size of the window for each dimension of the input tensor.",
        "type": 3
      },
      {
        "name": "strides",
        "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Gradients w.r.t. the input to `max_pool`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MaxPoolGradWithArgmax",
    "summary": "Computes gradients of the maxpooling function.",
    "attributes": [
      {
        "name": "ksize",
        "type": "int64[]",
        "description": "The size of the window for each dimension of the input tensor.",
        "minimum": 4
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
        "minimum": 4
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "include_batch_in_index",
        "type": "boolean",
        "description": "Whether to include batch dimension in flattened index of `argmax`.",
        "default": false
      },
      {
        "name": "Targmax",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The original input.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "4-D with shape `[batch, height, width, channels]`.  Gradients w.r.t. the\noutput of `max_pool`.",
        "typeAttr": "T"
      },
      {
        "name": "argmax",
        "description": "The indices of the maximum values chosen for each output of `max_pool`.",
        "typeAttr": "Targmax"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Gradients w.r.t. the input of `max_pool`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MaxPoolV2",
    "category": "Pool",
    "summary": "Performs max pooling on the input.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`, `int32`, `int64`, `uint8`, `int16`, `int8`, `uint16`, `qint8`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width]. Must be one of the following: `NHWC`, `NCHW`, `NCHW_VECT_C`.",
        "default": "NHWC"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "4-D input to pool over.",
        "typeAttr": "T"
      },
      {
        "name": "ksize",
        "description": "The size of the window for each dimension of the input tensor.",
        "type": 3
      },
      {
        "name": "strides",
        "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The max pooled output tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MaxPoolWithArgmax",
    "category": "Pool",
    "summary": "Performs max pooling on the input and outputs both max values and indices.",
    "description": "The indices in `argmax` are flattened, so that a maximum value at position\n`[b, y, x, c]` becomes flattened index:\n`(y * width + x) * channels + c` if `include_batch_in_index` is False;\n`((b * height + y) * width + x) * channels + c` if `include_batch_in_index` is True.\n\nThe indices returned are always in `[0, height) x [0, width)` before flattening,\neven if padding is involved and the mathematically correct answer is outside\n(either negative or too large).  This is a bug, but fixing it is difficult to do\nin a safe backwards compatible way, especially due to flattening.",
    "attributes": [
      {
        "name": "ksize",
        "type": "int64[]",
        "description": "The size of the window for each dimension of the input tensor.",
        "minimum": 4
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
        "minimum": 4
      },
      {
        "name": "Targmax",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "include_batch_in_index",
        "type": "boolean",
        "description": "Whether to include batch dimension in flattened index of `argmax`.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "4-D with shape `[batch, height, width, channels]`.  Input to pool over.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The max pooled output tensor.",
        "typeAttr": "T"
      },
      {
        "name": "argmax",
        "description": "4-D.  The flattened indices of the max values chosen for each output.",
        "typeAttr": "Targmax"
      }
    ]
  },
  {
    "name": "Maximum",
    "summary": "Returns the max of x and y (i.e. x > y ? x : y) element-wise.",
    "description": "*NOTE*: `Maximum` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `int8`, `uint8`, `int16`, `uint16`, `int32`, `uint32`, `int64`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Mean",
    "summary": "Computes the mean of elements across dimensions of a tensor.",
    "description": "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1.",
    "attributes": [
      {
        "name": "keep_dims",
        "type": "boolean",
        "description": "If true, retain reduced dimensions with length 1.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The tensor to reduce.",
        "typeAttr": "T"
      },
      {
        "name": "reduction_indices",
        "description": "The dimensions to reduce. Must be in the range\n`[-rank(input), rank(input))`.",
        "typeAttr": "Tidx"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The reduced tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Merge",
    "summary": "Forwards the value of an available tensor from `inputs` to `output`.",
    "description": "`Merge` waits for at least one of the tensors in `inputs` to become available.\nIt is usually combined with `Switch` to implement branching.\n\n`Merge` forwards the first tensor to become available to `output`, and sets\n`value_index` to its index in `inputs`.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "description": "The input tensors, exactly one of which will become available.",
        "numberAttr": "N",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Will be set to the available input tensor.",
        "typeAttr": "T"
      },
      {
        "name": "value_index",
        "description": "The index of the chosen input tensor in `inputs`.",
        "type": 3
      }
    ]
  },
  {
    "name": "MergeDedupData",
    "summary": "An op merges elements of integer and float tensors into deduplication data as\nXLA tuple.",
    "description": "This op merges outputs of SplitDedupDataOp, which gives two 1-D tensors, integer\nand floating point. With respect to tuple_mask, this op merges values of these\ntwo tensors into an XLA tuple, which should be as same as input to\nSplitDedupDataOp.",
    "attributes": [
      {
        "name": "tuple_mask",
        "type": "string",
        "description": "A serialized TensorProto string of output tuple mask. This mask is a 2-D tensor,\nwith first column as tuple element type, and second column as span of this type.\nFor example, an output tuple of (1, 2, 0.1, 3), its mask is [[0, 2], [1, 1], [0,\n1]]. We expect only two types of elements: integer(0) and float(1)."
      },
      {
        "name": "integer_type",
        "type": "type",
        "description": "integer_tensor type. Allowed types: {int32, int64, uint32, uint64}. Must be one of the following: `int32`, `int64`, `uint32`, `uint64`."
      },
      {
        "name": "float_type",
        "type": "type",
        "description": "float_tensor type. Allowed types: {half, bfloat16, float}. Must be one of the following: `float16`, `bfloat16`, `float32`."
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "integer_tensor",
        "description": "A 1-D integer tensor, includes integer elements of deduplication data tuple.",
        "typeAttr": "integer_type"
      },
      {
        "name": "float_tensor",
        "description": "A 1-D float tensor, includes float elements of deduplication data tuple.",
        "typeAttr": "float_type"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "An XLA tuple merging integer and float elements as deduplication data tuple.",
        "type": 21
      }
    ]
  },
  {
    "name": "MergeSummary",
    "summary": "Merges summaries.",
    "description": "This op creates a\n[`Summary`](https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto)\nprotocol buffer that contains the union of all the values in the input\nsummaries.\n\nWhen the Op is run, it reports an `InvalidArgument` error if multiple values\nin the summaries to merge use the same tag.",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "description": "Can be of any shape.  Each must contain serialized `Summary` protocol\nbuffers.",
        "numberAttr": "N",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "summary",
        "description": "Scalar. Serialized `Summary` protocol buffer.",
        "type": 7
      }
    ]
  },
  {
    "name": "MergeV2Checkpoints",
    "summary": "V2 format specific: merges the metadata files of sharded checkpoints.  The",
    "description": "result is one logical checkpoint, with one physical metadata file and renamed\ndata files.\n\nIntended for \"grouping\" multiple checkpoints in a sharded checkpoint setup.\n\nIf delete_old_dirs is true, attempts to delete recursively the dirname of each\npath in the input checkpoint_prefixes.  This is useful when those paths are non\nuser-facing temporary locations.\n\nIf allow_missing_files is true, merges the checkpoint prefixes as long as\nat least one file exists. Otherwise, if no files exist, an error will be thrown.\nThe default value for allow_missing_files is false.",
    "attributes": [
      {
        "name": "delete_old_dirs",
        "type": "boolean",
        "description": "see above.",
        "default": true
      },
      {
        "name": "allow_missing_files",
        "type": "boolean",
        "description": "see above.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "checkpoint_prefixes",
        "description": "prefixes of V2 checkpoints to merge.",
        "type": 7
      },
      {
        "name": "destination_prefix",
        "description": "scalar.  The desired final prefix.  Allowed to be the same\nas one of the checkpoint_prefixes.",
        "type": 7
      }
    ]
  },
  {
    "name": "Mfcc",
    "summary": "Transforms a spectrogram into a form that's useful for speech recognition.",
    "description": "Mel Frequency Cepstral Coefficients are a way of representing audio data that's\nbeen effective as an input feature for machine learning. They are created by\ntaking the spectrum of a spectrogram (a 'cepstrum'), and discarding some of the\nhigher frequencies that are less significant to the human ear. They have a long\nhistory in the speech recognition world, and https://en.wikipedia.org/wiki/Mel-frequency_cepstrum\nis a good resource to learn more.",
    "attributes": [
      {
        "name": "upper_frequency_limit",
        "type": "float32",
        "description": "The highest frequency to use when calculating the\nceptstrum.",
        "default": 4000.0
      },
      {
        "name": "lower_frequency_limit",
        "type": "float32",
        "description": "The lowest frequency to use when calculating the\nceptstrum.",
        "default": 20.0
      },
      {
        "name": "filterbank_channel_count",
        "type": "int64",
        "description": "Resolution of the Mel bank used internally.",
        "default": 40
      },
      {
        "name": "dct_coefficient_count",
        "type": "int64",
        "description": "How many output channels to produce per time slice.",
        "default": 13
      }
    ],
    "inputs": [
      {
        "name": "spectrogram",
        "description": "Typically produced by the Spectrogram op, with magnitude_squared\nset to true.",
        "type": 1
      },
      {
        "name": "sample_rate",
        "description": "How many samples per second the source audio used.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 1
      }
    ]
  },
  {
    "name": "Min",
    "summary": "Computes the minimum of elements across dimensions of a tensor.",
    "description": "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1.",
    "attributes": [
      {
        "name": "keep_dims",
        "type": "boolean",
        "description": "If true, retain reduced dimensions with length 1.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`, `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The tensor to reduce.",
        "typeAttr": "T"
      },
      {
        "name": "reduction_indices",
        "description": "The dimensions to reduce. Must be in the range\n`[-rank(input), rank(input))`.",
        "typeAttr": "Tidx"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The reduced tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Minimum",
    "summary": "Returns the min of x and y (i.e. x < y ? x : y) element-wise.",
    "description": "*NOTE*: `Minimum` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `int8`, `uint8`, `int16`, `uint16`, `int32`, `uint32`, `int64`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MirrorPad",
    "summary": "Pads a tensor with mirrored values.",
    "description": "This operation pads a `input` with mirrored values according to the `paddings`\nyou specify. `paddings` is an integer tensor with shape `[n, 2]`, where n is\nthe rank of `input`. For each dimension D of `input`, `paddings[D, 0]` indicates\nhow many values to add before the contents of `input` in that dimension, and\n`paddings[D, 1]` indicates how many values to add after the contents of `input`\nin that dimension. Both `paddings[D, 0]` and `paddings[D, 1]` must be no greater\nthan `input.dim_size(D)` (or `input.dim_size(D) - 1`) if `copy_border` is true\n(if false, respectively).\n\nThe padded size of each dimension D of the output is:\n\n`paddings(D, 0) + input.dim_size(D) + paddings(D, 1)`\n\nFor example:\n\n```\n# 't' is [[1, 2, 3], [4, 5, 6]].\n# 'paddings' is [[1, 1]], [2, 2]].\n# 'mode' is SYMMETRIC.\n# rank of 't' is 2.\npad(t, paddings) ==> [[2, 1, 1, 2, 3, 3, 2]\n                      [2, 1, 1, 2, 3, 3, 2]\n                      [5, 4, 4, 5, 6, 6, 5]\n                      [5, 4, 4, 5, 6, 6, 5]]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tpaddings",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "mode",
        "type": "string",
        "description": "Either `REFLECT` or `SYMMETRIC`. In reflect mode the padded regions\ndo not include the borders, while in symmetric mode the padded regions\ndo include the borders. For example, if `input` is `[1, 2, 3]` and `paddings`\nis `[0, 2]`, then the output is `[1, 2, 3, 2, 1]` in reflect mode, and\nit is `[1, 2, 3, 3, 2]` in symmetric mode. Must be one of the following: `REFLECT`, `SYMMETRIC`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The input tensor to be padded.",
        "typeAttr": "T"
      },
      {
        "name": "paddings",
        "description": "A two-column matrix specifying the padding sizes. The number of\nrows must be the same as the rank of `input`.",
        "typeAttr": "Tpaddings"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The padded tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MirrorPadGrad",
    "summary": "Gradient op for `MirrorPad` op. This op folds a mirror-padded tensor.",
    "description": "This operation folds the padded areas of `input` by `MirrorPad` according to the\n`paddings` you specify. `paddings` must be the same as `paddings` argument\ngiven to the corresponding `MirrorPad` op.\n\nThe folded size of each dimension D of the output is:\n\n`input.dim_size(D) - paddings(D, 0) - paddings(D, 1)`\n\nFor example:\n\n```\n# 't' is [[1, 2, 3], [4, 5, 6], [7, 8, 9]].\n# 'paddings' is [[0, 1]], [0, 1]].\n# 'mode' is SYMMETRIC.\n# rank of 't' is 2.\npad(t, paddings) ==> [[ 1,  5]\n                      [11, 28]]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tpaddings",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "mode",
        "type": "string",
        "description": "The mode used in the `MirrorPad` op. Must be one of the following: `REFLECT`, `SYMMETRIC`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The input tensor to be folded.",
        "typeAttr": "T"
      },
      {
        "name": "paddings",
        "description": "A two-column matrix specifying the padding sizes. The number of\nrows must be the same as the rank of `input`.",
        "typeAttr": "Tpaddings"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The folded tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MlirPassthroughOp",
    "summary": "Wraps an arbitrary MLIR computation expressed as a module with a main() function.",
    "description": "This operation does not have an associated kernel and is not intended to be\nexecuted in a regular TensorFlow session. Instead it is intended to be used for\ntesting or for special case where a user intends to pass custom MLIR computation\nthrough a TensorFlow graph with the intent of having custom tooling processing\nit downstream (when targeting a different environment, like TensorFlow lite for\nexample).\nThe MLIR module is expected to have a main() function that will be used as an\nentry point. The inputs to the operations will be passed as argument to the\nmain() function and the returned values of the main function mapped to the\noutputs.\nExample usage:\n\n```\nimport tensorflow as tf\nfrom tensorflow.compiler.mlir.tensorflow.gen_mlir_passthrough_op import mlir_passthrough_op\n\nmlir_module = '''python\nfunc @main(%arg0 : tensor<10xf32>, %arg1 : tensor<10xf32>) -> tensor<10x10xf32> {\n   %add = \"magic.op\"(%arg0, %arg1) : (tensor<10xf32>, tensor<10xf32>) -> tensor<10x10xf32>\n   return %ret : tensor<10x10xf32>\n}\n'''\n\n@tf.function\ndef foo(x, y):\n  return mlir_passthrough_op([x, y], mlir_module, Toutputs=[tf.float32])\n\ngraph_def = foo.get_concrete_function(tf.TensorSpec([10], tf.float32), tf.TensorSpec([10], tf.float32)).graph.as_graph_def()\n```",
    "attributes": [
      {
        "name": "mlir_module",
        "type": "string"
      },
      {
        "name": "Tinputs",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "Toutputs",
        "type": "type[]",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "typeListAttr": "Tinputs"
      }
    ],
    "outputs": [
      {
        "name": "outputs",
        "typeListAttr": "Toutputs"
      }
    ]
  },
  {
    "name": "Mod",
    "summary": "Returns element-wise remainder of division. This emulates C semantics in that",
    "description": "the result here is consistent with a truncating divide. E.g.\n`tf.truncatediv(x, y) * y + truncate_mod(x, y) = x`.\n\n*NOTE*: `Mod` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`, `float16`, `float16`, `bfloat16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ModelDataset",
    "summary": "Identity transformation that models performance.",
    "description": "Identity transformation that models performance.",
    "attributes": [
      {
        "name": "algorithm",
        "type": "int64",
        "default": 0
      },
      {
        "name": "cpu_budget",
        "type": "int64",
        "default": 0
      },
      {
        "name": "ram_budget",
        "type": "int64",
        "default": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the input dataset.",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "Mul",
    "summary": "Returns x * y element-wise.",
    "description": "*NOTE*: `Mul` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `uint8`, `int8`, `uint16`, `int16`, `int32`, `uint32`, `uint64`, `int64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MulNoNan",
    "summary": "Returns x * y element-wise. Returns zero if y is zero, even if x if infinite or NaN.",
    "description": "*NOTE*: `MulNoNan` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "MultiDeviceIterator",
    "summary": "Creates a MultiDeviceIterator resource.",
    "attributes": [
      {
        "name": "devices",
        "type": "string[]",
        "description": "A list of devices the iterator works across.",
        "minimum": 1
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this resource will be shared under the given name\nacross multiple sessions."
      },
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this resource is placed in the given container.\nOtherwise, a default container is used."
      },
      {
        "name": "output_types",
        "type": "type[]",
        "description": "The type list for the return values.",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "description": "The list of shapes being produced.",
        "minimum": 1
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "Handle to the resource created.",
        "type": 20
      }
    ]
  },
  {
    "name": "MultiDeviceIteratorFromStringHandle",
    "summary": "Generates a MultiDeviceIterator resource from its provided string handle.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "description": "The type list for the return values.",
        "minimum": 0,
        "default": []
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "description": "The list of shapes being produced.",
        "minimum": 0,
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "string_handle",
        "description": "String representing the resource.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "multi_device_iterator",
        "description": "A MultiDeviceIterator resource.",
        "type": 20
      }
    ]
  },
  {
    "name": "MultiDeviceIteratorGetNextFromShard",
    "summary": "Gets next element for the provided shard number.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "description": "The type list for the return values.",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "description": "The list of shapes being produced.",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "multi_device_iterator",
        "description": "A MultiDeviceIterator resource.",
        "type": 20
      },
      {
        "name": "shard_num",
        "description": "Integer representing which shard to fetch data for.",
        "type": 3
      },
      {
        "name": "incarnation_id",
        "description": "Which incarnation of the MultiDeviceIterator is running.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "components",
        "description": "Result of the get_next on the dataset.",
        "typeListAttr": "output_types"
      }
    ]
  },
  {
    "name": "MultiDeviceIteratorInit",
    "summary": "Initializes the multi device iterator with the given dataset.",
    "inputs": [
      {
        "name": "dataset",
        "description": "Dataset to be iterated upon.",
        "type": 21
      },
      {
        "name": "multi_device_iterator",
        "description": "A MultiDeviceIteratorResource.",
        "type": 20
      },
      {
        "name": "max_buffer_size",
        "description": "The maximum size of the host side per device buffer to keep.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "incarnation_id",
        "description": "An int64 indicating which incarnation of the MultiDeviceIterator\nis running.",
        "type": 9
      }
    ]
  },
  {
    "name": "MultiDeviceIteratorToStringHandle",
    "summary": "Produces a string handle for the given MultiDeviceIterator.",
    "inputs": [
      {
        "name": "multi_device_iterator",
        "description": "A MultiDeviceIterator resource.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "string_handle",
        "description": "A string representing the resource.",
        "type": 7
      }
    ]
  },
  {
    "name": "Multinomial",
    "summary": "Draws samples from a multinomial distribution.",
    "attributes": [
      {
        "name": "seed",
        "type": "int64",
        "description": "If either seed or seed2 is set to be non-zero, the internal random number\ngenerator is seeded by the given seed.  Otherwise, a random seed is used.",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "description": "A second seed to avoid seed collision.",
        "default": 0
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "output_dtype",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "logits",
        "description": "2-D Tensor with shape `[batch_size, num_classes]`.  Each slice `[i, :]`\nrepresents the unnormalized log probabilities for all classes.",
        "typeAttr": "T"
      },
      {
        "name": "num_samples",
        "description": "0-D.  Number of independent samples to draw for each row slice.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "2-D Tensor with shape `[batch_size, num_samples]`.  Each slice `[i, :]`\ncontains the drawn class labels with range `[0, num_classes)`.",
        "typeAttr": "output_dtype"
      }
    ]
  },
  {
    "name": "MutableDenseHashTable",
    "summary": "Creates an empty hash table that uses tensors as the backing store.",
    "description": "It uses \"open addressing\" with quadratic reprobing to resolve\ncollisions.\n\nThis op creates a mutable hash table, specifying the type of its keys and\nvalues. Each value must be a scalar. Data can be inserted into the table using\nthe insert operations. It does not support the initialization operation.",
    "attributes": [
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
        "default": ""
      },
      {
        "name": "use_node_name_sharing",
        "type": "boolean",
        "default": false
      },
      {
        "name": "key_dtype",
        "type": "type",
        "description": "Type of the table keys."
      },
      {
        "name": "value_dtype",
        "type": "type",
        "description": "Type of the table values."
      },
      {
        "name": "value_shape",
        "type": "shape",
        "description": "The shape of each value.",
        "default": {
          "type": "shape",
          "value": "?"
        }
      },
      {
        "name": "initial_num_buckets",
        "type": "int64",
        "description": "The initial number of hash table buckets. Must be a power\nto 2.",
        "default": 131072
      },
      {
        "name": "max_load_factor",
        "type": "float32",
        "description": "The maximum ratio between number of entries and number of\nbuckets before growing the table. Must be between 0 and 1.",
        "default": 0.800000011920929
      }
    ],
    "inputs": [
      {
        "name": "empty_key",
        "description": "The key used to represent empty key buckets internally. Must not\nbe used in insert or lookup operations.",
        "typeAttr": "key_dtype"
      }
    ],
    "outputs": [
      {
        "name": "table_handle",
        "description": "Handle to a table.",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "MutableDenseHashTableV2",
    "summary": "Creates an empty hash table that uses tensors as the backing store.",
    "description": "It uses \"open addressing\" with quadratic reprobing to resolve\ncollisions.\n\nThis op creates a mutable hash table, specifying the type of its keys and\nvalues. Each value must be a scalar. Data can be inserted into the table using\nthe insert operations. It does not support the initialization operation.",
    "attributes": [
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
        "default": ""
      },
      {
        "name": "use_node_name_sharing",
        "type": "boolean",
        "default": false
      },
      {
        "name": "key_dtype",
        "type": "type",
        "description": "Type of the table keys."
      },
      {
        "name": "value_dtype",
        "type": "type",
        "description": "Type of the table values."
      },
      {
        "name": "value_shape",
        "type": "shape",
        "description": "The shape of each value.",
        "default": {
          "type": "shape",
          "value": "?"
        }
      },
      {
        "name": "initial_num_buckets",
        "type": "int64",
        "description": "The initial number of hash table buckets. Must be a power\nto 2.",
        "default": 131072
      },
      {
        "name": "max_load_factor",
        "type": "float32",
        "description": "The maximum ratio between number of entries and number of\nbuckets before growing the table. Must be between 0 and 1.",
        "default": 0.800000011920929
      }
    ],
    "inputs": [
      {
        "name": "empty_key",
        "description": "The key used to represent empty key buckets internally. Must not\nbe used in insert or lookup operations.",
        "typeAttr": "key_dtype"
      },
      {
        "name": "deleted_key",
        "typeAttr": "key_dtype"
      }
    ],
    "outputs": [
      {
        "name": "table_handle",
        "description": "Handle to a table.",
        "type": 20
      }
    ]
  },
  {
    "name": "MutableHashTable",
    "summary": "Creates an empty hash table.",
    "description": "This op creates a mutable hash table, specifying the type of its keys and\nvalues. Each value must be a scalar. Data can be inserted into the table using\nthe insert operations. It does not support the initialization operation.",
    "attributes": [
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
        "default": ""
      },
      {
        "name": "use_node_name_sharing",
        "type": "boolean",
        "description": "If true and shared_name is empty, the table is shared\nusing the node name.",
        "default": false
      },
      {
        "name": "key_dtype",
        "type": "type",
        "description": "Type of the table keys."
      },
      {
        "name": "value_dtype",
        "type": "type",
        "description": "Type of the table values."
      }
    ],
    "outputs": [
      {
        "name": "table_handle",
        "description": "Handle to a table.",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "MutableHashTableOfTensors",
    "summary": "Creates an empty hash table.",
    "description": "This op creates a mutable hash table, specifying the type of its keys and\nvalues. Each value must be a vector. Data can be inserted into the table using\nthe insert operations. It does not support the initialization operation.",
    "attributes": [
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
        "default": ""
      },
      {
        "name": "use_node_name_sharing",
        "type": "boolean",
        "default": false
      },
      {
        "name": "key_dtype",
        "type": "type",
        "description": "Type of the table keys."
      },
      {
        "name": "value_dtype",
        "type": "type",
        "description": "Type of the table values."
      },
      {
        "name": "value_shape",
        "type": "shape",
        "default": {
          "type": "shape",
          "value": "?"
        }
      }
    ],
    "outputs": [
      {
        "name": "table_handle",
        "description": "Handle to a table.",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "MutableHashTableOfTensorsV2",
    "summary": "Creates an empty hash table.",
    "description": "This op creates a mutable hash table, specifying the type of its keys and\nvalues. Each value must be a vector. Data can be inserted into the table using\nthe insert operations. It does not support the initialization operation.",
    "attributes": [
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
        "default": ""
      },
      {
        "name": "use_node_name_sharing",
        "type": "boolean",
        "default": false
      },
      {
        "name": "key_dtype",
        "type": "type",
        "description": "Type of the table keys."
      },
      {
        "name": "value_dtype",
        "type": "type",
        "description": "Type of the table values."
      },
      {
        "name": "value_shape",
        "type": "shape",
        "default": {
          "type": "shape",
          "value": "?"
        }
      }
    ],
    "outputs": [
      {
        "name": "table_handle",
        "description": "Handle to a table.",
        "type": 20
      }
    ]
  },
  {
    "name": "MutableHashTableV2",
    "summary": "Creates an empty hash table.",
    "description": "This op creates a mutable hash table, specifying the type of its keys and\nvalues. Each value must be a scalar. Data can be inserted into the table using\nthe insert operations. It does not support the initialization operation.",
    "attributes": [
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
        "default": ""
      },
      {
        "name": "use_node_name_sharing",
        "type": "boolean",
        "description": "If true and shared_name is empty, the table is shared\nusing the node name.",
        "default": false
      },
      {
        "name": "key_dtype",
        "type": "type",
        "description": "Type of the table keys."
      },
      {
        "name": "value_dtype",
        "type": "type",
        "description": "Type of the table values."
      }
    ],
    "outputs": [
      {
        "name": "table_handle",
        "description": "Handle to a table.",
        "type": 20
      }
    ]
  },
  {
    "name": "MutexLock",
    "summary": "Locks a mutex resource.  The output is the lock.  So long as the lock tensor",
    "description": "is alive, any other request to use `MutexLock` with this mutex will wait.\n\nThis is particularly useful for creating a critical section when used in\nconjunction with `MutexLockIdentity`:\n\n```python\n\nmutex = mutex_v2(\n  shared_name=handle_name, container=container, name=name)\n\ndef execute_in_critical_section(fn, *args, **kwargs):\n  lock = gen_resource_variable_ops.mutex_lock(mutex)\n\n  with ops.control_dependencies([lock]):\n    r = fn(*args, **kwargs)\n\n  with ops.control_dependencies(nest.flatten(r)):\n    with ops.colocate_with(mutex):\n      ensure_lock_exists = mutex_lock_identity(lock)\n\n    # Make sure that if any element of r is accessed, all of\n    # them are executed together.\n    r = nest.map_structure(tf.identity, r)\n\n  with ops.control_dependencies([ensure_lock_exists]):\n    return nest.map_structure(tf.identity, r)\n```\n\nWhile `fn` is running in the critical section, no other functions which wish to\nuse this critical section may run.\n\nOften the use case is that two executions of the same graph, in parallel,\nwish to run `fn`; and we wish to ensure that only one of them executes\nat a time.  This is especially important if `fn` modifies one or more\nvariables at a time.\n\nIt is also useful if two separate functions must share a resource, but we\nwish to ensure the usage is exclusive.",
    "inputs": [
      {
        "name": "mutex",
        "description": "The mutex resource to lock.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "mutex_lock",
        "description": "A tensor that keeps a shared pointer to a lock on the mutex;\nwhen the Tensor is destroyed, the use count on the shared pointer is decreased\nby 1.  When it reaches 0, the lock is released.",
        "type": 21
      }
    ]
  },
  {
    "name": "MutexV2",
    "summary": "Creates a Mutex resource that can be locked by `MutexLock`.",
    "attributes": [
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this variable is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this variable is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "resource",
        "description": "The mutex resource.",
        "type": 20
      }
    ]
  },
  {
    "name": "NcclAllReduce",
    "summary": "Outputs a tensor containing the reduction across all input tensors.",
    "description": "Outputs a tensor containing the reduction across all input tensors passed to ops\nwithin the same `shared_name.\n\nThe graph should be constructed so if one op runs with shared_name value `c`,\nthen `num_devices` ops will run with shared_name value `c`.  Failure to do so\nwill cause the graph execution to fail to complete.\n\ninput: the input to the reduction\ndata: the value of the reduction across all `num_devices` devices.\nreduction: the reduction operation to perform.\nnum_devices: The number of devices participating in this reduction.\nshared_name: Identifier that shared between ops of the same reduction.",
    "attributes": [
      {
        "name": "reduction",
        "type": "string",
        "description": "Must be one of the following: `min`, `max`, `prod`, `sum`."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`, `float64`, `int32`, `int64`."
      },
      {
        "name": "num_devices",
        "type": "int64"
      },
      {
        "name": "shared_name",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "data",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "NcclBroadcast",
    "summary": "Sends `input` to all devices that are connected to the output.",
    "description": "Sends `input` to all devices that are connected to the output.\n\nThe graph should be constructed so that all ops connected to the output have a\nvalid device assignment, and the op itself is assigned one of these devices.\n\ninput: The input to the broadcast.\noutput: The same as input.\nshape: The shape of the input tensor.\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`, `float64`, `int32`, `int64`."
      },
      {
        "name": "shape",
        "type": "shape"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "NcclReduce",
    "summary": "Reduces `input` from `num_devices` using `reduction` to a single device.",
    "description": "Reduces `input` from `num_devices` using `reduction` to a single device.\n\nThe graph should be constructed so that all inputs have a valid device\nassignment, and the op itself is assigned one of these devices.\n\ninput: The input to the reduction.\ndata: the value of the reduction across all `num_devices` devices.\nreduction: the reduction operation to perform.",
    "attributes": [
      {
        "name": "reduction",
        "type": "string",
        "description": "Must be one of the following: `min`, `max`, `prod`, `sum`."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`, `float64`, `int32`, `int64`."
      },
      {
        "name": "num_devices",
        "type": "int64",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input",
        "numberAttr": "num_devices",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "data",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Ndtri",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "NearestNeighbors",
    "summary": "Selects the k nearest centers for each point.",
    "description": "Rows of points are assumed to be input points. Rows of centers are assumed to be\nthe list of candidate centers. For each point, the k centers that have least L2\ndistance to it are computed.",
    "inputs": [
      {
        "name": "points",
        "description": "Matrix of shape (n, d). Rows are assumed to be input points.",
        "type": 1
      },
      {
        "name": "centers",
        "description": "Matrix of shape (m, d). Rows are assumed to be centers.",
        "type": 1
      },
      {
        "name": "k",
        "description": "Number of nearest centers to return for each point. If k is larger than m, then\nonly m centers are returned.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "nearest_center_indices",
        "description": "Matrix of shape (n, min(m, k)). Each row contains the indices of the centers\nclosest to the corresponding point, ordered by increasing distance.",
        "type": 9
      },
      {
        "name": "nearest_center_distances",
        "description": "Matrix of shape (n, min(m, k)). Each row contains the squared L2 distance to the\ncorresponding center in nearest_center_indices.",
        "type": 1
      }
    ]
  },
  {
    "name": "Neg",
    "summary": "Computes numerical negative value element-wise.",
    "description": "I.e., \\\\(y = -x\\\\).",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `int8`, `int16`, `int32`, `int64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "NegTrain",
    "summary": "Training via negative sampling.",
    "attributes": [
      {
        "name": "vocab_count",
        "type": "int64[]",
        "description": "Count of words in the vocabulary."
      },
      {
        "name": "num_negative_samples",
        "type": "int64",
        "description": "Number of negative samples per example."
      }
    ],
    "inputs": [
      {
        "name": "w_in",
        "description": "input word embedding.",
        "type": 1,
        "isRef": true
      },
      {
        "name": "w_out",
        "description": "output word embedding.",
        "type": 1,
        "isRef": true
      },
      {
        "name": "examples",
        "description": "A vector of word ids.",
        "type": 3
      },
      {
        "name": "labels",
        "description": "A vector of word ids.",
        "type": 3
      },
      {
        "name": "lr",
        "type": 1
      }
    ]
  },
  {
    "name": "NextAfter",
    "summary": "Returns the next representable value of `x1` in the direction of `x2`, element-wise.",
    "description": "This operation returns the same result as the C++ std::nextafter function.\n\nIt can also return a subnormal number.\n\n@compatibility(cpp)\nEquivalent to C++ std::nextafter function.\n@end_compatibility",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float64`, `float32`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "x1",
        "typeAttr": "T"
      },
      {
        "name": "x2",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "NextIteration",
    "summary": "Makes its input available to the next iteration.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "data",
        "description": "The tensor to be made available to the next iteration.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The same tensor as `data`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "NoOp",
    "summary": "Does nothing. Only useful as a placeholder for control edges."
  },
  {
    "name": "NonDeterministicInts",
    "summary": "Non-deterministically generates some integers.",
    "description": "This op may use some OS-provided source of non-determinism (e.g. an RNG), so each execution will give different results.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output.",
        "default": {
          "type": "type",
          "value": 9
        }
      },
      {
        "name": "shape_dtype",
        "type": "type",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "shape_dtype"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Non-deterministic integer values with specified shape.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "NonMaxSuppression",
    "summary": "Greedily selects a subset of bounding boxes in descending order of score,",
    "description": "pruning away boxes that have high intersection-over-union (IOU) overlap\nwith previously selected boxes.  Bounding boxes are supplied as\n[y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any\ndiagonal pair of box corners and the coordinates can be provided as normalized\n(i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm\nis agnostic to where the origin is in the coordinate system.  Note that this\nalgorithm is invariant to orthogonal transformations and translations\nof the coordinate system; thus translating or reflections of the coordinate\nsystem result in the same boxes being selected by the algorithm.\nThe output of this operation is a set of integers indexing into the input\ncollection of bounding boxes representing the selected boxes.  The bounding\nbox coordinates corresponding to the selected indices can then be obtained\nusing the `tf.gather operation`.  For example:\n  selected_indices = tf.image.non_max_suppression(\n      boxes, scores, max_output_size, iou_threshold)\n  selected_boxes = tf.gather(boxes, selected_indices)",
    "attributes": [
      {
        "name": "iou_threshold",
        "type": "float32",
        "description": "A float representing the threshold for deciding whether boxes\noverlap too much with respect to IOU.",
        "default": 0.5
      }
    ],
    "inputs": [
      {
        "name": "boxes",
        "description": "A 2-D float tensor of shape `[num_boxes, 4]`.",
        "type": 1
      },
      {
        "name": "scores",
        "description": "A 1-D float tensor of shape `[num_boxes]` representing a single\nscore corresponding to each box (each row of boxes).",
        "type": 1
      },
      {
        "name": "max_output_size",
        "description": "A scalar integer tensor representing the maximum number of\nboxes to be selected by non max suppression.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "selected_indices",
        "description": "A 1-D integer tensor of shape `[M]` representing the selected\nindices from the boxes tensor, where `M <= max_output_size`.",
        "type": 3
      }
    ]
  },
  {
    "name": "NonMaxSuppressionV2",
    "summary": "Greedily selects a subset of bounding boxes in descending order of score,",
    "description": "pruning away boxes that have high intersection-over-union (IOU) overlap\nwith previously selected boxes.  Bounding boxes are supplied as\n[y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any\ndiagonal pair of box corners and the coordinates can be provided as normalized\n(i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm\nis agnostic to where the origin is in the coordinate system.  Note that this\nalgorithm is invariant to orthogonal transformations and translations\nof the coordinate system; thus translating or reflections of the coordinate\nsystem result in the same boxes being selected by the algorithm.\n\nThe output of this operation is a set of integers indexing into the input\ncollection of bounding boxes representing the selected boxes.  The bounding\nbox coordinates corresponding to the selected indices can then be obtained\nusing the `tf.gather operation`.  For example:\n\n  selected_indices = tf.image.non_max_suppression_v2(\n      boxes, scores, max_output_size, iou_threshold)\n  selected_boxes = tf.gather(boxes, selected_indices)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "T_threshold",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "boxes",
        "description": "A 2-D float tensor of shape `[num_boxes, 4]`.",
        "typeAttr": "T"
      },
      {
        "name": "scores",
        "description": "A 1-D float tensor of shape `[num_boxes]` representing a single\nscore corresponding to each box (each row of boxes).",
        "typeAttr": "T"
      },
      {
        "name": "max_output_size",
        "description": "A scalar integer tensor representing the maximum number of\nboxes to be selected by non max suppression.",
        "type": 3
      },
      {
        "name": "iou_threshold",
        "description": "A 0-D float tensor representing the threshold for deciding whether\nboxes overlap too much with respect to IOU.",
        "typeAttr": "T_threshold"
      }
    ],
    "outputs": [
      {
        "name": "selected_indices",
        "description": "A 1-D integer tensor of shape `[M]` representing the selected\nindices from the boxes tensor, where `M <= max_output_size`.",
        "type": 3
      }
    ]
  },
  {
    "name": "NonMaxSuppressionV3",
    "summary": "Greedily selects a subset of bounding boxes in descending order of score,",
    "description": "pruning away boxes that have high intersection-over-union (IOU) overlap\nwith previously selected boxes.  Bounding boxes with score less than\n`score_threshold` are removed.  Bounding boxes are supplied as\n[y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any\ndiagonal pair of box corners and the coordinates can be provided as normalized\n(i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm\nis agnostic to where the origin is in the coordinate system and more\ngenerally is invariant to orthogonal transformations and translations\nof the coordinate system; thus translating or reflections of the coordinate\nsystem result in the same boxes being selected by the algorithm.\nThe output of this operation is a set of integers indexing into the input\ncollection of bounding boxes representing the selected boxes.  The bounding\nbox coordinates corresponding to the selected indices can then be obtained\nusing the `tf.gather operation`.  For example:\n  selected_indices = tf.image.non_max_suppression_v2(\n      boxes, scores, max_output_size, iou_threshold, score_threshold)\n  selected_boxes = tf.gather(boxes, selected_indices)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "T_threshold",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "boxes",
        "description": "A 2-D float tensor of shape `[num_boxes, 4]`.",
        "typeAttr": "T"
      },
      {
        "name": "scores",
        "description": "A 1-D float tensor of shape `[num_boxes]` representing a single\nscore corresponding to each box (each row of boxes).",
        "typeAttr": "T"
      },
      {
        "name": "max_output_size",
        "description": "A scalar integer tensor representing the maximum number of\nboxes to be selected by non max suppression.",
        "type": 3
      },
      {
        "name": "iou_threshold",
        "description": "A 0-D float tensor representing the threshold for deciding whether\nboxes overlap too much with respect to IOU.",
        "typeAttr": "T_threshold"
      },
      {
        "name": "score_threshold",
        "description": "A 0-D float tensor representing the threshold for deciding when to remove\nboxes based on score.",
        "typeAttr": "T_threshold"
      }
    ],
    "outputs": [
      {
        "name": "selected_indices",
        "description": "A 1-D integer tensor of shape `[M]` representing the selected\nindices from the boxes tensor, where `M <= max_output_size`.",
        "type": 3
      }
    ]
  },
  {
    "name": "NonMaxSuppressionV4",
    "summary": "Greedily selects a subset of bounding boxes in descending order of score,",
    "description": "pruning away boxes that have high intersection-over-union (IOU) overlap\nwith previously selected boxes.  Bounding boxes with score less than\n`score_threshold` are removed.  Bounding boxes are supplied as\n[y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any\ndiagonal pair of box corners and the coordinates can be provided as normalized\n(i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm\nis agnostic to where the origin is in the coordinate system and more\ngenerally is invariant to orthogonal transformations and translations\nof the coordinate system; thus translating or reflections of the coordinate\nsystem result in the same boxes being selected by the algorithm.\nThe output of this operation is a set of integers indexing into the input\ncollection of bounding boxes representing the selected boxes.  The bounding\nbox coordinates corresponding to the selected indices can then be obtained\nusing the `tf.gather operation`.  For example:\n  selected_indices = tf.image.non_max_suppression_v2(\n      boxes, scores, max_output_size, iou_threshold, score_threshold)\n  selected_boxes = tf.gather(boxes, selected_indices)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "T_threshold",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "pad_to_max_output_size",
        "type": "boolean",
        "description": "If true, the output `selected_indices` is padded to be of length\n`max_output_size`. Defaults to false.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "boxes",
        "description": "A 2-D float tensor of shape `[num_boxes, 4]`.",
        "typeAttr": "T"
      },
      {
        "name": "scores",
        "description": "A 1-D float tensor of shape `[num_boxes]` representing a single\nscore corresponding to each box (each row of boxes).",
        "typeAttr": "T"
      },
      {
        "name": "max_output_size",
        "description": "A scalar integer tensor representing the maximum number of\nboxes to be selected by non max suppression.",
        "type": 3
      },
      {
        "name": "iou_threshold",
        "description": "A 0-D float tensor representing the threshold for deciding whether\nboxes overlap too much with respect to IOU.",
        "typeAttr": "T_threshold"
      },
      {
        "name": "score_threshold",
        "description": "A 0-D float tensor representing the threshold for deciding when to remove\nboxes based on score.",
        "typeAttr": "T_threshold"
      }
    ],
    "outputs": [
      {
        "name": "selected_indices",
        "description": "A 1-D integer tensor of shape `[M]` representing the selected\nindices from the boxes tensor, where `M <= max_output_size`.",
        "type": 3
      },
      {
        "name": "valid_outputs",
        "description": "A 0-D integer tensor representing the number of valid elements in\n`selected_indices`, with the valid elements appearing first.",
        "type": 3
      }
    ]
  },
  {
    "name": "NonMaxSuppressionV5",
    "summary": "Greedily selects a subset of bounding boxes in descending order of score,",
    "description": "pruning away boxes that have high intersection-over-union (IOU) overlap\nwith previously selected boxes.  Bounding boxes with score less than\n`score_threshold` are removed.  Bounding boxes are supplied as\n[y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any\ndiagonal pair of box corners and the coordinates can be provided as normalized\n(i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm\nis agnostic to where the origin is in the coordinate system and more\ngenerally is invariant to orthogonal transformations and translations\nof the coordinate system; thus translating or reflections of the coordinate\nsystem result in the same boxes being selected by the algorithm.\nThe output of this operation is a set of integers indexing into the input\ncollection of bounding boxes representing the selected boxes.  The bounding\nbox coordinates corresponding to the selected indices can then be obtained\nusing the `tf.gather operation`.  For example:\n  selected_indices = tf.image.non_max_suppression_v2(\n      boxes, scores, max_output_size, iou_threshold, score_threshold)\n  selected_boxes = tf.gather(boxes, selected_indices)\nThis op also supports a Soft-NMS (with Gaussian weighting) mode (c.f.\nBodla et al, https://arxiv.org/abs/1704.04503) where boxes reduce the score\nof other overlapping boxes instead of directly causing them to be pruned.\nTo enable this Soft-NMS mode, set the `soft_nms_sigma` parameter to be\nlarger than 0.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "pad_to_max_output_size",
        "type": "boolean",
        "description": "If true, the output `selected_indices` is padded to be of length\n`max_output_size`. Defaults to false.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "boxes",
        "description": "A 2-D float tensor of shape `[num_boxes, 4]`.",
        "typeAttr": "T"
      },
      {
        "name": "scores",
        "description": "A 1-D float tensor of shape `[num_boxes]` representing a single\nscore corresponding to each box (each row of boxes).",
        "typeAttr": "T"
      },
      {
        "name": "max_output_size",
        "description": "A scalar integer tensor representing the maximum number of\nboxes to be selected by non max suppression.",
        "type": 3
      },
      {
        "name": "iou_threshold",
        "description": "A 0-D float tensor representing the threshold for deciding whether\nboxes overlap too much with respect to IOU.",
        "typeAttr": "T"
      },
      {
        "name": "score_threshold",
        "description": "A 0-D float tensor representing the threshold for deciding when to remove\nboxes based on score.",
        "typeAttr": "T"
      },
      {
        "name": "soft_nms_sigma",
        "description": "A 0-D float tensor representing the sigma parameter for Soft NMS; see Bodla et\nal (c.f. https://arxiv.org/abs/1704.04503).  When `soft_nms_sigma=0.0` (which\nis default), we fall back to standard (hard) NMS.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "selected_indices",
        "description": "A 1-D integer tensor of shape `[M]` representing the selected\nindices from the boxes tensor, where `M <= max_output_size`.",
        "type": 3
      },
      {
        "name": "selected_scores",
        "description": "A 1-D float tensor of shape `[M]` representing the corresponding\nscores for each selected box, where `M <= max_output_size`.  Scores only differ\nfrom corresponding input scores when using Soft NMS (i.e. when\n`soft_nms_sigma>0`)",
        "typeAttr": "T"
      },
      {
        "name": "valid_outputs",
        "description": "A 0-D integer tensor representing the number of valid elements in\n`selected_indices`, with the valid elements appearing first.",
        "type": 3
      }
    ]
  },
  {
    "name": "NonMaxSuppressionWithOverlaps",
    "summary": "Greedily selects a subset of bounding boxes in descending order of score,",
    "description": "pruning away boxes that have high overlaps\nwith previously selected boxes.  Bounding boxes with score less than\n`score_threshold` are removed. N-by-n overlap values are supplied as square matrix,\nwhich allows for defining a custom overlap criterium (eg. intersection over union,\nintersection over area, etc.).\n\nThe output of this operation is a set of integers indexing into the input\ncollection of bounding boxes representing the selected boxes.  The bounding\nbox coordinates corresponding to the selected indices can then be obtained\nusing the `tf.gather operation`.  For example:\n\n  selected_indices = tf.image.non_max_suppression_with_overlaps(\n      overlaps, scores, max_output_size, overlap_threshold, score_threshold)\n  selected_boxes = tf.gather(boxes, selected_indices)",
    "inputs": [
      {
        "name": "overlaps",
        "description": "A 2-D float tensor of shape `[num_boxes, num_boxes]` representing\nthe n-by-n box overlap values.",
        "type": 1
      },
      {
        "name": "scores",
        "description": "A 1-D float tensor of shape `[num_boxes]` representing a single\nscore corresponding to each box (each row of boxes).",
        "type": 1
      },
      {
        "name": "max_output_size",
        "description": "A scalar integer tensor representing the maximum number of\nboxes to be selected by non max suppression.",
        "type": 3
      },
      {
        "name": "overlap_threshold",
        "description": "A 0-D float tensor representing the threshold for deciding whether\nboxes overlap too.",
        "type": 1
      },
      {
        "name": "score_threshold",
        "description": "A 0-D float tensor representing the threshold for deciding when to remove\nboxes based on score.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "selected_indices",
        "description": "A 1-D integer tensor of shape `[M]` representing the selected\nindices from the boxes tensor, where `M <= max_output_size`.",
        "type": 3
      }
    ]
  },
  {
    "name": "NonSerializableDataset",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "NotEqual",
    "summary": "Returns the truth value of (x != y) element-wise.",
    "description": "*NOTE*: `NotEqual` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "incompatible_shape_error",
        "type": "boolean",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "type": 10
      }
    ]
  },
  {
    "name": "NthElement",
    "summary": "Finds values of the `n`-th order statistic for the last dimension.",
    "description": "If the input is a vector (rank-1), finds the entries which is the nth-smallest\nvalue in the vector and outputs their values as scalar tensor.\n\nFor matrices (resp. higher rank input), computes the entries which is the\nnth-smallest value in each row (resp. vector along the last dimension). Thus,\n\n    values.shape = input.shape[:-1]",
    "attributes": [
      {
        "name": "reverse",
        "type": "boolean",
        "description": "When set to True, find the nth-largest value in the vector and vice\nversa.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "1-D or higher with last dimension at least `n+1`.",
        "typeAttr": "T"
      },
      {
        "name": "n",
        "description": "0-D. Position of sorted vector to select along the last dimension (along\neach row for matrices). Valid range of n is `[0, input.shape[:-1])`",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "values",
        "description": "The `n`-th order statistic along each last dimensional slice.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "OneHot",
    "summary": "Returns a one-hot tensor.",
    "description": "The locations represented by indices in `indices` take value `on_value`,\nwhile all other locations take value `off_value`.\n\nIf the input `indices` is rank `N`, the output will have rank `N+1`,\nThe new axis is created at dimension `axis` (default: the new axis is\nappended at the end).\n\nIf `indices` is a scalar the output shape will be a vector of length `depth`.\n\nIf `indices` is a vector of length `features`, the output shape will be:\n```\n  features x depth if axis == -1\n  depth x features if axis == 0\n```\n\nIf `indices` is a matrix (batch) with shape `[batch, features]`,\nthe output shape will be:\n```\n  batch x features x depth if axis == -1\n  batch x depth x features if axis == 1\n  depth x batch x features if axis == 0\n```\n\n\nExamples\n=========\n\nSuppose that\n```\n  indices = [0, 2, -1, 1]\n  depth = 3\n  on_value = 5.0\n  off_value = 0.0\n  axis = -1\n```\n\nThen output is `[4 x 3]`:\n```\noutput =\n  [5.0 0.0 0.0]  // one_hot(0)\n  [0.0 0.0 5.0]  // one_hot(2)\n  [0.0 0.0 0.0]  // one_hot(-1)\n  [0.0 5.0 0.0]  // one_hot(1)\n```\n\nSuppose that\n```\n  indices = [0, 2, -1, 1]\n  depth = 3\n  on_value = 0.0\n  off_value = 3.0\n  axis = 0\n```\n\nThen output is `[3 x 4]`:\n```\noutput =\n  [0.0 3.0 3.0 3.0]\n  [3.0 3.0 3.0 0.0]\n  [3.0 3.0 3.0 3.0]\n  [3.0 0.0 3.0 3.0]\n//  ^                one_hot(0)\n//      ^            one_hot(2)\n//          ^        one_hot(-1)\n//              ^    one_hot(1)\n```\n\nSuppose that\n```\n  indices = [[0, 2], [1, -1]]\n  depth = 3\n  on_value = 1.0\n  off_value = 0.0\n  axis = -1\n```\n\nThen output is `[2 x 2 x 3]`:\n```\noutput =\n  [\n    [1.0, 0.0, 0.0]  // one_hot(0)\n    [0.0, 0.0, 1.0]  // one_hot(2)\n  ][\n    [0.0, 1.0, 0.0]  // one_hot(1)\n    [0.0, 0.0, 0.0]  // one_hot(-1)\n  ]\n```",
    "attributes": [
      {
        "name": "axis",
        "type": "int64",
        "description": "The axis to fill (default: -1, a new inner-most axis).",
        "default": -1
      },
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "TI",
        "type": "type",
        "description": "Must be one of the following: `uint8`, `int8`, `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "indices",
        "description": "A tensor of indices.",
        "typeAttr": "TI"
      },
      {
        "name": "depth",
        "description": "A scalar defining the depth of the one hot dimension.",
        "type": 3
      },
      {
        "name": "on_value",
        "description": "A scalar defining the value to fill in output when `indices[j] = i`.",
        "typeAttr": "T"
      },
      {
        "name": "off_value",
        "description": "A scalar defining the value to fill in output when `indices[j] != i`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The one-hot tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "OneShotIterator",
    "summary": "Makes a \"one-shot\" iterator that can be iterated only once.",
    "description": "A one-shot iterator bundles the logic for defining the dataset and\nthe state of the iterator in a single op, which allows simple input\npipelines to be defined without an additional initialization\n(\"MakeIterator\") step.\n\nOne-shot iterators have the following limitations:\n\n* They do not support parameterization: all logic for creating the underlying\n  dataset must be bundled in the `dataset_factory` function.\n* They are not resettable. Once a one-shot iterator reaches the end of its\n  underlying dataset, subsequent \"IteratorGetNext\" operations on that\n  iterator will always produce an `OutOfRange` error.\n\nFor greater flexibility, use \"Iterator\" and \"MakeIterator\" to define\nan iterator using an arbitrary subgraph, which may capture tensors\n(including fed values) as parameters, and which may be reset multiple\ntimes by rerunning \"MakeIterator\".",
    "attributes": [
      {
        "name": "dataset_factory",
        "type": "function",
        "description": "A function of type `() -> DT_VARIANT`, where the returned\nDT_VARIANT is a dataset."
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "A handle to the iterator that can be passed to an \"IteratorGetNext\"\nop.",
        "type": 20
      }
    ]
  },
  {
    "name": "OnesLike",
    "summary": "Returns a tensor of ones with the same shape and type as x.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `int8`, `uint8`, `int16`, `uint16`, `int32`, `uint32`, `int64`, `uint64`, `complex64`, `complex128`, `bool`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "a tensor of type T.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "description": "a tensor of the same shape and type as x but filled with ones.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "OptimizeDataset",
    "summary": "Creates a dataset by applying optimizations to `input_dataset`.",
    "description": "Creates a dataset by applying optimizations to `input_dataset`.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "optimization_configs",
        "type": "string[]",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the input dataset.",
        "type": 21
      },
      {
        "name": "optimizations",
        "description": "A `tf.string` vector `tf.Tensor` identifying optimizations to use.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "OptimizeDatasetV2",
    "summary": "Creates a dataset by applying related optimizations to `input_dataset`.",
    "description": "Creates a dataset by applying related optimizations to `input_dataset`.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "optimization_configs",
        "type": "string[]",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the input dataset.",
        "type": 21
      },
      {
        "name": "optimizations_enabled",
        "description": "A `tf.string` vector `tf.Tensor` identifying user enabled optimizations.",
        "type": 7
      },
      {
        "name": "optimizations_disabled",
        "description": "A `tf.string` vector `tf.Tensor` identifying user disabled optimizations.",
        "type": 7
      },
      {
        "name": "optimizations_default",
        "description": "A `tf.string` vector `tf.Tensor` identifying optimizations by default.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "OptionalFromValue",
    "summary": "Constructs an Optional variant from a tuple of tensors.",
    "attributes": [
      {
        "name": "Toutput_types",
        "type": "type[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "components",
        "typeListAttr": "Toutput_types"
      }
    ],
    "outputs": [
      {
        "name": "optional",
        "type": 21
      }
    ]
  },
  {
    "name": "OptionalGetValue",
    "summary": "Returns the value stored in an Optional variant or raises an error if none exists.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "optional",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "components",
        "typeListAttr": "output_types"
      }
    ]
  },
  {
    "name": "OptionalHasValue",
    "summary": "Returns true if and only if the given Optional variant has a value.",
    "inputs": [
      {
        "name": "optional",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "has_value",
        "type": 10
      }
    ]
  },
  {
    "name": "OptionalNone",
    "summary": "Creates an Optional variant with no value.",
    "outputs": [
      {
        "name": "optional",
        "type": 21
      }
    ]
  },
  {
    "name": "OptionsDataset",
    "summary": "Creates a dataset by attaching tf.data.Options to `input_dataset`.",
    "attributes": [
      {
        "name": "serialized_options",
        "type": "string",
        "description": "A `tf.string` scalar `tf.Tensor` of serialized `tf.data.Options` protocol buffer."
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the input dataset.",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "OrderedMapClear",
    "summary": "Op removes all elements in the underlying container.",
    "attributes": [
      {
        "name": "capacity",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "memory_limit",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "dtypes",
        "type": "type[]"
      },
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ]
  },
  {
    "name": "OrderedMapIncompleteSize",
    "summary": "Op returns the number of incomplete elements in the underlying container.",
    "attributes": [
      {
        "name": "capacity",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "memory_limit",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "dtypes",
        "type": "type[]"
      },
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "size",
        "type": 3
      }
    ]
  },
  {
    "name": "OrderedMapPeek",
    "summary": "Op peeks at the values at the specified key.  If the",
    "description": "underlying container does not contain this key\nthis op will block until it does.   This Op is optimized for\nperformance.",
    "attributes": [
      {
        "name": "capacity",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "memory_limit",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "dtypes",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "key",
        "type": 9
      },
      {
        "name": "indices",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "values",
        "typeListAttr": "dtypes"
      }
    ]
  },
  {
    "name": "OrderedMapSize",
    "summary": "Op returns the number of elements in the underlying container.",
    "attributes": [
      {
        "name": "capacity",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "memory_limit",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "dtypes",
        "type": "type[]"
      },
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "size",
        "type": 3
      }
    ]
  },
  {
    "name": "OrderedMapStage",
    "summary": "Stage (key, values) in the underlying container which behaves like a ordered",
    "description": "associative container.   Elements are ordered by key.",
    "attributes": [
      {
        "name": "capacity",
        "type": "int64",
        "description": "Maximum number of elements in the Staging Area. If > 0, inserts\non the container will block when the capacity is reached.",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "memory_limit",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "dtypes",
        "type": "type[]"
      },
      {
        "name": "fake_dtypes",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this queue is placed in the given container. Otherwise,\na default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "It is necessary to match this name to the matching Unstage Op.",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "key",
        "description": "int64",
        "type": 9
      },
      {
        "name": "indices",
        "type": 3
      },
      {
        "name": "values",
        "description": "a list of tensors\ndtypes A list of data types that inserted values should adhere to.",
        "typeListAttr": "fake_dtypes"
      }
    ]
  },
  {
    "name": "OrderedMapUnstage",
    "summary": "Op removes and returns the values associated with the key",
    "description": "from the underlying container.   If the underlying container\ndoes not contain this key, the op will block until it does.",
    "attributes": [
      {
        "name": "capacity",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "memory_limit",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "dtypes",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "key",
        "type": 9
      },
      {
        "name": "indices",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "values",
        "typeListAttr": "dtypes"
      }
    ]
  },
  {
    "name": "OrderedMapUnstageNoKey",
    "summary": "Op removes and returns the (key, value) element with the smallest",
    "description": "key from the underlying container.   If the underlying container\ndoes not contain elements, the op will block until it does.",
    "attributes": [
      {
        "name": "capacity",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "memory_limit",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "dtypes",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "indices",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "key",
        "type": 9
      },
      {
        "name": "values",
        "typeListAttr": "dtypes"
      }
    ]
  },
  {
    "name": "OutfeedDequeue",
    "summary": "Retrieves a single tensor from the computation outfeed.",
    "description": "This operation will block indefinitely until data is available.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of elements in the tensor."
      },
      {
        "name": "shape",
        "type": "shape",
        "description": "The shape of the tensor."
      },
      {
        "name": "device_ordinal",
        "type": "int64",
        "description": "The TPU device to use. This should be -1 when the Op\nis running on a TPU device, and >= 0 when the Op is running on the CPU\ndevice.",
        "default": -1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A tensor that will be read from the device outfeed.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "OutfeedDequeueTuple",
    "summary": "Retrieve multiple values from the computation outfeed.",
    "description": "This operation will block indefinitely until data is available. Output `i`\ncorresponds to XLA tuple element `i`.",
    "attributes": [
      {
        "name": "dtypes",
        "type": "type[]",
        "description": "The element types of each element in `outputs`.",
        "minimum": 1
      },
      {
        "name": "shapes",
        "type": "shape[]",
        "description": "The shapes of each tensor in `outputs`."
      },
      {
        "name": "device_ordinal",
        "type": "int64",
        "description": "The TPU device to use. This should be -1 when the Op\nis running on a TPU device, and >= 0 when the Op is running on the CPU\ndevice.",
        "default": -1
      }
    ],
    "outputs": [
      {
        "name": "outputs",
        "description": "A list of tensors that will be read from the outfeed.",
        "typeListAttr": "dtypes"
      }
    ]
  },
  {
    "name": "OutfeedDequeueTupleV2",
    "summary": "Retrieve multiple values from the computation outfeed. Device ordinal is a\ntensor allowing dynamic outfeed.",
    "description": "This operation will block indefinitely until data is available. Output `i`\ncorresponds to XLA tuple element `i`.",
    "attributes": [
      {
        "name": "dtypes",
        "type": "type[]",
        "description": "The element types of each element in `outputs`.",
        "minimum": 1
      },
      {
        "name": "shapes",
        "type": "shape[]",
        "description": "The shapes of each tensor in `outputs`."
      }
    ],
    "inputs": [
      {
        "name": "device_ordinal",
        "description": "An int scalar tensor, representing the TPU device to use. This should be -1 when\nthe Op is running on a TPU device, and >= 0 when the Op is running on the CPU\ndevice.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "outputs",
        "description": "A list of tensors that will be read from the outfeed.",
        "typeListAttr": "dtypes"
      }
    ]
  },
  {
    "name": "OutfeedDequeueV2",
    "summary": "Retrieves a single tensor from the computation outfeed. Device ordinal is a\ntensor allowing dynamic outfeed.",
    "description": "This operation will block indefinitely until data is available.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of elements in the tensor."
      },
      {
        "name": "shape",
        "type": "shape",
        "description": "The shape of the tensor."
      }
    ],
    "inputs": [
      {
        "name": "device_ordinal",
        "description": "An int scalar tensor, representing the TPU device to use. This should be -1 when\nthe Op is running on a TPU device, and >= 0 when the Op is running on the CPU\ndevice.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A tensor that will be read from the device outfeed.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "OutfeedEnqueue",
    "summary": "Enqueue a Tensor on the computation outfeed.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A tensor that will be inserted into the outfeed queue.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "OutfeedEnqueueTuple",
    "summary": "Enqueue multiple Tensor values on the computation outfeed.",
    "attributes": [
      {
        "name": "dtypes",
        "type": "type[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "description": "A list of tensors that will be inserted into the outfeed queue as an\nXLA tuple.",
        "typeListAttr": "dtypes"
      }
    ]
  },
  {
    "name": "Pack",
    "summary": "Packs a list of `N` rank-`R` tensors into one rank-`(R+1)` tensor.",
    "description": "Packs the `N` tensors in `values` into a tensor with rank one higher than each\ntensor in `values`, by packing them along the `axis` dimension.\nGiven a list of tensors of shape `(A, B, C)`;\n\nif `axis == 0` then the `output` tensor will have the shape `(N, A, B, C)`.\nif `axis == 1` then the `output` tensor will have the shape `(A, N, B, C)`.\nEtc.\n\nFor example:\n\n```\n# 'x' is [1, 4]\n# 'y' is [2, 5]\n# 'z' is [3, 6]\npack([x, y, z]) => [[1, 4], [2, 5], [3, 6]]  # Pack along first dim.\npack([x, y, z], axis=1) => [[1, 2, 3], [4, 5, 6]]\n```\n\nThis is the opposite of `unpack`.",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "axis",
        "type": "int64",
        "description": "Dimension along which to pack.  Negative values wrap around, so the\nvalid range is `[-(R+1), R+1)`.",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "values",
        "description": "Must be of same shape and type.",
        "numberAttr": "N",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The packed tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Pad",
    "category": "Tensor",
    "summary": "Pads a tensor with zeros.",
    "description": "This operation pads a `input` with zeros according to the `paddings` you\nspecify. `paddings` is an integer tensor with shape `[Dn, 2]`, where n is the\nrank of `input`. For each dimension D of `input`, `paddings[D, 0]` indicates\nhow many zeros to add before the contents of `input` in that dimension, and\n`paddings[D, 1]` indicates how many zeros to add after the contents of `input`\nin that dimension.\n\nThe padded size of each dimension D of the output is:\n\n`paddings(D, 0) + input.dim_size(D) + paddings(D, 1)`\n\nFor example:\n\n```\n# 't' is [[1, 1], [2, 2]]\n# 'paddings' is [[1, 1], [2, 2]]\n# rank of 't' is 2\npad(t, paddings) ==> [[0, 0, 0, 0, 0, 0]\n                      [0, 0, 1, 1, 0, 0]\n                      [0, 0, 2, 2, 0, 0]\n                      [0, 0, 0, 0, 0, 0]]\n```\n",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tpaddings",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "paddings",
        "typeAttr": "Tpaddings"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "PadV2",
    "summary": "Pads a tensor.",
    "description": "This operation pads `input` according to the `paddings` and `constant_values`\nyou specify. `paddings` is an integer tensor with shape `[Dn, 2]`, where n is\nthe rank of `input`. For each dimension D of `input`, `paddings[D, 0]` indicates\nhow many padding values to add before the contents of `input` in that dimension,\nand `paddings[D, 1]` indicates how many padding values to add after the contents\nof `input` in that dimension. `constant_values` is a scalar tensor of the same\ntype as `input` that indicates the value to use for padding `input`.\n\nThe padded size of each dimension D of the output is:\n\n`paddings(D, 0) + input.dim_size(D) + paddings(D, 1)`\n\nFor example:\n\n```\n# 't' is [[1, 1], [2, 2]]\n# 'paddings' is [[1, 1], [2, 2]]\n# 'constant_values' is 0\n# rank of 't' is 2\npad(t, paddings) ==> [[0, 0, 0, 0, 0, 0]\n                      [0, 0, 1, 1, 0, 0]\n                      [0, 0, 2, 2, 0, 0]\n                      [0, 0, 0, 0, 0, 0]]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tpaddings",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "paddings",
        "typeAttr": "Tpaddings"
      },
      {
        "name": "constant_values",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "PaddedBatchDataset",
    "summary": "Creates a dataset that batches and pads `batch_size` elements from the input.",
    "attributes": [
      {
        "name": "Toutput_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "batch_size",
        "description": "A scalar representing the number of elements to accumulate in a\nbatch.",
        "type": 9
      },
      {
        "name": "padded_shapes",
        "description": "A list of int64 tensors representing the desired padded shapes\nof the corresponding output components. These shapes may be partially\nspecified, using `-1` to indicate that a particular dimension should be\npadded to the maximum size of all batch elements.",
        "numberAttr": "N",
        "type": 9
      },
      {
        "name": "padding_values",
        "description": "A list of scalars containing the padding value to use for\neach of the outputs.",
        "typeListAttr": "Toutput_types"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "PaddedBatchDatasetV2",
    "summary": "Creates a dataset that batches and pads `batch_size` elements from the input.",
    "attributes": [
      {
        "name": "parallel_copy",
        "type": "boolean",
        "default": false
      },
      {
        "name": "Toutput_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "batch_size",
        "description": "A scalar representing the number of elements to accumulate in a\nbatch.",
        "type": 9
      },
      {
        "name": "padded_shapes",
        "description": "A list of int64 tensors representing the desired padded shapes\nof the corresponding output components. These shapes may be partially\nspecified, using `-1` to indicate that a particular dimension should be\npadded to the maximum size of all batch elements.",
        "numberAttr": "N",
        "type": 9
      },
      {
        "name": "padding_values",
        "description": "A list of scalars containing the padding value to use for\neach of the outputs.",
        "typeListAttr": "Toutput_types"
      },
      {
        "name": "drop_remainder",
        "description": "A scalar representing whether the last batch should be dropped in case its size\nis smaller than desired.",
        "type": 10
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "PaddingFIFOQueue",
    "summary": "A queue that produces elements in first-in first-out order.",
    "description": "Variable-size shapes are allowed by setting the corresponding shape dimensions\nto 0 in the shape attr.  In this case DequeueMany will pad up to the maximum\nsize of any given element in the minibatch.  See below for details.",
    "attributes": [
      {
        "name": "component_types",
        "type": "type[]",
        "description": "The type of each component in a value.",
        "minimum": 1
      },
      {
        "name": "shapes",
        "type": "shape[]",
        "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types.\nShapes of fixed rank but variable size are allowed by setting\nany shape dimension to -1.  In this case, the inputs' shape may vary along\nthe given dimension, and DequeueMany will pad the given dimension with\nzeros up to the maximum shape of all elements in the given batch.\nIf the length of this attr is 0, different queue elements may have\ndifferent ranks and shapes, but only one element may be dequeued at a time.",
        "minimum": 0,
        "default": []
      },
      {
        "name": "capacity",
        "type": "int64",
        "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
        "default": -1
      },
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "The handle to the queue.",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "PaddingFIFOQueueV2",
    "summary": "A queue that produces elements in first-in first-out order.",
    "description": "Variable-size shapes are allowed by setting the corresponding shape dimensions\nto 0 in the shape attr.  In this case DequeueMany will pad up to the maximum\nsize of any given element in the minibatch.  See below for details.",
    "attributes": [
      {
        "name": "component_types",
        "type": "type[]",
        "description": "The type of each component in a value.",
        "minimum": 1
      },
      {
        "name": "shapes",
        "type": "shape[]",
        "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types.\nShapes of fixed rank but variable size are allowed by setting\nany shape dimension to -1.  In this case, the inputs' shape may vary along\nthe given dimension, and DequeueMany will pad the given dimension with\nzeros up to the maximum shape of all elements in the given batch.\nIf the length of this attr is 0, different queue elements may have\ndifferent ranks and shapes, but only one element may be dequeued at a time.",
        "minimum": 0,
        "default": []
      },
      {
        "name": "capacity",
        "type": "int64",
        "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
        "default": -1
      },
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "The handle to the queue.",
        "type": 20
      }
    ]
  },
  {
    "name": "ParallelBatchDataset",
    "attributes": [
      {
        "name": "parallel_copy",
        "type": "boolean",
        "default": false
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "deterministic",
        "type": "string",
        "default": "default"
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "batch_size",
        "type": 9
      },
      {
        "name": "num_parallel_calls",
        "type": 9
      },
      {
        "name": "drop_remainder",
        "type": 10
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ParallelConcat",
    "summary": "Concatenates a list of `N` tensors along the first dimension.",
    "description": "The input tensors are all required to have size 1 in the first dimension.\n\nFor example:\n\n```\n# 'x' is [[1, 4]]\n# 'y' is [[2, 5]]\n# 'z' is [[3, 6]]\nparallel_concat([x, y, z]) => [[1, 4], [2, 5], [3, 6]]  # Pack along first dim.\n```\n\nThe difference between concat and parallel_concat is that concat requires all\nof the inputs be computed before the operation will begin but doesn't require\nthat the input shapes be known during graph construction.  Parallel concat\nwill copy pieces of the input into the output as they become available, in\nsome situations this can provide a performance benefit.",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "shape",
        "type": "shape",
        "description": "the final shape of the result; should be equal to the shapes of any input\nbut with the number of input values in the first dimension."
      }
    ],
    "inputs": [
      {
        "name": "values",
        "description": "Tensors to be concatenated. All must have size 1 in the first dimension\nand same shape.",
        "numberAttr": "N",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The concatenated tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ParallelDynamicStitch",
    "summary": "Interleave the values from the `data` tensors into a single tensor.",
    "description": "Builds a merged tensor such that\n\n```python\n    merged[indices[m][i, ..., j], ...] = data[m][i, ..., j, ...]\n```\n\nFor example, if each `indices[m]` is scalar or vector, we have\n\n```python\n    # Scalar indices:\n    merged[indices[m], ...] = data[m][...]\n\n    # Vector indices:\n    merged[indices[m][i], ...] = data[m][i, ...]\n```\n\nEach `data[i].shape` must start with the corresponding `indices[i].shape`,\nand the rest of `data[i].shape` must be constant w.r.t. `i`.  That is, we\nmust have `data[i].shape = indices[i].shape + constant`.  In terms of this\n`constant`, the output shape is\n\n    merged.shape = [max(indices)] + constant\n\nValues may be merged in parallel, so if an index appears in both `indices[m][i]`\nand `indices[n][j]`, the result may be invalid. This differs from the normal\nDynamicStitch operator that defines the behavior in that case.\n\nFor example:\n\n```python\n    indices[0] = 6\n    indices[1] = [4, 1]\n    indices[2] = [[5, 2], [0, 3]]\n    data[0] = [61, 62]\n    data[1] = [[41, 42], [11, 12]]\n    data[2] = [[[51, 52], [21, 22]], [[1, 2], [31, 32]]]\n    merged = [[1, 2], [11, 12], [21, 22], [31, 32], [41, 42],\n              [51, 52], [61, 62]]\n```\n\nThis method can be used to merge partitions created by `dynamic_partition`\nas illustrated on the following example:\n\n```python\n    # Apply function (increments x_i) on elements for which a certain condition\n    # apply (x_i != -1 in this example).\n    x=tf.constant([0.1, -1., 5.2, 4.3, -1., 7.4])\n    condition_mask=tf.not_equal(x,tf.constant(-1.))\n    partitioned_data = tf.dynamic_partition(\n        x, tf.cast(condition_mask, tf.int32) , 2)\n    partitioned_data[1] = partitioned_data[1] + 1.0\n    condition_indices = tf.dynamic_partition(\n        tf.range(tf.shape(x)[0]), tf.cast(condition_mask, tf.int32) , 2)\n    x = tf.dynamic_stitch(condition_indices, partitioned_data)\n    # Here x=[1.1, -1., 6.2, 5.3, -1, 8.4], the -1. values remain\n    # unchanged.\n```\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/DynamicStitch.png\" alt>\n</div>",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "indices",
        "numberAttr": "N",
        "type": 3
      },
      {
        "name": "data",
        "numberAttr": "N",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "merged",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ParallelFilterDataset",
    "summary": "Creates a dataset containing elements of `input_dataset` matching `predicate`.",
    "description": "The `predicate` function must return a scalar boolean and accept the\nfollowing arguments:\n\n* One tensor for each component of an element of `input_dataset`.\n* One tensor for each value in `other_arguments`.\n\nUnlike a \"FilterDataset\", which applies `predicate` sequentially, this dataset\ninvokes up to `num_parallel_calls` copies of `predicate` in parallel.\n  ",
    "attributes": [
      {
        "name": "predicate",
        "type": "function",
        "description": "A function returning a scalar boolean."
      },
      {
        "name": "deterministic",
        "type": "string",
        "description": "A string indicating the op-level determinism to use. Deterministic controls\nwhether the interleave is allowed to return elements out of order if the next\nelement to be returned isn't available, but a later element is. Options are\n\"true\", \"false\", and \"default\". \"default\" indicates that determinism should be\ndecided by the `experimental_deterministic` parameter of `tf.data.Options`.",
        "default": "default"
      },
      {
        "name": "Targuments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "other_arguments",
        "description": "A list of tensors, typically values that were captured when\nbuilding a closure for `predicate`.",
        "typeListAttr": "Targuments"
      },
      {
        "name": "num_parallel_calls",
        "description": "The number of concurrent invocations of `predicate` that process\nelements from `input_dataset` in parallel.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ParallelInterleaveDataset",
    "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`.",
    "description": "The resulting dataset is similar to the `InterleaveDataset`, with the exception\nthat if retrieving the next value from a dataset would cause the requester to\nblock, it will skip that input dataset. This dataset is especially useful\nwhen loading data from a variable-latency datastores (e.g. HDFS, GCS), as it\nallows the training step to proceed so long as some data is available.\n\n!! WARNING !! If the `sloppy` parameter is set to `True`, the operation of this\ndataset will not be deterministic!\n\nThis dataset has been superseded by `ParallelInterleaveDatasetV2`.  New code\nshould use `ParallelInterleaveDatasetV2`.\n\nThe Python API `tf.data.experimental.parallel_interleave` creates instances of\nthis op. `tf.data.experimental.parallel_interleave` is a deprecated API.",
    "attributes": [
      {
        "name": "f",
        "type": "function",
        "description": "A function mapping elements of `input_dataset`, concatenated with\n`other_arguments`, to a Dataset variant that contains elements matching\n`output_types` and `output_shapes`."
      },
      {
        "name": "Targuments",
        "type": "type[]",
        "description": "Types of the elements of `other_arguments`.",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "Dataset that produces a stream of arguments for the function `f`.",
        "type": 21
      },
      {
        "name": "other_arguments",
        "description": "Additional arguments to pass to `f` beyond those produced by `input_dataset`.\nEvaluated once when the dataset is instantiated.",
        "typeListAttr": "Targuments"
      },
      {
        "name": "cycle_length",
        "description": "Number of datasets (each created by applying `f` to the elements of\n`input_dataset`) among which the `ParallelInterleaveDataset` will cycle in a\nround-robin fashion.",
        "type": 9
      },
      {
        "name": "block_length",
        "description": "Number of elements at a time to produce from each interleaved invocation of a\ndataset returned by `f`.",
        "type": 9
      },
      {
        "name": "sloppy",
        "description": "If `True`, return elements as they become available, even if that means returning\nthese elements in a non-deterministic order. Sloppy operation may result in better\nperformance in the presence of stragglers, but the dataset will still block if\nall of its open streams are blocked.\nIf `False`, always return elements in a deterministic order.",
        "type": 10
      },
      {
        "name": "buffer_output_elements",
        "description": "The number of elements each iterator being interleaved should buffer (similar\nto the `.prefetch()` transformation for each interleaved iterator).",
        "type": 9
      },
      {
        "name": "prefetch_input_elements",
        "description": "Determines the number of iterators to prefetch, allowing buffers to warm up and\ndata to be pre-fetched without blocking the main thread.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ParallelInterleaveDatasetV2",
    "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`.",
    "description": "The resulting dataset is similar to the `InterleaveDataset`, except that the\ndataset will fetch records from the interleaved datasets in parallel.\n\nThe `tf.data` Python API creates instances of this op from\n`Dataset.interleave()` when the `num_parallel_calls` parameter of that method\nis set to any value other than `None`.\n\nBy default, the output of this dataset will be deterministic, which may result\nin the dataset blocking if the next data item to be returned isn't available.\nIn order to avoid head-of-line blocking, one can set the\n`experimental_deterministic` parameter of `tf.data.Options` to `False`,\nwhich can improve performance at the expense of non-determinism.",
    "attributes": [
      {
        "name": "f",
        "type": "function",
        "description": "A function mapping elements of `input_dataset`, concatenated with\n`other_arguments`, to a Dataset variant that contains elements matching\n`output_types` and `output_shapes`."
      },
      {
        "name": "Targuments",
        "type": "type[]",
        "description": "Types of the elements of `other_arguments`.",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "sloppy",
        "type": "boolean",
        "default": false
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "Dataset that produces a stream of arguments for the function `f`.",
        "type": 21
      },
      {
        "name": "other_arguments",
        "description": "Additional arguments to pass to `f` beyond those produced by `input_dataset`.\nEvaluated once when the dataset is instantiated.",
        "typeListAttr": "Targuments"
      },
      {
        "name": "cycle_length",
        "description": "Number of datasets (each created by applying `f` to the elements of\n`input_dataset`) among which the `ParallelInterleaveDatasetV2` will cycle in a\nround-robin fashion.",
        "type": 9
      },
      {
        "name": "block_length",
        "description": "Number of elements at a time to produce from each interleaved invocation of a\ndataset returned by `f`.",
        "type": 9
      },
      {
        "name": "num_parallel_calls",
        "description": "Determines the number of threads that should be used for fetching data from\ninput datasets in parallel. The Python API `tf.data.experimental.AUTOTUNE`\nconstant can be used to indicate that the level of parallelism should be autotuned.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ParallelInterleaveDatasetV3",
    "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`.",
    "description": "The resulting dataset is similar to the `InterleaveDataset`, except that the\ndataset will fetch records from the interleaved datasets in parallel.\n\nThe `tf.data` Python API creates instances of this op from\n`Dataset.interleave()` when the `num_parallel_calls` parameter of that method\nis set to any value other than `None`.\n\nBy default, the output of this dataset will be deterministic, which may result\nin the dataset blocking if the next data item to be returned isn't available.\nIn order to avoid head-of-line blocking, one can either set the `deterministic`\nattribute to \"false\", or leave it as \"default\" and set the\n`experimental_deterministic` parameter of `tf.data.Options` to `False`.\nThis can improve performance at the expense of non-determinism.",
    "attributes": [
      {
        "name": "f",
        "type": "function",
        "description": "A function mapping elements of `input_dataset`, concatenated with\n`other_arguments`, to a Dataset variant that contains elements matching\n`output_types` and `output_shapes`."
      },
      {
        "name": "deterministic",
        "type": "string",
        "description": "A string indicating the op-level determinism to use. Deterministic controls\nwhether the interleave is allowed to return elements out of order if the next\nelement to be returned isn't available, but a later element is. Options are\n\"true\", \"false\", and \"default\". \"default\" indicates that determinism should be\ndecided by the `experimental_deterministic` parameter of `tf.data.Options`.",
        "default": "default"
      },
      {
        "name": "Targuments",
        "type": "type[]",
        "description": "Types of the elements of `other_arguments`.",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "Dataset that produces a stream of arguments for the function `f`.",
        "type": 21
      },
      {
        "name": "other_arguments",
        "description": "Additional arguments to pass to `f` beyond those produced by `input_dataset`.\nEvaluated once when the dataset is instantiated.",
        "typeListAttr": "Targuments"
      },
      {
        "name": "cycle_length",
        "description": "Number of datasets (each created by applying `f` to the elements of\n`input_dataset`) among which the `ParallelInterleaveDatasetV2` will cycle in a\nround-robin fashion.",
        "type": 9
      },
      {
        "name": "block_length",
        "description": "Number of elements at a time to produce from each interleaved invocation of a\ndataset returned by `f`.",
        "type": 9
      },
      {
        "name": "num_parallel_calls",
        "description": "Determines the number of threads that should be used for fetching data from\ninput datasets in parallel. The Python API `tf.data.experimental.AUTOTUNE`\nconstant can be used to indicate that the level of parallelism should be autotuned.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ParallelInterleaveDatasetV4",
    "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`.",
    "description": "The resulting dataset is similar to the `InterleaveDataset`, except that the\ndataset will fetch records from the interleaved datasets in parallel.\n\nThe `tf.data` Python API creates instances of this op from\n`Dataset.interleave()` when the `num_parallel_calls` parameter of that method\nis set to any value other than `None`.\n\nBy default, the output of this dataset will be deterministic, which may result\nin the dataset blocking if the next data item to be returned isn't available.\nIn order to avoid head-of-line blocking, one can either set the `deterministic`\nattribute to \"false\", or leave it as \"default\" and set the\n`experimental_deterministic` parameter of `tf.data.Options` to `False`.\nThis can improve performance at the expense of non-determinism.",
    "attributes": [
      {
        "name": "f",
        "type": "function",
        "description": "A function mapping elements of `input_dataset`, concatenated with\n`other_arguments`, to a Dataset variant that contains elements matching\n`output_types` and `output_shapes`."
      },
      {
        "name": "deterministic",
        "type": "string",
        "description": "A string indicating the op-level determinism to use. Deterministic controls\nwhether the interleave is allowed to return elements out of order if the next\nelement to be returned isn't available, but a later element is. Options are\n\"true\", \"false\", and \"default\". \"default\" indicates that determinism should be\ndecided by the `experimental_deterministic` parameter of `tf.data.Options`.",
        "default": "default"
      },
      {
        "name": "Targuments",
        "type": "type[]",
        "description": "Types of the elements of `other_arguments`.",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "Dataset that produces a stream of arguments for the function `f`.",
        "type": 21
      },
      {
        "name": "other_arguments",
        "description": "Additional arguments to pass to `f` beyond those produced by `input_dataset`.\nEvaluated once when the dataset is instantiated.",
        "typeListAttr": "Targuments"
      },
      {
        "name": "cycle_length",
        "description": "Number of datasets (each created by applying `f` to the elements of\n`input_dataset`) among which the `ParallelInterleaveDatasetV2` will cycle in a\nround-robin fashion.",
        "type": 9
      },
      {
        "name": "block_length",
        "description": "Number of elements at a time to produce from each interleaved invocation of a\ndataset returned by `f`.",
        "type": 9
      },
      {
        "name": "buffer_output_elements",
        "description": "The number of elements each iterator being interleaved should buffer (similar\nto the `.prefetch()` transformation for each interleaved iterator).",
        "type": 9
      },
      {
        "name": "prefetch_input_elements",
        "description": "Determines the number of iterators to prefetch, allowing buffers to warm up and\ndata to be pre-fetched without blocking the main thread.",
        "type": 9
      },
      {
        "name": "num_parallel_calls",
        "description": "Determines the number of threads that should be used for fetching data from\ninput datasets in parallel. The Python API `tf.data.experimental.AUTOTUNE`\nconstant can be used to indicate that the level of parallelism should be autotuned.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ParallelMapDataset",
    "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`.",
    "description": "Unlike a \"MapDataset\", which applies `f` sequentially, this dataset invokes up\nto `num_parallel_calls` copies of `f` in parallel.",
    "attributes": [
      {
        "name": "f",
        "type": "function"
      },
      {
        "name": "Targuments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "use_inter_op_parallelism",
        "type": "boolean",
        "default": true
      },
      {
        "name": "sloppy",
        "type": "boolean",
        "default": false
      },
      {
        "name": "preserve_cardinality",
        "type": "boolean",
        "default": false
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "other_arguments",
        "typeListAttr": "Targuments"
      },
      {
        "name": "num_parallel_calls",
        "description": "The number of concurrent invocations of `f` that process\nelements from `input_dataset` in parallel.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ParallelMapDatasetV2",
    "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`.",
    "description": "Unlike a \"MapDataset\", which applies `f` sequentially, this dataset invokes up\nto `num_parallel_calls` copies of `f` in parallel.",
    "attributes": [
      {
        "name": "f",
        "type": "function"
      },
      {
        "name": "Targuments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "use_inter_op_parallelism",
        "type": "boolean",
        "default": true
      },
      {
        "name": "deterministic",
        "type": "string",
        "default": "default"
      },
      {
        "name": "preserve_cardinality",
        "type": "boolean",
        "default": false
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "other_arguments",
        "typeListAttr": "Targuments"
      },
      {
        "name": "num_parallel_calls",
        "description": "The number of concurrent invocations of `f` that process\nelements from `input_dataset` in parallel.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ParameterizedTruncatedNormal",
    "summary": "Outputs random values from a normal distribution. The parameters may each be a",
    "description": "scalar which applies to the entire output, or a vector of length shape[0] which\nstores the parameters for each batch.",
    "attributes": [
      {
        "name": "seed",
        "type": "int64",
        "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "description": "A second seed to avoid seed collision.",
        "default": 0
      },
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "The shape of the output tensor. Batches are indexed by the 0th dimension.",
        "typeAttr": "T"
      },
      {
        "name": "means",
        "description": "The mean parameter of each batch.",
        "typeAttr": "dtype"
      },
      {
        "name": "stdevs",
        "description": "The standard deviation parameter of each batch. Must be greater than 0.",
        "typeAttr": "dtype"
      },
      {
        "name": "minvals",
        "description": "The minimum cutoff. May be -infinity.",
        "typeAttr": "dtype"
      },
      {
        "name": "maxvals",
        "description": "The maximum cutoff. May be +infinity, and must be more than the minval\nfor each batch.",
        "typeAttr": "dtype"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A matrix of shape num_batches x samples_per_batch, filled with random\ntruncated normal values using the parameters for each row.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "ParseExample",
    "summary": "Transforms a vector of brain.Example protos (as strings) into typed tensors.",
    "attributes": [
      {
        "name": "Nsparse",
        "type": "int64",
        "minimum": 0
      },
      {
        "name": "Ndense",
        "type": "int64",
        "minimum": 0
      },
      {
        "name": "sparse_types",
        "type": "type[]",
        "description": "A list of Nsparse types; the data types of data in each Feature\ngiven in sparse_keys.\nCurrently the ParseExample supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList). Must be one of the following: `float32`, `int64`, `string`.",
        "minimum": 0
      },
      {
        "name": "Tdense",
        "type": "type[]",
        "minimum": 0,
        "description": "Must be one of the following: `float32`, `int64`, `string`."
      },
      {
        "name": "dense_shapes",
        "type": "shape[]",
        "description": "A list of Ndense shapes; the shapes of data in each Feature\ngiven in dense_keys.\nThe number of elements in the Feature corresponding to dense_key[j]\nmust always equal dense_shapes[j].NumEntries().\nIf dense_shapes[j] == (D0, D1, ..., DN) then the shape of output\nTensor dense_values[j] will be (|serialized|, D0, D1, ..., DN):\nThe dense outputs are just the inputs row-stacked by batch.\nThis works for dense_shapes[j] = (-1, D1, ..., DN).  In this case\nthe shape of the output Tensor dense_values[j] will be\n(|serialized|, M, D1, .., DN), where M is the maximum number of blocks\nof elements of length D1 * .... * DN, across all minibatch entries\nin the input.  Any minibatch entry with less than M blocks of elements of\nlength D1 * ... * DN will be padded with the corresponding default_value\nscalar element along the second dimension.",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "serialized",
        "description": "A vector containing a batch of binary serialized Example protos.",
        "type": 7
      },
      {
        "name": "names",
        "description": "A vector containing the names of the serialized protos.\nMay contain, for example, table key (descriptive) names for the\ncorresponding serialized protos.  These are purely useful for debugging\npurposes, and the presence of values here has no effect on the output.\nMay also be an empty vector if no names are available.\nIf non-empty, this vector must be the same length as \"serialized\".",
        "type": 7
      },
      {
        "name": "sparse_keys",
        "description": "A list of Nsparse string Tensors (scalars).\nThe keys expected in the Examples' features associated with sparse values.",
        "numberAttr": "Nsparse",
        "type": 7
      },
      {
        "name": "dense_keys",
        "description": "A list of Ndense string Tensors (scalars).\nThe keys expected in the Examples' features associated with dense values.",
        "numberAttr": "Ndense",
        "type": 7
      },
      {
        "name": "dense_defaults",
        "description": "A list of Ndense Tensors (some may be empty).\ndense_defaults[j] provides default values\nwhen the example's feature_map lacks dense_key[j].  If an empty Tensor is\nprovided for dense_defaults[j], then the Feature dense_keys[j] is required.\nThe input type is inferred from dense_defaults[j], even when it's empty.\nIf dense_defaults[j] is not empty, and dense_shapes[j] is fully defined,\nthen the shape of dense_defaults[j] must match that of dense_shapes[j].\nIf dense_shapes[j] has an undefined major dimension (variable strides dense\nfeature), dense_defaults[j] must contain a single element:\nthe padding element.",
        "typeListAttr": "Tdense"
      }
    ],
    "outputs": [
      {
        "name": "sparse_indices",
        "numberAttr": "Nsparse",
        "type": 9
      },
      {
        "name": "sparse_values",
        "typeListAttr": "sparse_types"
      },
      {
        "name": "sparse_shapes",
        "numberAttr": "Nsparse",
        "type": 9
      },
      {
        "name": "dense_values",
        "typeListAttr": "Tdense"
      }
    ]
  },
  {
    "name": "ParseExampleDataset",
    "summary": "Transforms `input_dataset` containing `Example` protos as vectors of DT_STRING into a dataset of `Tensor` or `SparseTensor` objects representing the parsed features.",
    "attributes": [
      {
        "name": "sparse_keys",
        "type": "string[]",
        "description": "A list of string keys in the examples features.\nThe results for these keys will be returned as `SparseTensor` objects.",
        "minimum": 0
      },
      {
        "name": "dense_keys",
        "type": "string[]",
        "description": "A list of Ndense string Tensors (scalars).\nThe keys expected in the Examples features associated with dense values.",
        "minimum": 0
      },
      {
        "name": "sparse_types",
        "type": "type[]",
        "description": "A list of `DTypes` of the same length as `sparse_keys`.\nOnly `tf.float32` (`FloatList`), `tf.int64` (`Int64List`),\nand `tf.string` (`BytesList`) are supported. Must be one of the following: `float32`, `int64`, `string`.",
        "minimum": 0
      },
      {
        "name": "Tdense",
        "type": "type[]",
        "description": "A list of DTypes of the same length as `dense_keys`.\nOnly `tf.float32` (`FloatList`), `tf.int64` (`Int64List`),\nand `tf.string` (`BytesList`) are supported.\n Must be one of the following: `float32`, `int64`, `string`.",
        "minimum": 0
      },
      {
        "name": "dense_shapes",
        "type": "shape[]",
        "description": "List of tuples with the same length as `dense_keys`.\nThe shape of the data for each dense feature referenced by `dense_keys`.\nRequired for any input tensors identified by `dense_keys`.  Must be\neither fully defined, or may contain an unknown first dimension.\nAn unknown first dimension means the feature is treated as having\na variable number of blocks, and the output shape along this dimension\nis considered unknown at graph build time.  Padding is applied for\nminibatch elements smaller than the maximum number of blocks for the\ngiven feature along this dimension.",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "description": "The type list for the return values.",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "description": "The list of shapes being produced.",
        "minimum": 1
      },
      {
        "name": "sloppy",
        "type": "boolean",
        "default": false
      },
      {
        "name": "ragged_keys",
        "type": "string[]",
        "minimum": 0,
        "default": []
      },
      {
        "name": "ragged_value_types",
        "type": "type[]",
        "minimum": 0,
        "description": "Must be one of the following: `float32`, `int64`, `string`.",
        "default": []
      },
      {
        "name": "ragged_split_types",
        "type": "type[]",
        "minimum": 0,
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "num_parallel_calls",
        "type": 9
      },
      {
        "name": "dense_defaults",
        "description": "A dict mapping string keys to `Tensor`s.\nThe keys of the dict must match the dense_keys of the feature.",
        "typeListAttr": "Tdense"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ParseExampleDatasetV2",
    "summary": "Transforms `input_dataset` containing `Example` protos as vectors of DT_STRING into a dataset of `Tensor` or `SparseTensor` objects representing the parsed features.",
    "attributes": [
      {
        "name": "sparse_keys",
        "type": "string[]",
        "description": "A list of string keys in the examples features.\nThe results for these keys will be returned as `SparseTensor` objects.",
        "minimum": 0
      },
      {
        "name": "dense_keys",
        "type": "string[]",
        "description": "A list of Ndense string Tensors (scalars).\nThe keys expected in the Examples features associated with dense values.",
        "minimum": 0
      },
      {
        "name": "sparse_types",
        "type": "type[]",
        "description": "A list of `DTypes` of the same length as `sparse_keys`.\nOnly `tf.float32` (`FloatList`), `tf.int64` (`Int64List`),\nand `tf.string` (`BytesList`) are supported. Must be one of the following: `float32`, `int64`, `string`.",
        "minimum": 0
      },
      {
        "name": "Tdense",
        "type": "type[]",
        "description": "A list of DTypes of the same length as `dense_keys`.\nOnly `tf.float32` (`FloatList`), `tf.int64` (`Int64List`),\nand `tf.string` (`BytesList`) are supported.\n Must be one of the following: `float32`, `int64`, `string`.",
        "minimum": 0
      },
      {
        "name": "dense_shapes",
        "type": "shape[]",
        "description": "List of tuples with the same length as `dense_keys`.\nThe shape of the data for each dense feature referenced by `dense_keys`.\nRequired for any input tensors identified by `dense_keys`.  Must be\neither fully defined, or may contain an unknown first dimension.\nAn unknown first dimension means the feature is treated as having\na variable number of blocks, and the output shape along this dimension\nis considered unknown at graph build time.  Padding is applied for\nminibatch elements smaller than the maximum number of blocks for the\ngiven feature along this dimension.",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "description": "The type list for the return values.",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "description": "The list of shapes being produced.",
        "minimum": 1
      },
      {
        "name": "deterministic",
        "type": "string",
        "description": "A string indicating the op-level determinism to use. Deterministic controls\nwhether the dataset is allowed to return elements out of order if the next\nelement to be returned isn't available, but a later element is. Options are\n\"true\", \"false\", and \"default\". \"default\" indicates that determinism should be\ndecided by the `experimental_deterministic` parameter of `tf.data.Options`.",
        "default": "default"
      },
      {
        "name": "ragged_keys",
        "type": "string[]",
        "minimum": 0,
        "default": []
      },
      {
        "name": "ragged_value_types",
        "type": "type[]",
        "minimum": 0,
        "description": "Must be one of the following: `float32`, `int64`, `string`.",
        "default": []
      },
      {
        "name": "ragged_split_types",
        "type": "type[]",
        "minimum": 0,
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "num_parallel_calls",
        "type": 9
      },
      {
        "name": "dense_defaults",
        "description": "A dict mapping string keys to `Tensor`s.\nThe keys of the dict must match the dense_keys of the feature.",
        "typeListAttr": "Tdense"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ParseExampleV2",
    "summary": "Transforms a vector of tf.Example protos (as strings) into typed tensors.",
    "attributes": [
      {
        "name": "Tdense",
        "type": "type[]",
        "minimum": 0,
        "description": "Must be one of the following: `float32`, `int64`, `string`."
      },
      {
        "name": "num_sparse",
        "type": "int64",
        "description": "The number of sparse keys.",
        "minimum": 0
      },
      {
        "name": "sparse_types",
        "type": "type[]",
        "description": "A list of `num_sparse` types; the data types of data in each Feature\ngiven in sparse_keys.\nCurrently the ParseExample supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList). Must be one of the following: `float32`, `int64`, `string`.",
        "minimum": 0
      },
      {
        "name": "ragged_value_types",
        "type": "type[]",
        "description": "A list of `num_ragged` types; the data types of data in each Feature\ngiven in ragged_keys (where `num_ragged = sparse_keys.size()`).\nCurrently the ParseExample supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList). Must be one of the following: `float32`, `int64`, `string`.",
        "minimum": 0
      },
      {
        "name": "ragged_split_types",
        "type": "type[]",
        "description": "A list of `num_ragged` types; the data types of row_splits in each Feature\ngiven in ragged_keys (where `num_ragged = sparse_keys.size()`).\nMay be DT_INT32 or DT_INT64. Must be one of the following: `int32`, `int64`.",
        "minimum": 0
      },
      {
        "name": "dense_shapes",
        "type": "shape[]",
        "description": "A list of `num_dense` shapes; the shapes of data in each Feature\ngiven in dense_keys (where `num_dense = dense_keys.size()`).\nThe number of elements in the Feature corresponding to dense_key[j]\nmust always equal dense_shapes[j].NumEntries().\nIf dense_shapes[j] == (D0, D1, ..., DN) then the shape of output\nTensor dense_values[j] will be (|serialized|, D0, D1, ..., DN):\nThe dense outputs are just the inputs row-stacked by batch.\nThis works for dense_shapes[j] = (-1, D1, ..., DN).  In this case\nthe shape of the output Tensor dense_values[j] will be\n(|serialized|, M, D1, .., DN), where M is the maximum number of blocks\nof elements of length D1 * .... * DN, across all minibatch entries\nin the input.  Any minibatch entry with less than M blocks of elements of\nlength D1 * ... * DN will be padded with the corresponding default_value\nscalar element along the second dimension.",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "serialized",
        "description": "A scalar or vector containing binary serialized Example protos.",
        "type": 7
      },
      {
        "name": "names",
        "description": "A tensor containing the names of the serialized protos.\nCorresponds 1:1 with the `serialized` tensor.\nMay contain, for example, table key (descriptive) names for the\ncorresponding serialized protos.  These are purely useful for debugging\npurposes, and the presence of values here has no effect on the output.\nMay also be an empty vector if no names are available.\nIf non-empty, this tensor must have the same shape as \"serialized\".",
        "type": 7
      },
      {
        "name": "sparse_keys",
        "description": "Vector of strings.\nThe keys expected in the Examples' features associated with sparse values.",
        "type": 7
      },
      {
        "name": "dense_keys",
        "description": "Vector of strings.\nThe keys expected in the Examples' features associated with dense values.",
        "type": 7
      },
      {
        "name": "ragged_keys",
        "description": "Vector of strings.\nThe keys expected in the Examples' features associated with ragged values.",
        "type": 7
      },
      {
        "name": "dense_defaults",
        "description": "A list of Tensors (some may be empty).  Corresponds 1:1 with `dense_keys`.\ndense_defaults[j] provides default values\nwhen the example's feature_map lacks dense_key[j].  If an empty Tensor is\nprovided for dense_defaults[j], then the Feature dense_keys[j] is required.\nThe input type is inferred from dense_defaults[j], even when it's empty.\nIf dense_defaults[j] is not empty, and dense_shapes[j] is fully defined,\nthen the shape of dense_defaults[j] must match that of dense_shapes[j].\nIf dense_shapes[j] has an undefined major dimension (variable strides dense\nfeature), dense_defaults[j] must contain a single element:\nthe padding element.",
        "typeListAttr": "Tdense"
      }
    ],
    "outputs": [
      {
        "name": "sparse_indices",
        "numberAttr": "num_sparse",
        "type": 9
      },
      {
        "name": "sparse_values",
        "typeListAttr": "sparse_types"
      },
      {
        "name": "sparse_shapes",
        "numberAttr": "num_sparse",
        "type": 9
      },
      {
        "name": "dense_values",
        "typeListAttr": "Tdense"
      },
      {
        "name": "ragged_values",
        "typeListAttr": "ragged_value_types"
      },
      {
        "name": "ragged_row_splits",
        "typeListAttr": "ragged_split_types"
      }
    ]
  },
  {
    "name": "ParseSequenceExample",
    "summary": "Transforms a vector of brain.SequenceExample protos (as strings) into typed tensors.",
    "attributes": [
      {
        "name": "feature_list_dense_missing_assumed_empty",
        "type": "string[]",
        "description": "A vector listing the\nFeatureList keys which may be missing from the SequenceExamples.  If the\nassociated FeatureList is missing, it is treated as empty.  By default,\nany FeatureList not listed in this vector must exist in the SequenceExamples.",
        "minimum": 0
      },
      {
        "name": "context_sparse_keys",
        "type": "string[]",
        "description": "A list of Ncontext_sparse string Tensors (scalars).\nThe keys expected in the Examples' features associated with context_sparse\nvalues.",
        "minimum": 0
      },
      {
        "name": "context_dense_keys",
        "type": "string[]",
        "description": "A list of Ncontext_dense string Tensors (scalars).\nThe keys expected in the SequenceExamples' context features associated with\ndense values.",
        "minimum": 0
      },
      {
        "name": "feature_list_sparse_keys",
        "type": "string[]",
        "description": "A list of Nfeature_list_sparse string Tensors\n(scalars).  The keys expected in the FeatureLists associated with sparse\nvalues.",
        "minimum": 0
      },
      {
        "name": "feature_list_dense_keys",
        "type": "string[]",
        "description": "A list of Nfeature_list_dense string Tensors (scalars).\nThe keys expected in the SequenceExamples' feature_lists associated\nwith lists of dense values.",
        "minimum": 0
      },
      {
        "name": "Ncontext_sparse",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "Ncontext_dense",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "Nfeature_list_sparse",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "Nfeature_list_dense",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "context_sparse_types",
        "type": "type[]",
        "description": "A list of Ncontext_sparse types; the data types of data in\neach context Feature given in context_sparse_keys.\nCurrently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList). Must be one of the following: `float32`, `int64`, `string`.",
        "minimum": 0,
        "default": []
      },
      {
        "name": "Tcontext_dense",
        "type": "type[]",
        "minimum": 0,
        "description": "Must be one of the following: `float32`, `int64`, `string`.",
        "default": []
      },
      {
        "name": "feature_list_dense_types",
        "type": "type[]",
        "minimum": 0,
        "description": "Must be one of the following: `float32`, `int64`, `string`.",
        "default": []
      },
      {
        "name": "context_dense_shapes",
        "type": "shape[]",
        "description": "A list of Ncontext_dense shapes; the shapes of data in\neach context Feature given in context_dense_keys.\nThe number of elements in the Feature corresponding to context_dense_key[j]\nmust always equal context_dense_shapes[j].NumEntries().\nThe shape of context_dense_values[j] will match context_dense_shapes[j].",
        "minimum": 0,
        "default": []
      },
      {
        "name": "feature_list_sparse_types",
        "type": "type[]",
        "description": "A list of Nfeature_list_sparse types; the data types\nof data in each FeatureList given in feature_list_sparse_keys.\nCurrently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList). Must be one of the following: `float32`, `int64`, `string`.",
        "minimum": 0,
        "default": []
      },
      {
        "name": "feature_list_dense_shapes",
        "type": "shape[]",
        "description": "A list of Nfeature_list_dense shapes; the shapes of\ndata in each FeatureList given in feature_list_dense_keys.\nThe shape of each Feature in the FeatureList corresponding to\nfeature_list_dense_key[j] must always equal\nfeature_list_dense_shapes[j].NumEntries().",
        "minimum": 0,
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "serialized",
        "description": "A vector containing binary serialized SequenceExample protos.",
        "type": 7
      },
      {
        "name": "debug_name",
        "description": "A vector containing the names of the serialized protos.\nMay contain, for example, table key (descriptive) name for the\ncorresponding serialized proto.  This is purely useful for debugging\npurposes, and the presence of values here has no effect on the output.\nMay also be an empty vector if no name is available.",
        "type": 7
      },
      {
        "name": "context_dense_defaults",
        "description": "A list of Ncontext_dense Tensors (some may be empty).\ncontext_dense_defaults[j] provides default values\nwhen the SequenceExample's context map lacks context_dense_key[j].\nIf an empty Tensor is provided for context_dense_defaults[j],\nthen the Feature context_dense_keys[j] is required.\nThe input type is inferred from context_dense_defaults[j], even when it's\nempty.  If context_dense_defaults[j] is not empty, its shape must match\ncontext_dense_shapes[j].",
        "typeListAttr": "Tcontext_dense"
      }
    ],
    "outputs": [
      {
        "name": "context_sparse_indices",
        "numberAttr": "Ncontext_sparse",
        "type": 9
      },
      {
        "name": "context_sparse_values",
        "typeListAttr": "context_sparse_types"
      },
      {
        "name": "context_sparse_shapes",
        "numberAttr": "Ncontext_sparse",
        "type": 9
      },
      {
        "name": "context_dense_values",
        "typeListAttr": "Tcontext_dense"
      },
      {
        "name": "feature_list_sparse_indices",
        "numberAttr": "Nfeature_list_sparse",
        "type": 9
      },
      {
        "name": "feature_list_sparse_values",
        "typeListAttr": "feature_list_sparse_types"
      },
      {
        "name": "feature_list_sparse_shapes",
        "numberAttr": "Nfeature_list_sparse",
        "type": 9
      },
      {
        "name": "feature_list_dense_values",
        "typeListAttr": "feature_list_dense_types"
      },
      {
        "name": "feature_list_dense_lengths",
        "numberAttr": "Nfeature_list_dense",
        "type": 9
      }
    ]
  },
  {
    "name": "ParseSequenceExampleV2",
    "summary": "Transforms a vector of tf.io.SequenceExample protos (as strings) into\ntyped tensors.",
    "attributes": [
      {
        "name": "Ncontext_sparse",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "Tcontext_dense",
        "type": "type[]",
        "minimum": 0,
        "description": "Must be one of the following: `float32`, `int64`, `string`.",
        "default": []
      },
      {
        "name": "context_sparse_types",
        "type": "type[]",
        "description": "A list of Ncontext_sparse types; the data types of data in\neach context Feature given in context_sparse_keys.\nCurrently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList). Must be one of the following: `float32`, `int64`, `string`.",
        "minimum": 0,
        "default": []
      },
      {
        "name": "context_ragged_value_types",
        "type": "type[]",
        "description": "RaggedTensor.value dtypes for the ragged context features. Must be one of the following: `float32`, `int64`, `string`.",
        "minimum": 0,
        "default": []
      },
      {
        "name": "context_ragged_split_types",
        "type": "type[]",
        "description": "RaggedTensor.row_split dtypes for the ragged context features. Must be one of the following: `int32`, `int64`.",
        "minimum": 0,
        "default": []
      },
      {
        "name": "context_dense_shapes",
        "type": "shape[]",
        "description": "A list of Ncontext_dense shapes; the shapes of data in\neach context Feature given in context_dense_keys.\nThe number of elements in the Feature corresponding to context_dense_key[j]\nmust always equal context_dense_shapes[j].NumEntries().\nThe shape of context_dense_values[j] will match context_dense_shapes[j].",
        "minimum": 0,
        "default": []
      },
      {
        "name": "Nfeature_list_sparse",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "Nfeature_list_dense",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "feature_list_dense_types",
        "type": "type[]",
        "minimum": 0,
        "description": "Must be one of the following: `float32`, `int64`, `string`.",
        "default": []
      },
      {
        "name": "feature_list_sparse_types",
        "type": "type[]",
        "description": "A list of Nfeature_list_sparse types; the data types\nof data in each FeatureList given in feature_list_sparse_keys.\nCurrently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList). Must be one of the following: `float32`, `int64`, `string`.",
        "minimum": 0,
        "default": []
      },
      {
        "name": "feature_list_ragged_value_types",
        "type": "type[]",
        "description": "RaggedTensor.value dtypes for the ragged FeatureList features. Must be one of the following: `float32`, `int64`, `string`.",
        "minimum": 0,
        "default": []
      },
      {
        "name": "feature_list_ragged_split_types",
        "type": "type[]",
        "description": "RaggedTensor.row_split dtypes for the ragged FeatureList features. Must be one of the following: `int32`, `int64`.",
        "minimum": 0,
        "default": []
      },
      {
        "name": "feature_list_dense_shapes",
        "type": "shape[]",
        "description": "A list of Nfeature_list_dense shapes; the shapes of\ndata in each FeatureList given in feature_list_dense_keys.\nThe shape of each Feature in the FeatureList corresponding to\nfeature_list_dense_key[j] must always equal\nfeature_list_dense_shapes[j].NumEntries().",
        "minimum": 0,
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "serialized",
        "description": "A scalar or vector containing binary serialized SequenceExample protos.",
        "type": 7
      },
      {
        "name": "debug_name",
        "description": "A scalar or vector containing the names of the serialized protos.\nMay contain, for example, table key (descriptive) name for the\ncorresponding serialized proto.  This is purely useful for debugging\npurposes, and the presence of values here has no effect on the output.\nMay also be an empty vector if no name is available.",
        "type": 7
      },
      {
        "name": "context_sparse_keys",
        "description": "The keys expected in the Examples' features associated with context_sparse\nvalues.",
        "type": 7
      },
      {
        "name": "context_dense_keys",
        "description": "The keys expected in the SequenceExamples' context features associated with\ndense values.",
        "type": 7
      },
      {
        "name": "context_ragged_keys",
        "description": "The keys expected in the Examples' features associated with context_ragged\nvalues.",
        "type": 7
      },
      {
        "name": "feature_list_sparse_keys",
        "description": "The keys expected in the FeatureLists associated with sparse values.",
        "type": 7
      },
      {
        "name": "feature_list_dense_keys",
        "description": "The keys expected in the SequenceExamples' feature_lists associated\nwith lists of dense values.",
        "type": 7
      },
      {
        "name": "feature_list_ragged_keys",
        "description": "The keys expected in the FeatureLists associated with ragged values.",
        "type": 7
      },
      {
        "name": "feature_list_dense_missing_assumed_empty",
        "description": "A vector corresponding 1:1 with feature_list_dense_keys, indicating which\nfeatures may be missing from the SequenceExamples.  If the associated\nFeatureList is missing, it is treated as empty.",
        "type": 10
      },
      {
        "name": "context_dense_defaults",
        "description": "A list of Ncontext_dense Tensors (some may be empty).\ncontext_dense_defaults[j] provides default values\nwhen the SequenceExample's context map lacks context_dense_key[j].\nIf an empty Tensor is provided for context_dense_defaults[j],\nthen the Feature context_dense_keys[j] is required.\nThe input type is inferred from context_dense_defaults[j], even when it's\nempty.  If context_dense_defaults[j] is not empty, its shape must match\ncontext_dense_shapes[j].",
        "typeListAttr": "Tcontext_dense"
      }
    ],
    "outputs": [
      {
        "name": "context_sparse_indices",
        "numberAttr": "Ncontext_sparse",
        "type": 9
      },
      {
        "name": "context_sparse_values",
        "typeListAttr": "context_sparse_types"
      },
      {
        "name": "context_sparse_shapes",
        "numberAttr": "Ncontext_sparse",
        "type": 9
      },
      {
        "name": "context_dense_values",
        "typeListAttr": "Tcontext_dense"
      },
      {
        "name": "context_ragged_values",
        "typeListAttr": "context_ragged_value_types"
      },
      {
        "name": "context_ragged_row_splits",
        "typeListAttr": "context_ragged_split_types"
      },
      {
        "name": "feature_list_sparse_indices",
        "numberAttr": "Nfeature_list_sparse",
        "type": 9
      },
      {
        "name": "feature_list_sparse_values",
        "typeListAttr": "feature_list_sparse_types"
      },
      {
        "name": "feature_list_sparse_shapes",
        "numberAttr": "Nfeature_list_sparse",
        "type": 9
      },
      {
        "name": "feature_list_dense_values",
        "typeListAttr": "feature_list_dense_types"
      },
      {
        "name": "feature_list_dense_lengths",
        "numberAttr": "Nfeature_list_dense",
        "type": 9
      },
      {
        "name": "feature_list_ragged_values",
        "typeListAttr": "feature_list_ragged_value_types"
      },
      {
        "name": "feature_list_ragged_outer_splits",
        "typeListAttr": "feature_list_ragged_split_types"
      },
      {
        "name": "feature_list_ragged_inner_splits",
        "typeListAttr": "feature_list_ragged_split_types"
      }
    ]
  },
  {
    "name": "ParseSingleExample",
    "summary": "Transforms a tf.Example proto (as a string) into typed tensors.",
    "attributes": [
      {
        "name": "num_sparse",
        "type": "int64",
        "description": "The number of sparse features to be parsed from the example. This\nmust match the lengths of `sparse_keys` and `sparse_types`.",
        "minimum": 0
      },
      {
        "name": "sparse_keys",
        "type": "string[]",
        "description": "A list of `num_sparse` strings.\nThe keys expected in the Examples' features associated with sparse values.",
        "minimum": 0
      },
      {
        "name": "dense_keys",
        "type": "string[]",
        "description": "The keys expected in the Examples' features associated with dense\nvalues.",
        "minimum": 0
      },
      {
        "name": "sparse_types",
        "type": "type[]",
        "description": "A list of `num_sparse` types; the data types of data in each\nFeature given in sparse_keys.\nCurrently the ParseSingleExample op supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList). Must be one of the following: `float32`, `int64`, `string`.",
        "minimum": 0
      },
      {
        "name": "Tdense",
        "type": "type[]",
        "description": "The data types of data in each Feature given in dense_keys.\nThe length of this list must match the length of `dense_keys`.\nCurrently the ParseSingleExample op supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList). Must be one of the following: `float32`, `int64`, `string`.",
        "minimum": 0
      },
      {
        "name": "dense_shapes",
        "type": "shape[]",
        "description": "The shapes of data in each Feature given in dense_keys.\nThe length of this list must match the length of `dense_keys`.  The\nnumber of elements in the Feature corresponding to dense_key[j] must\nalways equal dense_shapes[j].NumEntries().  If dense_shapes[j] ==\n(D0, D1, ..., DN) then the shape of output Tensor dense_values[j]\nwill be (D0, D1, ..., DN): In the case dense_shapes[j] = (-1, D1,\n..., DN), the shape of the output Tensor dense_values[j] will be (M,\nD1, .., DN), where M is the number of blocks of elements of length\nD1 * .... * DN, in the input.",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "serialized",
        "description": "A vector containing a batch of binary serialized Example protos.",
        "type": 7
      },
      {
        "name": "dense_defaults",
        "description": "A list of Tensors (some may be empty), whose length matches\nthe length of `dense_keys`. dense_defaults[j] provides default values\nwhen the example's feature_map lacks dense_key[j].  If an empty Tensor is\nprovided for dense_defaults[j], then the Feature dense_keys[j] is required.\nThe input type is inferred from dense_defaults[j], even when it's empty.\nIf dense_defaults[j] is not empty, and dense_shapes[j] is fully defined,\nthen the shape of dense_defaults[j] must match that of dense_shapes[j].\nIf dense_shapes[j] has an undefined major dimension (variable strides dense\nfeature), dense_defaults[j] must contain a single element:\nthe padding element.",
        "typeListAttr": "Tdense"
      }
    ],
    "outputs": [
      {
        "name": "sparse_indices",
        "numberAttr": "num_sparse",
        "type": 9
      },
      {
        "name": "sparse_values",
        "typeListAttr": "sparse_types"
      },
      {
        "name": "sparse_shapes",
        "numberAttr": "num_sparse",
        "type": 9
      },
      {
        "name": "dense_values",
        "typeListAttr": "Tdense"
      }
    ]
  },
  {
    "name": "ParseSingleSequenceExample",
    "summary": "Transforms a scalar brain.SequenceExample proto (as strings) into typed tensors.",
    "attributes": [
      {
        "name": "Ncontext_sparse",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "Ncontext_dense",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "Nfeature_list_sparse",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "Nfeature_list_dense",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "context_sparse_types",
        "type": "type[]",
        "description": "A list of Ncontext_sparse types; the data types of data in\neach context Feature given in context_sparse_keys.\nCurrently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList). Must be one of the following: `float32`, `int64`, `string`.",
        "minimum": 0,
        "default": []
      },
      {
        "name": "Tcontext_dense",
        "type": "type[]",
        "minimum": 0,
        "description": "Must be one of the following: `float32`, `int64`, `string`.",
        "default": []
      },
      {
        "name": "feature_list_dense_types",
        "type": "type[]",
        "minimum": 0,
        "description": "Must be one of the following: `float32`, `int64`, `string`.",
        "default": []
      },
      {
        "name": "context_dense_shapes",
        "type": "shape[]",
        "description": "A list of Ncontext_dense shapes; the shapes of data in\neach context Feature given in context_dense_keys.\nThe number of elements in the Feature corresponding to context_dense_key[j]\nmust always equal context_dense_shapes[j].NumEntries().\nThe shape of context_dense_values[j] will match context_dense_shapes[j].",
        "minimum": 0,
        "default": []
      },
      {
        "name": "feature_list_sparse_types",
        "type": "type[]",
        "description": "A list of Nfeature_list_sparse types; the data types\nof data in each FeatureList given in feature_list_sparse_keys.\nCurrently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList). Must be one of the following: `float32`, `int64`, `string`.",
        "minimum": 0,
        "default": []
      },
      {
        "name": "feature_list_dense_shapes",
        "type": "shape[]",
        "description": "A list of Nfeature_list_dense shapes; the shapes of\ndata in each FeatureList given in feature_list_dense_keys.\nThe shape of each Feature in the FeatureList corresponding to\nfeature_list_dense_key[j] must always equal\nfeature_list_dense_shapes[j].NumEntries().",
        "minimum": 0,
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "serialized",
        "description": "A scalar containing a binary serialized SequenceExample proto.",
        "type": 7
      },
      {
        "name": "feature_list_dense_missing_assumed_empty",
        "description": "A vector listing the\nFeatureList keys which may be missing from the SequenceExample.  If the\nassociated FeatureList is missing, it is treated as empty.  By default,\nany FeatureList not listed in this vector must exist in the SequenceExample.",
        "type": 7
      },
      {
        "name": "context_sparse_keys",
        "description": "A list of Ncontext_sparse string Tensors (scalars).\nThe keys expected in the Examples' features associated with context_sparse\nvalues.",
        "numberAttr": "Ncontext_sparse",
        "type": 7
      },
      {
        "name": "context_dense_keys",
        "description": "A list of Ncontext_dense string Tensors (scalars).\nThe keys expected in the SequenceExamples' context features associated with\ndense values.",
        "numberAttr": "Ncontext_dense",
        "type": 7
      },
      {
        "name": "feature_list_sparse_keys",
        "description": "A list of Nfeature_list_sparse string Tensors\n(scalars).  The keys expected in the FeatureLists associated with sparse\nvalues.",
        "numberAttr": "Nfeature_list_sparse",
        "type": 7
      },
      {
        "name": "feature_list_dense_keys",
        "description": "A list of Nfeature_list_dense string Tensors (scalars).\nThe keys expected in the SequenceExamples' feature_lists associated\nwith lists of dense values.",
        "numberAttr": "Nfeature_list_dense",
        "type": 7
      },
      {
        "name": "context_dense_defaults",
        "description": "A list of Ncontext_dense Tensors (some may be empty).\ncontext_dense_defaults[j] provides default values\nwhen the SequenceExample's context map lacks context_dense_key[j].\nIf an empty Tensor is provided for context_dense_defaults[j],\nthen the Feature context_dense_keys[j] is required.\nThe input type is inferred from context_dense_defaults[j], even when it's\nempty.  If context_dense_defaults[j] is not empty, its shape must match\ncontext_dense_shapes[j].",
        "typeListAttr": "Tcontext_dense"
      },
      {
        "name": "debug_name",
        "description": "A scalar containing the name of the serialized proto.\nMay contain, for example, table key (descriptive) name for the\ncorresponding serialized proto.  This is purely useful for debugging\npurposes, and the presence of values here has no effect on the output.\nMay also be an empty scalar if no name is available.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "context_sparse_indices",
        "numberAttr": "Ncontext_sparse",
        "type": 9
      },
      {
        "name": "context_sparse_values",
        "typeListAttr": "context_sparse_types"
      },
      {
        "name": "context_sparse_shapes",
        "numberAttr": "Ncontext_sparse",
        "type": 9
      },
      {
        "name": "context_dense_values",
        "typeListAttr": "Tcontext_dense"
      },
      {
        "name": "feature_list_sparse_indices",
        "numberAttr": "Nfeature_list_sparse",
        "type": 9
      },
      {
        "name": "feature_list_sparse_values",
        "typeListAttr": "feature_list_sparse_types"
      },
      {
        "name": "feature_list_sparse_shapes",
        "numberAttr": "Nfeature_list_sparse",
        "type": 9
      },
      {
        "name": "feature_list_dense_values",
        "typeListAttr": "feature_list_dense_types"
      }
    ]
  },
  {
    "name": "ParseTensor",
    "summary": "Transforms a serialized tensorflow.TensorProto proto into a Tensor.",
    "attributes": [
      {
        "name": "out_type",
        "type": "type",
        "description": "The type of the serialized tensor.  The provided type must match the\ntype of the serialized tensor and no implicit conversion will take place."
      }
    ],
    "inputs": [
      {
        "name": "serialized",
        "description": "A scalar string containing a serialized TensorProto proto.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A Tensor of type `out_type`.",
        "typeAttr": "out_type"
      }
    ]
  },
  {
    "name": "PartitionedCall",
    "summary": "returns `f(inputs)`, where `f`'s body is placed and partitioned.",
    "description": "Asynchronously executes a function, potentially across multiple devices but\nwithin a single process. The kernel places and partitions a given function's\nunderlying graph, and executes each of the partitioned subgraphs as a function.",
    "attributes": [
      {
        "name": "Tin",
        "type": "type[]",
        "description": "A list of input types.",
        "minimum": 0
      },
      {
        "name": "Tout",
        "type": "type[]",
        "description": "A list of output types.",
        "minimum": 0
      },
      {
        "name": "f",
        "type": "function",
        "description": "      A function that takes 'args', a list of tensors, and returns 'output',\n      another list of tensors. Input and output types are specified by 'Tin'\n      and 'Tout'. The function body of f will be placed and partitioned across\n      devices, setting this op apart from the regular Call op."
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      },
      {
        "name": "config_proto",
        "type": "string",
        "default": ""
      },
      {
        "name": "executor_type",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "args",
        "description": "A list of input tensors.",
        "typeListAttr": "Tin"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A list of return values.",
        "typeListAttr": "Tout"
      }
    ]
  },
  {
    "name": "Placeholder",
    "summary": "A placeholder op for a value that will be fed into the computation.",
    "description": "N.B. This operation will fail with an error if it is executed. It is\nintended as a way to represent a value that will always be fed, and to\nprovide attrs that enable the fed value to be checked at runtime.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of elements in the tensor."
      },
      {
        "name": "shape",
        "type": "shape",
        "description": "(Optional) The shape of the tensor. If the shape has 0 dimensions, the\nshape is unconstrained.",
        "default": {
          "type": "shape",
          "value": "?"
        }
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A placeholder tensor that must be replaced using the feed mechanism.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "PlaceholderV2",
    "summary": "A placeholder op for a value that will be fed into the computation.",
    "description": "N.B. This operation will fail with an error if it is executed. It is\nintended as a way to represent a value that will always be fed, and to\nprovide attrs that enable the fed value to be checked at runtime.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of elements in the tensor."
      },
      {
        "name": "shape",
        "type": "shape",
        "description": "The shape of the tensor. The shape can be any partially-specified\nshape.  To be unconstrained, pass in a shape with unknown rank."
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A placeholder tensor that must be replaced using the feed mechanism.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "PlaceholderWithDefault",
    "summary": "A placeholder op that passes through `input` when its output is not fed.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of elements in the tensor."
      },
      {
        "name": "shape",
        "type": "shape",
        "description": "The (possibly partial) shape of the tensor."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The default value to produce when `output` is not fed.",
        "typeAttr": "dtype"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A placeholder tensor that defaults to `input` if it is not fed.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "Polygamma",
    "summary": "Compute the polygamma function \\\\(\\psi^{(n)}(x)\\\\).",
    "description": "The polygamma function is defined as:\n\n\n\\\\(\\psi^{(a)}(x) = \\frac{d^a}{dx^a} \\psi(x)\\\\)\n\nwhere \\\\(\\psi(x)\\\\) is the digamma function.\nThe polygamma function is defined only for non-negative integer orders \\\\a\\\\.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "a",
        "typeAttr": "T"
      },
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "PopulationCount",
    "summary": "Computes element-wise population count (a.k.a. popcount, bitsum, bitcount).",
    "description": "For each entry in `x`, calculates the number of `1` (on) bits in the binary\nrepresentation of that entry.\n\n**NOTE**: It is more efficient to first `tf.bitcast` your tensors into\n`int32` or `int64` and perform the bitcount on the result, than to feed in\n8- or 16-bit inputs and then aggregate the resulting counts.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "type": 4
      }
    ]
  },
  {
    "name": "Pow",
    "summary": "Computes the power of one value to another.",
    "description": "Given a tensor `x` and a tensor `y`, this operation computes \\\\(x^y\\\\) for\ncorresponding elements in `x` and `y`. For example:\n\n```\n# tensor 'x' is [[2, 2]], [3, 3]]\n# tensor 'y' is [[8, 16], [2, 3]]\ntf.pow(x, y) ==> [[256, 65536], [9, 27]]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float32`, `float16`, `float64`, `int8`, `int16`, `int32`, `int64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "PrefetchDataset",
    "summary": "Creates a dataset that asynchronously prefetches elements from `input_dataset`.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "slack_period",
        "type": "int64",
        "default": 0
      },
      {
        "name": "legacy_autotune",
        "type": "boolean",
        "default": true
      },
      {
        "name": "buffer_size_min",
        "type": "int64",
        "default": 0
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "buffer_size",
        "description": "The maximum number of elements to buffer in an iterator over\nthis dataset.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "Prelinearize",
    "summary": "An op which linearizes one Tensor value to an opaque variant tensor.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of elements in the tensor."
      },
      {
        "name": "shape",
        "type": "shape",
        "description": "The shape of the tensor.",
        "default": {
          "type": "shape",
          "value": "?"
        }
      },
      {
        "name": "layout",
        "type": "int64[]",
        "description": "A vector holding the requested layout in minor-to-major sequence. If a layout\nattribute is passed but its values are all -1 the layout will be computed by\nthe infeed operation.",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A tensor that will be linearized.",
        "typeAttr": "dtype"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 21
      }
    ]
  },
  {
    "name": "PrelinearizeTuple",
    "summary": "An op which linearizes multiple Tensor values to an opaque variant tensor.",
    "attributes": [
      {
        "name": "dtypes",
        "type": "type[]",
        "description": "The element types of each element in `inputs`.",
        "minimum": 1
      },
      {
        "name": "shapes",
        "type": "shape[]",
        "description": "The shapes of each tensor in `inputs`."
      },
      {
        "name": "layouts",
        "type": "int64[]",
        "description": "A vector holding the requested layout in minor-to-major sequence for all the\ntuple shapes in the order the shapes appear in the \"shapes\" input. The layout\nelements for a sub-shape can be set to -1 in which case the corresponding layout\nwill be computed by the infeed operation.",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "description": "A list of tensors that will be provided using the infeed mechanism.",
        "typeListAttr": "dtypes"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 21
      }
    ]
  },
  {
    "name": "PreventGradient",
    "summary": "An identity op that triggers an error if a gradient is requested.",
    "description": "When executed in a graph, this op outputs its input tensor as-is.\n\nWhen building ops to compute gradients, the TensorFlow gradient system\nwill return an error when trying to lookup the gradient of this op,\nbecause no gradient must ever be registered for this function.  This\nop exists to prevent subtle bugs from silently returning unimplemented\ngradients in some corner cases.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "message",
        "type": "string",
        "description": "Will be printed in the error when anyone tries to differentiate\nthis operation.",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "any tensor.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "the same input tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Print",
    "summary": "Prints a list of tensors.",
    "description": "Passes `input` through to `output` and prints `data` when evaluating.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "U",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "message",
        "type": "string",
        "description": "A string, prefix of the error message.",
        "default": ""
      },
      {
        "name": "first_n",
        "type": "int64",
        "description": "Only log `first_n` number of times. -1 disables logging.",
        "default": -1
      },
      {
        "name": "summarize",
        "type": "int64",
        "description": "Only print this many entries of each tensor.",
        "default": 3
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The tensor passed to `output`",
        "typeAttr": "T"
      },
      {
        "name": "data",
        "description": "A list of tensors to print out when op is evaluated.",
        "typeListAttr": "U"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The unmodified `input` tensor",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "PrintV2",
    "summary": "Prints a string scalar.",
    "description": "Prints a string scalar to the desired output_stream.",
    "attributes": [
      {
        "name": "output_stream",
        "type": "string",
        "description": "A string specifying the output stream or logging level to print to.",
        "default": "stderr"
      },
      {
        "name": "end",
        "type": "string",
        "default": "\n"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The string scalar to print.",
        "type": 7
      }
    ]
  },
  {
    "name": "PriorityQueue",
    "summary": "A queue that produces elements sorted by the first component value.",
    "description": "Note that the PriorityQueue requires the first component of any element\nto be a scalar int64, in addition to the other elements declared by\ncomponent_types.  Therefore calls to Enqueue and EnqueueMany (resp. Dequeue\nand DequeueMany) on a PriorityQueue will all require (resp. output) one extra\nentry in their input (resp. output) lists.",
    "attributes": [
      {
        "name": "component_types",
        "type": "type[]",
        "description": "The type of each component in a value.",
        "minimum": 0,
        "default": []
      },
      {
        "name": "shapes",
        "type": "shape[]",
        "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types. If the length of\nthis attr is 0, the shapes of queue elements are not constrained, and\nonly one element may be dequeued at a time.",
        "minimum": 0
      },
      {
        "name": "capacity",
        "type": "int64",
        "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
        "default": -1
      },
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "The handle to the queue.",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "PriorityQueueV2",
    "summary": "A queue that produces elements sorted by the first component value.",
    "description": "Note that the PriorityQueue requires the first component of any element\nto be a scalar int64, in addition to the other elements declared by\ncomponent_types.  Therefore calls to Enqueue and EnqueueMany (resp. Dequeue\nand DequeueMany) on a PriorityQueue will all require (resp. output) one extra\nentry in their input (resp. output) lists.",
    "attributes": [
      {
        "name": "component_types",
        "type": "type[]",
        "description": "The type of each component in a value.",
        "minimum": 0,
        "default": []
      },
      {
        "name": "shapes",
        "type": "shape[]",
        "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types. If the length of\nthis attr is 0, the shapes of queue elements are not constrained, and\nonly one element may be dequeued at a time.",
        "minimum": 0
      },
      {
        "name": "capacity",
        "type": "int64",
        "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
        "default": -1
      },
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "The handle to the queue.",
        "type": 20
      }
    ]
  },
  {
    "name": "PrivateThreadPoolDataset",
    "summary": "Creates a dataset that uses a custom thread pool to compute `input_dataset`.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "num_threads",
        "description": "Identifies the number of threads to use for the private threadpool.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "Prod",
    "summary": "Computes the product of elements across dimensions of a tensor.",
    "description": "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1.",
    "attributes": [
      {
        "name": "keep_dims",
        "type": "boolean",
        "description": "If true, retain reduced dimensions with length 1.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The tensor to reduce.",
        "typeAttr": "T"
      },
      {
        "name": "reduction_indices",
        "description": "The dimensions to reduce. Must be in the range\n`[-rank(input), rank(input))`.",
        "typeAttr": "Tidx"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The reduced tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "PyFunc",
    "summary": "Invokes a python function to compute func(input)->output.",
    "description": "This operation is considered stateful. For a stateless version, see\nPyFuncStateless.",
    "attributes": [
      {
        "name": "token",
        "type": "string",
        "description": "A token representing a registered python function in this address space."
      },
      {
        "name": "Tin",
        "type": "type[]",
        "description": "Data types of the inputs to the op.",
        "minimum": 0
      },
      {
        "name": "Tout",
        "type": "type[]",
        "description": "Data types of the outputs from the op.\nThe length of the list specifies the number of outputs.",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "List of Tensors that will provide input to the Op.",
        "typeListAttr": "Tin"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The outputs from the Op.",
        "typeListAttr": "Tout"
      }
    ]
  },
  {
    "name": "PyFuncStateless",
    "summary": "A stateless version of PyFunc.",
    "attributes": [
      {
        "name": "token",
        "type": "string"
      },
      {
        "name": "Tin",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "Tout",
        "type": "type[]",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeListAttr": "Tin"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeListAttr": "Tout"
      }
    ]
  },
  {
    "name": "Qr",
    "summary": "Computes the QR decompositions of one or more matrices.",
    "description": "Computes the QR decomposition of each inner matrix in `tensor` such that\n`tensor[..., :, :] = q[..., :, :] * r[..., :,:])`\n\nCurrently, the gradient for the QR decomposition is well-defined only when\nthe first `P` columns of the inner matrix are linearly independent, where\n`P` is the minimum of `M` and `N`, the 2 inner-most dimmensions of `tensor`.\n\n```python\n# a is a tensor.\n# q is a tensor of orthonormal matrices.\n# r is a tensor of upper triangular matrices.\nq, r = qr(a)\nq_full, r_full = qr(a, full_matrices=True)\n```",
    "attributes": [
      {
        "name": "full_matrices",
        "type": "boolean",
        "description": "If true, compute full-sized `q` and `r`. If false\n(the default), compute only the leading `P` columns of `q`.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float64`, `float32`, `float16`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A tensor of shape `[..., M, N]` whose inner-most 2 dimensions\nform matrices of size `[M, N]`. Let `P` be the minimum of `M` and `N`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "q",
        "description": "Orthonormal basis for range of `a`. If `full_matrices` is `False` then\nshape is `[..., M, P]`; if `full_matrices` is `True` then shape is\n`[..., M, M]`.",
        "typeAttr": "T"
      },
      {
        "name": "r",
        "description": "Triangular factor. If `full_matrices` is `False` then shape is\n`[..., P, N]`. If `full_matrices` is `True` then shape is `[..., M, N]`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "QuantizeAndDequantize",
    "category": "Quantization",
    "summary": "Use QuantizeAndDequantizeV2 instead.",
    "attributes": [
      {
        "name": "signed_input",
        "type": "boolean",
        "default": true
      },
      {
        "name": "num_bits",
        "type": "int64",
        "default": 8
      },
      {
        "name": "range_given",
        "type": "boolean",
        "default": false
      },
      {
        "name": "input_min",
        "type": "float32",
        "default": 0.0
      },
      {
        "name": "input_max",
        "type": "float32",
        "default": 0.0
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "QuantizeAndDequantizeV2",
    "category": "Quantization",
    "summary": "Quantizes then dequantizes a tensor.",
    "description": "This op simulates the precision loss from the quantized forward pass by:\n\n1. Quantizing the tensor to fixed point numbers, which should match the target\n   quantization method when it is used in inference.\n2. Dequantizing it back to floating point numbers for the following ops, most\n   likely matmul.\n\nThere are different ways to quantize. This version uses only scaling, so 0.0\nmaps to 0.\n\nFrom the specified 'num_bits' in the quantized output type, it determines\nminimum and maximum representable quantized values.\n\ne.g.\n\n*   [-128, 127] for signed, num_bits = 8, or\n*   [0, 255] for unsigned, num_bits = 8.\n\nIf range_given == False, the initial input_min, input_max will be determined\nautomatically as the minimum and maximum values in the input tensor, otherwise\nthe specified values of input_min, input_max are used.\n\nNote: If the input_min, input_max are specified, they do not need to equal the\nactual minimum and maximum values in the tensor. e.g. in some cases it may be\nbeneficial to specify these values such that the low probability extremes of the\ninput distribution are clipped.\n\nThis op determines the maximum scale_factor that would map the initial\n[input_min, input_max] range to a range that lies within the representable\nquantized range.\n\nIt determines the scale from one of input_min and input_max, then updates the\nother one to maximize the representable range.\n\ne.g.\n\n*   if the output is signed, num_bits = 8, [input_min, input_max] = [-10.0,\n    5.0]: it would use a scale_factor of -128 / -10.0 = 12.8 In this case, it\n    would update input_max to be 127 / 12.8 = 9.921875\n*   if the output is signed, num_bits = 8, [input_min, input_max] = [-10.0,\n    10.0]: it would use a scale_factor of 127 / 10.0 = 12.7 In this case, it\n    would update input_min to be 128.0 / 12.7 = -10.07874\n*   if the output is unsigned, input_min is forced to be 0, and only the\n    specified input_max is used.\n\nAfter determining the scale_factor and updating the input range, it applies the\nfollowing to each value in the 'input' tensor.\n\noutput = round(clamp(value, input_min, input_max) * scale_factor) / scale_factor.\n\nThe above round function rounds the value based on the given round_mode.\n",
    "attributes": [
      {
        "name": "signed_input",
        "type": "boolean",
        "description": "Whether the quantization is signed or unsigned. (actually this parameter should\nhave been called <b>`signed_output`</b>)",
        "default": true
      },
      {
        "name": "num_bits",
        "type": "int64",
        "description": "The bitwidth of the quantization.",
        "default": 8
      },
      {
        "name": "range_given",
        "type": "boolean",
        "description": "Whether the range is given or should be determined from the `input` tensor.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "round_mode",
        "type": "string",
        "description": "The 'round_mode' attribute controls which rounding tie-breaking algorithm is\nused when rounding float values to their quantized equivalents. The following\nrounding modes are currently supported:\n\n*   HALF_TO_EVEN: this is the default round_mode.\n*   HALF_UP: round towards positive. In this mode 7.5 rounds up to 8 and -7.5\n    rounds up to -7.\n Must be one of the following: `HALF_TO_EVEN`, `HALF_UP`.",
        "default": "HALF_TO_EVEN"
      },
      {
        "name": "narrow_range",
        "type": "boolean",
        "description": "If True, then the absolute value of the quantized minimum value is the same as\nthe quantized maximum value, instead of 1 greater.\ni.e. for 8 bit quantization, the minimum value is -127 instead of -128.",
        "default": false
      },
      {
        "name": "axis",
        "type": "int64",
        "description": "If specified, this axis is treated as a channel or slice axis, and a separate\nquantization range is used for each channel or slice along this axis.",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Tensor to quantize and then dequantize.",
        "typeAttr": "T"
      },
      {
        "name": "input_min",
        "description": "If `range_given == True`, this specifies the minimum input value that needs to\nbe represented, otherwise it is determined from the min value of the `input`\ntensor.",
        "typeAttr": "T"
      },
      {
        "name": "input_max",
        "description": "If `range_given == True`, this specifies the maximum input value that needs to\nbe represented, otherwise it is determined from the max value of the `input`\ntensor.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "QuantizeAndDequantizeV3",
    "category": "Quantization",
    "summary": "Quantizes then dequantizes a tensor.",
    "description": "This is almost identical to QuantizeAndDequantizeV2, except that num_bits is a\ntensor, so its value can change during training.",
    "attributes": [
      {
        "name": "signed_input",
        "type": "boolean",
        "default": true
      },
      {
        "name": "range_given",
        "type": "boolean",
        "default": true
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "narrow_range",
        "type": "boolean",
        "default": false
      },
      {
        "name": "axis",
        "type": "int64",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "input_min",
        "typeAttr": "T"
      },
      {
        "name": "input_max",
        "typeAttr": "T"
      },
      {
        "name": "num_bits",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "QuantizeAndDequantizeV4",
    "category": "Quantization",
    "summary": "Quantizes then dequantizes a tensor.",
    "description": "This is almost identical to QuantizeAndDequantizeV2, except that it returns a\ngradient of 1 for inputs that are within the quantization range, or 0 otherwise.",
    "attributes": [
      {
        "name": "signed_input",
        "type": "boolean",
        "description": "Whether the quantization is signed or unsigned. (actually this parameter should\nhave been called <b>`signed_output`</b>)",
        "default": true
      },
      {
        "name": "num_bits",
        "type": "int64",
        "description": "The bitwidth of the quantization.",
        "default": 8
      },
      {
        "name": "range_given",
        "type": "boolean",
        "description": "Whether the range is given or should be determined from the `input` tensor.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "round_mode",
        "type": "string",
        "description": "The 'round_mode' attribute controls which rounding tie-breaking algorithm is\nused when rounding float values to their quantized equivalents. The following\nrounding modes are currently supported:\n\n*   HALF_TO_EVEN: this is the default round_mode.\n*   HALF_UP: round towards positive. In this mode 7.5 rounds up to 8 and -7.5\n    rounds up to -7.\n Must be one of the following: `HALF_TO_EVEN`, `HALF_UP`.",
        "default": "HALF_TO_EVEN"
      },
      {
        "name": "narrow_range",
        "type": "boolean",
        "description": "If True, then the absolute value of the quantized minimum value is the same as\nthe quantized maximum value, instead of 1 greater.\ni.e. for 8 bit quantization, the minimum value is -127 instead of -128.",
        "default": false
      },
      {
        "name": "axis",
        "type": "int64",
        "description": "If specified, this axis is treated as a channel or slice axis, and a separate\nquantization range is used for each channel or slice along this axis.",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Tensor to quantize and then dequantize.",
        "typeAttr": "T"
      },
      {
        "name": "input_min",
        "description": "If `range_given == True`, this specifies the minimum input value that needs to\nbe represented, otherwise it is determined from the min value of the `input`\ntensor.",
        "typeAttr": "T"
      },
      {
        "name": "input_max",
        "description": "If `range_given == True`, this specifies the maximum input value that needs to\nbe represented, otherwise it is determined from the max value of the `input`\ntensor.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "QuantizeAndDequantizeV4Grad",
    "category": "Quantization",
    "summary": "Returns the gradient of `QuantizeAndDequantizeV4`.",
    "description": "Returns a gradient of 1 for inputs that are within the quantization range,\nor 0 otherwise.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "axis",
        "type": "int64",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "gradients",
        "typeAttr": "T"
      },
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "input_min",
        "typeAttr": "T"
      },
      {
        "name": "input_max",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "input_backprop",
        "typeAttr": "T"
      },
      {
        "name": "input_min_backprop",
        "typeAttr": "T"
      },
      {
        "name": "input_max_backprop",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "QuantizeDownAndShrinkRange",
    "category": "Quantization",
    "summary": "Convert the quantized 'input' tensor into a lower-precision 'output', using the",
    "description": "actual distribution of the values to maximize the usage of the lower bit depth\nand adjusting the output min and max ranges accordingly.\n\n[input_min, input_max] are scalar floats that specify the range for the float\ninterpretation of the 'input' data. For example, if input_min is -1.0f and\ninput_max is 1.0f, and we are dealing with quint16 quantized data, then a 0\nvalue in the 16-bit data should be interpreted as -1.0f, and a 65535 means 1.0f.\n\nThis operator tries to squeeze as much precision as possible into an output with\na lower bit depth by calculating the actual min and max values found in the\ndata. For example, maybe that quint16 input has no values lower than 16,384 and\nnone higher than 49,152. That means only half the range is actually needed, all\nthe float interpretations are between -0.5f and 0.5f, so if we want to compress\nthe data into a quint8 output, we can use that range rather than the theoretical\n-1.0f to 1.0f that is suggested by the input min and max.\n\nIn practice, this is most useful for taking output from operations like\nQuantizedMatMul that can produce higher bit-depth outputs than their inputs and\nmay have large potential output ranges, but in practice have a distribution of\ninput values that only uses a small fraction of the possible range. By feeding\nthat output into this operator, we can reduce it from 32 bits down to 8 with\nminimal loss of accuracy.",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type",
        "description": "The type of the input. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "The type of the output. Should be a lower bit depth than Tinput. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "Tinput"
      },
      {
        "name": "input_min",
        "description": "The float value that the minimum quantized input value represents.",
        "type": 1
      },
      {
        "name": "input_max",
        "description": "The float value that the maximum quantized input value represents.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "out_type"
      },
      {
        "name": "output_min",
        "description": "The float value that the minimum quantized output value represents.",
        "type": 1
      },
      {
        "name": "output_max",
        "description": "The float value that the maximum quantized output value represents.",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizeV2",
    "category": "Quantization",
    "summary": "Quantize the 'input' tensor of type float to 'output' tensor of type 'T'.",
    "description": "[min_range, max_range] are scalar floats that specify the range for\nthe 'input' data. The 'mode' attribute controls exactly which calculations are\nused to convert the float values to their quantized equivalents.  The\n'round_mode' attribute controls which rounding tie-breaking algorithm is used\nwhen rounding float values to their quantized equivalents.\n\nIn 'MIN_COMBINED' mode, each value of the tensor will undergo the following:\n\n```\nout[i] = (in[i] - min_range) * range(T) / (max_range - min_range)\nif T == qint8: out[i] -= (range(T) + 1) / 2.0\n```\n\nhere `range(T) = numeric_limits<T>::max() - numeric_limits<T>::min()`\n\n*MIN_COMBINED Mode Example*\n\nAssume the input is type float and has a possible range of [0.0, 6.0] and the\noutput type is quint8 ([0, 255]). The min_range and max_range values should be\nspecified as 0.0 and 6.0. Quantizing from float to quint8 will multiply each\nvalue of the input by 255/6 and cast to quint8.\n\nIf the output type was qint8 ([-128, 127]), the operation will additionally\nsubtract each value by 128 prior to casting, so that the range of values aligns\nwith the range of qint8.\n\nIf the mode is 'MIN_FIRST', then this approach is used:\n\n```\nnum_discrete_values = 1 << (# of bits in T)\nrange_adjust = num_discrete_values / (num_discrete_values - 1)\nrange = (range_max - range_min) * range_adjust\nrange_scale = num_discrete_values / range\nquantized = round(input * range_scale) - round(range_min * range_scale) +\n  numeric_limits<T>::min()\nquantized = max(quantized, numeric_limits<T>::min())\nquantized = min(quantized, numeric_limits<T>::max())\n```\n\nThe biggest difference between this and MIN_COMBINED is that the minimum range\nis rounded first, before it's subtracted from the rounded value. With\nMIN_COMBINED, a small bias is introduced where repeated iterations of quantizing\nand dequantizing will introduce a larger and larger error.\n\n*SCALED mode Example*\n\n`SCALED` mode matches the quantization approach used in\n`QuantizeAndDequantize{V2|V3}`.\n\nIf the mode is `SCALED`, the quantization is performed by multiplying each\ninput value by a scaling_factor.\nThe scaling_factor is determined from `min_range` and `max_range` to be as large\nas possible such that the range from `min_range` to `max_range` is representable\nwithin values of type T.\n\n```c++\n\n  const int min_T = std::numeric_limits<T>::min();\n  const int max_T = std::numeric_limits<T>::max();\n  const float max_float = std::numeric_limits<float>::max();\n\n  const float scale_factor_from_min_side =\n      (min_T * min_range > 0) ? min_T / min_range : max_float;\n  const float scale_factor_from_max_side =\n      (max_T * max_range > 0) ? max_T / max_range : max_float;\n\n  const float scale_factor = std::min(scale_factor_from_min_side,\n                                      scale_factor_from_max_side);\n```\n\nWe next use the scale_factor to adjust min_range and max_range as follows:\n\n```c++\n      min_range = min_T / scale_factor;\n      max_range = max_T / scale_factor;\n```\n\n\ne.g. if T = qint8, and initially min_range = -10, and max_range = 9, we would\ncompare -128/-10.0 = 12.8 to 127/9.0 = 14.11, and set scaling_factor = 12.8\nIn this case, min_range would remain -10, but max_range would be adjusted to\n127 / 12.8 = 9.921875\n\nSo we will quantize input values in the range (-10, 9.921875) to (-128, 127).\n\nThe input tensor can now be quantized by clipping values to the range\n`min_range` to `max_range`, then multiplying by scale_factor as follows:\n\n```c++\nresult = round(min(max_range, max(min_range, input)) * scale_factor)\n```\n\nThe adjusted `min_range` and `max_range` are returned as outputs 2 and 3 of\nthis operation. These outputs should be used as the range for any further\ncalculations.\n\n\n*narrow_range (bool) attribute*\n\nIf true, we do not use the minimum quantized value.\ni.e. for int8 the quantized output, it would be restricted to the range\n-127..127 instead of the full -128..127 range.\nThis is provided for compatibility with certain inference backends.\n(Only applies to SCALED mode)\n\n\n*axis (int) attribute*\n\nAn optional `axis` attribute can specify a dimension index of the input tensor,\nsuch that quantization ranges will be calculated and applied separately for each\nslice of the tensor along that dimension. This is useful for per-channel\nquantization.\n\nIf axis is specified, min_range and max_range\n\nif `axis`=None, per-tensor quantization is performed as normal.\n\n\n*ensure_minimum_range (float) attribute*\n\nEnsures the minimum quantization range is at least this value.\nThe legacy default value for this is 0.01, but it is strongly suggested to\nset it to 0 for new uses.\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "mode",
        "type": "string",
        "description": "Must be one of the following: `MIN_COMBINED`, `MIN_FIRST`, `SCALED`.",
        "default": "MIN_COMBINED"
      },
      {
        "name": "round_mode",
        "type": "string",
        "description": "Must be one of the following: `HALF_AWAY_FROM_ZERO`, `HALF_TO_EVEN`.",
        "default": "HALF_AWAY_FROM_ZERO"
      },
      {
        "name": "narrow_range",
        "type": "boolean",
        "default": false
      },
      {
        "name": "axis",
        "type": "int64",
        "default": -1
      },
      {
        "name": "ensure_minimum_range",
        "type": "float32",
        "default": 0.009999999776482582
      }
    ],
    "inputs": [
      {
        "name": "input",
        "type": 1
      },
      {
        "name": "min_range",
        "description": "The minimum value of the quantization range. This value may be adjusted by the\nop depending on other parameters. The adjusted value is written to `output_min`.\nIf the `axis` attribute is specified, this must be a 1-D tensor whose size\nmatches the `axis` dimension of the input and output tensors.",
        "type": 1
      },
      {
        "name": "max_range",
        "description": "The maximum value of the quantization range. This value may be adjusted by the\nop depending on other parameters. The adjusted value is written to `output_max`.\nIf the `axis` attribute is specified, this must be a 1-D tensor whose size\nmatches the `axis` dimension of the input and output tensors.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The quantized data produced from the float input.",
        "typeAttr": "T"
      },
      {
        "name": "output_min",
        "description": "The final quantization range minimum, used to clip input values before scaling\nand rounding them to quantized values.\nIf the `axis` attribute is specified, this will be a 1-D tensor whose size\nmatches the `axis` dimension of the input and output tensors.",
        "type": 1
      },
      {
        "name": "output_max",
        "description": "The final quantization range maximum, used to clip input values before scaling\nand rounding them to quantized values.\nIf the `axis` attribute is specified, this will be a 1-D tensor whose size\nmatches the `axis` dimension of the input and output tensors.",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedAdd",
    "summary": "Returns x + y element-wise, working on quantized buffers.",
    "attributes": [
      {
        "name": "T1",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "T2",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Toutput",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 13
        }
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T1"
      },
      {
        "name": "y",
        "typeAttr": "T2"
      },
      {
        "name": "min_x",
        "description": "The float value that the lowest quantized `x` value represents.",
        "type": 1
      },
      {
        "name": "max_x",
        "description": "The float value that the highest quantized `x` value represents.",
        "type": 1
      },
      {
        "name": "min_y",
        "description": "The float value that the lowest quantized `y` value represents.",
        "type": 1
      },
      {
        "name": "max_y",
        "description": "The float value that the highest quantized `y` value represents.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "Toutput"
      },
      {
        "name": "min_z",
        "description": "The float value that the lowest quantized output value represents.",
        "type": 1
      },
      {
        "name": "max_z",
        "description": "The float value that the highest quantized output value represents.\n\n*NOTE*: `QuantizedAdd` supports limited forms of broadcasting. More about\nbroadcasting [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedAvgPool",
    "summary": "Produces the average pool of the input tensor for quantized types.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "ksize",
        "type": "int64[]",
        "description": "The size of the window for each dimension of the input tensor.\nThe length must be 4 to match the number of dimensions of the input."
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "The stride of the sliding window for each dimension of the input\ntensor.  The length must be 4 to match the number of dimensions of the input."
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "4-D with shape `[batch, height, width, channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "min_input",
        "description": "The float value that the lowest quantized input value represents.",
        "type": 1
      },
      {
        "name": "max_input",
        "description": "The float value that the highest quantized input value represents.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      },
      {
        "name": "min_output",
        "description": "The float value that the lowest quantized output value represents.",
        "type": 1
      },
      {
        "name": "max_output",
        "description": "The float value that the highest quantized output value represents.",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedBatchNormWithGlobalNormalization",
    "summary": "Quantized Batch normalization.",
    "description": "This op is deprecated and will be removed in the future. Prefer\n`tf.nn.batch_normalization`.",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "variance_epsilon",
        "type": "float32",
        "description": "A small float number to avoid dividing by 0."
      },
      {
        "name": "scale_after_normalization",
        "type": "boolean",
        "description": "A bool indicating whether the resulted tensor\nneeds to be multiplied with gamma."
      }
    ],
    "inputs": [
      {
        "name": "t",
        "description": "A 4D input Tensor.",
        "typeAttr": "Tinput"
      },
      {
        "name": "t_min",
        "description": "The value represented by the lowest quantized input.",
        "type": 1
      },
      {
        "name": "t_max",
        "description": "The value represented by the highest quantized input.",
        "type": 1
      },
      {
        "name": "m",
        "description": "A 1D mean Tensor with size matching the last dimension of t.\nThis is the first output from tf.nn.moments,\nor a saved moving average thereof.",
        "typeAttr": "Tinput"
      },
      {
        "name": "m_min",
        "description": "The value represented by the lowest quantized mean.",
        "type": 1
      },
      {
        "name": "m_max",
        "description": "The value represented by the highest quantized mean.",
        "type": 1
      },
      {
        "name": "v",
        "description": "A 1D variance Tensor with size matching the last dimension of t.\nThis is the second output from tf.nn.moments,\nor a saved moving average thereof.",
        "typeAttr": "Tinput"
      },
      {
        "name": "v_min",
        "description": "The value represented by the lowest quantized variance.",
        "type": 1
      },
      {
        "name": "v_max",
        "description": "The value represented by the highest quantized variance.",
        "type": 1
      },
      {
        "name": "beta",
        "description": "A 1D beta Tensor with size matching the last dimension of t.\nAn offset to be added to the normalized tensor.",
        "typeAttr": "Tinput"
      },
      {
        "name": "beta_min",
        "description": "The value represented by the lowest quantized offset.",
        "type": 1
      },
      {
        "name": "beta_max",
        "description": "The value represented by the highest quantized offset.",
        "type": 1
      },
      {
        "name": "gamma",
        "description": "A 1D gamma Tensor with size matching the last dimension of t.\nIf \"scale_after_normalization\" is true, this tensor will be multiplied\nwith the normalized tensor.",
        "typeAttr": "Tinput"
      },
      {
        "name": "gamma_min",
        "description": "The value represented by the lowest quantized gamma.",
        "type": 1
      },
      {
        "name": "gamma_max",
        "description": "The value represented by the highest quantized gamma.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "result",
        "typeAttr": "out_type"
      },
      {
        "name": "result_min",
        "type": 1
      },
      {
        "name": "result_max",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedBiasAdd",
    "summary": "Adds Tensor 'bias' to Tensor 'input' for Quantized types.",
    "description": "Broadcasts the values of bias on dimensions 0..N-2 of 'input'.",
    "attributes": [
      {
        "name": "T1",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "T2",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T1"
      },
      {
        "name": "bias",
        "description": "A 1D bias Tensor with size matching the last dimension of 'input'.",
        "typeAttr": "T2"
      },
      {
        "name": "min_input",
        "description": "The float value that the lowest quantized input value represents.",
        "type": 1
      },
      {
        "name": "max_input",
        "description": "The float value that the highest quantized input value represents.",
        "type": 1
      },
      {
        "name": "min_bias",
        "description": "The float value that the lowest quantized bias value represents.",
        "type": 1
      },
      {
        "name": "max_bias",
        "description": "The float value that the highest quantized bias value represents.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "out_type"
      },
      {
        "name": "min_out",
        "description": "The float value that the lowest quantized output value represents.",
        "type": 1
      },
      {
        "name": "max_out",
        "description": "The float value that the highest quantized output value represents.",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedConcat",
    "summary": "Concatenates quantized tensors along one dimension.",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 2
      },
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "concat_dim",
        "description": "0-D.  The dimension along which to concatenate.  Must be in the\nrange [0, rank(values)).",
        "type": 3
      },
      {
        "name": "values",
        "description": "The `N` Tensors to concatenate. Their ranks and types must match,\nand their sizes must match in all dimensions except `concat_dim`.",
        "numberAttr": "N",
        "typeAttr": "T"
      },
      {
        "name": "input_mins",
        "description": "The minimum scalar values for each of the input tensors.",
        "numberAttr": "N",
        "type": 1
      },
      {
        "name": "input_maxes",
        "description": "The maximum scalar values for each of the input tensors.",
        "numberAttr": "N",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A `Tensor` with the concatenation of values stacked along the\n`concat_dim` dimension.  This tensor's shape matches that of `values` except\nin `concat_dim` where it has the sum of the sizes.",
        "typeAttr": "T"
      },
      {
        "name": "output_min",
        "description": "The float value that the minimum quantized output value represents.",
        "type": 1
      },
      {
        "name": "output_max",
        "description": "The float value that the maximum quantized output value represents.",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedConv2D",
    "summary": "Computes a 2D convolution given quantized 4D input and filter tensors.",
    "description": "The inputs are quantized tensors where the lowest value represents the real\nnumber of the associated minimum, and the highest represents the maximum.\nThis means that you can only interpret the quantized output in the same way, by\ntaking the returned minimum and maximum values into account.",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tfilter",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 13
        }
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "The stride of the sliding window for each dimension of the input\ntensor."
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "description": "1-D tensor of length 4.  The dilation factor for each dimension of\n`input`. If set to k > 1, there will be k-1 skipped cells between each\nfilter element on that dimension. The dimension order is determined by the\nvalue of `data_format`, see above for details. Dilations in the batch and\ndepth dimensions must be 1.",
        "default": [
          1,
          1,
          1,
          1
        ]
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "Tinput"
      },
      {
        "name": "filter",
        "description": "filter's input_depth dimension must match input's depth dimensions.",
        "typeAttr": "Tfilter"
      },
      {
        "name": "min_input",
        "description": "The float value that the lowest quantized input value represents.",
        "type": 1
      },
      {
        "name": "max_input",
        "description": "The float value that the highest quantized input value represents.",
        "type": 1
      },
      {
        "name": "min_filter",
        "description": "The float value that the lowest quantized filter value represents.",
        "type": 1
      },
      {
        "name": "max_filter",
        "description": "The float value that the highest quantized filter value represents.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "out_type"
      },
      {
        "name": "min_output",
        "description": "The float value that the lowest quantized output value represents.",
        "type": 1
      },
      {
        "name": "max_output",
        "description": "The float value that the highest quantized output value represents.",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedConv2DAndRelu",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tfilter",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 13
        }
      },
      {
        "name": "strides",
        "type": "int64[]"
      },
      {
        "name": "padding",
        "type": "string",
        "description": "Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "default": [
          1,
          1,
          1,
          1
        ]
      },
      {
        "name": "padding_list",
        "type": "int64[]",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "Tinput"
      },
      {
        "name": "filter",
        "typeAttr": "Tfilter"
      },
      {
        "name": "min_input",
        "type": 1
      },
      {
        "name": "max_input",
        "type": 1
      },
      {
        "name": "min_filter",
        "type": 1
      },
      {
        "name": "max_filter",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "out_type"
      },
      {
        "name": "min_output",
        "type": 1
      },
      {
        "name": "max_output",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedConv2DAndReluAndRequantize",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tfilter",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 12
        }
      },
      {
        "name": "strides",
        "type": "int64[]"
      },
      {
        "name": "padding",
        "type": "string",
        "description": "Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "default": [
          1,
          1,
          1,
          1
        ]
      },
      {
        "name": "padding_list",
        "type": "int64[]",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "Tinput"
      },
      {
        "name": "filter",
        "typeAttr": "Tfilter"
      },
      {
        "name": "min_input",
        "type": 1
      },
      {
        "name": "max_input",
        "type": 1
      },
      {
        "name": "min_filter",
        "type": 1
      },
      {
        "name": "max_filter",
        "type": 1
      },
      {
        "name": "min_freezed_output",
        "type": 1
      },
      {
        "name": "max_freezed_output",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "out_type"
      },
      {
        "name": "min_output",
        "type": 1
      },
      {
        "name": "max_output",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedConv2DAndRequantize",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tfilter",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 11
        }
      },
      {
        "name": "strides",
        "type": "int64[]"
      },
      {
        "name": "padding",
        "type": "string",
        "description": "Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "default": [
          1,
          1,
          1,
          1
        ]
      },
      {
        "name": "padding_list",
        "type": "int64[]",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "Tinput"
      },
      {
        "name": "filter",
        "typeAttr": "Tfilter"
      },
      {
        "name": "min_input",
        "type": 1
      },
      {
        "name": "max_input",
        "type": 1
      },
      {
        "name": "min_filter",
        "type": 1
      },
      {
        "name": "max_filter",
        "type": 1
      },
      {
        "name": "min_freezed_output",
        "type": 1
      },
      {
        "name": "max_freezed_output",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "out_type"
      },
      {
        "name": "min_output",
        "type": 1
      },
      {
        "name": "max_output",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedConv2DPerChannel",
    "summary": "Computes QuantizedConv2D per channel.",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type",
        "description": "The quantized type of input tensor that needs to be converted. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tfilter",
        "type": "type",
        "description": "The quantized type of filter tensor that needs to be converted. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "The quantized type of output tensor that needs to be converted. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 13
        }
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "list of stride values."
      },
      {
        "name": "padding",
        "type": "string",
        "description": "Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "description": "list of dilation values.",
        "default": [
          1,
          1,
          1,
          1
        ]
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The original input tensor.",
        "typeAttr": "Tinput"
      },
      {
        "name": "filter",
        "description": "The original filter tensor.",
        "typeAttr": "Tfilter"
      },
      {
        "name": "min_input",
        "description": "The minimum value of the input tensor",
        "type": 1
      },
      {
        "name": "max_input",
        "description": "The maximum value of the input tensor.",
        "type": 1
      },
      {
        "name": "min_filter",
        "description": "The minimum value of the filter tensor.",
        "type": 1
      },
      {
        "name": "max_filter",
        "description": "The maximum value of the filter tensor.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The output tensor.",
        "typeAttr": "out_type"
      },
      {
        "name": "min_output",
        "description": "The minimum value of the final output tensor.",
        "type": 1
      },
      {
        "name": "max_output",
        "description": "The maximum value of the final output tensor.",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedConv2DWithBias",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tfilter",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 13
        }
      },
      {
        "name": "strides",
        "type": "int64[]"
      },
      {
        "name": "padding",
        "type": "string",
        "description": "Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "default": [
          1,
          1,
          1,
          1
        ]
      },
      {
        "name": "padding_list",
        "type": "int64[]",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "Tinput"
      },
      {
        "name": "filter",
        "typeAttr": "Tfilter"
      },
      {
        "name": "bias",
        "type": 1
      },
      {
        "name": "min_input",
        "type": 1
      },
      {
        "name": "max_input",
        "type": 1
      },
      {
        "name": "min_filter",
        "type": 1
      },
      {
        "name": "max_filter",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "out_type"
      },
      {
        "name": "min_output",
        "type": 1
      },
      {
        "name": "max_output",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedConv2DWithBiasAndRelu",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tfilter",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 13
        }
      },
      {
        "name": "strides",
        "type": "int64[]"
      },
      {
        "name": "padding",
        "type": "string",
        "description": "Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "default": [
          1,
          1,
          1,
          1
        ]
      },
      {
        "name": "padding_list",
        "type": "int64[]",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "Tinput"
      },
      {
        "name": "filter",
        "typeAttr": "Tfilter"
      },
      {
        "name": "bias",
        "type": 1
      },
      {
        "name": "min_input",
        "type": 1
      },
      {
        "name": "max_input",
        "type": 1
      },
      {
        "name": "min_filter",
        "type": 1
      },
      {
        "name": "max_filter",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "out_type"
      },
      {
        "name": "min_output",
        "type": 1
      },
      {
        "name": "max_output",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedConv2DWithBiasAndReluAndRequantize",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tfilter",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tbias",
        "type": "type",
        "description": "Must be one of the following: `float32`, `qint32`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 12
        }
      },
      {
        "name": "strides",
        "type": "int64[]"
      },
      {
        "name": "padding",
        "type": "string",
        "description": "Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "default": [
          1,
          1,
          1,
          1
        ]
      },
      {
        "name": "padding_list",
        "type": "int64[]",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "Tinput"
      },
      {
        "name": "filter",
        "typeAttr": "Tfilter"
      },
      {
        "name": "bias",
        "typeAttr": "Tbias"
      },
      {
        "name": "min_input",
        "type": 1
      },
      {
        "name": "max_input",
        "type": 1
      },
      {
        "name": "min_filter",
        "type": 1
      },
      {
        "name": "max_filter",
        "type": 1
      },
      {
        "name": "min_freezed_output",
        "type": 1
      },
      {
        "name": "max_freezed_output",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "out_type"
      },
      {
        "name": "min_output",
        "type": 1
      },
      {
        "name": "max_output",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedConv2DWithBiasAndRequantize",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tfilter",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tbias",
        "type": "type",
        "description": "Must be one of the following: `float32`, `qint32`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 11
        }
      },
      {
        "name": "strides",
        "type": "int64[]"
      },
      {
        "name": "padding",
        "type": "string",
        "description": "Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "default": [
          1,
          1,
          1,
          1
        ]
      },
      {
        "name": "padding_list",
        "type": "int64[]",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "Tinput"
      },
      {
        "name": "filter",
        "typeAttr": "Tfilter"
      },
      {
        "name": "bias",
        "typeAttr": "Tbias"
      },
      {
        "name": "min_input",
        "type": 1
      },
      {
        "name": "max_input",
        "type": 1
      },
      {
        "name": "min_filter",
        "type": 1
      },
      {
        "name": "max_filter",
        "type": 1
      },
      {
        "name": "min_freezed_output",
        "type": 1
      },
      {
        "name": "max_freezed_output",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "out_type"
      },
      {
        "name": "min_output",
        "type": 1
      },
      {
        "name": "max_output",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedConv2DWithBiasSignedSumAndReluAndRequantize",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tfilter",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tbias",
        "type": "type",
        "description": "Must be one of the following: `float32`, `qint32`."
      },
      {
        "name": "Tsummand",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 12
        }
      },
      {
        "name": "strides",
        "type": "int64[]"
      },
      {
        "name": "padding",
        "type": "string",
        "description": "Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "default": [
          1,
          1,
          1,
          1
        ]
      },
      {
        "name": "padding_list",
        "type": "int64[]",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "Tinput"
      },
      {
        "name": "filter",
        "typeAttr": "Tfilter"
      },
      {
        "name": "bias",
        "typeAttr": "Tbias"
      },
      {
        "name": "min_input",
        "type": 1
      },
      {
        "name": "max_input",
        "type": 1
      },
      {
        "name": "min_filter",
        "type": 1
      },
      {
        "name": "max_filter",
        "type": 1
      },
      {
        "name": "min_freezed_output",
        "type": 1
      },
      {
        "name": "max_freezed_output",
        "type": 1
      },
      {
        "name": "summand",
        "typeAttr": "Tsummand"
      },
      {
        "name": "min_summand",
        "type": 1
      },
      {
        "name": "max_summand",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "out_type"
      },
      {
        "name": "min_output",
        "type": 1
      },
      {
        "name": "max_output",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedConv2DWithBiasSumAndRelu",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tfilter",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 13
        }
      },
      {
        "name": "strides",
        "type": "int64[]"
      },
      {
        "name": "padding",
        "type": "string",
        "description": "Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "default": [
          1,
          1,
          1,
          1
        ]
      },
      {
        "name": "padding_list",
        "type": "int64[]",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "Tinput"
      },
      {
        "name": "filter",
        "typeAttr": "Tfilter"
      },
      {
        "name": "bias",
        "type": 1
      },
      {
        "name": "min_input",
        "type": 1
      },
      {
        "name": "max_input",
        "type": 1
      },
      {
        "name": "min_filter",
        "type": 1
      },
      {
        "name": "max_filter",
        "type": 1
      },
      {
        "name": "summand",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "out_type"
      },
      {
        "name": "min_output",
        "type": 1
      },
      {
        "name": "max_output",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedConv2DWithBiasSumAndReluAndRequantize",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tfilter",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tbias",
        "type": "type",
        "description": "Must be one of the following: `float32`, `qint32`."
      },
      {
        "name": "Tsummand",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 12
        }
      },
      {
        "name": "strides",
        "type": "int64[]"
      },
      {
        "name": "padding",
        "type": "string",
        "description": "Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "default": [
          1,
          1,
          1,
          1
        ]
      },
      {
        "name": "padding_list",
        "type": "int64[]",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "Tinput"
      },
      {
        "name": "filter",
        "typeAttr": "Tfilter"
      },
      {
        "name": "bias",
        "typeAttr": "Tbias"
      },
      {
        "name": "min_input",
        "type": 1
      },
      {
        "name": "max_input",
        "type": 1
      },
      {
        "name": "min_filter",
        "type": 1
      },
      {
        "name": "max_filter",
        "type": 1
      },
      {
        "name": "min_freezed_output",
        "type": 1
      },
      {
        "name": "max_freezed_output",
        "type": 1
      },
      {
        "name": "summand",
        "typeAttr": "Tsummand"
      },
      {
        "name": "min_summand",
        "type": 1
      },
      {
        "name": "max_summand",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "out_type"
      },
      {
        "name": "min_output",
        "type": 1
      },
      {
        "name": "max_output",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedDepthwiseConv2D",
    "summary": "Computes quantized depthwise Conv2D.",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type",
        "description": "The type of the input. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tfilter",
        "type": "type",
        "description": "The type of the filter. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 13
        }
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "List of stride values."
      },
      {
        "name": "padding",
        "type": "string",
        "description": "Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "description": "List of dilation values.",
        "default": [
          1,
          1,
          1,
          1
        ]
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The original input tensor.",
        "typeAttr": "Tinput"
      },
      {
        "name": "filter",
        "description": "The original filter tensor.",
        "typeAttr": "Tfilter"
      },
      {
        "name": "min_input",
        "description": "The float value that the minimum quantized input value represents.",
        "type": 1
      },
      {
        "name": "max_input",
        "description": "The float value that the maximum quantized input value represents.",
        "type": 1
      },
      {
        "name": "min_filter",
        "description": "The float value that the minimum quantized filter value represents.",
        "type": 1
      },
      {
        "name": "max_filter",
        "description": "The float value that the maximum quantized filter value represents.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The output tensor.",
        "typeAttr": "out_type"
      },
      {
        "name": "min_output",
        "description": "The float value that the minimum quantized output value represents.",
        "type": 1
      },
      {
        "name": "max_output",
        "description": "The float value that the maximum quantized output value represents.",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedDepthwiseConv2DWithBias",
    "summary": "Computes quantized depthwise Conv2D with Bias.",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type",
        "description": "The type of the input. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tfilter",
        "type": "type",
        "description": "The type of the filter. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 13
        }
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "List of stride values."
      },
      {
        "name": "padding",
        "type": "string",
        "description": "Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "description": "List of dilation values.",
        "default": [
          1,
          1,
          1,
          1
        ]
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The original input tensor.",
        "typeAttr": "Tinput"
      },
      {
        "name": "filter",
        "description": "The original filter tensor.",
        "typeAttr": "Tfilter"
      },
      {
        "name": "bias",
        "description": "The original bias tensor.",
        "type": 1
      },
      {
        "name": "min_input",
        "description": "The float value that the minimum quantized input value represents.",
        "type": 1
      },
      {
        "name": "max_input",
        "description": "The float value that the maximum quantized input value represents.",
        "type": 1
      },
      {
        "name": "min_filter",
        "description": "The float value that the minimum quantized filter value represents.",
        "type": 1
      },
      {
        "name": "max_filter",
        "description": "The float value that the maximum quantized filter value represents.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The output tensor.",
        "typeAttr": "out_type"
      },
      {
        "name": "min_output",
        "description": "The float value that the minimum quantized output value represents.",
        "type": 1
      },
      {
        "name": "max_output",
        "description": "The float value that the maximum quantized output value represents.",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedDepthwiseConv2DWithBiasAndRelu",
    "summary": "Computes quantized depthwise Conv2D with Bias and Relu.",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type",
        "description": "The type of the input. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tfilter",
        "type": "type",
        "description": "The type of the filter. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 13
        }
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "List of stride values."
      },
      {
        "name": "padding",
        "type": "string",
        "description": "Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "description": "List of dilation values.",
        "default": [
          1,
          1,
          1,
          1
        ]
      },
      {
        "name": "padding_list",
        "type": "int64[]",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The original input tensor.",
        "typeAttr": "Tinput"
      },
      {
        "name": "filter",
        "description": "The original filter tensor.",
        "typeAttr": "Tfilter"
      },
      {
        "name": "bias",
        "description": "The original bias tensor.",
        "type": 1
      },
      {
        "name": "min_input",
        "description": "The float value that the minimum quantized input value represents.",
        "type": 1
      },
      {
        "name": "max_input",
        "description": "The float value that the maximum quantized input value represents.",
        "type": 1
      },
      {
        "name": "min_filter",
        "description": "The float value that the minimum quantized filter value represents.",
        "type": 1
      },
      {
        "name": "max_filter",
        "description": "The float value that the maximum quantized filter value represents.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The output tensor.",
        "typeAttr": "out_type"
      },
      {
        "name": "min_output",
        "description": "The float value that the minimum quantized output value represents.",
        "type": 1
      },
      {
        "name": "max_output",
        "description": "The float value that the maximum quantized output value represents.",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize",
    "summary": "Computes quantized depthwise Conv2D with Bias, Relu and Requantize.",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type",
        "description": "The type of the input. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tfilter",
        "type": "type",
        "description": "The type of the filter. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tbias",
        "type": "type",
        "description": "The type of the bias. Must be one of the following: `float32`, `qint32`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 12
        }
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "List of stride values."
      },
      {
        "name": "padding",
        "type": "string",
        "description": "Must be one of the following: `SAME`, `VALID`."
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "description": "List of dilation values.",
        "default": [
          1,
          1,
          1,
          1
        ]
      },
      {
        "name": "padding_list",
        "type": "int64[]",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The original input tensor.",
        "typeAttr": "Tinput"
      },
      {
        "name": "filter",
        "description": "The original filter tensor.",
        "typeAttr": "Tfilter"
      },
      {
        "name": "bias",
        "description": "The original bias tensor.",
        "typeAttr": "Tbias"
      },
      {
        "name": "min_input",
        "description": "The float value that the minimum quantized input value represents.",
        "type": 1
      },
      {
        "name": "max_input",
        "description": "The float value that the maximum quantized input value represents.",
        "type": 1
      },
      {
        "name": "min_filter",
        "description": "The float value that the minimum quantized filter value represents.",
        "type": 1
      },
      {
        "name": "max_filter",
        "description": "The float value that the maximum quantized filter value represents.",
        "type": 1
      },
      {
        "name": "min_freezed_output",
        "description": "The minimum float value of the output tensor.",
        "type": 1
      },
      {
        "name": "max_freezed_output",
        "description": "The maximum float value of the output tensor.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The output tensor.",
        "typeAttr": "out_type"
      },
      {
        "name": "min_output",
        "description": "The float value that the minimum quantized output value represents.",
        "type": 1
      },
      {
        "name": "max_output",
        "description": "The float value that the maximum quantized output value represents.",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedInstanceNorm",
    "summary": "Quantized Instance normalization.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "output_range_given",
        "type": "boolean",
        "description": "If True, `given_y_min` and `given_y_min`\nand `given_y_max` are used as the output range. Otherwise,\nthe implementation computes the output range.",
        "default": false
      },
      {
        "name": "given_y_min",
        "type": "float32",
        "description": "Output in `y_min` if `output_range_given` is True.",
        "default": 0.0
      },
      {
        "name": "given_y_max",
        "type": "float32",
        "description": "Output in `y_max` if `output_range_given` is True.",
        "default": 0.0
      },
      {
        "name": "variance_epsilon",
        "type": "float32",
        "description": "A small float number to avoid dividing by 0.",
        "default": 9.999999747378752e-06
      },
      {
        "name": "min_separation",
        "type": "float32",
        "description": "Minimum value of `y_max - y_min`",
        "default": 0.0010000000474974513
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "A 4D input Tensor.",
        "typeAttr": "T"
      },
      {
        "name": "x_min",
        "description": "The value represented by the lowest quantized input.",
        "type": 1
      },
      {
        "name": "x_max",
        "description": "The value represented by the highest quantized input.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "y",
        "description": "A 4D Tensor.",
        "typeAttr": "T"
      },
      {
        "name": "y_min",
        "description": "The value represented by the lowest quantized output.",
        "type": 1
      },
      {
        "name": "y_max",
        "description": "The value represented by the highest quantized output.",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedMatMul",
    "summary": "Perform a quantized matrix multiplication of  `a` by the matrix `b`.",
    "description": "The inputs must be two-dimensional matrices and the inner dimension of\n`a` (after being transposed if `transpose_a` is non-zero) must match the\nouter dimension of `b` (after being transposed if `transposed_b` is\nnon-zero).",
    "attributes": [
      {
        "name": "T1",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "T2",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Toutput",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 13
        }
      },
      {
        "name": "transpose_a",
        "type": "boolean",
        "description": "If true, `a` is transposed before multiplication.",
        "default": false
      },
      {
        "name": "transpose_b",
        "type": "boolean",
        "description": "If true, `b` is transposed before multiplication.",
        "default": false
      },
      {
        "name": "Tactivation",
        "type": "type",
        "description": "The type of output produced by activation function\nfollowing this operation. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 12
        }
      }
    ],
    "inputs": [
      {
        "name": "a",
        "description": "Must be a two-dimensional tensor.",
        "typeAttr": "T1"
      },
      {
        "name": "b",
        "description": "Must be a two-dimensional tensor.",
        "typeAttr": "T2"
      },
      {
        "name": "min_a",
        "description": "The float value that the lowest quantized `a` value represents.",
        "type": 1
      },
      {
        "name": "max_a",
        "description": "The float value that the highest quantized `a` value represents.",
        "type": 1
      },
      {
        "name": "min_b",
        "description": "The float value that the lowest quantized `b` value represents.",
        "type": 1
      },
      {
        "name": "max_b",
        "description": "The float value that the highest quantized `b` value represents.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "out",
        "typeAttr": "Toutput"
      },
      {
        "name": "min_out",
        "description": "The float value that the lowest quantized output value represents.",
        "type": 1
      },
      {
        "name": "max_out",
        "description": "The float value that the highest quantized output value represents.",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedMatMulWithBias",
    "summary": "Performs a quantized matrix multiplication of `a` by the matrix `b` with bias\nadd.",
    "description": "The inputs must be two-dimensional matrices and 1D bias vector. And the inner\ndimension of `a` (after being transposed if `transpose_a` is non-zero) must\nmatch the outer dimension of `b` (after being transposed if `transposed_b` is\nnon-zero). Then do broadcast add operation with bias values on the matrix\nmultiplication result. The bias size must match inner dimension of `b`.",
    "attributes": [
      {
        "name": "T1",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "T2",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tbias",
        "type": "type",
        "description": "Must be one of the following: `float32`, `qint32`."
      },
      {
        "name": "Toutput",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 13
        }
      },
      {
        "name": "transpose_a",
        "type": "boolean",
        "description": "If true, `a` is transposed before multiplication.",
        "default": false
      },
      {
        "name": "transpose_b",
        "type": "boolean",
        "description": "If true, `b` is transposed before multiplication.",
        "default": false
      },
      {
        "name": "input_quant_mode",
        "type": "string",
        "description": "Input data quantization mode. Either MIN_FIRST(default) or SCALED. Must be one of the following: `MIN_FIRST`, `SCALED`.",
        "default": "MIN_FIRST"
      }
    ],
    "inputs": [
      {
        "name": "a",
        "description": "A matrix to be multiplied. Must be a two-dimensional tensor of type `quint8`.",
        "typeAttr": "T1"
      },
      {
        "name": "b",
        "description": "A matrix to be multiplied and must be a two-dimensional tensor of type `qint8`.",
        "typeAttr": "T2"
      },
      {
        "name": "bias",
        "description": "A 1D bias tensor with size matching inner dimension of `b` (after being\ntransposed if `transposed_b` is non-zero).",
        "typeAttr": "Tbias"
      },
      {
        "name": "min_a",
        "description": "The float value that the lowest quantized `a` value represents.",
        "type": 1
      },
      {
        "name": "max_a",
        "description": "The float value that the highest quantized `a` value represents.",
        "type": 1
      },
      {
        "name": "min_b",
        "description": "The float value that the lowest quantized `b` value represents.",
        "type": 1
      },
      {
        "name": "max_b",
        "description": "The float value that the highest quantized `b` value represents.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "out",
        "typeAttr": "Toutput"
      },
      {
        "name": "min_out",
        "description": "The float value that the lowest quantized output value represents.",
        "type": 1
      },
      {
        "name": "max_out",
        "description": "The float value that the highest quantized output value represents.",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedMatMulWithBiasAndDequantize",
    "attributes": [
      {
        "name": "T1",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "T2",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tbias",
        "type": "type",
        "description": "Must be one of the following: `float32`, `qint32`."
      },
      {
        "name": "Toutput",
        "type": "type",
        "description": "Must be one of the following: `float32`."
      },
      {
        "name": "transpose_a",
        "type": "boolean",
        "default": false
      },
      {
        "name": "transpose_b",
        "type": "boolean",
        "default": false
      },
      {
        "name": "input_quant_mode",
        "type": "string",
        "description": "Must be one of the following: `MIN_FIRST`, `SCALED`.",
        "default": "MIN_FIRST"
      }
    ],
    "inputs": [
      {
        "name": "a",
        "typeAttr": "T1"
      },
      {
        "name": "b",
        "typeAttr": "T2"
      },
      {
        "name": "bias",
        "typeAttr": "Tbias"
      },
      {
        "name": "min_a",
        "type": 1
      },
      {
        "name": "max_a",
        "type": 1
      },
      {
        "name": "min_b",
        "type": 1
      },
      {
        "name": "max_b",
        "type": 1
      },
      {
        "name": "min_freezed_output",
        "type": 1
      },
      {
        "name": "max_freezed_output",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "out",
        "typeAttr": "Toutput"
      }
    ]
  },
  {
    "name": "QuantizedMatMulWithBiasAndRelu",
    "summary": "Perform a quantized matrix multiplication of  `a` by the matrix `b` with bias\nadd and relu fusion.",
    "description": "The inputs must be two-dimensional matrices and 1D bias vector. And the inner\ndimension of `a` (after being transposed if `transpose_a` is non-zero) must\nmatch the outer dimension of `b` (after being transposed if `transposed_b` is\nnon-zero). Then do broadcast add operation with bias values on the matrix\nmultiplication result. The bias size must match inner dimension of `b`. Then do\nrelu activation to get non-negative result.",
    "attributes": [
      {
        "name": "T1",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "T2",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Toutput",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 13
        }
      },
      {
        "name": "transpose_a",
        "type": "boolean",
        "description": "If true, `a` is transposed before multiplication.",
        "default": false
      },
      {
        "name": "transpose_b",
        "type": "boolean",
        "description": "If true, `b` is transposed before multiplication.",
        "default": false
      },
      {
        "name": "input_quant_mode",
        "type": "string",
        "description": "Input data quantization mode. Either MIN_FIRST(default) or SCALED. Must be one of the following: `MIN_FIRST`, `SCALED`.",
        "default": "MIN_FIRST"
      }
    ],
    "inputs": [
      {
        "name": "a",
        "description": "A matrix to be multiplied. Must be a two-dimensional tensor of type `quint8`.",
        "typeAttr": "T1"
      },
      {
        "name": "b",
        "description": "A matrix to be multiplied and must be a two-dimensional tensor of type `qint8`.",
        "typeAttr": "T2"
      },
      {
        "name": "bias",
        "description": "A 1D bias tensor with size matching with inner dimension of `b` (after being\ntransposed if `transposed_b` is non-zero).",
        "type": 1
      },
      {
        "name": "min_a",
        "description": "The float value that the lowest quantized `a` value represents.",
        "type": 1
      },
      {
        "name": "max_a",
        "description": "The float value that the highest quantized `a` value represents.",
        "type": 1
      },
      {
        "name": "min_b",
        "description": "The float value that the lowest quantized `b` value represents.",
        "type": 1
      },
      {
        "name": "max_b",
        "description": "The float value that the highest quantized `b` value represents.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "out",
        "typeAttr": "Toutput"
      },
      {
        "name": "min_out",
        "description": "The float value that the lowest quantized output value represents.",
        "type": 1
      },
      {
        "name": "max_out",
        "description": "The float value that the highest quantized output value represents.",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedMatMulWithBiasAndReluAndRequantize",
    "summary": "Perform a quantized matrix multiplication of  `a` by the matrix `b` with bias\nadd and relu and requantize fusion.",
    "description": "The inputs must be two-dimensional matrices and 1D bias vector. And the inner\ndimension of `a` (after being transposed if `transpose_a` is non-zero) must\nmatch the outer dimension of `b` (after being transposed if `transposed_b` is\nnon-zero). Then do broadcast add operation with bias values on the matrix\nmultiplication result. The bias size must match inner dimension of `b`.  Then do\nrelu activation to get non-negative result. Then do requantize operation to get\nfinal uint8 result.",
    "attributes": [
      {
        "name": "T1",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "T2",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tbias",
        "type": "type",
        "description": "Must be one of the following: `float32`, `qint32`."
      },
      {
        "name": "Toutput",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 12
        }
      },
      {
        "name": "transpose_a",
        "type": "boolean",
        "description": "If true, `a` is transposed before multiplication.",
        "default": false
      },
      {
        "name": "transpose_b",
        "type": "boolean",
        "description": "If true, `b` is transposed before multiplication.",
        "default": false
      },
      {
        "name": "input_quant_mode",
        "type": "string",
        "description": "Input data quantization mode. Either MIN_FIRST(default) or SCALED. Must be one of the following: `MIN_FIRST`, `SCALED`.",
        "default": "MIN_FIRST"
      }
    ],
    "inputs": [
      {
        "name": "a",
        "description": "A matrix to be multiplied. Must be a two-dimensional tensor of type `quint8`.",
        "typeAttr": "T1"
      },
      {
        "name": "b",
        "description": "A matrix to be multiplied and must be a two-dimensional tensor of type `qint8`.",
        "typeAttr": "T2"
      },
      {
        "name": "bias",
        "description": "A 1D bias tensor with size matching with inner dimension of `b` (after being\ntransposed if `transposed_b` is non-zero).",
        "typeAttr": "Tbias"
      },
      {
        "name": "min_a",
        "description": "The float value that the lowest quantized `a` value represents.",
        "type": 1
      },
      {
        "name": "max_a",
        "description": "The float value that the highest quantized `a` value represents.",
        "type": 1
      },
      {
        "name": "min_b",
        "description": "The float value that the lowest quantized `b` value represents.",
        "type": 1
      },
      {
        "name": "max_b",
        "description": "The float value that the highest quantized `b` value represents.",
        "type": 1
      },
      {
        "name": "min_freezed_output",
        "description": "The float value that the highest quantized output value after requantize.",
        "type": 1
      },
      {
        "name": "max_freezed_output",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "out",
        "typeAttr": "Toutput"
      },
      {
        "name": "min_out",
        "description": "The float value that the lowest quantized output value represents.",
        "type": 1
      },
      {
        "name": "max_out",
        "description": "The float value that the highest quantized output value represents.",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedMatMulWithBiasAndRequantize",
    "attributes": [
      {
        "name": "T1",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "T2",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Tbias",
        "type": "type",
        "description": "Must be one of the following: `float32`, `qint32`."
      },
      {
        "name": "Toutput",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 12
        }
      },
      {
        "name": "transpose_a",
        "type": "boolean",
        "default": false
      },
      {
        "name": "transpose_b",
        "type": "boolean",
        "default": false
      },
      {
        "name": "input_quant_mode",
        "type": "string",
        "description": "Must be one of the following: `MIN_FIRST`, `SCALED`.",
        "default": "MIN_FIRST"
      }
    ],
    "inputs": [
      {
        "name": "a",
        "typeAttr": "T1"
      },
      {
        "name": "b",
        "typeAttr": "T2"
      },
      {
        "name": "bias",
        "typeAttr": "Tbias"
      },
      {
        "name": "min_a",
        "type": 1
      },
      {
        "name": "max_a",
        "type": 1
      },
      {
        "name": "min_b",
        "type": 1
      },
      {
        "name": "max_b",
        "type": 1
      },
      {
        "name": "min_freezed_output",
        "type": 1
      },
      {
        "name": "max_freezed_output",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "out",
        "typeAttr": "Toutput"
      },
      {
        "name": "min_out",
        "type": 1
      },
      {
        "name": "max_out",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedMaxPool",
    "summary": "Produces the max pool of the input tensor for quantized types.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "ksize",
        "type": "int64[]",
        "description": "The size of the window for each dimension of the input tensor.\nThe length must be 4 to match the number of dimensions of the input."
      },
      {
        "name": "strides",
        "type": "int64[]",
        "description": "The stride of the sliding window for each dimension of the input\ntensor. The length must be 4 to match the number of dimensions of the input."
      },
      {
        "name": "padding",
        "type": "string",
        "description": "The type of padding algorithm to use. Must be one of the following: `SAME`, `VALID`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The 4D (batch x rows x cols x depth) Tensor to MaxReduce over.",
        "typeAttr": "T"
      },
      {
        "name": "min_input",
        "description": "The float value that the lowest quantized input value represents.",
        "type": 1
      },
      {
        "name": "max_input",
        "description": "The float value that the highest quantized input value represents.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      },
      {
        "name": "min_output",
        "description": "The float value that the lowest quantized output value represents.",
        "type": 1
      },
      {
        "name": "max_output",
        "description": "The float value that the highest quantized output value represents.",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedMul",
    "summary": "Returns x * y element-wise, working on quantized buffers.",
    "attributes": [
      {
        "name": "T1",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "T2",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "Toutput",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 13
        }
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T1"
      },
      {
        "name": "y",
        "typeAttr": "T2"
      },
      {
        "name": "min_x",
        "description": "The float value that the lowest quantized `x` value represents.",
        "type": 1
      },
      {
        "name": "max_x",
        "description": "The float value that the highest quantized `x` value represents.",
        "type": 1
      },
      {
        "name": "min_y",
        "description": "The float value that the lowest quantized `y` value represents.",
        "type": 1
      },
      {
        "name": "max_y",
        "description": "The float value that the highest quantized `y` value represents.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "Toutput"
      },
      {
        "name": "min_z",
        "description": "The float value that the lowest quantized output value represents.",
        "type": 1
      },
      {
        "name": "max_z",
        "description": "The float value that the highest quantized output value represents.\n\n*NOTE*: `QuantizedMul` supports limited forms of broadcasting. More about\nbroadcasting [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedRelu",
    "summary": "Computes Quantized Rectified Linear: `max(features, 0)`",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 12
        }
      }
    ],
    "inputs": [
      {
        "name": "features",
        "typeAttr": "Tinput"
      },
      {
        "name": "min_features",
        "description": "The float value that the lowest quantized value represents.",
        "type": 1
      },
      {
        "name": "max_features",
        "description": "The float value that the highest quantized value represents.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "activations",
        "description": "Has the same output shape as \"features\".",
        "typeAttr": "out_type"
      },
      {
        "name": "min_activations",
        "description": "The float value that the lowest quantized value represents.",
        "type": 1
      },
      {
        "name": "max_activations",
        "description": "The float value that the highest quantized value represents.",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedRelu6",
    "summary": "Computes Quantized Rectified Linear 6: `min(max(features, 0), 6)`",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 12
        }
      }
    ],
    "inputs": [
      {
        "name": "features",
        "typeAttr": "Tinput"
      },
      {
        "name": "min_features",
        "description": "The float value that the lowest quantized value represents.",
        "type": 1
      },
      {
        "name": "max_features",
        "description": "The float value that the highest quantized value represents.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "activations",
        "description": "Has the same output shape as \"features\".",
        "typeAttr": "out_type"
      },
      {
        "name": "min_activations",
        "description": "The float value that the lowest quantized value represents.",
        "type": 1
      },
      {
        "name": "max_activations",
        "description": "The float value that the highest quantized value represents.",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedReluX",
    "summary": "Computes Quantized Rectified Linear X: `min(max(features, 0), max_value)`",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 12
        }
      }
    ],
    "inputs": [
      {
        "name": "features",
        "typeAttr": "Tinput"
      },
      {
        "name": "max_value",
        "type": 1
      },
      {
        "name": "min_features",
        "description": "The float value that the lowest quantized value represents.",
        "type": 1
      },
      {
        "name": "max_features",
        "description": "The float value that the highest quantized value represents.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "activations",
        "description": "Has the same output shape as \"features\".",
        "typeAttr": "out_type"
      },
      {
        "name": "min_activations",
        "description": "The float value that the lowest quantized value represents.",
        "type": 1
      },
      {
        "name": "max_activations",
        "description": "The float value that the highest quantized value represents.",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedReshape",
    "summary": "Reshapes a quantized tensor as per the Reshape op.",
    "description": "```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tshape",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "tensor",
        "typeAttr": "T"
      },
      {
        "name": "shape",
        "description": "Defines the shape of the output tensor.",
        "typeAttr": "Tshape"
      },
      {
        "name": "input_min",
        "description": "The minimum value of the input.",
        "type": 1
      },
      {
        "name": "input_max",
        "description": "The maximum value of the input.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      },
      {
        "name": "output_min",
        "description": "This value is copied from input_min.",
        "type": 1
      },
      {
        "name": "output_max",
        "description": "This value is copied from input_max.",
        "type": 1
      }
    ]
  },
  {
    "name": "QuantizedResizeBilinear",
    "summary": "Resize quantized `images` to `size` using quantized bilinear interpolation.",
    "description": "Input images and output images must be quantized types.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `quint8`, `qint32`, `float32`."
      },
      {
        "name": "align_corners",
        "type": "boolean",
        "description": "If true, the centers of the 4 corner pixels of the input and output tensors are\naligned, preserving the values at the corner pixels. Defaults to false.",
        "default": false
      },
      {
        "name": "half_pixel_centers",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "images",
        "description": "4-D with shape `[batch, height, width, channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "size",
        "description": "= A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images.",
        "type": 3
      },
      {
        "name": "min",
        "type": 1
      },
      {
        "name": "max",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "resized_images",
        "description": "4-D with shape\n`[batch, new_height, new_width, channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "out_min",
        "type": 1
      },
      {
        "name": "out_max",
        "type": 1
      }
    ]
  },
  {
    "name": "QueueClose",
    "summary": "Closes the given queue.",
    "description": "This operation signals that no more elements will be enqueued in the\ngiven queue. Subsequent Enqueue(Many) operations will fail.\nSubsequent Dequeue(Many) operations will continue to succeed if\nsufficient elements remain in the queue. Subsequent Dequeue(Many)\noperations that would block will fail immediately.",
    "attributes": [
      {
        "name": "cancel_pending_enqueues",
        "type": "boolean",
        "description": "If true, all pending enqueue requests that are\nblocked on the given queue will be canceled.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a queue.",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "QueueCloseV2",
    "summary": "Closes the given queue.",
    "description": "This operation signals that no more elements will be enqueued in the\ngiven queue. Subsequent Enqueue(Many) operations will fail.\nSubsequent Dequeue(Many) operations will continue to succeed if\nsufficient elements remain in the queue. Subsequent Dequeue(Many)\noperations that would block will fail immediately.",
    "attributes": [
      {
        "name": "cancel_pending_enqueues",
        "type": "boolean",
        "description": "If true, all pending enqueue requests that are\nblocked on the given queue will be canceled.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a queue.",
        "type": 20
      }
    ]
  },
  {
    "name": "QueueDequeue",
    "summary": "Dequeues a tuple of one or more tensors from the given queue.",
    "description": "This operation has k outputs, where k is the number of components\nin the tuples stored in the given queue, and output i is the ith\ncomponent of the dequeued tuple.\n\nN.B. If the queue is empty, this operation will block until an element\nhas been dequeued (or 'timeout_ms' elapses, if specified).",
    "attributes": [
      {
        "name": "component_types",
        "type": "type[]",
        "description": "The type of each component in a tuple.",
        "minimum": 1
      },
      {
        "name": "timeout_ms",
        "type": "int64",
        "description": "If the queue is empty, this operation will block for up to\ntimeout_ms milliseconds.\nNote: This option is not supported yet.",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a queue.",
        "type": 7,
        "isRef": true
      }
    ],
    "outputs": [
      {
        "name": "components",
        "description": "One or more tensors that were dequeued as a tuple.",
        "typeListAttr": "component_types"
      }
    ]
  },
  {
    "name": "QueueDequeueMany",
    "summary": "Dequeues `n` tuples of one or more tensors from the given queue.",
    "description": "If the queue is closed and there are fewer than `n` elements, then an\nOutOfRange error is returned.\n\nThis operation concatenates queue-element component tensors along the\n0th dimension to make a single component tensor.  All of the components\nin the dequeued tuple will have size `n` in the 0th dimension.\n\nThis operation has `k` outputs, where `k` is the number of components in\nthe tuples stored in the given queue, and output `i` is the ith\ncomponent of the dequeued tuple.\n\nN.B. If the queue is empty, this operation will block until `n` elements\nhave been dequeued (or 'timeout_ms' elapses, if specified).",
    "attributes": [
      {
        "name": "component_types",
        "type": "type[]",
        "description": "The type of each component in a tuple.",
        "minimum": 1
      },
      {
        "name": "timeout_ms",
        "type": "int64",
        "description": "If the queue has fewer than n elements, this operation\nwill block for up to timeout_ms milliseconds.\nNote: This option is not supported yet.",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a queue.",
        "type": 7,
        "isRef": true
      },
      {
        "name": "n",
        "description": "The number of tuples to dequeue.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "components",
        "description": "One or more tensors that were dequeued as a tuple.",
        "typeListAttr": "component_types"
      }
    ]
  },
  {
    "name": "QueueDequeueManyV2",
    "summary": "Dequeues `n` tuples of one or more tensors from the given queue.",
    "description": "If the queue is closed and there are fewer than `n` elements, then an\nOutOfRange error is returned.\n\nThis operation concatenates queue-element component tensors along the\n0th dimension to make a single component tensor.  All of the components\nin the dequeued tuple will have size `n` in the 0th dimension.\n\nThis operation has `k` outputs, where `k` is the number of components in\nthe tuples stored in the given queue, and output `i` is the ith\ncomponent of the dequeued tuple.\n\nN.B. If the queue is empty, this operation will block until `n` elements\nhave been dequeued (or 'timeout_ms' elapses, if specified).",
    "attributes": [
      {
        "name": "component_types",
        "type": "type[]",
        "description": "The type of each component in a tuple.",
        "minimum": 1
      },
      {
        "name": "timeout_ms",
        "type": "int64",
        "description": "If the queue has fewer than n elements, this operation\nwill block for up to timeout_ms milliseconds.\nNote: This option is not supported yet.",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a queue.",
        "type": 20
      },
      {
        "name": "n",
        "description": "The number of tuples to dequeue.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "components",
        "description": "One or more tensors that were dequeued as a tuple.",
        "typeListAttr": "component_types"
      }
    ]
  },
  {
    "name": "QueueDequeueUpTo",
    "summary": "Dequeues `n` tuples of one or more tensors from the given queue.",
    "description": "This operation is not supported by all queues.  If a queue does not support\nDequeueUpTo, then an Unimplemented error is returned.\n\nIf the queue is closed and there are more than 0 but less than `n`\nelements remaining, then instead of returning an OutOfRange error like\nQueueDequeueMany, less than `n` elements are returned immediately.  If\nthe queue is closed and there are 0 elements left in the queue, then\nan OutOfRange error is returned just like in QueueDequeueMany.\nOtherwise the behavior is identical to QueueDequeueMany:\n\nThis operation concatenates queue-element component tensors along the\n0th dimension to make a single component tensor.  All of the components\nin the dequeued tuple will have size `n` in the 0th dimension.\n\nThis operation has k outputs, where `k` is the number of components in\nthe tuples stored in the given queue, and output `i` is the ith\ncomponent of the dequeued tuple.",
    "attributes": [
      {
        "name": "component_types",
        "type": "type[]",
        "description": "The type of each component in a tuple.",
        "minimum": 1
      },
      {
        "name": "timeout_ms",
        "type": "int64",
        "description": "If the queue has fewer than n elements, this operation\nwill block for up to timeout_ms milliseconds.\nNote: This option is not supported yet.",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a queue.",
        "type": 7,
        "isRef": true
      },
      {
        "name": "n",
        "description": "The number of tuples to dequeue.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "components",
        "description": "One or more tensors that were dequeued as a tuple.",
        "typeListAttr": "component_types"
      }
    ]
  },
  {
    "name": "QueueDequeueUpToV2",
    "summary": "Dequeues `n` tuples of one or more tensors from the given queue.",
    "description": "This operation is not supported by all queues.  If a queue does not support\nDequeueUpTo, then an Unimplemented error is returned.\n\nIf the queue is closed and there are more than 0 but less than `n`\nelements remaining, then instead of returning an OutOfRange error like\nQueueDequeueMany, less than `n` elements are returned immediately.  If\nthe queue is closed and there are 0 elements left in the queue, then\nan OutOfRange error is returned just like in QueueDequeueMany.\nOtherwise the behavior is identical to QueueDequeueMany:\n\nThis operation concatenates queue-element component tensors along the\n0th dimension to make a single component tensor.  All of the components\nin the dequeued tuple will have size n in the 0th dimension.\n\nThis operation has `k` outputs, where `k` is the number of components in\nthe tuples stored in the given queue, and output `i` is the ith\ncomponent of the dequeued tuple.",
    "attributes": [
      {
        "name": "component_types",
        "type": "type[]",
        "description": "The type of each component in a tuple.",
        "minimum": 1
      },
      {
        "name": "timeout_ms",
        "type": "int64",
        "description": "If the queue has fewer than n elements, this operation\nwill block for up to timeout_ms milliseconds.\nNote: This option is not supported yet.",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a queue.",
        "type": 20
      },
      {
        "name": "n",
        "description": "The number of tuples to dequeue.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "components",
        "description": "One or more tensors that were dequeued as a tuple.",
        "typeListAttr": "component_types"
      }
    ]
  },
  {
    "name": "QueueDequeueV2",
    "summary": "Dequeues a tuple of one or more tensors from the given queue.",
    "description": "This operation has k outputs, where k is the number of components\nin the tuples stored in the given queue, and output i is the ith\ncomponent of the dequeued tuple.\n\nN.B. If the queue is empty, this operation will block until an element\nhas been dequeued (or 'timeout_ms' elapses, if specified).",
    "attributes": [
      {
        "name": "component_types",
        "type": "type[]",
        "description": "The type of each component in a tuple.",
        "minimum": 1
      },
      {
        "name": "timeout_ms",
        "type": "int64",
        "description": "If the queue is empty, this operation will block for up to\ntimeout_ms milliseconds.\nNote: This option is not supported yet.",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a queue.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "components",
        "description": "One or more tensors that were dequeued as a tuple.",
        "typeListAttr": "component_types"
      }
    ]
  },
  {
    "name": "QueueEnqueue",
    "summary": "Enqueues a tuple of one or more tensors in the given queue.",
    "description": "The components input has k elements, which correspond to the components of\ntuples stored in the given queue.\n\nN.B. If the queue is full, this operation will block until the given\nelement has been enqueued (or 'timeout_ms' elapses, if specified).",
    "attributes": [
      {
        "name": "Tcomponents",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "timeout_ms",
        "type": "int64",
        "description": "If the queue is full, this operation will block for up to\ntimeout_ms milliseconds.\nNote: This option is not supported yet.",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a queue.",
        "type": 7,
        "isRef": true
      },
      {
        "name": "components",
        "description": "One or more tensors from which the enqueued tensors should be taken.",
        "typeListAttr": "Tcomponents"
      }
    ]
  },
  {
    "name": "QueueEnqueueMany",
    "summary": "Enqueues zero or more tuples of one or more tensors in the given queue.",
    "description": "This operation slices each component tensor along the 0th dimension to\nmake multiple queue elements. All of the tuple components must have the\nsame size in the 0th dimension.\n\nThe components input has k elements, which correspond to the components of\ntuples stored in the given queue.\n\nN.B. If the queue is full, this operation will block until the given\nelements have been enqueued (or 'timeout_ms' elapses, if specified).",
    "attributes": [
      {
        "name": "Tcomponents",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "timeout_ms",
        "type": "int64",
        "description": "If the queue is too full, this operation will block for up\nto timeout_ms milliseconds.\nNote: This option is not supported yet.",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a queue.",
        "type": 7,
        "isRef": true
      },
      {
        "name": "components",
        "description": "One or more tensors from which the enqueued tensors should\nbe taken.",
        "typeListAttr": "Tcomponents"
      }
    ]
  },
  {
    "name": "QueueEnqueueManyV2",
    "summary": "Enqueues zero or more tuples of one or more tensors in the given queue.",
    "description": "This operation slices each component tensor along the 0th dimension to\nmake multiple queue elements. All of the tuple components must have the\nsame size in the 0th dimension.\n\nThe components input has k elements, which correspond to the components of\ntuples stored in the given queue.\n\nN.B. If the queue is full, this operation will block until the given\nelements have been enqueued (or 'timeout_ms' elapses, if specified).",
    "attributes": [
      {
        "name": "Tcomponents",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "timeout_ms",
        "type": "int64",
        "description": "If the queue is too full, this operation will block for up\nto timeout_ms milliseconds.\nNote: This option is not supported yet.",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a queue.",
        "type": 20
      },
      {
        "name": "components",
        "description": "One or more tensors from which the enqueued tensors should\nbe taken.",
        "typeListAttr": "Tcomponents"
      }
    ]
  },
  {
    "name": "QueueEnqueueV2",
    "summary": "Enqueues a tuple of one or more tensors in the given queue.",
    "description": "The components input has k elements, which correspond to the components of\ntuples stored in the given queue.\n\nN.B. If the queue is full, this operation will block until the given\nelement has been enqueued (or 'timeout_ms' elapses, if specified).",
    "attributes": [
      {
        "name": "Tcomponents",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "timeout_ms",
        "type": "int64",
        "description": "If the queue is full, this operation will block for up to\ntimeout_ms milliseconds.\nNote: This option is not supported yet.",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a queue.",
        "type": 20
      },
      {
        "name": "components",
        "description": "One or more tensors from which the enqueued tensors should be taken.",
        "typeListAttr": "Tcomponents"
      }
    ]
  },
  {
    "name": "QueueIsClosed",
    "summary": "Returns true if queue is closed.",
    "description": "This operation returns true if the queue is closed and false if the queue\nis open.",
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a queue.",
        "type": 7,
        "isRef": true
      }
    ],
    "outputs": [
      {
        "name": "is_closed",
        "type": 10
      }
    ]
  },
  {
    "name": "QueueIsClosedV2",
    "summary": "Returns true if queue is closed.",
    "description": "This operation returns true if the queue is closed and false if the queue\nis open.",
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a queue.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "is_closed",
        "type": 10
      }
    ]
  },
  {
    "name": "QueueSize",
    "summary": "Computes the number of elements in the given queue.",
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a queue.",
        "type": 7,
        "isRef": true
      }
    ],
    "outputs": [
      {
        "name": "size",
        "description": "The number of elements in the given queue.",
        "type": 3
      }
    ]
  },
  {
    "name": "QueueSizeV2",
    "summary": "Computes the number of elements in the given queue.",
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a queue.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "size",
        "description": "The number of elements in the given queue.",
        "type": 3
      }
    ]
  },
  {
    "name": "RFFT",
    "summary": "Real-valued fast Fourier transform.",
    "description": "Computes the 1-dimensional discrete Fourier transform of a real-valued signal\nover the inner-most dimension of `input`.\n\nSince the DFT of a real signal is Hermitian-symmetric, `RFFT` only returns the\n`fft_length / 2 + 1` unique components of the FFT: the zero-frequency term,\nfollowed by the `fft_length / 2` positive-frequency terms.\n\nAlong the axis `RFFT` is computed on, if `fft_length` is smaller than the\ncorresponding dimension of `input`, the dimension is cropped. If it is larger,\nthe dimension is padded with zeros.",
    "attributes": [
      {
        "name": "Treal",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "Tcomplex",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A float32 tensor.",
        "typeAttr": "Treal"
      },
      {
        "name": "fft_length",
        "description": "An int32 tensor of shape [1]. The FFT length.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A complex64 tensor of the same rank as `input`. The inner-most\n  dimension of `input` is replaced with the `fft_length / 2 + 1` unique\n  frequency components of its 1D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.rfft\n@end_compatibility",
        "typeAttr": "Tcomplex"
      }
    ]
  },
  {
    "name": "RFFT2D",
    "summary": "2D real-valued fast Fourier transform.",
    "description": "Computes the 2-dimensional discrete Fourier transform of a real-valued signal\nover the inner-most 2 dimensions of `input`.\n\nSince the DFT of a real signal is Hermitian-symmetric, `RFFT2D` only returns the\n`fft_length / 2 + 1` unique components of the FFT for the inner-most dimension\nof `output`: the zero-frequency term, followed by the `fft_length / 2`\npositive-frequency terms.\n\nAlong each axis `RFFT2D` is computed on, if `fft_length` is smaller than the\ncorresponding dimension of `input`, the dimension is cropped. If it is larger,\nthe dimension is padded with zeros.",
    "attributes": [
      {
        "name": "Treal",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "Tcomplex",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A float32 tensor.",
        "typeAttr": "Treal"
      },
      {
        "name": "fft_length",
        "description": "An int32 tensor of shape [2]. The FFT length for each dimension.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A complex64 tensor of the same rank as `input`. The inner-most 2\n  dimensions of `input` are replaced with their 2D Fourier transform. The\n  inner-most dimension contains `fft_length / 2 + 1` unique frequency\n  components.\n\n@compatibility(numpy)\nEquivalent to np.fft.rfft2\n@end_compatibility",
        "typeAttr": "Tcomplex"
      }
    ]
  },
  {
    "name": "RFFT3D",
    "summary": "3D real-valued fast Fourier transform.",
    "description": "Computes the 3-dimensional discrete Fourier transform of a real-valued signal\nover the inner-most 3 dimensions of `input`.\n\nSince the DFT of a real signal is Hermitian-symmetric, `RFFT3D` only returns the\n`fft_length / 2 + 1` unique components of the FFT for the inner-most dimension\nof `output`: the zero-frequency term, followed by the `fft_length / 2`\npositive-frequency terms.\n\nAlong each axis `RFFT3D` is computed on, if `fft_length` is smaller than the\ncorresponding dimension of `input`, the dimension is cropped. If it is larger,\nthe dimension is padded with zeros.",
    "attributes": [
      {
        "name": "Treal",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "Tcomplex",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A float32 tensor.",
        "typeAttr": "Treal"
      },
      {
        "name": "fft_length",
        "description": "An int32 tensor of shape [3]. The FFT length for each dimension.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A complex64 tensor of the same rank as `input`. The inner-most 3\n  dimensions of `input` are replaced with the their 3D Fourier transform. The\n  inner-most dimension contains `fft_length / 2 + 1` unique frequency\n  components.\n\n@compatibility(numpy)\nEquivalent to np.fft.rfftn with 3 dimensions.\n@end_compatibility",
        "typeAttr": "Tcomplex"
      }
    ]
  },
  {
    "name": "RFFTND",
    "summary": "ND fast real Fourier transform.",
    "description": "Computes the n-dimensional real discrete Fourier transform over designated\ndimensions of `input`. The designated dimensions of `input` are assumed to be\nthe result of `RFFTND`. The length of the last axis transformed will be\nfft_length[-1]//2+1.\n\nIf fft_length[i]<shape(input)[i], the input is cropped. If\nfft_length[i]>shape(input)[i], the input is padded with zeros. If fft_length\nis not given, the default shape(input) is used.\n\nAxes mean the dimensions to perform the transform on. Default is to perform on\nall axes.",
    "attributes": [
      {
        "name": "Treal",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "Tcomplex",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A complex tensor.",
        "typeAttr": "Treal"
      },
      {
        "name": "fft_length",
        "description": "An int32 tensor. The FFT length for each dimension.",
        "type": 3
      },
      {
        "name": "axes",
        "description": "An int32 tensor with a same shape as fft_length. Axes to perform the transform.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A complex tensor of the same shape as `input`. The designated\ndimensions of `input` are replaced with their real Fourier transforms.\n\n@compatibility(numpy)\nEquivalent to np.fft.rfftn.\n@end_compatibility",
        "typeAttr": "Tcomplex"
      }
    ]
  },
  {
    "name": "RGBToHSV",
    "summary": "Converts one or more images from RGB to HSV.",
    "description": "Outputs a tensor of the same shape as the `images` tensor, containing the HSV\nvalue of the pixels. The output is only well defined if the value in `images`\nare in `[0,1]`.\n\n`output[..., 0]` contains hue, `output[..., 1]` contains saturation, and\n`output[..., 2]` contains value. All HSV values are in `[0,1]`. A hue of 0\ncorresponds to pure red, hue 1/3 is pure green, and 2/3 is pure blue.\n\nUsage Example:\n\n>>> blue_image = tf.stack([\n...    tf.zeros([5,5]),\n...    tf.zeros([5,5]),\n...    tf.ones([5,5])],\n...    axis=-1)\n>>> blue_hsv_image = tf.image.rgb_to_hsv(blue_image)\n>>> blue_hsv_image[0,0].numpy()\narray([0.6666667, 1. , 1. ], dtype=float32)\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "images",
        "description": "1-D or higher rank. RGB data to convert. Last dimension must be size 3.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "`images` converted to HSV.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RaggedBincount",
    "summary": "Counts the number of occurrences of each value in an integer array.",
    "description": "Outputs a vector with length `size` and the same dtype as `weights`. If\n`weights` are empty, then index `i` stores the number of times the value `i` is\ncounted in `arr`. If `weights` are non-empty, then index `i` stores the sum of\nthe value in `weights` at each index where the corresponding value in `arr` is\n`i`.\n\nValues in `arr` outside of the range [0, size) are ignored.",
    "attributes": [
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`, `float32`, `float64`."
      },
      {
        "name": "binary_output",
        "type": "boolean",
        "description": "bool; Whether the kernel should count the appearance or number of occurrences.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "splits",
        "description": "1D int64 `Tensor`.",
        "type": 9
      },
      {
        "name": "values",
        "description": "2D int `Tensor`.",
        "typeAttr": "Tidx"
      },
      {
        "name": "size",
        "description": "non-negative int scalar `Tensor`.",
        "typeAttr": "Tidx"
      },
      {
        "name": "weights",
        "description": "is an int32, int64, float32, or float64 `Tensor` with the same\nshape as `input`, or a length-0 `Tensor`, in which case it acts as all weights\nequal to 1.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "1D `Tensor` with length equal to `size` or 2D `Tensor` with [batch_size, `size`].\nThe counts or summed weights for each value in the range [0, size).",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RaggedCountSparseOutput",
    "summary": "Performs sparse-output bin counting for a ragged tensor input.",
    "description": "  Counts the number of times each value occurs in the input.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "minlength",
        "type": "int64",
        "description": "Minimum value to count. Can be set to -1 for no minimum.",
        "minimum": -1,
        "default": -1
      },
      {
        "name": "maxlength",
        "type": "int64",
        "description": "Maximum value to count. Can be set to -1 for no maximum.",
        "minimum": -1,
        "default": -1
      },
      {
        "name": "binary_output",
        "type": "boolean",
        "description": "Whether to output the number of occurrences of each value or 1."
      },
      {
        "name": "output_type",
        "type": "type",
        "description": "Dtype of the output values tensor. Must be one of the following: `int32`, `int64`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "splits",
        "description": "Tensor containing the row splits of the ragged tensor to count.",
        "type": 9
      },
      {
        "name": "values",
        "description": "Tensor containing values of the sparse tensor to count.",
        "typeAttr": "T"
      },
      {
        "name": "weights",
        "description": "A Tensor of the same shape as indices containing per-index weight values.\nMay also be the empty tensor if no weights are used.",
        "typeAttr": "output_type"
      }
    ],
    "outputs": [
      {
        "name": "output_indices",
        "description": "Indices tensor for the resulting sparse tensor object.",
        "type": 9
      },
      {
        "name": "output_values",
        "description": "Values tensor for the resulting sparse tensor object.",
        "typeAttr": "output_type"
      },
      {
        "name": "output_dense_shape",
        "description": "Shape tensor for the resulting sparse tensor object.\n  END\n  }\n  attr {\n    name: \"T\"\n    description: <<END\nDtype of the input values tensor.",
        "type": 9
      }
    ]
  },
  {
    "name": "RaggedCross",
    "summary": "Generates a feature cross from a list of tensors, and returns it as a\nRaggedTensor.  See `tf.ragged.cross` for more details.",
    "attributes": [
      {
        "name": "Nsparse",
        "type": "int64",
        "minimum": 0
      },
      {
        "name": "input_order",
        "type": "string",
        "description": "String specifying the tensor type for each input.  The `i`th character in\nthis string specifies the type of the `i`th input, and is one of: 'R' (ragged),\n'D' (dense), or 'S' (sparse).  This attr is used to ensure that the crossed\nvalues are combined in the order of the inputs from the call to tf.ragged.cross."
      },
      {
        "name": "hashed_output",
        "type": "boolean"
      },
      {
        "name": "num_buckets",
        "type": "int64",
        "minimum": 0
      },
      {
        "name": "hash_key",
        "type": "int64"
      },
      {
        "name": "ragged_values_types",
        "type": "type[]",
        "minimum": 0,
        "description": "Must be one of the following: `int64`, `string`."
      },
      {
        "name": "ragged_splits_types",
        "type": "type[]",
        "minimum": 0,
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "sparse_values_types",
        "type": "type[]",
        "minimum": 0,
        "description": "Must be one of the following: `int64`, `string`."
      },
      {
        "name": "dense_types",
        "type": "type[]",
        "minimum": 0,
        "description": "Must be one of the following: `int64`, `string`."
      },
      {
        "name": "out_values_type",
        "type": "type",
        "description": "Must be one of the following: `int64`, `string`."
      },
      {
        "name": "out_row_splits_type",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "ragged_values",
        "description": "The values tensor for each RaggedTensor input.",
        "typeListAttr": "ragged_values_types"
      },
      {
        "name": "ragged_row_splits",
        "description": "The row_splits tensor for each RaggedTensor input.",
        "typeListAttr": "ragged_splits_types"
      },
      {
        "name": "sparse_indices",
        "description": "The indices tensor for each SparseTensor input.",
        "numberAttr": "Nsparse",
        "type": 9
      },
      {
        "name": "sparse_values",
        "description": "The values tensor for each SparseTensor input.",
        "typeListAttr": "sparse_values_types"
      },
      {
        "name": "sparse_shape",
        "description": "The dense_shape tensor for each SparseTensor input.",
        "numberAttr": "Nsparse",
        "type": 9
      },
      {
        "name": "dense_inputs",
        "description": "The tf.Tensor inputs.",
        "typeListAttr": "dense_types"
      }
    ],
    "outputs": [
      {
        "name": "output_values",
        "description": "The `values` for the returned `RaggedTensor`.",
        "typeAttr": "out_values_type"
      },
      {
        "name": "output_row_splits",
        "description": "The `row_splits` for the returned `RaggedTensor`.",
        "typeAttr": "out_row_splits_type"
      }
    ]
  },
  {
    "name": "RaggedFillEmptyRows",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "value_rowids",
        "type": 9
      },
      {
        "name": "values",
        "typeAttr": "T"
      },
      {
        "name": "nrows",
        "type": 9
      },
      {
        "name": "default_value",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output_value_rowids",
        "type": 9
      },
      {
        "name": "output_values",
        "typeAttr": "T"
      },
      {
        "name": "empty_row_indicator",
        "type": 10
      },
      {
        "name": "reverse_index_map",
        "type": 9
      }
    ]
  },
  {
    "name": "RaggedFillEmptyRowsGrad",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "reverse_index_map",
        "type": 9
      },
      {
        "name": "grad_values",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "d_values",
        "typeAttr": "T"
      },
      {
        "name": "d_default_value",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RaggedGather",
    "summary": "Gather ragged slices from `params` axis `0` according to `indices`.",
    "description": "Outputs a `RaggedTensor` output composed from `output_dense_values` and\n`output_nested_splits`, such that:\n\n```python\noutput.shape = indices.shape + params.shape[1:]\noutput.ragged_rank = indices.shape.ndims + params.ragged_rank\noutput[i...j, d0...dn] = params[indices[i...j], d0...dn]\n```\n\nwhere\n\n* `params =\n   ragged.from_nested_row_splits(params_dense_values, params_nested_splits)`\n   provides the values that should be gathered.\n* `indices` ia a dense tensor with dtype `int32` or `int64`, indicating which\n   values should be gathered.\n* `output =\n   ragged.from_nested_row_splits(output_dense_values, output_nested_splits)`\n   is the output tensor.\n\n(Note: This c++ op is used to implement the higher-level python\n`tf.ragged.gather` op, which also supports ragged indices.)\n",
    "attributes": [
      {
        "name": "Tvalues",
        "type": "type"
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "Tsplits",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      },
      {
        "name": "PARAMS_RAGGED_RANK",
        "type": "int64",
        "description": "The ragged rank of the `params` RaggedTensor. `params_nested_splits` should\ncontain this number of `row_splits` tensors. This value should equal\n`params.ragged_rank`.",
        "minimum": 1
      },
      {
        "name": "OUTPUT_RAGGED_RANK",
        "type": "int64",
        "description": "The ragged rank of the output RaggedTensor. `output_nested_splits` will contain\nthis number of `row_splits` tensors. This value should equal\n`indices.shape.ndims + params.ragged_rank - 1`.",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "params_nested_splits",
        "description": "The `nested_row_splits` tensors that define the row-partitioning for the\n`params` RaggedTensor input.",
        "numberAttr": "PARAMS_RAGGED_RANK",
        "typeAttr": "Tsplits"
      },
      {
        "name": "params_dense_values",
        "description": "The `flat_values` for the `params` RaggedTensor. There was a terminology change\nat the python level from dense_values to flat_values, so dense_values is the\ndeprecated name.",
        "typeAttr": "Tvalues"
      },
      {
        "name": "indices",
        "description": "Indices in the outermost dimension of `params` of the values that should be\ngathered.",
        "typeAttr": "Tindices"
      }
    ],
    "outputs": [
      {
        "name": "output_nested_splits",
        "description": "The `nested_row_splits` tensors that define the row-partitioning for the\nreturned RaggedTensor.",
        "numberAttr": "OUTPUT_RAGGED_RANK",
        "typeAttr": "Tsplits"
      },
      {
        "name": "output_dense_values",
        "description": "The `flat_values` for the returned RaggedTensor.",
        "typeAttr": "Tvalues"
      }
    ]
  },
  {
    "name": "RaggedRange",
    "summary": "Returns a `RaggedTensor` containing the specified sequences of numbers.",
    "description": "\nReturns a `RaggedTensor` `result` composed from `rt_dense_values` and\n`rt_nested_splits`, such that\n`result[i] = range(starts[i], limits[i], deltas[i])`.\n\n```python\n(rt_nested_splits, rt_dense_values) = ragged_range(\n      starts=[2, 5, 8], limits=[3, 5, 12], deltas=1)\nresult = tf.ragged.from_row_splits(rt_dense_values, rt_nested_splits)\nprint(result)\n<tf.RaggedTensor [[2], [], [8, 9, 10, 11]] >\n```\n\nThe input tensors `starts`, `limits`, and `deltas` may be scalars or vectors.\nThe vector inputs must all have the same size.  Scalar inputs are broadcast\nto match the size of the vector inputs.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float32`, `float64`, `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "Tsplits",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "starts",
        "description": "The starts of each range.",
        "typeAttr": "T"
      },
      {
        "name": "limits",
        "description": "The limits of each range.",
        "typeAttr": "T"
      },
      {
        "name": "deltas",
        "description": "The deltas of each range.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "rt_nested_splits",
        "description": "The `row_splits` for the returned `RaggedTensor`.",
        "typeAttr": "Tsplits"
      },
      {
        "name": "rt_dense_values",
        "description": "The `flat_values` for the returned `RaggedTensor`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RaggedTensorFromVariant",
    "summary": "Decodes a `variant` Tensor into a `RaggedTensor`.",
    "description": "Decodes the given `variant` Tensor and returns a `RaggedTensor`. The input\ncould be a scalar, meaning it encodes a single `RaggedTensor` with ragged_rank\n`output_ragged_rank`. It could also have an arbitrary rank, in which case each\nelement is decoded into a `RaggedTensor` with ragged_rank `input_ragged_rank`\nand these are then stacked according to the input shape to output a single\n`RaggedTensor` with ragged_rank `output_ragged_rank`. Each `variant` element in\nthe input Tensor is decoded by retrieving from the element a 1-D `variant`\nTensor with `input_ragged_rank + 1` Tensors, corresponding to the splits and\nvalues of the decoded `RaggedTensor`. If `input_ragged_rank` is -1, then it is\ninferred as `output_ragged_rank` - `rank(encoded_ragged)`. See\n`RaggedTensorToVariant` for the corresponding encoding logic.\n",
    "attributes": [
      {
        "name": "input_ragged_rank",
        "type": "int64",
        "description": "The ragged rank of each encoded `RaggedTensor` component in the input. If set to\n-1, this is inferred as `output_ragged_rank` - `rank(encoded_ragged)`",
        "minimum": -1
      },
      {
        "name": "output_ragged_rank",
        "type": "int64",
        "description": "The expected ragged rank of the output `RaggedTensor`. The following must hold:\n`output_ragged_rank = rank(encoded_ragged) + input_ragged_rank`.",
        "minimum": 0
      },
      {
        "name": "Tvalues",
        "type": "type"
      },
      {
        "name": "Tsplits",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "encoded_ragged",
        "description": "A `variant` Tensor containing encoded `RaggedTensor`s.",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "output_nested_splits",
        "description": "A list of one or more Tensors representing the splits of the output\n`RaggedTensor`.",
        "numberAttr": "output_ragged_rank",
        "typeAttr": "Tsplits"
      },
      {
        "name": "output_dense_values",
        "description": "A Tensor representing the values of the output `RaggedTensor`.",
        "typeAttr": "Tvalues"
      }
    ]
  },
  {
    "name": "RaggedTensorToSparse",
    "summary": "Converts a `RaggedTensor` into a `SparseTensor` with the same values.",
    "description": "input=ragged.from_nested_row_splits(rt_dense_values, rt_nested_splits)\noutput=SparseTensor(indices=sparse_indices, values=sparse_values,\n                    dense_shape=sparse_dense_shape)",
    "attributes": [
      {
        "name": "RAGGED_RANK",
        "type": "int64",
        "description": "The ragged rank of the input RaggedTensor.  `rt_nested_splits` should contain\nthis number of ragged-splits tensors.  This value should equal\n`input.ragged_rank`.",
        "minimum": 1
      },
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tsplits",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "rt_nested_splits",
        "description": "The `row_splits` for the `RaggedTensor`.",
        "numberAttr": "RAGGED_RANK",
        "typeAttr": "Tsplits"
      },
      {
        "name": "rt_dense_values",
        "description": "The `flat_values` for the `RaggedTensor`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "sparse_indices",
        "description": "The indices for the `SparseTensor`.",
        "type": 9
      },
      {
        "name": "sparse_values",
        "description": "The values of the `SparseTensor`.",
        "typeAttr": "T"
      },
      {
        "name": "sparse_dense_shape",
        "description": "`sparse_dense_shape` is a tight bounding box of the input `RaggedTensor`.",
        "type": 9
      }
    ]
  },
  {
    "name": "RaggedTensorToTensor",
    "summary": "Create a dense tensor from a ragged tensor, possibly altering its shape.",
    "description": "The `ragged_to_dense` op creates a dense tensor from a list of row partition\ntensors, a value vector, and default values. If the shape is unspecified, the\nminimal shape required to contain all the elements in the ragged tensor (the\nnatural shape) will be used. If some dimensions are left unspecified, then the\nsize of the natural shape is used in that dimension.\n\nThe default_value will be broadcast to the output shape. After that, the values\nfrom the ragged tensor overwrite the default values. Note that the default_value\nmust have less dimensions than the value.\n\nThe row partition tensors are in the order of the dimensions.\nAt present, the types can be:\n* \"ROW_SPLITS\": the row_splits tensor from the ragged tensor.\n* \"VALUE_ROWIDS\": the value_rowids tensor from the ragged tensor.\n* \"FIRST_DIM_SIZE\": if value_rowids is used for the first dimension, then it\n  is preceded by \"FIRST_DIM_SIZE\".",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tindex",
        "type": "type",
        "description": "Must be one of the following: `int64`, `int32`."
      },
      {
        "name": "Tshape",
        "type": "type",
        "description": "Must be one of the following: `int64`, `int32`."
      },
      {
        "name": "num_row_partition_tensors",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "row_partition_types",
        "type": "string[]",
        "description": "The types of the row partition tensors. At present, these can be:\n* \"ROW_SPLITS\": the row_splits tensor from the ragged tensor.\n* \"VALUE_ROWIDS\": the value_rowids tensor from the ragged tensor.\n* \"FIRST_DIM_SIZE\": if value_rowids is used for the first dimension, then it\n  is preceeded by \"FIRST_DIM_SIZE\".\nThe tensors are in the order of the dimensions."
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "The desired shape of the output tensor. If left unspecified (empty),\nthe minimal shape required to contain all the elements in the ragged tensor\n(the natural shape) will be used. If some dimensions are left unspecified, then\nthe size of the natural shape is used in that dimension.\n\nNote that dense dimensions cannot be modified by the shape argument. Trying to\nchange the size of a dense dimension will cause the op to fail.\nExamples:\nnatural shape: [4, 5, 6]\nshape: -1\noutput shape: [4, 5, 6]\n\nnatural shape: [4, 5, 6]\nshape: [3, -1, 2]\noutput shape: [3, 5, 2]\n\nnatural shape: [4, 5, 6]\nshape: [3, 7, 2]\noutput shape: [3, 7, 2]\n",
        "typeAttr": "Tshape"
      },
      {
        "name": "values",
        "description": "A 1D tensor representing the values of the ragged tensor.",
        "typeAttr": "T"
      },
      {
        "name": "default_value",
        "description": "The default_value when the shape is larger than the ragged tensor. The\ndefault_value is broadcast until it is the shape of the output tensor, and\nthen overwritten by values in the ragged tensor. The default value must be\ncompatible with this broadcast operation, and must have fewer dimensions than\nthe value tensor.",
        "typeAttr": "T"
      },
      {
        "name": "row_partition_tensors",
        "numberAttr": "num_row_partition_tensors",
        "typeAttr": "Tindex"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "description": "The resulting dense tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RaggedTensorToVariant",
    "summary": "Encodes a `RaggedTensor` into a `variant` Tensor.",
    "description": "\nEncodes the given `RaggedTensor` and returns a `variant` Tensor. If\n`batched_input` is True, then input `RaggedTensor` is unbatched along the\nzero-th dimension, each component `RaggedTensor` is encoded into a scalar\n`variant` Tensor, and these are stacked to return a 1-D `variant` Tensor.\nIf `batched_input` is False, then the input `RaggedTensor` is encoded as is and\na scalar `variant` Tensor is returned. A `RaggedTensor` is encoded by first\ncreating a 1-D `variant` Tensor with `ragged_rank + 1` elements, containing the\nsplits and values Tensors of the `RaggedTensor`. Then the 1-D `variant` Tensor\nis wrapped in a scalar `variant` Tensor. See `RaggedTensorFromVariant` for the\ncorresponding decoding logic.\n",
    "attributes": [
      {
        "name": "RAGGED_RANK",
        "type": "int64",
        "minimum": 0
      },
      {
        "name": "Tvalues",
        "type": "type"
      },
      {
        "name": "Tsplits",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      },
      {
        "name": "batched_input",
        "type": "boolean",
        "description": "A `bool` denoting whether the input is a batched `RaggedTensor`."
      }
    ],
    "inputs": [
      {
        "name": "rt_nested_splits",
        "description": "A list of one or more Tensors representing the splits of the input\n`RaggedTensor`.",
        "numberAttr": "RAGGED_RANK",
        "typeAttr": "Tsplits"
      },
      {
        "name": "rt_dense_values",
        "description": "A Tensor representing the values of the input `RaggedTensor`.",
        "typeAttr": "Tvalues"
      }
    ],
    "outputs": [
      {
        "name": "encoded_ragged",
        "description": "A `variant` Tensor that containing encoded `RaggedTensor`.",
        "type": 21
      }
    ]
  },
  {
    "name": "RaggedTensorToVariantGradient",
    "summary": "Helper used to compute the gradient for `RaggedTensorToVariant`.",
    "description": "Computes the gradient for the dense_values input to the RaggedTensorToVariant\nop, given the variant-encoded ragged gradients of the outputs, along with\nthe outer row-splits and the shape of the dense-values that were provided as\ninputs to the RaggedTensorToVariant op.",
    "attributes": [
      {
        "name": "Tvalues",
        "type": "type"
      },
      {
        "name": "Tsplits",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "encoded_ragged_grad",
        "description": "A `variant` Tensor containing encoded `RaggedTensor` gradients.",
        "type": 21
      },
      {
        "name": "row_splits",
        "description": "Outermost row-splits that were used as input to the RaggedTensorToVariant op.",
        "typeAttr": "Tsplits"
      },
      {
        "name": "dense_values_shape",
        "description": "Shape of the dense_values that was used as an input to the\nRaggedTensorToVariant op.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "dense_values_grad",
        "description": "Gradient for the dense_values of the RaggedTensorToVariant op.",
        "typeAttr": "Tvalues"
      }
    ]
  },
  {
    "name": "RandomCrop",
    "summary": "Randomly crop `image`.",
    "description": "`size` is a 1-D int64 tensor with 2 elements representing the crop height and\nwidth.  The values must be non negative.\n\nThis Op picks a random location in `image` and crops a `height` by `width`\nrectangle from that location.  The random location is picked so the cropped\narea will fit inside the original image.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `uint8`, `int8`, `int16`, `int32`, `int64`, `float32`, `float64`."
      },
      {
        "name": "seed",
        "type": "int64",
        "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "description": "An second seed to avoid seed collision.",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "image",
        "description": "3-D of shape `[height, width, channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "size",
        "description": "1-D of length 2 containing: `crop_height`, `crop_width`..",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "3-D of shape `[crop_height, crop_width, channels].`",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RandomDataset",
    "summary": "Creates a Dataset that returns pseudorandom numbers.",
    "description": "Creates a Dataset that returns a stream of uniformly distributed\npseudorandom 64-bit signed integers.\n\nIn the TensorFlow Python API, you can instantiate this dataset via the\nclass `tf.data.experimental.RandomDataset`.\n\nInstances of this dataset are also created as a result of the\n`hoist_random_uniform` static optimization. Whether this optimization is\nperformed is determined by the `experimental_optimization.hoist_random_uniform`\noption of `tf.data.Options`.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "seed",
        "description": "A scalar seed for the random number generator. If either seed or\nseed2 is set to be non-zero, the random number generator is seeded\nby the given seed.  Otherwise, a random seed is used.",
        "type": 9
      },
      {
        "name": "seed2",
        "description": "A second scalar seed to avoid seed collision.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "RandomDatasetV2",
    "summary": "Creates a Dataset that returns pseudorandom numbers.",
    "description": "Creates a Dataset that returns a stream of uniformly distributed\npseudorandom 64-bit signed integers. It accepts a boolean attribute that\ndetermines if the random number generators are re-applied at each epoch. The\ndefault value is True which means that the seeds are applied and the same\nsequence of random numbers are generated at each epoch. If set to False, the\nseeds are not re-applied and a different sequence of random numbers are\ngenerated at each epoch.\n\nIn the TensorFlow Python API, you can instantiate this dataset via the\nclass `tf.data.experimental.RandomDatasetV2`.",
    "attributes": [
      {
        "name": "rerandomize_each_iteration",
        "type": "boolean",
        "description": "A boolean attribute to rerandomize the sequence of random numbers generated\nat each epoch.",
        "default": false
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "seed",
        "description": "A scalar seed for the random number generator. If either seed or\nseed2 is set to be non-zero, the random number generator is seeded\nby the given seed.  Otherwise, a random seed is used.",
        "type": 9
      },
      {
        "name": "seed2",
        "description": "A second scalar seed to avoid seed collision.",
        "type": 9
      },
      {
        "name": "seed_generator",
        "description": "A resource for the random number seed generator.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "RandomGamma",
    "summary": "Outputs random values from the Gamma distribution(s) described by alpha.",
    "description": "This op uses the algorithm by Marsaglia et al. to acquire samples via\ntransformation-rejection from pairs of uniform and normal random variables.\nSee http://dl.acm.org/citation.cfm?id=358414",
    "attributes": [
      {
        "name": "seed",
        "type": "int64",
        "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "description": "A second seed to avoid seed collision.",
        "default": 0
      },
      {
        "name": "S",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "1-D integer tensor. Shape of independent samples to draw from each\ndistribution described by the shape parameters given in alpha.",
        "typeAttr": "S"
      },
      {
        "name": "alpha",
        "description": "A tensor in which each scalar is a \"shape\" parameter describing the\nassociated gamma distribution.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A tensor with shape `shape + shape(alpha)`. Each slice\n`[:, ..., :, i0, i1, ...iN]` contains the samples drawn for\n`alpha[i0, i1, ...iN]`. The dtype of the output matches the dtype of alpha.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RandomGammaGrad",
    "summary": "Computes the derivative of a Gamma random sample w.r.t. `alpha`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "alpha",
        "typeAttr": "T"
      },
      {
        "name": "sample",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RandomIndexShuffle",
    "summary": "Outputs the position of `value` in a permutation of [0, ..., max_index].",
    "description": "Output values are a bijection of the `index` for any combination and `seed` and `max_index`.\n\nIf multiple inputs are vectors (matrix in case of seed) then the size of the\nfirst dimension must match.\n\nThe outputs are deterministic.",
    "attributes": [
      {
        "name": "rounds",
        "type": "int64",
        "description": "The number of rounds to use the in block cipher.",
        "default": 4
      },
      {
        "name": "dtype",
        "type": "type",
        "description": "The dtype of the input and output. Must be one of the following: `int32`, `uint32`, `int64`, `uint64`."
      },
      {
        "name": "Tseed",
        "type": "type",
        "description": "The type of `seed`. Must be one of the following: `int32`, `uint32`, `int64`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "index",
        "description": "A scalar tensor or a vector of dtype `dtype`. The index (or indices) to be shuffled. Must be within [0, max_index].",
        "typeAttr": "dtype"
      },
      {
        "name": "seed",
        "description": "A tensor of dtype `Tseed` and shape [3] or [n, 3]. The random seed.",
        "typeAttr": "Tseed"
      },
      {
        "name": "max_index",
        "description": "A scalar tensor or vector of dtype `dtype`. The upper bound(s) of the interval (inclusive).",
        "typeAttr": "dtype"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A scalar tensor of dtype `dtype`, within [0, max_index]. The randomly shuffled index.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "RandomPoisson",
    "summary": "Use RandomPoissonV2 instead.",
    "attributes": [
      {
        "name": "seed",
        "type": "int64",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "default": 0
      },
      {
        "name": "S",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "dtype",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "typeAttr": "S"
      },
      {
        "name": "rate",
        "typeAttr": "dtype"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "RandomPoissonV2",
    "summary": "Outputs random values from the Poisson distribution(s) described by rate.",
    "description": "This op uses two algorithms, depending on rate. If rate >= 10, then\nthe algorithm by Hormann is used to acquire samples via\ntransformation-rejection.\nSee http://www.sciencedirect.com/science/article/pii/0167668793909974.\n\nOtherwise, Knuth's algorithm is used to acquire samples via multiplying uniform\nrandom variables.\nSee Donald E. Knuth (1969). Seminumerical Algorithms. The Art of Computer\nProgramming, Volume 2. Addison Wesley",
    "attributes": [
      {
        "name": "seed",
        "type": "int64",
        "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "description": "A second seed to avoid seed collision.",
        "default": 0
      },
      {
        "name": "S",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "R",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`, `float64`, `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 2
        }
      },
      {
        "name": "dtype",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`, `float64`, `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "1-D integer tensor. Shape of independent samples to draw from each\ndistribution described by the shape parameters given in rate.",
        "typeAttr": "S"
      },
      {
        "name": "rate",
        "description": "A tensor in which each scalar is a \"rate\" parameter describing the\nassociated poisson distribution.",
        "typeAttr": "R"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A tensor with shape `shape + shape(rate)`. Each slice\n`[:, ..., :, i0, i1, ...iN]` contains the samples drawn for\n`rate[i0, i1, ...iN]`.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "RandomShuffle",
    "summary": "Randomly shuffles a tensor along its first dimension.",
    "description": "  The tensor is shuffled along dimension 0, such that each `value[j]` is mapped\n  to one and only one `output[i]`. For example, a mapping that might occur for a\n  3x2 tensor is:\n\n```\n[[1, 2],       [[5, 6],\n [3, 4],  ==>   [1, 2],\n [5, 6]]        [3, 4]]\n```",
    "attributes": [
      {
        "name": "seed",
        "type": "int64",
        "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "description": "A second seed to avoid seed collision.",
        "default": 0
      },
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "value",
        "description": "The tensor to be shuffled.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A tensor of same shape and type as `value`, shuffled along its first\ndimension.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RandomShuffleQueue",
    "summary": "A queue that randomizes the order of elements.",
    "attributes": [
      {
        "name": "component_types",
        "type": "type[]",
        "description": "The type of each component in a value.",
        "minimum": 1
      },
      {
        "name": "shapes",
        "type": "shape[]",
        "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types. If the length of\nthis attr is 0, the shapes of queue elements are not constrained, and\nonly one element may be dequeued at a time.",
        "minimum": 0,
        "default": []
      },
      {
        "name": "capacity",
        "type": "int64",
        "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
        "default": -1
      },
      {
        "name": "min_after_dequeue",
        "type": "int64",
        "description": "Dequeue will block unless there would be this\nmany elements after the dequeue or the queue is closed. This\nensures a minimum level of mixing of elements.",
        "default": 0
      },
      {
        "name": "seed",
        "type": "int64",
        "description": "If either seed or seed2 is set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, a random seed is used.",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "description": "A second seed to avoid seed collision.",
        "default": 0
      },
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "The handle to the queue.",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "RandomShuffleQueueV2",
    "summary": "A queue that randomizes the order of elements.",
    "attributes": [
      {
        "name": "component_types",
        "type": "type[]",
        "description": "The type of each component in a value.",
        "minimum": 1
      },
      {
        "name": "shapes",
        "type": "shape[]",
        "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types. If the length of\nthis attr is 0, the shapes of queue elements are not constrained, and\nonly one element may be dequeued at a time.",
        "minimum": 0,
        "default": []
      },
      {
        "name": "capacity",
        "type": "int64",
        "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
        "default": -1
      },
      {
        "name": "min_after_dequeue",
        "type": "int64",
        "description": "Dequeue will block unless there would be this\nmany elements after the dequeue or the queue is closed. This\nensures a minimum level of mixing of elements.",
        "default": 0
      },
      {
        "name": "seed",
        "type": "int64",
        "description": "If either seed or seed2 is set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, a random seed is used.",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "description": "A second seed to avoid seed collision.",
        "default": 0
      },
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "The handle to the queue.",
        "type": 20
      }
    ]
  },
  {
    "name": "RandomStandardNormal",
    "summary": "Outputs random values from a normal distribution.",
    "description": "The generated values will have mean 0 and standard deviation 1.",
    "attributes": [
      {
        "name": "seed",
        "type": "int64",
        "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "description": "A second seed to avoid seed collision.",
        "default": 0
      },
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A tensor of the specified shape filled with random normal values.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "RandomUniform",
    "summary": "Outputs random values from a uniform distribution.",
    "description": "The generated values follow a uniform distribution in the range `[0, 1)`. The\nlower bound 0 is included in the range, while the upper bound 1 is excluded.",
    "attributes": [
      {
        "name": "seed",
        "type": "int64",
        "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "description": "A second seed to avoid seed collision.",
        "default": 0
      },
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A tensor of the specified shape filled with uniform random values.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "RandomUniformInt",
    "summary": "Outputs random integers from a uniform distribution.",
    "description": "The generated values are uniform integers in the range `[minval, maxval)`.\nThe lower bound `minval` is included in the range, while the upper bound\n`maxval` is excluded.\n\nThe random integers are slightly biased unless `maxval - minval` is an exact\npower of two.  The bias is small for values of `maxval - minval` significantly\nsmaller than the range of the output (either `2^32` or `2^64`).",
    "attributes": [
      {
        "name": "seed",
        "type": "int64",
        "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "description": "A second seed to avoid seed collision.",
        "default": 0
      },
      {
        "name": "Tout",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "T"
      },
      {
        "name": "minval",
        "description": "0-D.  Inclusive lower bound on the generated integers.",
        "typeAttr": "Tout"
      },
      {
        "name": "maxval",
        "description": "0-D.  Exclusive upper bound on the generated integers.",
        "typeAttr": "Tout"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A tensor of the specified shape filled with uniform random integers.",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "Range",
    "summary": "Creates a sequence of numbers.",
    "description": "This operation creates a sequence of numbers that begins at `start` and\nextends by increments of `delta` up to but not including `limit`.\n\nFor example:\n\n```\n# 'start' is 3\n# 'limit' is 18\n# 'delta' is 3\ntf.range(start, limit, delta) ==> [3, 6, 9, 12, 15]\n```",
    "attributes": [
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `int8`, `int16`, `int32`, `int64`, `uint16`, `uint32`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "start",
        "description": "0-D (scalar). First entry in the sequence.",
        "typeAttr": "Tidx"
      },
      {
        "name": "limit",
        "description": "0-D (scalar). Upper limit of sequence, exclusive.",
        "typeAttr": "Tidx"
      },
      {
        "name": "delta",
        "description": "0-D (scalar). Optional. Default is 1. Number that increments `start`.",
        "typeAttr": "Tidx"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "1-D.",
        "typeAttr": "Tidx"
      }
    ]
  },
  {
    "name": "RangeDataset",
    "summary": "Creates a dataset with a range of values. Corresponds to python's xrange.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      },
      {
        "name": "replicate_on_split",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "start",
        "description": "corresponds to start in python's xrange().",
        "type": 9
      },
      {
        "name": "stop",
        "description": "corresponds to stop in python's xrange().",
        "type": 9
      },
      {
        "name": "step",
        "description": "corresponds to step in python's xrange().",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "Rank",
    "summary": "Returns the rank of a tensor.",
    "description": "This operation returns an integer representing the rank of `input`.\n\nFor example:\n\n```\n# 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]\n# shape of tensor 't' is [2, 2, 3]\nrank(t) ==> 3\n```\n\n**Note**: The rank of a tensor is not the same as the rank of a matrix. The rank\nof a tensor is the number of indices required to uniquely select each element\nof the tensor. Rank is also known as \"order\", \"degree\", or \"ndims.\"",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 3
      }
    ]
  },
  {
    "name": "ReadFile",
    "summary": "Reads and outputs the entire contents of the input filename.",
    "inputs": [
      {
        "name": "filename",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "contents",
        "type": 7
      }
    ]
  },
  {
    "name": "ReadVariableOp",
    "summary": "Reads the value of a variable.",
    "description": "The tensor returned by this operation is immutable.\n\nThe value returned by this operation is guaranteed to be influenced by all the\nwrites on which this operation depends directly or indirectly, and to not be\ninfluenced by any of the writes which depend directly or indirectly on this\noperation.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "the dtype of the value."
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "description": "handle to the resource in which to store the variable.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "value",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "ReadVariableXlaSplitND",
    "summary": "Splits resource variable input tensor across all dimensions.",
    "description": "An op which splits the resource variable input tensor based on the given\nnum_splits attribute, pads slices optionally, and returned the slices. Slices\nare returned in row-major order.\n\nThis op may be generated via the TPU bridge.\n\nFor example, with `input` tensor:\n```\n[[0, 1, 2],\n [3, 4, 5],\n [6, 7, 8]]\n```\n`num_splits`:\n```\n[2, 2]\n```\nand `paddings`:\n```\n[1, 1]\n```\nthe expected `outputs` is:\n```\n[[0, 1],\n [3, 4]]\n[[2, 0],\n [5, 0]]\n[[6, 7],\n [0, 0]]\n[[8, 0],\n [0, 0]]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "num_splits",
        "type": "int64[]",
        "description": "Number of ways to split per dimension. Shape dimensions must be evenly\ndivisible."
      },
      {
        "name": "paddings",
        "type": "int64[]",
        "description": "Optional list of right paddings per dimension of input tensor to apply before\nsplitting. This can be used to make a dimension evenly divisible.",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "description": "Resource variable of input tensor to split across all dimensions.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "outputs",
        "description": "Output slices based on input and num_splits defined, in row-major order.",
        "numberAttr": "N",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ReaderNumRecordsProduced",
    "summary": "Returns the number of records this Reader has produced.",
    "description": "This is the same as the number of ReaderRead executions that have\nsucceeded.",
    "inputs": [
      {
        "name": "reader_handle",
        "description": "Handle to a Reader.",
        "type": 7,
        "isRef": true
      }
    ],
    "outputs": [
      {
        "name": "records_produced",
        "type": 9
      }
    ]
  },
  {
    "name": "ReaderNumRecordsProducedV2",
    "summary": "Returns the number of records this Reader has produced.",
    "description": "This is the same as the number of ReaderRead executions that have\nsucceeded.",
    "inputs": [
      {
        "name": "reader_handle",
        "description": "Handle to a Reader.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "records_produced",
        "type": 9
      }
    ]
  },
  {
    "name": "ReaderNumWorkUnitsCompleted",
    "summary": "Returns the number of work units this Reader has finished processing.",
    "inputs": [
      {
        "name": "reader_handle",
        "description": "Handle to a Reader.",
        "type": 7,
        "isRef": true
      }
    ],
    "outputs": [
      {
        "name": "units_completed",
        "type": 9
      }
    ]
  },
  {
    "name": "ReaderNumWorkUnitsCompletedV2",
    "summary": "Returns the number of work units this Reader has finished processing.",
    "inputs": [
      {
        "name": "reader_handle",
        "description": "Handle to a Reader.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "units_completed",
        "type": 9
      }
    ]
  },
  {
    "name": "ReaderRead",
    "summary": "Returns the next record (key, value pair) produced by a Reader.",
    "description": "Will dequeue from the input queue if necessary (e.g. when the\nReader needs to start reading from a new file since it has finished\nwith the previous file).",
    "inputs": [
      {
        "name": "reader_handle",
        "description": "Handle to a Reader.",
        "type": 7,
        "isRef": true
      },
      {
        "name": "queue_handle",
        "description": "Handle to a Queue, with string work items.",
        "type": 7,
        "isRef": true
      }
    ],
    "outputs": [
      {
        "name": "key",
        "description": "A scalar.",
        "type": 7
      },
      {
        "name": "value",
        "description": "A scalar.",
        "type": 7
      }
    ]
  },
  {
    "name": "ReaderReadUpTo",
    "summary": "Returns up to `num_records` (key, value) pairs produced by a Reader.",
    "description": "Will dequeue from the input queue if necessary (e.g. when the\nReader needs to start reading from a new file since it has finished\nwith the previous file).\nIt may return less than `num_records` even before the last batch.",
    "inputs": [
      {
        "name": "reader_handle",
        "description": "Handle to a `Reader`.",
        "type": 7,
        "isRef": true
      },
      {
        "name": "queue_handle",
        "description": "Handle to a `Queue`, with string work items.",
        "type": 7,
        "isRef": true
      },
      {
        "name": "num_records",
        "description": "number of records to read from `Reader`.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "keys",
        "description": "A 1-D tensor.",
        "type": 7
      },
      {
        "name": "values",
        "description": "A 1-D tensor.",
        "type": 7
      }
    ]
  },
  {
    "name": "ReaderReadUpToV2",
    "summary": "Returns up to `num_records` (key, value) pairs produced by a Reader.",
    "description": "Will dequeue from the input queue if necessary (e.g. when the\nReader needs to start reading from a new file since it has finished\nwith the previous file).\nIt may return less than `num_records` even before the last batch.",
    "inputs": [
      {
        "name": "reader_handle",
        "description": "Handle to a `Reader`.",
        "type": 20
      },
      {
        "name": "queue_handle",
        "description": "Handle to a `Queue`, with string work items.",
        "type": 20
      },
      {
        "name": "num_records",
        "description": "number of records to read from `Reader`.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "keys",
        "description": "A 1-D tensor.",
        "type": 7
      },
      {
        "name": "values",
        "description": "A 1-D tensor.",
        "type": 7
      }
    ]
  },
  {
    "name": "ReaderReadV2",
    "summary": "Returns the next record (key, value pair) produced by a Reader.",
    "description": "Will dequeue from the input queue if necessary (e.g. when the\nReader needs to start reading from a new file since it has finished\nwith the previous file).",
    "inputs": [
      {
        "name": "reader_handle",
        "description": "Handle to a Reader.",
        "type": 20
      },
      {
        "name": "queue_handle",
        "description": "Handle to a Queue, with string work items.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "key",
        "description": "A scalar.",
        "type": 7
      },
      {
        "name": "value",
        "description": "A scalar.",
        "type": 7
      }
    ]
  },
  {
    "name": "ReaderReset",
    "summary": "Restore a Reader to its initial clean state.",
    "inputs": [
      {
        "name": "reader_handle",
        "description": "Handle to a Reader.",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "ReaderResetV2",
    "summary": "Restore a Reader to its initial clean state.",
    "inputs": [
      {
        "name": "reader_handle",
        "description": "Handle to a Reader.",
        "type": 20
      }
    ]
  },
  {
    "name": "ReaderRestoreState",
    "summary": "Restore a reader to a previously saved state.",
    "description": "Not all Readers support being restored, so this can produce an\nUnimplemented error.",
    "inputs": [
      {
        "name": "reader_handle",
        "description": "Handle to a Reader.",
        "type": 7,
        "isRef": true
      },
      {
        "name": "state",
        "description": "Result of a ReaderSerializeState of a Reader with type\nmatching reader_handle.",
        "type": 7
      }
    ]
  },
  {
    "name": "ReaderRestoreStateV2",
    "summary": "Restore a reader to a previously saved state.",
    "description": "Not all Readers support being restored, so this can produce an\nUnimplemented error.",
    "inputs": [
      {
        "name": "reader_handle",
        "description": "Handle to a Reader.",
        "type": 20
      },
      {
        "name": "state",
        "description": "Result of a ReaderSerializeState of a Reader with type\nmatching reader_handle.",
        "type": 7
      }
    ]
  },
  {
    "name": "ReaderSerializeState",
    "summary": "Produce a string tensor that encodes the state of a Reader.",
    "description": "Not all Readers support being serialized, so this can produce an\nUnimplemented error.",
    "inputs": [
      {
        "name": "reader_handle",
        "description": "Handle to a Reader.",
        "type": 7,
        "isRef": true
      }
    ],
    "outputs": [
      {
        "name": "state",
        "type": 7
      }
    ]
  },
  {
    "name": "ReaderSerializeStateV2",
    "summary": "Produce a string tensor that encodes the state of a Reader.",
    "description": "Not all Readers support being serialized, so this can produce an\nUnimplemented error.",
    "inputs": [
      {
        "name": "reader_handle",
        "description": "Handle to a Reader.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "state",
        "type": 7
      }
    ]
  },
  {
    "name": "Real",
    "summary": "Returns the real part of a complex number.",
    "description": "Given a tensor `input` of complex numbers, this operation returns a tensor of\ntype `float` that is the real part of each element in `input`. All elements in\n`input` must be complex numbers of the form \\\\(a + bj\\\\), where *a* is the real\n part returned by this operation and *b* is the imaginary part.\n\nFor example:\n\n```\n# tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]\ntf.real(input) ==> [-2.25, 3.25]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      },
      {
        "name": "Tout",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "RealDiv",
    "summary": "Returns x / y element-wise for real types.",
    "description": "If `x` and `y` are reals, this will return the floating-point division.\n\n*NOTE*: `Div` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `uint8`, `int8`, `uint16`, `int16`, `int32`, `uint32`, `uint64`, `int64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RebatchDataset",
    "summary": "Creates a dataset that changes the batch size.",
    "description": "Creates a dataset that changes the batch size of the dataset to current batch\nsize // num_workers.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "use_fallback",
        "type": "boolean",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the input dataset.",
        "type": 21
      },
      {
        "name": "num_replicas",
        "description": "A scalar representing the number of replicas to distribute this batch across. As\na result of this transformation the current batch size would end up being\ndivided  by this parameter.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "RebatchDatasetV2",
    "summary": "Creates a dataset that changes the batch size.",
    "description": "Creates a dataset that rebatches elements from `input_dataset` into new batch\nsizes.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the input dataset.",
        "type": 21
      },
      {
        "name": "batch_sizes",
        "description": "A vector of integers representing the size of batches to produce. These values\nare cycled through in order.",
        "type": 9
      },
      {
        "name": "drop_remainder",
        "type": 10
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "Reciprocal",
    "summary": "Computes the reciprocal of x element-wise.",
    "description": "I.e., \\\\(y = 1 / x\\\\).",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `int8`, `int16`, `int32`, `int64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ReciprocalGrad",
    "summary": "Computes the gradient for the inverse of `x` wrt its input.",
    "description": "Specifically, `grad = -dy * y*y`, where `y = 1/x`, and `dy`\nis the corresponding input gradient.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "y",
        "typeAttr": "T"
      },
      {
        "name": "dy",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RecordInput",
    "summary": "Emits randomized records.",
    "attributes": [
      {
        "name": "file_pattern",
        "type": "string",
        "description": "Glob pattern for the data files."
      },
      {
        "name": "file_random_seed",
        "type": "int64",
        "description": "Random seeds used to produce randomized records.",
        "default": 301
      },
      {
        "name": "file_shuffle_shift_ratio",
        "type": "float32",
        "description": "Shifts the list of files after the list is randomly\nshuffled.",
        "default": 0.0
      },
      {
        "name": "file_buffer_size",
        "type": "int64",
        "description": "The randomization shuffling buffer.",
        "default": 10000
      },
      {
        "name": "file_parallelism",
        "type": "int64",
        "description": "How many sstables are opened and concurrently iterated over.",
        "default": 16
      },
      {
        "name": "batch_size",
        "type": "int64",
        "description": "The batch size.",
        "default": 32
      },
      {
        "name": "compression_type",
        "type": "string",
        "description": "The type of compression for the file. Currently ZLIB and\nGZIP are supported. Defaults to none.",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "records",
        "description": "A tensor of shape [batch_size].",
        "type": 7
      }
    ]
  },
  {
    "name": "Recv",
    "summary": "Receives the named tensor from send_device on recv_device.",
    "attributes": [
      {
        "name": "tensor_type",
        "type": "type"
      },
      {
        "name": "tensor_name",
        "type": "string",
        "description": "The name of the tensor to receive."
      },
      {
        "name": "send_device",
        "type": "string",
        "description": "The name of the device sending the tensor."
      },
      {
        "name": "send_device_incarnation",
        "type": "int64",
        "description": "The current incarnation of send_device."
      },
      {
        "name": "recv_device",
        "type": "string",
        "description": "The name of the device receiving the tensor."
      },
      {
        "name": "client_terminated",
        "type": "boolean",
        "description": "If set to true, this indicates that the node was added\nto the graph as a result of a client-side feed or fetch of Tensor data,\nin which case the corresponding send or recv is expected to be managed\nlocally by the caller.",
        "default": false
      }
    ],
    "outputs": [
      {
        "name": "tensor",
        "description": "The tensor to receive.",
        "typeAttr": "tensor_type"
      }
    ]
  },
  {
    "name": "RecvTPUEmbeddingActivations",
    "summary": "An op that receives embedding activations on the TPU.",
    "description": "The TPU system performs the embedding lookups and aggregations specified by\nthe arguments to TPUEmbeddingEnqueue(Integer/Sparse/SparseTensor)Batch. The\nresults of these aggregations are visible to the Tensorflow Graph as the\noutputs of a RecvTPUEmbeddingActivations op. This op returns a list containing\none Tensor of activations per table specified in the model. There can be at\nmost one RecvTPUEmbeddingActivations op in the TPU graph.",
    "attributes": [
      {
        "name": "num_outputs",
        "type": "int64",
        "description": "The number of output activation tensors, equal to the number of\nembedding tables in the model.",
        "minimum": 1
      },
      {
        "name": "config",
        "type": "string",
        "description": "Serialized TPUEmbeddingConfiguration proto."
      }
    ],
    "outputs": [
      {
        "name": "outputs",
        "description": "A TensorList of embedding activations containing one Tensor per\nembedding table in the model.",
        "numberAttr": "num_outputs",
        "type": 1
      }
    ]
  },
  {
    "name": "ReduceDataset",
    "summary": "Reduces the input dataset to a singleton using a reduce function.",
    "attributes": [
      {
        "name": "f",
        "type": "function",
        "description": "A function that maps `(old_state, input_element)` to `new_state`. It must take\ntwo arguments and return a nested structures of tensors. The structure of\n`new_state` must match the structure of `initial_state`."
      },
      {
        "name": "Tstate",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "Targuments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "use_inter_op_parallelism",
        "type": "boolean",
        "default": true
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the input dataset.",
        "type": 21
      },
      {
        "name": "initial_state",
        "description": "A nested structure of tensors, representing the initial state of the\ntransformation.",
        "typeListAttr": "Tstate"
      },
      {
        "name": "other_arguments",
        "typeListAttr": "Targuments"
      }
    ],
    "outputs": [
      {
        "name": "components",
        "typeListAttr": "output_types"
      }
    ]
  },
  {
    "name": "ReduceJoin",
    "summary": "Joins a string Tensor across the given dimensions.",
    "description": "Computes the string join across dimensions in the given string Tensor of shape\n`[\\\\(d_0, d_1, ..., d_{n-1}\\\\)]`.  Returns a new Tensor created by joining the input\nstrings with the given separator (default: empty string).  Negative indices are\ncounted backwards from the end, with `-1` being equivalent to `n - 1`.  If\nindices are not specified, joins across all dimensions beginning from `n - 1`\nthrough `0`.\n\nFor example:\n\n```python\n# tensor `a` is [[\"a\", \"b\"], [\"c\", \"d\"]]\ntf.reduce_join(a, 0) ==> [\"ac\", \"bd\"]\ntf.reduce_join(a, 1) ==> [\"ab\", \"cd\"]\ntf.reduce_join(a, -2) = tf.reduce_join(a, 0) ==> [\"ac\", \"bd\"]\ntf.reduce_join(a, -1) = tf.reduce_join(a, 1) ==> [\"ab\", \"cd\"]\ntf.reduce_join(a, 0, keep_dims=True) ==> [[\"ac\", \"bd\"]]\ntf.reduce_join(a, 1, keep_dims=True) ==> [[\"ab\"], [\"cd\"]]\ntf.reduce_join(a, 0, separator=\".\") ==> [\"a.c\", \"b.d\"]\ntf.reduce_join(a, [0, 1]) ==> \"acbd\"\ntf.reduce_join(a, [1, 0]) ==> \"abcd\"\ntf.reduce_join(a, []) ==> [[\"a\", \"b\"], [\"c\", \"d\"]]\ntf.reduce_join(a) = tf.reduce_join(a, [1, 0]) ==> \"abcd\"\n```",
    "attributes": [
      {
        "name": "keep_dims",
        "type": "boolean",
        "description": "If `True`, retain reduced dimensions with length `1`.",
        "default": false
      },
      {
        "name": "separator",
        "type": "string",
        "description": "The separator to use when joining.",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "description": "The input to be joined.  All reduced indices must have non-zero size.",
        "type": 7
      },
      {
        "name": "reduction_indices",
        "description": "The dimensions to reduce over.  Dimensions are reduced in the\norder specified.  Omitting `reduction_indices` is equivalent to passing\n`[n-1, n-2, ..., 0]`.  Negative indices from `-n` to `-1` are supported.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Has shape equal to that of the input with reduced dimensions removed or\nset to `1` depending on `keep_dims`.",
        "type": 7
      }
    ]
  },
  {
    "name": "RefEnter",
    "summary": "Creates or finds a child frame, and makes `data` available to the child frame.",
    "description": "The unique `frame_name` is used by the `Executor` to identify frames. If\n`is_constant` is true, `output` is a constant in the child frame; otherwise\nit may be changed in the child frame. At most `parallel_iterations` iterations\nare run in parallel in the child frame.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "frame_name",
        "type": "string",
        "description": "The name of the child frame."
      },
      {
        "name": "is_constant",
        "type": "boolean",
        "description": "If true, the output is constant within the child frame.",
        "default": false
      },
      {
        "name": "parallel_iterations",
        "type": "int64",
        "description": "The number of iterations allowed to run in parallel.",
        "default": 10
      }
    ],
    "inputs": [
      {
        "name": "data",
        "description": "The tensor to be made available to the child frame.",
        "typeAttr": "T",
        "isRef": true
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The same tensor as `data`.",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "RefExit",
    "summary": "Exits the current frame to its parent frame.",
    "description": "Exit makes its input `data` available to the parent frame.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "data",
        "description": "The tensor to be made available to the parent frame.",
        "typeAttr": "T",
        "isRef": true
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The same tensor as `data`.",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "RefIdentity",
    "summary": "Return the same ref tensor as the input ref tensor.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T",
        "isRef": true
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "RefMerge",
    "summary": "Forwards the value of an available tensor from `inputs` to `output`.",
    "description": "`Merge` waits for at least one of the tensors in `inputs` to become available.\nIt is usually combined with `Switch` to implement branching.\n\n`Merge` forwards the first tensor for become available to `output`, and sets\n`value_index` to its index in `inputs`.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "description": "The input tensors, exactly one of which will become available.",
        "numberAttr": "N",
        "typeAttr": "T",
        "isRef": true
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Will be set to the available input tensor.",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "value_index",
        "description": "The index of the chosen input tensor in `inputs`.",
        "type": 3
      }
    ]
  },
  {
    "name": "RefNextIteration",
    "summary": "Makes its input available to the next iteration.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "data",
        "description": "The tensor to be made available to the next iteration.",
        "typeAttr": "T",
        "isRef": true
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The same tensor as `data`.",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "RefSelect",
    "summary": "Forwards the `index`th element of `inputs` to `output`.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "index",
        "description": "A scalar that determines the input that gets selected.",
        "type": 3
      },
      {
        "name": "inputs",
        "description": "A list of ref tensors, one of which will be forwarded to `output`.",
        "numberAttr": "N",
        "typeAttr": "T",
        "isRef": true
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The forwarded tensor.",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "RefSwitch",
    "summary": "Forwards the ref tensor `data` to the output port determined by `pred`.",
    "description": "If `pred` is true, the `data` input is forwarded to `output_true`. Otherwise,\nthe data goes to `output_false`.\n\nSee also `Switch` and `Merge`.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "data",
        "description": "The ref tensor to be forwarded to the appropriate output.",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "pred",
        "description": "A scalar that specifies which output port will receive data.",
        "type": 10
      }
    ],
    "outputs": [
      {
        "name": "output_false",
        "description": "If `pred` is false, data will be forwarded to this output.",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "output_true",
        "description": "If `pred` is true, data will be forwarded to this output.",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "RegexFullMatch",
    "summary": "Check if the input matches the regex pattern.",
    "description": "The input is a string tensor of any shape. The pattern is a scalar\nstring tensor which is applied to every element of the input tensor.\nThe boolean values (True or False) of the output tensor indicate\nif the input matches the regex pattern provided.\n\nThe pattern follows the re2 syntax (https://github.com/google/re2/wiki/Syntax)\n\nExamples:\n\n>>> tf.strings.regex_full_match([\"TF lib\", \"lib TF\"], \".*lib$\")\n<tf.Tensor: shape=(2,), dtype=bool, numpy=array([ True, False])>\n>>> tf.strings.regex_full_match([\"TF lib\", \"lib TF\"], \".*TF$\")\n<tf.Tensor: shape=(2,), dtype=bool, numpy=array([False,  True])>",
    "inputs": [
      {
        "name": "input",
        "description": "A string tensor of the text to be processed.",
        "type": 7
      },
      {
        "name": "pattern",
        "description": "A scalar string tensor containing the regular expression to match the input.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A bool tensor with the same shape as `input`.",
        "type": 10
      }
    ]
  },
  {
    "name": "RegexReplace",
    "summary": "Replaces matches of the `pattern` regular expression in `input` with the\nreplacement string provided in `rewrite`.",
    "description": "It follows the re2 syntax (https://github.com/google/re2/wiki/Syntax)",
    "attributes": [
      {
        "name": "replace_global",
        "type": "boolean",
        "description": "If True, the replacement is global (that is, all matches of the `pattern` regular\nexpression in each input string are rewritten), otherwise the `rewrite`\nsubstitution is only made for the first `pattern` match.",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The text to be processed.",
        "type": 7
      },
      {
        "name": "pattern",
        "description": "The regular expression to be matched in the `input` strings.",
        "type": 7
      },
      {
        "name": "rewrite",
        "description": "The rewrite string to be substituted for the `pattern` expression where it is\nmatched in the `input` strings.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The text after applying pattern match and rewrite substitution.",
        "type": 7
      }
    ]
  },
  {
    "name": "RegisterDataset",
    "summary": "Registers a dataset with the tf.data service.",
    "attributes": [
      {
        "name": "external_state_policy",
        "type": "int64"
      },
      {
        "name": "element_spec",
        "type": "string",
        "default": ""
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "dataset",
        "type": 21
      },
      {
        "name": "address",
        "type": 7
      },
      {
        "name": "protocol",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "dataset_id",
        "type": 9
      }
    ]
  },
  {
    "name": "RegisterDatasetV2",
    "summary": "Registers a dataset with the tf.data service.",
    "attributes": [
      {
        "name": "external_state_policy",
        "type": "int64"
      },
      {
        "name": "element_spec",
        "type": "string",
        "default": ""
      },
      {
        "name": "requested_dataset_id",
        "type": "string",
        "default": ""
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "dataset",
        "type": 21
      },
      {
        "name": "address",
        "type": 7
      },
      {
        "name": "protocol",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "dataset_id",
        "type": 7
      }
    ]
  },
  {
    "name": "Relayout",
    "attributes": [
      {
        "name": "layout",
        "type": "string"
      },
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RelayoutLike",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "U",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "layout_input",
        "typeAttr": "U"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Relu",
    "category": "Activation",
    "summary": "Computes rectified linear: `max(features, 0)`.",
    "description": "See: https://en.wikipedia.org/wiki/Rectifier_(neural_networks)\nExample usage:\n>>> tf.nn.relu([-2., 0., 3.]).numpy()\narray([0., 0., 3.], dtype=float32)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`, `qint8`."
      }
    ],
    "inputs": [
      {
        "name": "features",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "activations",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Relu6",
    "category": "Activation",
    "summary": "Computes rectified linear 6: `min(max(features, 0), 6)`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "features",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "activations",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Relu6Grad",
    "summary": "Computes rectified linear 6 gradients for a Relu6 operation.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "gradients",
        "description": "The backpropagated gradients to the corresponding Relu6 operation.",
        "typeAttr": "T"
      },
      {
        "name": "features",
        "description": "The features passed as input to the corresponding Relu6 operation, or\nits output; using either one produces the same result.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "backprops",
        "description": "The gradients:\n`gradients * (features > 0) * (features < 6)`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ReluGrad",
    "summary": "Computes rectified linear gradients for a Relu operation.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "gradients",
        "description": "The backpropagated gradients to the corresponding Relu operation.",
        "typeAttr": "T"
      },
      {
        "name": "features",
        "description": "The features passed as input to the corresponding Relu operation, OR\nthe outputs of that operation (both work equivalently).",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "backprops",
        "description": "`gradients * (features > 0)`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RemoteCall",
    "summary": "Runs function `f` on a remote device indicated by `target`.",
    "attributes": [
      {
        "name": "Tin",
        "type": "type[]",
        "description": "The type list for the arguments.",
        "minimum": 1
      },
      {
        "name": "Tout",
        "type": "type[]",
        "description": "The type list for the return values.",
        "minimum": 1
      },
      {
        "name": "f",
        "type": "function",
        "description": "The function to run remotely."
      }
    ],
    "inputs": [
      {
        "name": "target",
        "description": "A fully specified device name where we want to run the function.",
        "type": 7
      },
      {
        "name": "args",
        "description": "A list of arguments for the function.",
        "typeListAttr": "Tin"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A list of return values.",
        "typeListAttr": "Tout"
      }
    ]
  },
  {
    "name": "RepeatDataset",
    "summary": "Creates a dataset that emits the outputs of `input_dataset` `count` times.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "count",
        "description": "A scalar representing the number of times that `input_dataset` should\nbe repeated. A value of `-1` indicates that it should be repeated infinitely.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "RequantizationRange",
    "summary": "Computes a range that covers the actual values present in a quantized tensor.",
    "description": "Given a quantized tensor described by `(input, input_min, input_max)`, outputs a\nrange that covers the actual values present in that tensor. This op is typically\nused to produce the `requested_output_min` and `requested_output_max` for\n`Requantize`.",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type",
        "description": "The type of the input. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "Tinput"
      },
      {
        "name": "input_min",
        "description": "The float value that the minimum quantized input value represents.",
        "type": 1
      },
      {
        "name": "input_max",
        "description": "The float value that the maximum quantized input value represents.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output_min",
        "description": "The computed min output.",
        "type": 1
      },
      {
        "name": "output_max",
        "description": "the computed max output.",
        "type": 1
      }
    ]
  },
  {
    "name": "RequantizationRangePerChannel",
    "summary": "Computes requantization range per channel.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "The quantized type of input tensor that needs to be converted. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 13
        }
      },
      {
        "name": "clip_value_max",
        "type": "float32",
        "description": "The maximum value of the output that needs to be clipped.\nExample: set this to 6 for Relu6."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The original input tensor.",
        "typeAttr": "T"
      },
      {
        "name": "input_min",
        "description": "The minimum value of the input tensor",
        "type": 1
      },
      {
        "name": "input_max",
        "description": "The maximum value of the input tensor.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output_min",
        "description": "The minimum value of the final output tensor",
        "type": 1
      },
      {
        "name": "output_max",
        "description": "The maximum value of the final output tensor.",
        "type": 1
      }
    ]
  },
  {
    "name": "Requantize",
    "summary": "Converts the quantized `input` tensor into a lower-precision `output`.",
    "description": "Converts the quantized `input` tensor into a lower-precision `output`, using the\noutput range specified with `requested_output_min` and `requested_output_max`.\n\n`[input_min, input_max]` are scalar floats that specify the range for the float\ninterpretation of the `input` data. For example, if `input_min` is -1.0f and\n`input_max` is 1.0f, and we are dealing with `quint16` quantized data, then a 0\nvalue in the 16-bit data should be interpreted as -1.0f, and a 65535 means 1.0f.",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type",
        "description": "The type of the input. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "The type of the output. Should be a lower bit depth than Tinput. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "Tinput"
      },
      {
        "name": "input_min",
        "description": "The float value that the minimum quantized input value represents.",
        "type": 1
      },
      {
        "name": "input_max",
        "description": "The float value that the maximum quantized input value represents.",
        "type": 1
      },
      {
        "name": "requested_output_min",
        "description": "The float value that the minimum quantized output value represents.",
        "type": 1
      },
      {
        "name": "requested_output_max",
        "description": "The float value that the maximum quantized output value represents.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "out_type"
      },
      {
        "name": "output_min",
        "description": "The requested_output_min value is copied into this output.",
        "type": 1
      },
      {
        "name": "output_max",
        "description": "The requested_output_max value is copied into this output.",
        "type": 1
      }
    ]
  },
  {
    "name": "RequantizePerChannel",
    "summary": "Requantizes input with min and max values known per channel.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "The quantized type of input tensor that needs to be converted. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 13
        }
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "The quantized type of output tensor that needs to be converted. Must be one of the following: `qint8`, `quint8`, `qint32`, `qint16`, `quint16`.",
        "default": {
          "type": "type",
          "value": 12
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The original input tensor.",
        "typeAttr": "T"
      },
      {
        "name": "input_min",
        "description": "The minimum value of the input tensor",
        "type": 1
      },
      {
        "name": "input_max",
        "description": "The maximum value of the input tensor.",
        "type": 1
      },
      {
        "name": "requested_output_min",
        "description": "The minimum value of the output tensor requested.",
        "type": 1
      },
      {
        "name": "requested_output_max",
        "description": "The maximum value of the output tensor requested.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Output tensor.",
        "typeAttr": "out_type"
      },
      {
        "name": "output_min",
        "description": "The minimum value of the final output tensor",
        "type": 1
      },
      {
        "name": "output_max",
        "description": "The maximum value of the final output tensor.",
        "type": 1
      }
    ]
  },
  {
    "name": "Reshape",
    "category": "Shape",
    "summary": "Reshapes a tensor.",
    "description": "Given `tensor`, this operation returns a tensor that has the same values\nas `tensor` with shape `shape`.\n\nIf one component of 1-D tensor `shape` is the special value -1, the size of that\ndimension is computed so that the total size remains constant.  In particular, a\n`shape` of `[-1]` flattens into 1-D.  At most one component of `shape` may be\nunknown.\n\nThe `shape` must be 1-D and the operation returns a tensor with shape\n`shape` filled with the values of `tensor`. In this case, the number of elements\nimplied by `shape` must be the same as the number of elements in `tensor`.\n\nIt is an error if `shape` is not 1-D.\n\nFor example:\n\n```\n# tensor 't' is [1, 2, 3, 4, 5, 6, 7, 8, 9]\n# tensor 't' has shape [9]\nreshape(t, [3, 3]) ==> [[1, 2, 3],\n                        [4, 5, 6],\n                        [7, 8, 9]]\n\n# tensor 't' is [[[1, 1], [2, 2]],\n#                [[3, 3], [4, 4]]]\n# tensor 't' has shape [2, 2, 2]\nreshape(t, [2, 4]) ==> [[1, 1, 2, 2],\n                        [3, 3, 4, 4]]\n\n# tensor 't' is [[[1, 1, 1],\n#                 [2, 2, 2]],\n#                [[3, 3, 3],\n#                 [4, 4, 4]],\n#                [[5, 5, 5],\n#                 [6, 6, 6]]]\n# tensor 't' has shape [3, 2, 3]\n# pass '[-1]' to flatten 't'\nreshape(t, [-1]) ==> [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6]\n\n# -1 can also be used to infer the shape\n\n# -1 is inferred to be 9:\nreshape(t, [2, -1]) ==> [[1, 1, 1, 2, 2, 2, 3, 3, 3],\n                         [4, 4, 4, 5, 5, 5, 6, 6, 6]]\n# -1 is inferred to be 2:\nreshape(t, [-1, 9]) ==> [[1, 1, 1, 2, 2, 2, 3, 3, 3],\n                         [4, 4, 4, 5, 5, 5, 6, 6, 6]]\n# -1 is inferred to be 3:\nreshape(t, [ 2, -1, 3]) ==> [[[1, 1, 1],\n                              [2, 2, 2],\n                              [3, 3, 3]],\n                             [[4, 4, 4],\n                              [5, 5, 5],\n                              [6, 6, 6]]]\n\n# tensor 't' is [7]\n# shape `[]` reshapes to a scalar\nreshape(t, []) ==> 7\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tshape",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "tensor",
        "typeAttr": "T"
      },
      {
        "name": "shape",
        "description": "Defines the shape of the output tensor.",
        "typeAttr": "Tshape"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResizeArea",
    "summary": "Resize `images` to `size` using area interpolation.",
    "description": "Input images can be of different types but output images are always float.\n\nThe range of pixel values for the output image might be slightly different\nfrom the range for the input image because of limited numerical precision.\nTo guarantee an output range, for example `[0.0, 1.0]`, apply\n`tf.clip_by_value` to the output.\n\nEach output pixel is computed by first transforming the pixel's footprint into\nthe input tensor and then averaging the pixels that intersect the footprint. An\ninput pixel's contribution to the average is weighted by the fraction of its\narea that intersects the footprint.  This is the same as OpenCV's INTER_AREA.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int8`, `uint8`, `int16`, `uint16`, `int32`, `int64`, `float16`, `float32`, `float64`, `bfloat16`."
      },
      {
        "name": "align_corners",
        "type": "boolean",
        "description": "If true, the centers of the 4 corner pixels of the input and output tensors are\naligned, preserving the values at the corner pixels. Defaults to false.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "images",
        "description": "4-D with shape `[batch, height, width, channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "size",
        "description": "= A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "resized_images",
        "description": "4-D with shape\n`[batch, new_height, new_width, channels]`.",
        "type": 1
      }
    ]
  },
  {
    "name": "ResizeBicubic",
    "summary": "Resize `images` to `size` using bicubic interpolation.",
    "description": "Input images can be of different types but output images are always float.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int8`, `uint8`, `int16`, `uint16`, `int32`, `int64`, `float16`, `float32`, `float64`, `bfloat16`."
      },
      {
        "name": "align_corners",
        "type": "boolean",
        "description": "If true, the centers of the 4 corner pixels of the input and output tensors are\naligned, preserving the values at the corner pixels. Defaults to false.",
        "default": false
      },
      {
        "name": "half_pixel_centers",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "images",
        "description": "4-D with shape `[batch, height, width, channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "size",
        "description": "= A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "resized_images",
        "description": "4-D with shape\n`[batch, new_height, new_width, channels]`.",
        "type": 1
      }
    ]
  },
  {
    "name": "ResizeBicubicGrad",
    "summary": "Computes the gradient of bicubic interpolation.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`."
      },
      {
        "name": "align_corners",
        "type": "boolean",
        "description": "If true, the centers of the 4 corner pixels of the input and grad tensors are\naligned. Defaults to false.",
        "default": false
      },
      {
        "name": "half_pixel_centers",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "grads",
        "description": "4-D with shape `[batch, height, width, channels]`.",
        "type": 1
      },
      {
        "name": "original_image",
        "description": "4-D with shape `[batch, orig_height, orig_width, channels]`,\nThe image tensor that was resized.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "4-D with shape `[batch, orig_height, orig_width, channels]`.\nGradients with respect to the input image. Input image must have been\nfloat or double.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResizeBilinear",
    "summary": "Resize `images` to `size` using bilinear interpolation.",
    "description": "Input images can be of different types but output images are always float.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int8`, `uint8`, `int16`, `uint16`, `int32`, `int64`, `bfloat16`, `float16`, `float32`, `float64`, `bfloat16`."
      },
      {
        "name": "align_corners",
        "type": "boolean",
        "description": "If true, the centers of the 4 corner pixels of the input and output tensors are\naligned, preserving the values at the corner pixels. Defaults to false.",
        "default": false
      },
      {
        "name": "half_pixel_centers",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "images",
        "description": "4-D with shape `[batch, height, width, channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "size",
        "description": "= A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "resized_images",
        "description": "4-D with shape\n`[batch, new_height, new_width, channels]`.",
        "type": 1
      }
    ]
  },
  {
    "name": "ResizeBilinearGrad",
    "summary": "Computes the gradient of bilinear interpolation.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `bfloat16`, `float16`, `float64`."
      },
      {
        "name": "align_corners",
        "type": "boolean",
        "description": "If true, the centers of the 4 corner pixels of the input and grad tensors are\naligned. Defaults to false.",
        "default": false
      },
      {
        "name": "half_pixel_centers",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "grads",
        "description": "4-D with shape `[batch, height, width, channels]`.",
        "type": 1
      },
      {
        "name": "original_image",
        "description": "4-D with shape `[batch, orig_height, orig_width, channels]`,\nThe image tensor that was resized.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "4-D with shape `[batch, orig_height, orig_width, channels]`.\nGradients with respect to the input image. Input image must have been\nfloat or double.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResizeNearestNeighbor",
    "summary": "Resize `images` to `size` using nearest neighbor interpolation.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int8`, `uint8`, `int16`, `uint16`, `int32`, `int64`, `float16`, `float32`, `float64`, `bfloat16`."
      },
      {
        "name": "align_corners",
        "type": "boolean",
        "description": "If true, the centers of the 4 corner pixels of the input and output tensors are\naligned, preserving the values at the corner pixels. Defaults to false.",
        "default": false
      },
      {
        "name": "half_pixel_centers",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "images",
        "description": "4-D with shape `[batch, height, width, channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "size",
        "description": "= A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "resized_images",
        "description": "4-D with shape\n`[batch, new_height, new_width, channels]`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResizeNearestNeighborGrad",
    "summary": "Computes the gradient of nearest neighbor interpolation.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `uint8`, `int8`, `int32`, `float16`, `float32`, `float64`, `bfloat16`."
      },
      {
        "name": "align_corners",
        "type": "boolean",
        "description": "If true, the centers of the 4 corner pixels of the input and grad tensors are\naligned. Defaults to false.",
        "default": false
      },
      {
        "name": "half_pixel_centers",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "grads",
        "description": "4-D with shape `[batch, height, width, channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "size",
        "description": "= A 1-D int32 Tensor of 2 elements: `orig_height, orig_width`. The\noriginal input size.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "4-D with shape `[batch, orig_height, orig_width, channels]`. Gradients\nwith respect to the input image.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceAccumulatorApplyGradient",
    "summary": "Applies a gradient to a given accumulator.",
    "description": "Does not add if local_step is lesser than the accumulator's global_step.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The data type of accumulated gradients. Needs to correspond to the type\nof the accumulator. Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a accumulator.",
        "type": 20
      },
      {
        "name": "local_step",
        "description": "The local_step value at which the gradient was computed.",
        "type": 9
      },
      {
        "name": "gradient",
        "description": "A tensor of the gradient to be accumulated.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "ResourceAccumulatorNumAccumulated",
    "summary": "Returns the number of gradients aggregated in the given accumulators.",
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to an accumulator.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "num_accumulated",
        "description": "The number of gradients aggregated in the given accumulator.",
        "type": 3
      }
    ]
  },
  {
    "name": "ResourceAccumulatorSetGlobalStep",
    "summary": "Updates the accumulator with a new value for global_step.",
    "description": "Logs warning if the accumulator's value is already higher than\nnew_global_step.",
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to an accumulator.",
        "type": 20
      },
      {
        "name": "new_global_step",
        "description": "The new global_step value to set.",
        "type": 9
      }
    ]
  },
  {
    "name": "ResourceAccumulatorTakeGradient",
    "summary": "Extracts the average gradient in the given ConditionalAccumulator.",
    "description": "The op blocks until sufficient (i.e., more than num_required)\ngradients have been accumulated.  If the accumulator has already\naggregated more than num_required gradients, it returns the average of\nthe accumulated gradients.  Also automatically increments the recorded\nglobal_step in the accumulator by 1, and resets the aggregate to 0.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The data type of accumulated gradients. Needs to correspond to the type\nof the accumulator. Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to an accumulator.",
        "type": 20
      },
      {
        "name": "num_required",
        "description": "Number of gradients required before we return an aggregate.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "average",
        "description": "The average of the accumulated gradients.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "ResourceApplyAdaMax",
    "summary": "Update '*var' according to the AdaMax algorithm.",
    "description": "m_t <- beta1 * m_{t-1} + (1 - beta1) * g\nv_t <- max(beta2 * v_{t-1}, abs(g))\nvariable <- variable - learning_rate / (1 - beta1^t) * m_t / (v_t + epsilon)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var, m, and v tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "m",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "v",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "beta1_power",
        "description": "Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "beta1",
        "description": "Momentum factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "beta2",
        "description": "Momentum factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "epsilon",
        "description": "Ridge term. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceApplyAdadelta",
    "summary": "Update '*var' according to the adadelta scheme.",
    "description": "accum = rho() * accum + (1 - rho()) * grad.square();\nupdate = (update_accum + epsilon).sqrt() * (accum + epsilon()).rsqrt() * grad;\nupdate_accum = rho() * update_accum + (1 - rho()) * update.square();\nvar -= update;",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, updating of the var, accum and update_accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "accum_update",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "rho",
        "description": "Decay factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "epsilon",
        "description": "Constant factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceApplyAdagrad",
    "summary": "Update '*var' according to the adagrad scheme.",
    "description": "accum += grad * grad\nvar -= lr * grad * (1 / sqrt(accum))",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "update_slots",
        "type": "boolean",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceApplyAdagradDA",
    "summary": "Update '*var' according to the proximal adagrad scheme.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "gradient_accumulator",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "gradient_squared_accumulator",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l1",
        "description": "L1 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2",
        "description": "L2 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "global_step",
        "description": "Training step number. Must be a scalar.",
        "type": 9
      }
    ]
  },
  {
    "name": "ResourceApplyAdagradV2",
    "summary": "Update '*var' according to the adagrad scheme.",
    "description": "accum += grad * grad\nvar -= lr * grad * (1 / (sqrt(accum) + epsilon))",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "update_slots",
        "type": "boolean",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "epsilon",
        "description": "Constant factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceApplyAdam",
    "summary": "Update '*var' according to the Adam algorithm.",
    "description": "$$\\text{lr}_t := \\mathrm{lr} \\cdot \\frac{\\sqrt{1 - \\beta_2^t}}{1 - \\beta_1^t}$$\n$$m_t := \\beta_1 \\cdot m_{t-1} + (1 - \\beta_1) \\cdot g$$\n$$v_t := \\beta_2 \\cdot v_{t-1} + (1 - \\beta_2) \\cdot g^2$$\n$$\\text{var} := \\begin{cases} \\text{var} - (m_t \\beta_1 + g \\cdot (1 - \\beta_1))\\cdot\\text{lr}_t/(\\sqrt{v_t} + \\epsilon), &\\text{if use_nesterov}\\\\\\\\  \\text{var} - m_t \\cdot \\text{lr}_t /(\\sqrt{v_t} + \\epsilon), &\\text{otherwise} \\end{cases}$$",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var, m, and v tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "use_nesterov",
        "type": "boolean",
        "description": "If `True`, uses the nesterov update.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "m",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "v",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "beta1_power",
        "description": "Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "beta2_power",
        "description": "Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "beta1",
        "description": "Momentum factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "beta2",
        "description": "Momentum factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "epsilon",
        "description": "Ridge term. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceApplyAdamWithAmsgrad",
    "summary": "Update '*var' according to the Adam algorithm.",
    "description": "$$\\text{lr}_t := \\mathrm{learning_rate} * \\sqrt{1 - \\beta_2^t} / (1 - \\beta_1^t)$$\n$$m_t := \\beta_1 * m_{t-1} + (1 - \\beta_1) * g$$\n$$v_t := \\beta_2 * v_{t-1} + (1 - \\beta_2) * g * g$$\n$$\\hat{v}_t := max{\\hat{v}_{t-1}, v_t}$$\n$$\\text{variable} := \\text{variable} - \\text{lr}_t * m_t / (\\sqrt{\\hat{v}_t} + \\epsilon)$$",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var, m, and v tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "m",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "v",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "vhat",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "beta1_power",
        "description": "Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "beta2_power",
        "description": "Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "beta1",
        "description": "Momentum factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "beta2",
        "description": "Momentum factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "epsilon",
        "description": "Ridge term. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceApplyAddSign",
    "summary": "Update '*var' according to the AddSign update.",
    "description": "m_t <- beta1 * m_{t-1} + (1 - beta1) * g\nupdate <- (alpha + sign_decay * sign(g) *sign(m)) * g\nvariable <- variable - lr_t * update",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and m tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "m",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "alpha",
        "description": "Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "sign_decay",
        "description": "Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "beta",
        "description": "Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceApplyCenteredRMSProp",
    "summary": "Update '*var' according to the centered RMSProp algorithm.",
    "description": "The centered RMSProp algorithm uses an estimate of the centered second moment\n(i.e., the variance) for normalization, as opposed to regular RMSProp, which\nuses the (uncentered) second moment. This often helps with training, but is\nslightly more expensive in terms of computation and memory.\n\nNote that in dense implementation of this algorithm, mg, ms, and mom will\nupdate even if the grad is zero, but in this sparse implementation, mg, ms,\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nmean_grad = decay * mean_grad + (1-decay) * gradient\n\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)\n\nmg <- rho * mg_{t-1} + (1-rho) * grad\nms <- rho * ms_{t-1} + (1-rho) * grad * grad\nmom <- momentum * mom_{t-1} + lr * grad / sqrt(ms - mg * mg + epsilon)\nvar <- var - mom",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var, mg, ms, and mom tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "mg",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "ms",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "mom",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "rho",
        "description": "Decay rate. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "momentum",
        "description": "Momentum Scale. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "epsilon",
        "description": "Ridge term. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceApplyFtrl",
    "summary": "Update '*var' according to the Ftrl-proximal scheme.",
    "description": "accum_new = accum + grad * grad\nlinear += grad - (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "multiply_linear_by_lr",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "linear",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l1",
        "description": "L1 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2",
        "description": "L2 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "lr_power",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceApplyFtrlV2",
    "summary": "Update '*var' according to the Ftrl-proximal scheme.",
    "description": "accum_new = accum + grad * grad\ngrad_with_shrinkage = grad + 2 * l2_shrinkage * var\nlinear += grad_with_shrinkage +\n    (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "multiply_linear_by_lr",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "linear",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l1",
        "description": "L1 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2",
        "description": "L2 shrinkage regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2_shrinkage",
        "typeAttr": "T"
      },
      {
        "name": "lr_power",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceApplyGradientDescent",
    "summary": "Update '*var' by subtracting 'alpha' * 'delta' from it.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "alpha",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "delta",
        "description": "The change.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceApplyKerasMomentum",
    "summary": "Update '*var' according to the momentum scheme.",
    "description": "Set use_nesterov = True if you want to use Nesterov momentum.\n\naccum = accum * momentum - lr * grad\nvar += accum",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "use_nesterov",
        "type": "boolean",
        "description": "If `True`, the tensor passed to compute grad will be\nvar + momentum * accum, so in the end, the var you get is actually\nvar + momentum * accum.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "momentum",
        "description": "Momentum. Must be a scalar.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceApplyMomentum",
    "summary": "Update '*var' according to the momentum scheme.",
    "description": "Set use_nesterov = True if you want to use Nesterov momentum.\n\naccum = accum * momentum + grad\nvar -= lr * accum",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "use_nesterov",
        "type": "boolean",
        "description": "If `True`, the tensor passed to compute grad will be\nvar - lr * momentum * accum, so in the end, the var you get is actually\nvar - lr * momentum * accum.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "momentum",
        "description": "Momentum. Must be a scalar.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceApplyPowerSign",
    "summary": "Update '*var' according to the AddSign update.",
    "description": "m_t <- beta1 * m_{t-1} + (1 - beta1) * g\nupdate <- exp(logbase * sign_decay * sign(g) * sign(m_t)) * g\nvariable <- variable - lr_t * update",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and m tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "m",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "logbase",
        "description": "Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "sign_decay",
        "description": "Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "beta",
        "description": "Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceApplyProximalAdagrad",
    "summary": "Update '*var' and '*accum' according to FOBOS with Adagrad learning rate.",
    "description": "accum += grad * grad\nprox_v = var - lr * grad * (1 / sqrt(accum))\nvar = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l1",
        "description": "L1 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2",
        "description": "L2 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceApplyProximalGradientDescent",
    "summary": "Update '*var' as FOBOS algorithm with fixed learning rate.",
    "description": "prox_v = var - alpha * delta\nvar = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "alpha",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l1",
        "description": "L1 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2",
        "description": "L2 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "delta",
        "description": "The change.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceApplyRMSProp",
    "summary": "Update '*var' according to the RMSProp algorithm.",
    "description": "Note that in dense implementation of this algorithm, ms and mom will\nupdate even if the grad is zero, but in this sparse implementation, ms\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon)\n\nms <- rho * ms_{t-1} + (1-rho) * grad * grad\nmom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)\nvar <- var - mom",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var, ms, and mom tensors is protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "ms",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "mom",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "rho",
        "description": "Decay rate. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "momentum",
        "typeAttr": "T"
      },
      {
        "name": "epsilon",
        "description": "Ridge term. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceConditionalAccumulator",
    "summary": "A conditional accumulator for aggregating gradients.",
    "description": "The accumulator accepts gradients marked with local_step greater or\nequal to the most recent global_step known to the accumulator. The\naverage can be extracted from the accumulator, provided sufficient\ngradients have been accumulated. Extracting the average automatically\nresets the aggregate to 0, and increments the global_step recorded by\nthe accumulator.\nThis is a resource version of ConditionalAccumulator that will work in TF2.0\nwith tf.cond version 2.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the value being accumulated. Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "shape",
        "type": "shape",
        "description": "The shape of the values, can be [], in which case shape is unknown."
      },
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this accumulator is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this accumulator will be shared under the\ngiven name across multiple sessions.",
        "default": ""
      },
      {
        "name": "reduction_type",
        "type": "string",
        "description": "Must be one of the following: `MEAN`, `SUM`.",
        "default": "MEAN"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "The handle to the accumulator.",
        "type": 20
      }
    ]
  },
  {
    "name": "ResourceCountUpTo",
    "summary": "Increments variable pointed to by 'resource' until it reaches 'limit'.",
    "attributes": [
      {
        "name": "limit",
        "type": "int64",
        "description": "If incrementing ref would bring it above limit, instead generates an\n'OutOfRange' error."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "description": "Should be from a scalar `Variable` node.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A copy of the input before increment. If nothing else modifies the\ninput, the values produced will all be distinct.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceGather",
    "summary": "Gather slices from the variable pointed to by `resource` according to `indices`.",
    "description": "`indices` must be an integer tensor of any dimension (usually 0-D or 1-D).\nProduces an output tensor with shape `indices.shape + params.shape[1:]` where:\n\n```python\n    # Scalar indices\n    output[:, ..., :] = params[indices, :, ... :]\n\n    # Vector indices\n    output[i, :, ..., :] = params[indices[i], :, ... :]\n\n    # Higher rank indices\n    output[i, ..., j, :, ... :] = params[indices[i, ..., j], :, ..., :]\n```",
    "attributes": [
      {
        "name": "batch_dims",
        "type": "int64",
        "default": 0
      },
      {
        "name": "validate_indices",
        "type": "boolean",
        "default": true
      },
      {
        "name": "dtype",
        "type": "type"
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "type": 20
      },
      {
        "name": "indices",
        "typeAttr": "Tindices"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "ResourceGatherNd",
    "attributes": [
      {
        "name": "dtype",
        "type": "type"
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "type": 20
      },
      {
        "name": "indices",
        "typeAttr": "Tindices"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "ResourceScatterAdd",
    "summary": "Adds sparse updates to the variable referenced by `resource`.",
    "description": "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] += updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] += updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] += updates[i, ..., j, ...]\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions add.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src='https://www.tensorflow.org/images/ScatterAdd.png' alt>\n</div>",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "description": "Should be from a `Variable` node.",
        "type": 20
      },
      {
        "name": "indices",
        "description": "A tensor of indices into the first dimension of `ref`.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A tensor of updated values to add to `ref`.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "ResourceScatterDiv",
    "summary": "Divides sparse updates into the variable referenced by `resource`.",
    "description": "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] /= updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] /= updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] /= updates[i, ..., j, ...]\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions multiply.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src='https://www.tensorflow.org/images/ScatterAdd.png' alt>\n</div>",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "description": "Should be from a `Variable` node.",
        "type": 20
      },
      {
        "name": "indices",
        "description": "A tensor of indices into the first dimension of `ref`.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A tensor of updated values to add to `ref`.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "ResourceScatterMax",
    "summary": "Reduces sparse updates into the variable referenced by `resource` using the `max` operation.",
    "description": "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] = max(ref[indices, ...], updates[...])\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] = max(ref[indices[i], ...], updates[i, ...])\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] = max(ref[indices[i, ..., j], ...], updates[i, ..., j, ...])\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions are combined.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src='https://www.tensorflow.org/images/ScatterAdd.png' alt>\n</div>",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "description": "Should be from a `Variable` node.",
        "type": 20
      },
      {
        "name": "indices",
        "description": "A tensor of indices into the first dimension of `ref`.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A tensor of updated values to add to `ref`.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "ResourceScatterMin",
    "summary": "Reduces sparse updates into the variable referenced by `resource` using the `min` operation.",
    "description": "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] = min(ref[indices, ...], updates[...])\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] = min(ref[indices[i], ...], updates[i, ...])\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] = min(ref[indices[i, ..., j], ...], updates[i, ..., j, ...])\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions are combined.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src='https://www.tensorflow.org/images/ScatterAdd.png' alt>\n</div>",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "description": "Should be from a `Variable` node.",
        "type": 20
      },
      {
        "name": "indices",
        "description": "A tensor of indices into the first dimension of `ref`.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A tensor of updated values to add to `ref`.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "ResourceScatterMul",
    "summary": "Multiplies sparse updates into the variable referenced by `resource`.",
    "description": "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] *= updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] *= updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] *= updates[i, ..., j, ...]\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions multiply.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src='https://www.tensorflow.org/images/ScatterAdd.png' alt>\n</div>",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "description": "Should be from a `Variable` node.",
        "type": 20
      },
      {
        "name": "indices",
        "description": "A tensor of indices into the first dimension of `ref`.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A tensor of updated values to add to `ref`.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "ResourceScatterNdAdd",
    "summary": "Applies sparse addition to individual values or slices in a Variable.",
    "description": "`ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.\n\n`indices` must be integer tensor, containing indices into `ref`.\nIt must be shape `[d_0, ..., d_{Q-2}, K]` where `0 < K <= P`.\n\nThe innermost dimension of `indices` (with length `K`) corresponds to\nindices into elements (if `K = P`) or slices (if `K < P`) along the `K`th\ndimension of `ref`.\n\n`updates` is `Tensor` of rank `Q-1+P-K` with shape:\n\n```\n[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]]\n```\n\nFor example, say we want to add 4 scattered elements to a rank-1 tensor to\n8 elements. In Python, that addition would look like this:\n\n```python\nref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8], use_resource=True)\nindices = tf.constant([[4], [3], [1], [7]])\nupdates = tf.constant([9, 10, 11, 12])\nadd = tf.scatter_nd_add(ref, indices, updates)\nwith tf.Session() as sess:\n  print sess.run(add)\n```\n\nThe resulting update to ref would look like this:\n\n    [1, 13, 3, 14, 14, 6, 7, 20]\n\nSee `tf.scatter_nd` for more details about how to make updates to\nslices.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "An optional bool. Defaults to True. If True, the assignment will\nbe protected by a lock; otherwise the behavior is undefined,\nbut may exhibit less contention.",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "description": "A resource handle. Must be from a VarHandleOp.",
        "type": 20
      },
      {
        "name": "indices",
        "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into ref.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A Tensor. Must have the same type as ref. A tensor of\nvalues to add to ref.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceScatterNdMax",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "An optional bool. Defaults to True. If True, the assignment will\nbe protected by a lock; otherwise the behavior is undefined,\nbut may exhibit less contention.",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "description": "A resource handle. Must be from a VarHandleOp.",
        "type": 20
      },
      {
        "name": "indices",
        "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into ref.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A Tensor. Must have the same type as ref. A tensor of\nvalues whose element wise max is taken with ref",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceScatterNdMin",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "An optional bool. Defaults to True. If True, the assignment will\nbe protected by a lock; otherwise the behavior is undefined,\nbut may exhibit less contention.",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "description": "A resource handle. Must be from a VarHandleOp.",
        "type": 20
      },
      {
        "name": "indices",
        "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into ref.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A Tensor. Must have the same type as ref. A tensor of\nvalues whose element wise min is taken with ref.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceScatterNdSub",
    "summary": "Applies sparse subtraction to individual values or slices in a Variable.",
    "description": "`ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.\n\n`indices` must be integer tensor, containing indices into `ref`.\nIt must be shape `[d_0, ..., d_{Q-2}, K]` where `0 < K <= P`.\n\nThe innermost dimension of `indices` (with length `K`) corresponds to\nindices into elements (if `K = P`) or slices (if `K < P`) along the `K`th\ndimension of `ref`.\n\n`updates` is `Tensor` of rank `Q-1+P-K` with shape:\n\n```\n[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]]\n```\n\nFor example, say we want to subtract 4 scattered elements from a rank-1 tensor\nwith 8 elements. In Python, that subtraction would look like this:\n\n```python\nref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8], use_resource=True)\nindices = tf.constant([[4], [3], [1], [7]])\nupdates = tf.constant([9, 10, 11, 12])\nsub = tf.scatter_nd_sub(ref, indices, updates)\nwith tf.Session() as sess:\n  print sess.run(sub)\n```\n\nThe resulting update to ref would look like this:\n\n    [1, -9, 3, -6, -4, 6, 7, -4]\n\nSee `tf.scatter_nd` for more details about how to make updates to\nslices.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "An optional bool. Defaults to True. If True, the assignment will\nbe protected by a lock; otherwise the behavior is undefined,\nbut may exhibit less contention.",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "description": "A resource handle. Must be from a VarHandleOp.",
        "type": 20
      },
      {
        "name": "indices",
        "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into ref.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A Tensor. Must have the same type as ref. A tensor of\nvalues to add to ref.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceScatterNdUpdate",
    "summary": "Applies sparse `updates` to individual values or slices within a given",
    "description": "variable according to `indices`.\n\n`ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.\n\n`indices` must be integer tensor, containing indices into `ref`.\nIt must be shape `[d_0, ..., d_{Q-2}, K]` where `0 < K <= P`.\n\nThe innermost dimension of `indices` (with length `K`) corresponds to\nindices into elements (if `K = P`) or slices (if `K < P`) along the `K`th\ndimension of `ref`.\n\n`updates` is `Tensor` of rank `Q-1+P-K` with shape:\n\n```\n[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].\n```\n\nFor example, say we want to update 4 scattered elements to a rank-1 tensor to\n8 elements. In Python, that update would look like this:\n\n```python\n    ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])\n    indices = tf.constant([[4], [3], [1] ,[7]])\n    updates = tf.constant([9, 10, 11, 12])\n    update = tf.scatter_nd_update(ref, indices, updates)\n    with tf.Session() as sess:\n      print sess.run(update)\n```\n\nThe resulting update to ref would look like this:\n\n    [1, 11, 3, 10, 9, 6, 7, 12]\n\nSee `tf.scatter_nd` for more details about how to make updates to\nslices.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "An optional bool. Defaults to True. If True, the assignment will\nbe protected by a lock; otherwise the behavior is undefined,\nbut may exhibit less contention.",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "description": "A resource handle. Must be from a VarHandleOp.",
        "type": 20
      },
      {
        "name": "indices",
        "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into ref.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A Tensor. Must have the same type as ref. A tensor of updated\nvalues to add to ref.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceScatterSub",
    "summary": "Subtracts sparse updates from the variable referenced by `resource`.",
    "description": "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] -= updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] -= updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] -= updates[i, ..., j, ...]\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions add.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src='https://www.tensorflow.org/images/ScatterAdd.png' alt>\n</div>",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "description": "Should be from a `Variable` node.",
        "type": 20
      },
      {
        "name": "indices",
        "description": "A tensor of indices into the first dimension of `ref`.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A tensor of updated values to add to `ref`.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "ResourceScatterUpdate",
    "summary": "Assigns sparse updates to the variable referenced by `resource`.",
    "description": "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] = updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] = updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] = updates[i, ..., j, ...]",
    "attributes": [
      {
        "name": "dtype",
        "type": "type"
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "description": "Should be from a `Variable` node.",
        "type": 20
      },
      {
        "name": "indices",
        "description": "A tensor of indices into the first dimension of `ref`.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A tensor of updated values to add to `ref`.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "ResourceSparseApplyAdadelta",
    "summary": "var: Should be from a Variable().",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "type": 20
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "accum_update",
        "description": ": Should be from a Variable().",
        "type": 20
      },
      {
        "name": "lr",
        "description": "Learning rate. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "rho",
        "description": "Decay factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "epsilon",
        "description": "Constant factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A vector of indices into the first dimension of var and accum.",
        "typeAttr": "Tindices"
      }
    ]
  },
  {
    "name": "ResourceSparseApplyAdagrad",
    "summary": "Update relevant entries in '*var' and '*accum' according to the adagrad scheme.",
    "description": "That is for rows we have grad for, we update var and accum as follows:\naccum += grad * grad\nvar -= lr * grad * (1 / sqrt(accum))",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "update_slots",
        "type": "boolean",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "lr",
        "description": "Learning rate. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A vector of indices into the first dimension of var and accum.",
        "typeAttr": "Tindices"
      }
    ]
  },
  {
    "name": "ResourceSparseApplyAdagradDA",
    "summary": "Update entries in '*var' and '*accum' according to the proximal adagrad scheme.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "gradient_accumulator",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "gradient_squared_accumulator",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A vector of indices into the first dimension of var and accum.",
        "typeAttr": "Tindices"
      },
      {
        "name": "lr",
        "description": "Learning rate. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l1",
        "description": "L1 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2",
        "description": "L2 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "global_step",
        "description": "Training step number. Must be a scalar.",
        "type": 9
      }
    ]
  },
  {
    "name": "ResourceSparseApplyAdagradV2",
    "summary": "Update relevant entries in '*var' and '*accum' according to the adagrad scheme.",
    "description": "That is for rows we have grad for, we update var and accum as follows:\naccum += grad * grad\nvar -= lr * grad * (1 / sqrt(accum))",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "update_slots",
        "type": "boolean",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "lr",
        "description": "Learning rate. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "epsilon",
        "description": "Constant factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A vector of indices into the first dimension of var and accum.",
        "typeAttr": "Tindices"
      }
    ]
  },
  {
    "name": "ResourceSparseApplyCenteredRMSProp",
    "summary": "Update '*var' according to the centered RMSProp algorithm.",
    "description": "The centered RMSProp algorithm uses an estimate of the centered second moment\n(i.e., the variance) for normalization, as opposed to regular RMSProp, which\nuses the (uncentered) second moment. This often helps with training, but is\nslightly more expensive in terms of computation and memory.\n\nNote that in dense implementation of this algorithm, mg, ms, and mom will\nupdate even if the grad is zero, but in this sparse implementation, mg, ms,\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nmean_grad = decay * mean_grad + (1-decay) * gradient\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)\n\nms <- rho * ms_{t-1} + (1-rho) * grad * grad\nmom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)\nvar <- var - mom",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var, mg, ms, and mom tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "mg",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "ms",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "mom",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "rho",
        "description": "Decay rate. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "momentum",
        "typeAttr": "T"
      },
      {
        "name": "epsilon",
        "description": "Ridge term. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A vector of indices into the first dimension of var, ms and mom.",
        "typeAttr": "Tindices"
      }
    ]
  },
  {
    "name": "ResourceSparseApplyFtrl",
    "summary": "Update relevant entries in '*var' according to the Ftrl-proximal scheme.",
    "description": "That is for rows we have grad for, we update var, accum and linear as follows:\naccum_new = accum + grad * grad\nlinear += grad - (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "multiply_linear_by_lr",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "linear",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A vector of indices into the first dimension of var and accum.",
        "typeAttr": "Tindices"
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l1",
        "description": "L1 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2",
        "description": "L2 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "lr_power",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceSparseApplyFtrlV2",
    "summary": "Update relevant entries in '*var' according to the Ftrl-proximal scheme.",
    "description": "That is for rows we have grad for, we update var, accum and linear as follows:\ngrad_with_shrinkage = grad + 2 * l2_shrinkage * var\naccum_new = accum + grad_with_shrinkage * grad_with_shrinkage\nlinear += grad_with_shrinkage +\n    (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "multiply_linear_by_lr",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "linear",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A vector of indices into the first dimension of var and accum.",
        "typeAttr": "Tindices"
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l1",
        "description": "L1 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2",
        "description": "L2 shrinkage regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2_shrinkage",
        "typeAttr": "T"
      },
      {
        "name": "lr_power",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceSparseApplyKerasMomentum",
    "summary": "Update relevant entries in '*var' and '*accum' according to the momentum scheme.",
    "description": "Set use_nesterov = True if you want to use Nesterov momentum.\n\nThat is for rows we have grad for, we update var and accum as follows:\n\naccum = accum * momentum - lr * grad\nvar += accum",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "use_nesterov",
        "type": "boolean",
        "description": "If `True`, the tensor passed to compute grad will be\nvar + momentum * accum, so in the end, the var you get is actually\nvar + momentum * accum.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "lr",
        "description": "Learning rate. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A vector of indices into the first dimension of var and accum.",
        "typeAttr": "Tindices"
      },
      {
        "name": "momentum",
        "description": "Momentum. Must be a scalar.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceSparseApplyMomentum",
    "summary": "Update relevant entries in '*var' and '*accum' according to the momentum scheme.",
    "description": "Set use_nesterov = True if you want to use Nesterov momentum.\n\nThat is for rows we have grad for, we update var and accum as follows:\n\naccum = accum * momentum + grad\nvar -= lr * accum",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "use_nesterov",
        "type": "boolean",
        "description": "If `True`, the tensor passed to compute grad will be\nvar - lr * momentum * accum, so in the end, the var you get is actually\nvar - lr * momentum * accum.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "lr",
        "description": "Learning rate. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A vector of indices into the first dimension of var and accum.",
        "typeAttr": "Tindices"
      },
      {
        "name": "momentum",
        "description": "Momentum. Must be a scalar.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ResourceSparseApplyProximalAdagrad",
    "summary": "Sparse update entries in '*var' and '*accum' according to FOBOS algorithm.",
    "description": "That is for rows we have grad for, we update var and accum as follows:\naccum += grad * grad\nprox_v = var\nprox_v -= lr * grad * (1 / sqrt(accum))\nvar = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "lr",
        "description": "Learning rate. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l1",
        "description": "L1 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2",
        "description": "L2 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A vector of indices into the first dimension of var and accum.",
        "typeAttr": "Tindices"
      }
    ]
  },
  {
    "name": "ResourceSparseApplyProximalGradientDescent",
    "summary": "Sparse update '*var' as FOBOS algorithm with fixed learning rate.",
    "description": "That is for rows we have grad for, we update var as follows:\nprox_v = var - alpha * grad\nvar = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "alpha",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l1",
        "description": "L1 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2",
        "description": "L2 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A vector of indices into the first dimension of var and accum.",
        "typeAttr": "Tindices"
      }
    ]
  },
  {
    "name": "ResourceSparseApplyRMSProp",
    "summary": "Update '*var' according to the RMSProp algorithm.",
    "description": "Note that in dense implementation of this algorithm, ms and mom will\nupdate even if the grad is zero, but in this sparse implementation, ms\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon)\n\nms <- rho * ms_{t-1} + (1-rho) * grad * grad\nmom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)\nvar <- var - mom",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var, ms, and mom tensors is protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "ms",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "mom",
        "description": "Should be from a Variable().",
        "type": 20
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "rho",
        "description": "Decay rate. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "momentum",
        "typeAttr": "T"
      },
      {
        "name": "epsilon",
        "description": "Ridge term. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A vector of indices into the first dimension of var, ms and mom.",
        "typeAttr": "Tindices"
      }
    ]
  },
  {
    "name": "ResourceStridedSliceAssign",
    "summary": "Assign `value` to the sliced l-value reference of `ref`.",
    "description": "The values of `value` are assigned to the positions in the variable\n`ref` that are selected by the slice parameters. The slice parameters\n`begin, `end`, `strides`, etc. work exactly as in `StridedSlice`.\n\nNOTE this op currently does not support broadcasting and so `value`'s\nshape must be exactly the shape produced by the slice of `ref`.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Index",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "begin_mask",
        "type": "int64",
        "default": 0
      },
      {
        "name": "end_mask",
        "type": "int64",
        "default": 0
      },
      {
        "name": "ellipsis_mask",
        "type": "int64",
        "default": 0
      },
      {
        "name": "new_axis_mask",
        "type": "int64",
        "default": 0
      },
      {
        "name": "shrink_axis_mask",
        "type": "int64",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "type": 20
      },
      {
        "name": "begin",
        "typeAttr": "Index"
      },
      {
        "name": "end",
        "typeAttr": "Index"
      },
      {
        "name": "strides",
        "typeAttr": "Index"
      },
      {
        "name": "value",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Restore",
    "summary": "Restores a tensor from checkpoint files.",
    "description": "Reads a tensor stored in one or several files. If there are several files (for\ninstance because a tensor was saved as slices), `file_pattern` may contain\nwildcard symbols (`*` and `?`) in the filename portion only, not in the\ndirectory portion.\n\nIf a `file_pattern` matches several files, `preferred_shard` can be used to hint\nin which file the requested tensor is likely to be found. This op will first\nopen the file at index `preferred_shard` in the list of matching files and try\nto restore tensors from that file.  Only if some tensors or tensor slices are\nnot found in that first file, then the Op opens all the files. Setting\n`preferred_shard` to match the value passed as the `shard` input\nof a matching `Save` Op may speed up Restore.  This attribute only affects\nperformance, not correctness.  The default value -1 means files are processed in\norder.\n\nSee also `RestoreSlice`.",
    "attributes": [
      {
        "name": "dt",
        "type": "type",
        "description": "The type of the tensor to be restored."
      },
      {
        "name": "preferred_shard",
        "type": "int64",
        "description": "Index of file to open first if multiple files match\n`file_pattern`.",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "file_pattern",
        "description": "Must have a single element. The pattern of the files from\nwhich we read the tensor.",
        "type": 7
      },
      {
        "name": "tensor_name",
        "description": "Must have a single element. The name of the tensor to be\nrestored.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "tensor",
        "description": "The restored tensor.",
        "typeAttr": "dt"
      }
    ]
  },
  {
    "name": "RestoreSlice",
    "summary": "Restores a tensor from checkpoint files.",
    "description": "This is like `Restore` except that restored tensor can be listed as filling\nonly a slice of a larger tensor.  `shape_and_slice` specifies the shape of the\nlarger tensor and the slice that the restored tensor covers.\n\nThe `shape_and_slice` input has the same format as the\nelements of the `shapes_and_slices` input of the `SaveSlices` op.",
    "attributes": [
      {
        "name": "dt",
        "type": "type",
        "description": "The type of the tensor to be restored."
      },
      {
        "name": "preferred_shard",
        "type": "int64",
        "description": "Index of file to open first if multiple files match\n`file_pattern`. See the documentation for `Restore`.",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "file_pattern",
        "description": "Must have a single element. The pattern of the files from\nwhich we read the tensor.",
        "type": 7
      },
      {
        "name": "tensor_name",
        "description": "Must have a single element. The name of the tensor to be\nrestored.",
        "type": 7
      },
      {
        "name": "shape_and_slice",
        "description": "Scalar. The shapes and slice specifications to use when\nrestoring a tensors.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "tensor",
        "description": "The restored tensor.",
        "typeAttr": "dt"
      }
    ]
  },
  {
    "name": "RestoreV2",
    "summary": "Restores tensors from a V2 checkpoint.",
    "description": "For backward compatibility with the V1 format, this Op currently allows\nrestoring from a V1 checkpoint as well:\n  - This Op first attempts to find the V2 index file pointed to by \"prefix\", and\n    if found proceed to read it as a V2 checkpoint;\n  - Otherwise the V1 read path is invoked.\nRelying on this behavior is not recommended, as the ability to fall back to read\nV1 might be deprecated and eventually removed.\n\nBy default, restores the named tensors in full.  If the caller wishes to restore\nspecific slices of stored tensors, \"shape_and_slices\" should be non-empty\nstrings and correspondingly well-formed.\n\nCallers must ensure all the named tensors are indeed stored in the checkpoint.",
    "attributes": [
      {
        "name": "dtypes",
        "type": "type[]",
        "description": "shape {N}.  The list of expected dtype for the tensors.  Must match\nthose stored in the checkpoint.",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "prefix",
        "description": "Must have a single element.  The prefix of a V2 checkpoint.",
        "type": 7
      },
      {
        "name": "tensor_names",
        "description": "shape {N}.  The names of the tensors to be restored.",
        "type": 7
      },
      {
        "name": "shape_and_slices",
        "description": "shape {N}.  The slice specs of the tensors to be restored.\nEmpty strings indicate that they are non-partitioned tensors.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "tensors",
        "description": "shape {N}.  The restored tensors, whose shapes are read from the\ncheckpoint directly.",
        "typeListAttr": "dtypes"
      }
    ]
  },
  {
    "name": "RetrieveAllTPUEmbeddingParameters",
    "summary": "An op that retrieves optimization parameters from embedding to host memory.",
    "description": "An op that retrieves optimization parameters from embedding to host memory.\nMust be preceded by a ConfigureTPUEmbeddingHost op that sets up the correct\nembedding table configuration. For example, this op is used to retrieve updated\nparameters before saving a checkpoint.  For Adagrad, auxiliary1 will contain the\naccumulators after running this op. For SGD, all of the auxiliary* values will\nbe empty (0x0 tensors for that table). For FTRL, auxiliary1 will contain the\naccumulators and auxiliary2 will contain the linear terms. For ADAM, auxiliary1\nwill contain the momenta and auxiliary2 will contain the velocities.",
    "attributes": [
      {
        "name": "NumTables",
        "type": "int64",
        "description": "The number of embedding tables.",
        "minimum": 1
      },
      {
        "name": "config",
        "type": "string",
        "description": "An TPUEmbeddingConfiguration proto describing the\ntable parameters being loaded, serialized to a string."
      },
      {
        "name": "num_shards",
        "type": "int64",
        "description": "Number of shards into which the embedding tables are divided."
      },
      {
        "name": "shard_id",
        "type": "int64",
        "description": "Identifier of shard for this operation."
      }
    ],
    "outputs": [
      {
        "name": "parameters",
        "description": " A list of tensors, one for each embedding table, containing the\nstored embedding table parameters.",
        "numberAttr": "NumTables",
        "type": 1
      },
      {
        "name": "auxiliary1",
        "description": "A list of tensors, one for each embedding table, containing the\nfirst auxiliary optimization parameter stored. Elements are\npresent in the list, but have zero size, for unused optimization parameters\n(based on the algorithm in use for each table).",
        "numberAttr": "NumTables",
        "type": 1
      },
      {
        "name": "auxiliary2",
        "description": "A list of tensors, one for each embedding table, containing the\nsecond auxiliary optimization parameter stored. Elements are\npresent in the list, but have zero size, for unused optimization parameters\n(based on the algorithm in use for each table).",
        "numberAttr": "NumTables",
        "type": 1
      },
      {
        "name": "auxiliary3",
        "description": "A list of tensors, one for each embedding table, containing the\nthird auxiliary optimization parameter stored. Elements are\npresent in the list, but have zero size, for unused optimization parameters\n(based on the algorithm in use for each table).",
        "numberAttr": "NumTables",
        "type": 1
      },
      {
        "name": "auxiliary4",
        "description": "A list of tensors, one for each embedding table, containing the\nfourth auxiliary optimization parameter stored. Elements are\npresent in the list, but have zero size, for unused optimization parameters\n(based on the algorithm in use for each table).",
        "numberAttr": "NumTables",
        "type": 1
      },
      {
        "name": "auxiliary5",
        "description": "A list of tensors, one for each embedding table, containing the\nfifth auxiliary optimization parameter stored. Elements are\npresent in the list, but have zero size, for unused optimization parameters\n(based on the algorithm in use for each table).",
        "numberAttr": "NumTables",
        "type": 1
      },
      {
        "name": "auxiliary6",
        "description": "A list of tensors, one for each embedding table, containing the\nsix auxiliary optimization parameter stored. Elements are\npresent in the list, but have zero size, for unused optimization parameters\n(based on the algorithm in use for each table).",
        "numberAttr": "NumTables",
        "type": 1
      },
      {
        "name": "auxiliary7",
        "description": "A list of tensors, one for each embedding table, containing the\nseventh auxiliary optimization parameter stored. Elements are\npresent in the list, but have zero size, for unused optimization parameters\n(based on the algorithm in use for each table).",
        "numberAttr": "NumTables",
        "type": 1
      }
    ]
  },
  {
    "name": "RetrieveTPUEmbeddingADAMParameters",
    "summary": "Retrieve ADAM embedding parameters.",
    "description": "An op that retrieves optimization parameters from embedding to host\nmemory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\nthe correct embedding table configuration. For example, this op is\nused to retrieve updated parameters before saving a checkpoint.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "parameters",
        "description": "Parameter parameters updated by the ADAM optimization algorithm.",
        "type": 1
      },
      {
        "name": "momenta",
        "description": "Parameter momenta updated by the ADAM optimization algorithm.",
        "type": 1
      },
      {
        "name": "velocities",
        "description": "Parameter velocities updated by the ADAM optimization algorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "RetrieveTPUEmbeddingAdadeltaParameters",
    "summary": "Retrieve Adadelta embedding parameters.",
    "description": "An op that retrieves optimization parameters from embedding to host\nmemory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\nthe correct embedding table configuration. For example, this op is\nused to retrieve updated parameters before saving a checkpoint.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "parameters",
        "description": "Parameter parameters updated by the Adadelta optimization algorithm.",
        "type": 1
      },
      {
        "name": "accumulators",
        "description": "Parameter accumulators updated by the Adadelta optimization algorithm.",
        "type": 1
      },
      {
        "name": "updates",
        "description": "Parameter updates updated by the Adadelta optimization algorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "RetrieveTPUEmbeddingAdagradMomentumParameters",
    "summary": "Retrieve Adagrad Momentum embedding parameters.",
    "description": "An op that retrieves optimization parameters from embedding to host\nmemory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\nthe correct embedding table configuration. For example, this op is\nused to retrieve updated parameters before saving a checkpoint.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "parameters",
        "description": "Parameter parameters updated by the Adagrad Momentum optimization algorithm.",
        "type": 1
      },
      {
        "name": "accumulators",
        "description": "Parameter accumulators updated by the Adagrad Momentum optimization algorithm.",
        "type": 1
      },
      {
        "name": "momenta",
        "description": "Parameter momenta updated by the Adagrad Momentum optimization algorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "RetrieveTPUEmbeddingAdagradParameters",
    "summary": "Retrieve Adagrad embedding parameters.",
    "description": "An op that retrieves optimization parameters from embedding to host\nmemory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\nthe correct embedding table configuration. For example, this op is\nused to retrieve updated parameters before saving a checkpoint.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "parameters",
        "description": "Parameter parameters updated by the Adagrad optimization algorithm.",
        "type": 1
      },
      {
        "name": "accumulators",
        "description": "Parameter accumulators updated by the Adagrad optimization algorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "RetrieveTPUEmbeddingCenteredRMSPropParameters",
    "summary": "Retrieve centered RMSProp embedding parameters.",
    "description": "An op that retrieves optimization parameters from embedding to host\nmemory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\nthe correct embedding table configuration. For example, this op is\nused to retrieve updated parameters before saving a checkpoint.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "parameters",
        "description": "Parameter parameters updated by the centered RMSProp optimization algorithm.",
        "type": 1
      },
      {
        "name": "ms",
        "description": "Parameter ms updated by the centered RMSProp optimization algorithm.",
        "type": 1
      },
      {
        "name": "mom",
        "description": "Parameter mom updated by the centered RMSProp optimization algorithm.",
        "type": 1
      },
      {
        "name": "mg",
        "description": "Parameter mg updated by the centered RMSProp optimization algorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "RetrieveTPUEmbeddingFTRLParameters",
    "summary": "Retrieve FTRL embedding parameters.",
    "description": "An op that retrieves optimization parameters from embedding to host\nmemory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\nthe correct embedding table configuration. For example, this op is\nused to retrieve updated parameters before saving a checkpoint.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "parameters",
        "description": "Parameter parameters updated by the FTRL optimization algorithm.",
        "type": 1
      },
      {
        "name": "accumulators",
        "description": "Parameter accumulators updated by the FTRL optimization algorithm.",
        "type": 1
      },
      {
        "name": "linears",
        "description": "Parameter linears updated by the FTRL optimization algorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "RetrieveTPUEmbeddingFrequencyEstimatorParameters",
    "summary": "Retrieve frequency estimator embedding parameters.",
    "description": "An op that retrieves optimization parameters from embedding to host\nmemory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\nthe correct embedding table configuration. For example, this op is\nused to retrieve updated parameters before saving a checkpoint.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "parameters",
        "description": "Parameter parameters updated by the frequency estimator optimization algorithm.",
        "type": 1
      },
      {
        "name": "last_hit_step",
        "description": "Parameter last_hit_step updated by the frequency estimator optimization\nalgorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "RetrieveTPUEmbeddingMDLAdagradLightParameters",
    "summary": "Retrieve MDL Adagrad Light embedding parameters.",
    "description": "An op that retrieves optimization parameters from embedding to host\nmemory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\nthe correct embedding table configuration. For example, this op is\nused to retrieve updated parameters before saving a checkpoint.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "parameters",
        "description": "Parameter parameters updated by the MDL Adagrad Light optimization algorithm.",
        "type": 1
      },
      {
        "name": "accumulators",
        "description": "Parameter accumulators updated by the MDL Adagrad Light optimization algorithm.",
        "type": 1
      },
      {
        "name": "weights",
        "description": "Parameter weights updated by the MDL Adagrad Light optimization algorithm.",
        "type": 1
      },
      {
        "name": "benefits",
        "description": "Parameter benefits updated by the MDL Adagrad Light optimization algorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "RetrieveTPUEmbeddingMomentumParameters",
    "summary": "Retrieve Momentum embedding parameters.",
    "description": "An op that retrieves optimization parameters from embedding to host\nmemory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\nthe correct embedding table configuration. For example, this op is\nused to retrieve updated parameters before saving a checkpoint.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "parameters",
        "description": "Parameter parameters updated by the Momentum optimization algorithm.",
        "type": 1
      },
      {
        "name": "momenta",
        "description": "Parameter momenta updated by the Momentum optimization algorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "RetrieveTPUEmbeddingProximalAdagradParameters",
    "summary": "Retrieve proximal Adagrad embedding parameters.",
    "description": "An op that retrieves optimization parameters from embedding to host\nmemory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\nthe correct embedding table configuration. For example, this op is\nused to retrieve updated parameters before saving a checkpoint.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "parameters",
        "description": "Parameter parameters updated by the proximal Adagrad optimization algorithm.",
        "type": 1
      },
      {
        "name": "accumulators",
        "description": "Parameter accumulators updated by the proximal Adagrad optimization algorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "RetrieveTPUEmbeddingProximalYogiParameters",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "parameters",
        "type": 1
      },
      {
        "name": "v",
        "type": 1
      },
      {
        "name": "m",
        "type": 1
      }
    ]
  },
  {
    "name": "RetrieveTPUEmbeddingRMSPropParameters",
    "summary": "Retrieve RMSProp embedding parameters.",
    "description": "An op that retrieves optimization parameters from embedding to host\nmemory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\nthe correct embedding table configuration. For example, this op is\nused to retrieve updated parameters before saving a checkpoint.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "parameters",
        "description": "Parameter parameters updated by the RMSProp optimization algorithm.",
        "type": 1
      },
      {
        "name": "ms",
        "description": "Parameter ms updated by the RMSProp optimization algorithm.",
        "type": 1
      },
      {
        "name": "mom",
        "description": "Parameter mom updated by the RMSProp optimization algorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "RetrieveTPUEmbeddingStochasticGradientDescentParameters",
    "summary": "Retrieve SGD embedding parameters.",
    "description": "An op that retrieves optimization parameters from embedding to host\nmemory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\nthe correct embedding table configuration. For example, this op is\nused to retrieve updated parameters before saving a checkpoint.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "default": -1
      },
      {
        "name": "table_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "num_shards",
        "type": "int64"
      },
      {
        "name": "shard_id",
        "type": "int64"
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "parameters",
        "description": "Parameter parameters updated by the stochastic gradient descent optimization algorithm.",
        "type": 1
      }
    ]
  },
  {
    "name": "Reverse",
    "summary": "Reverses specific dimensions of a tensor.",
    "description": "Given a `tensor`, and a `bool` tensor `dims` representing the dimensions\nof `tensor`, this operation reverses each dimension i of `tensor` where\n`dims[i]` is `True`.\n\n`tensor` can have up to 8 dimensions. The number of dimensions\nof `tensor` must equal the number of elements in `dims`. In other words:\n\n`rank(tensor) = size(dims)`\n\nFor example:\n\n```\n# tensor 't' is [[[[ 0,  1,  2,  3],\n#                  [ 4,  5,  6,  7],\n#                  [ 8,  9, 10, 11]],\n#                 [[12, 13, 14, 15],\n#                  [16, 17, 18, 19],\n#                  [20, 21, 22, 23]]]]\n# tensor 't' shape is [1, 2, 3, 4]\n\n# 'dims' is [False, False, False, True]\nreverse(t, dims) ==> [[[[ 3,  2,  1,  0],\n                        [ 7,  6,  5,  4],\n                        [ 11, 10, 9, 8]],\n                       [[15, 14, 13, 12],\n                        [19, 18, 17, 16],\n                        [23, 22, 21, 20]]]]\n\n# 'dims' is [False, True, False, False]\nreverse(t, dims) ==> [[[[12, 13, 14, 15],\n                        [16, 17, 18, 19],\n                        [20, 21, 22, 23]\n                       [[ 0,  1,  2,  3],\n                        [ 4,  5,  6,  7],\n                        [ 8,  9, 10, 11]]]]\n\n# 'dims' is [False, False, True, False]\nreverse(t, dims) ==> [[[[8, 9, 10, 11],\n                        [4, 5, 6, 7],\n                        [0, 1, 2, 3]]\n                       [[20, 21, 22, 23],\n                        [16, 17, 18, 19],\n                        [12, 13, 14, 15]]]]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `uint8`, `int8`, `uint16`, `int16`, `uint32`, `int32`, `uint64`, `int64`, `bool`, `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`, `string`."
      }
    ],
    "inputs": [
      {
        "name": "tensor",
        "description": "Up to 8-D.",
        "typeAttr": "T"
      },
      {
        "name": "dims",
        "description": "1-D. The dimensions to reverse.",
        "type": 10
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The same shape as `tensor`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ReverseSequence",
    "summary": "Reverses variable length slices.",
    "description": "This op first slices `input` along the dimension `batch_dim`, and for each\nslice `i`, reverses the first `seq_lengths[i]` elements along\nthe dimension `seq_dim`.\n\nThe elements of `seq_lengths` must obey `seq_lengths[i] <= input.dims[seq_dim]`,\nand `seq_lengths` must be a vector of length `input.dims[batch_dim]`.\n\nThe output slice `i` along dimension `batch_dim` is then given by input\nslice `i`, with the first `seq_lengths[i]` slices along dimension\n`seq_dim` reversed.\n\nFor example:\n\n```\n# Given this:\nbatch_dim = 0\nseq_dim = 1\ninput.dims = (4, 8, ...)\nseq_lengths = [7, 2, 3, 5]\n\n# then slices of input are reversed on seq_dim, but only up to seq_lengths:\noutput[0, 0:7, :, ...] = input[0, 7:0:-1, :, ...]\noutput[1, 0:2, :, ...] = input[1, 2:0:-1, :, ...]\noutput[2, 0:3, :, ...] = input[2, 3:0:-1, :, ...]\noutput[3, 0:5, :, ...] = input[3, 5:0:-1, :, ...]\n\n# while entries past seq_lens are copied through:\noutput[0, 7:, :, ...] = input[0, 7:, :, ...]\noutput[1, 2:, :, ...] = input[1, 2:, :, ...]\noutput[2, 3:, :, ...] = input[2, 3:, :, ...]\noutput[3, 2:, :, ...] = input[3, 2:, :, ...]\n```\n\nIn contrast, if:\n\n```\n# Given this:\nbatch_dim = 2\nseq_dim = 0\ninput.dims = (8, ?, 4, ...)\nseq_lengths = [7, 2, 3, 5]\n\n# then slices of input are reversed on seq_dim, but only up to seq_lengths:\noutput[0:7, :, 0, :, ...] = input[7:0:-1, :, 0, :, ...]\noutput[0:2, :, 1, :, ...] = input[2:0:-1, :, 1, :, ...]\noutput[0:3, :, 2, :, ...] = input[3:0:-1, :, 2, :, ...]\noutput[0:5, :, 3, :, ...] = input[5:0:-1, :, 3, :, ...]\n\n# while entries past seq_lens are copied through:\noutput[7:, :, 0, :, ...] = input[7:, :, 0, :, ...]\noutput[2:, :, 1, :, ...] = input[2:, :, 1, :, ...]\noutput[3:, :, 2, :, ...] = input[3:, :, 2, :, ...]\noutput[2:, :, 3, :, ...] = input[2:, :, 3, :, ...]\n```",
    "attributes": [
      {
        "name": "seq_dim",
        "type": "int64",
        "description": "The dimension which is partially reversed."
      },
      {
        "name": "batch_dim",
        "type": "int64",
        "description": "The dimension along which reversal is performed.",
        "default": 0
      },
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tlen",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The input to reverse.",
        "typeAttr": "T"
      },
      {
        "name": "seq_lengths",
        "description": "1-D with length `input.dims(batch_dim)` and\n`max(seq_lengths) <= input.dims(seq_dim)`",
        "typeAttr": "Tlen"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The partially reversed input. It has the same shape as `input`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ReverseV2",
    "summary": "Reverses specific dimensions of a tensor.",
    "description": "Given a `tensor`, and a `int32` tensor `axis` representing the set of\ndimensions of `tensor` to reverse. This operation reverses each dimension\n`i` for which there exists `j` s.t. `axis[j] == i`.\n\n`tensor` can have up to 8 dimensions. The number of dimensions specified\nin `axis` may be 0 or more entries. If an index is specified more than\nonce, a InvalidArgument error is raised.\n\nFor example:\n\n```\n# tensor 't' is [[[[ 0,  1,  2,  3],\n#                  [ 4,  5,  6,  7],\n#                  [ 8,  9, 10, 11]],\n#                 [[12, 13, 14, 15],\n#                  [16, 17, 18, 19],\n#                  [20, 21, 22, 23]]]]\n# tensor 't' shape is [1, 2, 3, 4]\n\n# 'dims' is [3] or 'dims' is [-1]\nreverse(t, dims) ==> [[[[ 3,  2,  1,  0],\n                        [ 7,  6,  5,  4],\n                        [ 11, 10, 9, 8]],\n                       [[15, 14, 13, 12],\n                        [19, 18, 17, 16],\n                        [23, 22, 21, 20]]]]\n\n# 'dims' is '[1]' (or 'dims' is '[-3]')\nreverse(t, dims) ==> [[[[12, 13, 14, 15],\n                        [16, 17, 18, 19],\n                        [20, 21, 22, 23]\n                       [[ 0,  1,  2,  3],\n                        [ 4,  5,  6,  7],\n                        [ 8,  9, 10, 11]]]]\n\n# 'dims' is '[2]' (or 'dims' is '[-2]')\nreverse(t, dims) ==> [[[[8, 9, 10, 11],\n                        [4, 5, 6, 7],\n                        [0, 1, 2, 3]]\n                       [[20, 21, 22, 23],\n                        [16, 17, 18, 19],\n                        [12, 13, 14, 15]]]]\n```",
    "attributes": [
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `uint8`, `int8`, `uint16`, `int16`, `int32`, `uint32`, `int64`, `uint64`, `bool`, `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`, `string`."
      }
    ],
    "inputs": [
      {
        "name": "tensor",
        "description": "Up to 8-D.",
        "typeAttr": "T"
      },
      {
        "name": "axis",
        "description": "1-D. The indices of the dimensions to reverse. Must be in the range\n`[-rank(tensor), rank(tensor))`.",
        "typeAttr": "Tidx"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The same shape as `tensor`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RewriteDataset",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "rewrite_name",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "RightShift",
    "summary": "Elementwise computes the bitwise right-shift of `x` and `y`.",
    "description": "Performs a logical shift for unsigned integer types, and an arithmetic shift\nfor signed integer types.\n\nIf `y` is negative, or greater than or equal to than the width of `x` in bits\nthe result is implementation defined.\n\nExample:\n\n```python\nimport tensorflow as tf\nfrom tensorflow.python.ops import bitwise_ops\nimport numpy as np\ndtype_list = [tf.int8, tf.int16, tf.int32, tf.int64]\n\nfor dtype in dtype_list:\n  lhs = tf.constant([-1, -5, -3, -14], dtype=dtype)\n  rhs = tf.constant([5, 0, 7, 11], dtype=dtype)\n\n  right_shift_result = bitwise_ops.right_shift(lhs, rhs)\n\n  print(right_shift_result)\n\n# This will print:\n# tf.Tensor([-1 -5 -1 -1], shape=(4,), dtype=int8)\n# tf.Tensor([-1 -5 -1 -1], shape=(4,), dtype=int16)\n# tf.Tensor([-1 -5 -1 -1], shape=(4,), dtype=int32)\n# tf.Tensor([-1 -5 -1 -1], shape=(4,), dtype=int64)\n\nlhs = np.array([-2, 64, 101, 32], dtype=np.int8)\nrhs = np.array([-1, -5, -3, -14], dtype=np.int8)\nbitwise_ops.right_shift(lhs, rhs)\n# <tf.Tensor: shape=(4,), dtype=int8, numpy=array([ -2,  64, 101,  32], dtype=int8)>\n```\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Rint",
    "summary": "Returns element-wise integer closest to x.",
    "description": "If the result is midway between two representable values,\nthe even representable is chosen.\nFor example:\n\n```\nrint(-1.5) ==> -2.0\nrint(0.5000001) ==> 1.0\nrint([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) ==> [-2., -2., -0., 0., 2., 2., 2.]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscAbs",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscAdd",
    "summary": "Returns x + y element-wise.",
    "description": "*NOTE*: `RiscAdd` does not supports broadcasting.\n\nGiven two input tensors, the `tf.risc_add` operation computes the sum for every element in the tensor.\n\nBoth input and output have a range `(-inf, inf)`.\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscBinaryArithmetic",
    "attributes": [
      {
        "name": "op_type",
        "type": "string",
        "description": "Must be one of the following: `ADD`, `SUB`, `MUL`, `DIV`, `REM`, `MIN`, `POW`."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscBinaryComparison",
    "attributes": [
      {
        "name": "op_type",
        "type": "string",
        "description": "Must be one of the following: `EQ`, `NE`, `GE`, `GT`, `LE`, `LT`."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "type": 10
      }
    ]
  },
  {
    "name": "RiscBitcast",
    "attributes": [
      {
        "name": "SrcT",
        "type": "type"
      },
      {
        "name": "DstT",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "SrcT"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "DstT"
      }
    ]
  },
  {
    "name": "RiscBroadcast",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "shape",
        "typeAttr": "Tidx"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscCast",
    "attributes": [
      {
        "name": "SrcT",
        "type": "type"
      },
      {
        "name": "DstT",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "SrcT"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "DstT"
      }
    ]
  },
  {
    "name": "RiscCeil",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscCholesky",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscConcat",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 2
      },
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "values",
        "numberAttr": "N",
        "typeAttr": "T"
      },
      {
        "name": "axis",
        "typeAttr": "Tidx"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscCondition",
    "attributes": [
      {
        "name": "func_true",
        "type": "function"
      },
      {
        "name": "func_false",
        "type": "function"
      },
      {
        "name": "SrcT",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "DstT",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "pred",
        "type": 10
      },
      {
        "name": "input_true",
        "typeAttr": "SrcT"
      },
      {
        "name": "input_false",
        "typeAttr": "SrcT"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "DstT"
      }
    ]
  },
  {
    "name": "RiscConv",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "strides",
        "type": "int64[]"
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "Must be one of the following: `NHWC`, `NCHW`.",
        "default": "NHWC"
      },
      {
        "name": "dilations",
        "type": "int64[]",
        "default": [
          1,
          1,
          1,
          1
        ]
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "filter",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscCos",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscDiv",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscDot",
    "attributes": [
      {
        "name": "transpose_a",
        "type": "boolean",
        "default": false
      },
      {
        "name": "transpose_b",
        "type": "boolean",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "a",
        "typeAttr": "T"
      },
      {
        "name": "b",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "product",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscExp",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscFft",
    "attributes": [
      {
        "name": "Tcomplex",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "Tcomplex"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "Tcomplex"
      }
    ]
  },
  {
    "name": "RiscFloor",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscGather",
    "attributes": [
      {
        "name": "batch_dims",
        "type": "int64",
        "default": 0
      },
      {
        "name": "Tparams",
        "type": "type"
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "Taxis",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "params",
        "typeAttr": "Tparams"
      },
      {
        "name": "indices",
        "typeAttr": "Tindices"
      },
      {
        "name": "axis",
        "typeAttr": "Taxis"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "Tparams"
      }
    ]
  },
  {
    "name": "RiscImag",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      },
      {
        "name": "Tout",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "RiscIsFinite",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "type": 10
      }
    ]
  },
  {
    "name": "RiscLog",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscLogicalAnd",
    "inputs": [
      {
        "name": "x",
        "type": 10
      },
      {
        "name": "y",
        "type": 10
      }
    ],
    "outputs": [
      {
        "name": "z",
        "type": 10
      }
    ]
  },
  {
    "name": "RiscLogicalNot",
    "inputs": [
      {
        "name": "x",
        "type": 10
      }
    ],
    "outputs": [
      {
        "name": "z",
        "type": 10
      }
    ]
  },
  {
    "name": "RiscLogicalOr",
    "inputs": [
      {
        "name": "x",
        "type": 10
      },
      {
        "name": "y",
        "type": 10
      }
    ],
    "outputs": [
      {
        "name": "z",
        "type": 10
      }
    ]
  },
  {
    "name": "RiscMax",
    "summary": "Returns max(x, y) element-wise.",
    "description": "*NOTE*: `RiscMax` does not supports broadcasting.\n\nGiven two input tensors, the `tf.risc_max` operation computes the maximum for every element in the tensor.\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "max",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscMin",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscMul",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscNeg",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscPad",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "Tpaddings",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "paddings",
        "typeAttr": "Tpaddings"
      },
      {
        "name": "constant_values",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscPool",
    "attributes": [
      {
        "name": "ksize",
        "type": "int64[]",
        "minimum": 4
      },
      {
        "name": "strides",
        "type": "int64[]",
        "minimum": 4
      },
      {
        "name": "pooling_type",
        "type": "string",
        "description": "Must be one of the following: `AVG`, `MAX`."
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "Must be one of the following: `NHWC`, `NCHW`.",
        "default": "NHWC"
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "value",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscPow",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscRandomUniform",
    "attributes": [
      {
        "name": "seed",
        "type": "int64",
        "default": 0
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 1
      }
    ]
  },
  {
    "name": "RiscReal",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `complex64`, `complex128`.",
        "default": {
          "type": "type",
          "value": 8
        }
      },
      {
        "name": "Tout",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "RiscReduce",
    "attributes": [
      {
        "name": "reduce_type",
        "type": "string",
        "description": "Must be one of the following: `MEAN`, `SUM`."
      },
      {
        "name": "Index",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "tensor",
        "typeAttr": "T"
      },
      {
        "name": "axis",
        "typeAttr": "Index"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscRem",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscReshape",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "Tshape",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "tensor",
        "typeAttr": "T"
      },
      {
        "name": "shape",
        "typeAttr": "Tshape"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscReverse",
    "attributes": [
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "tensor",
        "typeAttr": "T"
      },
      {
        "name": "axis",
        "typeAttr": "Tidx"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscScatter",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "indices",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "typeAttr": "T"
      },
      {
        "name": "shape",
        "typeAttr": "Tindices"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscShape",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "out_type"
      }
    ]
  },
  {
    "name": "RiscSign",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscSlice",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "Index",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "begin",
        "typeAttr": "Index"
      },
      {
        "name": "size",
        "typeAttr": "Index"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscSort",
    "attributes": [
      {
        "name": "Index",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "direction",
        "type": "string",
        "description": "Must be one of the following: `ASCENDING`, `DESCENDING`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "axis",
        "typeAttr": "Index"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscSqueeze",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "squeeze_dims",
        "type": "int64[]",
        "minimum": 0,
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscSub",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscTranspose",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tperm",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "perm",
        "typeAttr": "Tperm"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscTriangularSolve",
    "attributes": [
      {
        "name": "lower",
        "type": "boolean",
        "default": true
      },
      {
        "name": "adjoint",
        "type": "boolean",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "matrix",
        "typeAttr": "T"
      },
      {
        "name": "rhs",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscUnary",
    "attributes": [
      {
        "name": "op_type",
        "type": "string",
        "description": "Must be one of the following: `ABL`, `CEIL`, `COS`, `EXP`, `FLOOR`, `IMAG`, `LOG`, `NEG`, `REAL`, `SIGN`."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RiscWhile",
    "attributes": [
      {
        "name": "T",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "cond",
        "type": "function"
      },
      {
        "name": "body",
        "type": "function"
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "default": []
      },
      {
        "name": "parallel_iterations",
        "type": "int64",
        "default": 10
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeListAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeListAttr": "T"
      }
    ]
  },
  {
    "name": "RngReadAndSkip",
    "summary": "Advance the counter of a counter-based RNG.",
    "description": "The state of the RNG after\n`rng_read_and_skip(n)` will be the same as that after `uniform([n])`\n(or any other distribution). The actual increment added to the\ncounter is an unspecified implementation choice.\n\nIn the case that the input algorithm is RNG_ALG_AUTO_SELECT, the counter in the state needs to be of size int64[2], the current maximal counter size among algorithms. In this case, this op will manage the counter as if it is an 128-bit integer with layout [lower_64bits, higher_64bits]. If an algorithm needs less than 128 bits for the counter, it should use the left portion of the int64[2]. In this way, the int64[2] is compatible with all current RNG algorithms (Philox, ThreeFry and xla::RandomAlgorithm::RNG_DEFAULT). Downstream RNG ops can thus use this counter with any RNG algorithm.",
    "inputs": [
      {
        "name": "resource",
        "description": "The handle of the resource variable that stores the state of the RNG. The state consists of the counter followed by the key.",
        "type": 20
      },
      {
        "name": "alg",
        "description": "The RNG algorithm.",
        "type": 3
      },
      {
        "name": "delta",
        "description": "The amount of advancement.",
        "type": 23
      }
    ],
    "outputs": [
      {
        "name": "value",
        "description": "The old value of the resource variable, before incrementing. Since state size is algorithm-dependent, this output will be right-padded with zeros to reach shape int64[3] (the current maximal state size among algorithms).",
        "type": 9
      }
    ]
  },
  {
    "name": "RngSkip",
    "summary": "Advance the counter of a counter-based RNG.",
    "description": "The state of the RNG after\n`rng_skip(n)` will be the same as that after `stateful_uniform([n])`\n(or any other distribution). The actual increment added to the\ncounter is an unspecified implementation detail.",
    "inputs": [
      {
        "name": "resource",
        "description": "The handle of the resource variable that stores the state of the RNG.",
        "type": 20
      },
      {
        "name": "algorithm",
        "description": "The RNG algorithm.",
        "type": 9
      },
      {
        "name": "delta",
        "description": "The amount of advancement.",
        "type": 9
      }
    ]
  },
  {
    "name": "Roll",
    "summary": "Rolls the elements of a tensor along an axis.",
    "description": "The elements are shifted positively (towards larger indices) by the offset of\n`shift` along the dimension of `axis`. Negative `shift` values will shift\nelements in the opposite direction. Elements that roll passed the last position\nwill wrap around to the first and vice versa. Multiple shifts along multiple\naxes may be specified.\n\nFor example:\n\n```\n# 't' is [0, 1, 2, 3, 4]\nroll(t, shift=2, axis=0) ==> [3, 4, 0, 1, 2]\n\n# shifting along multiple dimensions\n# 't' is [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]\nroll(t, shift=[1, -2], axis=[0, 1]) ==> [[7, 8, 9, 5, 6], [2, 3, 4, 0, 1]]\n\n# shifting along the same axis multiple times\n# 't' is [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]\nroll(t, shift=[2, -3], axis=[1, 1]) ==> [[1, 2, 3, 4, 0], [6, 7, 8, 9, 5]]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tshift",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "Taxis",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "shift",
        "description": "Dimension must be 0-D or 1-D. `shift[i]` specifies the number of places by which\nelements are shifted positively (towards larger indices) along the dimension\nspecified by `axis[i]`. Negative shifts will roll the elements in the opposite\ndirection.",
        "typeAttr": "Tshift"
      },
      {
        "name": "axis",
        "description": "Dimension must be 0-D or 1-D. `axis[i]` specifies the dimension that the shift\n`shift[i]` should occur. If the same axis is referenced more than once, the\ntotal shift for that axis will be the sum of all the shifts that belong to that\naxis.",
        "typeAttr": "Taxis"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Has the same shape and size as the input. The elements are shifted\npositively (towards larger indices) by the offsets of `shift` along the\ndimensions of `axis`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Round",
    "summary": "Rounds the values of a tensor to the nearest integer, element-wise.",
    "description": "Rounds half to even.  Also known as bankers rounding. If you want to round\naccording to the current system rounding mode use std::cint.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `int8`, `int16`, `int32`, `int64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Rsqrt",
    "summary": "Computes reciprocal of square root of x element-wise.",
    "description": "I.e., \\\\(y = 1 / \\sqrt{x}\\\\).",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "RsqrtGrad",
    "summary": "Computes the gradient for the rsqrt of `x` wrt its input.",
    "description": "Specifically, `grad = dy * -0.5 * y^3`, where `y = rsqrt(x)`, and `dy`\nis the corresponding input gradient.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "y",
        "typeAttr": "T"
      },
      {
        "name": "dy",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SampleDistortedBoundingBox",
    "summary": "Generate a single randomly distorted bounding box for an image.",
    "description": "Bounding box annotations are often supplied in addition to ground-truth labels\nin image recognition or object localization tasks. A common technique for\ntraining such a system is to randomly distort an image while preserving\nits content, i.e. *data augmentation*. This Op outputs a randomly distorted\nlocalization of an object, i.e. bounding box, given an `image_size`,\n`bounding_boxes` and a series of constraints.\n\nThe output of this Op is a single bounding box that may be used to crop the\noriginal image. The output is returned as 3 tensors: `begin`, `size` and\n`bboxes`. The first 2 tensors can be fed directly into `tf.slice` to crop the\nimage. The latter may be supplied to `tf.image.draw_bounding_boxes` to visualize\nwhat the bounding box looks like.\n\nBounding boxes are supplied and returned as `[y_min, x_min, y_max, x_max]`. The\nbounding box coordinates are floats in `[0.0, 1.0]` relative to the width and\nheight of the underlying image.\n\nFor example,\n\n```python\n    # Generate a single distorted bounding box.\n    begin, size, bbox_for_draw = tf.image.sample_distorted_bounding_box(\n        tf.shape(image),\n        bounding_boxes=bounding_boxes)\n\n    # Draw the bounding box in an image summary.\n    image_with_box = tf.image.draw_bounding_boxes(tf.expand_dims(image, 0),\n                                                  bbox_for_draw)\n    tf.summary.image('images_with_box', image_with_box)\n\n    # Employ the bounding box to distort the image.\n    distorted_image = tf.slice(image, begin, size)\n```\n\nNote that if no bounding box information is available, setting\n`use_image_if_no_bounding_boxes = true` will assume there is a single implicit\nbounding box covering the whole image. If `use_image_if_no_bounding_boxes` is\nfalse and no bounding boxes are supplied, an error is raised.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `uint8`, `int8`, `int16`, `int32`, `int64`."
      },
      {
        "name": "seed",
        "type": "int64",
        "description": "If either `seed` or `seed2` are set to non-zero, the random number\ngenerator is seeded by the given `seed`.  Otherwise, it is seeded by a random\nseed.",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "description": "A second seed to avoid seed collision.",
        "default": 0
      },
      {
        "name": "min_object_covered",
        "type": "float32",
        "description": "The cropped area of the image must contain at least this\nfraction of any bounding box supplied. The value of this parameter should be\nnon-negative. In the case of 0, the cropped area does not need to overlap\nany of the bounding boxes supplied.",
        "default": 0.10000000149011612
      },
      {
        "name": "aspect_ratio_range",
        "type": "float32[]",
        "description": "The cropped area of the image must have an aspect ratio =\nwidth / height within this range.",
        "default": [
          0.75,
          1.3300000429153442
        ]
      },
      {
        "name": "area_range",
        "type": "float32[]",
        "description": "The cropped area of the image must contain a fraction of the\nsupplied image within this range.",
        "default": [
          0.05000000074505806,
          1.0
        ]
      },
      {
        "name": "max_attempts",
        "type": "int64",
        "description": "Number of attempts at generating a cropped region of the image\nof the specified constraints. After `max_attempts` failures, return the entire\nimage.",
        "default": 100
      },
      {
        "name": "use_image_if_no_bounding_boxes",
        "type": "boolean",
        "description": "Controls behavior if no bounding boxes supplied.\nIf true, assume an implicit bounding box covering the whole input. If false,\nraise an error.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "image_size",
        "description": "1-D, containing `[height, width, channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "bounding_boxes",
        "description": "3-D with shape `[batch, N, 4]` describing the N bounding boxes\nassociated with the image.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "begin",
        "description": "1-D, containing `[offset_height, offset_width, 0]`. Provide as input to\n`tf.slice`.",
        "typeAttr": "T"
      },
      {
        "name": "size",
        "description": "1-D, containing `[target_height, target_width, -1]`. Provide as input to\n`tf.slice`.",
        "typeAttr": "T"
      },
      {
        "name": "bboxes",
        "description": "3-D with shape `[1, 1, 4]` containing the distorted bounding box.\nProvide as input to `tf.image.draw_bounding_boxes`.",
        "type": 1
      }
    ]
  },
  {
    "name": "SampleDistortedBoundingBoxV2",
    "summary": "Generate a single randomly distorted bounding box for an image.",
    "description": "Bounding box annotations are often supplied in addition to ground-truth labels\nin image recognition or object localization tasks. A common technique for\ntraining such a system is to randomly distort an image while preserving\nits content, i.e. *data augmentation*. This Op outputs a randomly distorted\nlocalization of an object, i.e. bounding box, given an `image_size`,\n`bounding_boxes` and a series of constraints.\n\nThe output of this Op is a single bounding box that may be used to crop the\noriginal image. The output is returned as 3 tensors: `begin`, `size` and\n`bboxes`. The first 2 tensors can be fed directly into `tf.slice` to crop the\nimage. The latter may be supplied to `tf.image.draw_bounding_boxes` to visualize\nwhat the bounding box looks like.\n\nBounding boxes are supplied and returned as `[y_min, x_min, y_max, x_max]`. The\nbounding box coordinates are floats in `[0.0, 1.0]` relative to the width and\nheight of the underlying image.\n\nFor example,\n\n```python\n    # Generate a single distorted bounding box.\n    begin, size, bbox_for_draw = tf.image.sample_distorted_bounding_box(\n        tf.shape(image),\n        bounding_boxes=bounding_boxes)\n\n    # Draw the bounding box in an image summary.\n    image_with_box = tf.image.draw_bounding_boxes(tf.expand_dims(image, 0),\n                                                  bbox_for_draw)\n    tf.summary.image('images_with_box', image_with_box)\n\n    # Employ the bounding box to distort the image.\n    distorted_image = tf.slice(image, begin, size)\n```\n\nNote that if no bounding box information is available, setting\n`use_image_if_no_bounding_boxes = true` will assume there is a single implicit\nbounding box covering the whole image. If `use_image_if_no_bounding_boxes` is\nfalse and no bounding boxes are supplied, an error is raised.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `uint8`, `int8`, `int16`, `int32`, `int64`."
      },
      {
        "name": "seed",
        "type": "int64",
        "description": "If either `seed` or `seed2` are set to non-zero, the random number\ngenerator is seeded by the given `seed`.  Otherwise, it is seeded by a random\nseed.",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "description": "A second seed to avoid seed collision.",
        "default": 0
      },
      {
        "name": "aspect_ratio_range",
        "type": "float32[]",
        "description": "The cropped area of the image must have an aspect ratio =\nwidth / height within this range.",
        "default": [
          0.75,
          1.3300000429153442
        ]
      },
      {
        "name": "area_range",
        "type": "float32[]",
        "description": "The cropped area of the image must contain a fraction of the\nsupplied image within this range.",
        "default": [
          0.05000000074505806,
          1.0
        ]
      },
      {
        "name": "max_attempts",
        "type": "int64",
        "description": "Number of attempts at generating a cropped region of the image\nof the specified constraints. After `max_attempts` failures, return the entire\nimage.",
        "default": 100
      },
      {
        "name": "use_image_if_no_bounding_boxes",
        "type": "boolean",
        "description": "Controls behavior if no bounding boxes supplied.\nIf true, assume an implicit bounding box covering the whole input. If false,\nraise an error.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "image_size",
        "description": "1-D, containing `[height, width, channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "bounding_boxes",
        "description": "3-D with shape `[batch, N, 4]` describing the N bounding boxes\nassociated with the image.",
        "type": 1
      },
      {
        "name": "min_object_covered",
        "description": "The cropped area of the image must contain at least this\nfraction of any bounding box supplied. The value of this parameter should be\nnon-negative. In the case of 0, the cropped area does not need to overlap\nany of the bounding boxes supplied.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "begin",
        "description": "1-D, containing `[offset_height, offset_width, 0]`. Provide as input to\n`tf.slice`.",
        "typeAttr": "T"
      },
      {
        "name": "size",
        "description": "1-D, containing `[target_height, target_width, -1]`. Provide as input to\n`tf.slice`.",
        "typeAttr": "T"
      },
      {
        "name": "bboxes",
        "description": "3-D with shape `[1, 1, 4]` containing the distorted bounding box.\nProvide as input to `tf.image.draw_bounding_boxes`.",
        "type": 1
      }
    ]
  },
  {
    "name": "SamplingDataset",
    "summary": "Creates a dataset that takes a Bernoulli sample of the contents of another dataset.",
    "description": "There is no transformation in the `tf.data` Python API for creating this dataset.\nInstead, it is created as a result of the `filter_with_random_uniform_fusion`\nstatic optimization. Whether this optimization is performed is determined by the\n`experimental_optimization.filter_with_random_uniform_fusion` option of\n`tf.data.Options`.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "rate",
        "description": "A scalar representing the sample rate. Each element of `input_dataset` is\nretained with this probability, independent of all other elements.",
        "type": 1
      },
      {
        "name": "seed",
        "description": "A scalar representing seed of random number generator.",
        "type": 9
      },
      {
        "name": "seed2",
        "description": "A scalar representing seed2 of random number generator.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "Save",
    "summary": "Saves the input tensors to disk.",
    "description": "The size of `tensor_names` must match the number of tensors in `data`. `data[i]`\nis written to `filename` with name `tensor_names[i]`.\n\nSee also `SaveSlices`.",
    "attributes": [
      {
        "name": "T",
        "type": "type[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "filename",
        "description": "Must have a single element. The name of the file to which we write\nthe tensor.",
        "type": 7
      },
      {
        "name": "tensor_names",
        "description": "Shape `[N]`. The names of the tensors to be saved.",
        "type": 7
      },
      {
        "name": "data",
        "description": "`N` tensors to save.",
        "typeListAttr": "T"
      }
    ]
  },
  {
    "name": "SaveDataset",
    "attributes": [
      {
        "name": "compression",
        "type": "string",
        "default": ""
      },
      {
        "name": "shard_func",
        "type": "function"
      },
      {
        "name": "use_shard_func",
        "type": "boolean",
        "default": true
      },
      {
        "name": "Tshard_func_args",
        "type": "type[]",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "path",
        "type": 7
      },
      {
        "name": "shard_func_other_args",
        "typeListAttr": "Tshard_func_args"
      }
    ]
  },
  {
    "name": "SaveDatasetV2",
    "attributes": [
      {
        "name": "compression",
        "type": "string",
        "default": ""
      },
      {
        "name": "shard_func",
        "type": "function"
      },
      {
        "name": "use_shard_func",
        "type": "boolean",
        "default": true
      },
      {
        "name": "Tshard_func_args",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "path",
        "type": 7
      },
      {
        "name": "shard_func_other_args",
        "typeListAttr": "Tshard_func_args"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "SaveSlices",
    "summary": "Saves input tensors slices to disk.",
    "description": "This is like `Save` except that tensors can be listed in the saved file as being\na slice of a larger tensor.  `shapes_and_slices` specifies the shape of the\nlarger tensor and the slice that this tensor covers. `shapes_and_slices` must\nhave as many elements as `tensor_names`.\n\nElements of the `shapes_and_slices` input must either be:\n\n*  The empty string, in which case the corresponding tensor is\n   saved normally.\n*  A string of the form `dim0 dim1 ... dimN-1 slice-spec` where the\n   `dimI` are the dimensions of the larger tensor and `slice-spec`\n   specifies what part is covered by the tensor to save.\n\n`slice-spec` itself is a `:`-separated list: `slice0:slice1:...:sliceN-1`\nwhere each `sliceI` is either:\n\n*  The string `-` meaning that the slice covers all indices of this dimension\n*  `start,length` where `start` and `length` are integers.  In that\n   case the slice covers `length` indices starting at `start`.\n\nSee also `Save`.",
    "attributes": [
      {
        "name": "T",
        "type": "type[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "filename",
        "description": "Must have a single element. The name of the file to which we write the\ntensor.",
        "type": 7
      },
      {
        "name": "tensor_names",
        "description": "Shape `[N]`. The names of the tensors to be saved.",
        "type": 7
      },
      {
        "name": "shapes_and_slices",
        "description": "Shape `[N]`.  The shapes and slice specifications to use when\nsaving the tensors.",
        "type": 7
      },
      {
        "name": "data",
        "description": "`N` tensors to save.",
        "typeListAttr": "T"
      }
    ]
  },
  {
    "name": "SaveV2",
    "summary": "Saves tensors in V2 checkpoint format.",
    "description": "By default, saves the named tensors in full.  If the caller wishes to save\nspecific slices of full tensors, \"shape_and_slices\" should be non-empty strings\nand correspondingly well-formed.",
    "attributes": [
      {
        "name": "dtypes",
        "type": "type[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "prefix",
        "description": "Must have a single element. The prefix of the V2 checkpoint to which we\nwrite the tensors.",
        "type": 7
      },
      {
        "name": "tensor_names",
        "description": "shape {N}. The names of the tensors to be saved.",
        "type": 7
      },
      {
        "name": "shape_and_slices",
        "description": "shape {N}.  The slice specs of the tensors to be saved.\nEmpty strings indicate that they are non-partitioned tensors.",
        "type": 7
      },
      {
        "name": "tensors",
        "description": "`N` tensors to save.",
        "typeListAttr": "dtypes"
      }
    ]
  },
  {
    "name": "ScalarSummary",
    "summary": "Outputs a `Summary` protocol buffer with scalar values.",
    "description": "The input `tags` and `values` must have the same shape.  The generated summary\nhas a summary value for each tag-value pair in `tags` and `values`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "tags",
        "description": "Tags for the summary.",
        "type": 7
      },
      {
        "name": "values",
        "description": "Same shape as `tags.  Values for the summary.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "summary",
        "description": "Scalar.  Serialized `Summary` protocol buffer.",
        "type": 7
      }
    ]
  },
  {
    "name": "ScaleAndTranslate",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int8`, `uint8`, `int16`, `uint16`, `int32`, `int64`, `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "kernel_type",
        "type": "string",
        "default": "lanczos3"
      },
      {
        "name": "antialias",
        "type": "boolean",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "images",
        "typeAttr": "T"
      },
      {
        "name": "size",
        "type": 3
      },
      {
        "name": "scale",
        "type": 1
      },
      {
        "name": "translation",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "resized_images",
        "type": 1
      }
    ]
  },
  {
    "name": "ScaleAndTranslateGrad",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`."
      },
      {
        "name": "kernel_type",
        "type": "string",
        "default": "lanczos3"
      },
      {
        "name": "antialias",
        "type": "boolean",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "grads",
        "typeAttr": "T"
      },
      {
        "name": "original_image",
        "typeAttr": "T"
      },
      {
        "name": "scale",
        "type": 1
      },
      {
        "name": "translation",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ScanDataset",
    "summary": "Creates a dataset successively reduces `f` over the elements of `input_dataset`.",
    "attributes": [
      {
        "name": "f",
        "type": "function"
      },
      {
        "name": "Tstate",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "Targuments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "preserve_cardinality",
        "type": "boolean",
        "default": false
      },
      {
        "name": "use_default_device",
        "type": "boolean",
        "default": true
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "initial_state",
        "typeListAttr": "Tstate"
      },
      {
        "name": "other_arguments",
        "typeListAttr": "Targuments"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ScatterAdd",
    "summary": "Adds sparse updates to a variable reference.",
    "description": "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] += updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] += updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] += updates[i, ..., j, ...]\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions add.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterAdd.png\" alt>\n</div>",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, the addition will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "description": "Should be from a `Variable` node.",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "indices",
        "description": "A tensor of indices into the first dimension of `ref`.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A tensor of updated values to add to `ref`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output_ref",
        "description": "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done.",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ScatterDiv",
    "summary": "Divides a variable reference by sparse updates.",
    "description": "This operation computes\n\n```python\n    # Scalar indices\n    ref[indices, ...] /= updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] /= updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] /= updates[i, ..., j, ...]\n```\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions divide.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, the operation will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "description": "Should be from a `Variable` node.",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "indices",
        "description": "A tensor of indices into the first dimension of `ref`.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A tensor of values that `ref` is divided by.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output_ref",
        "description": "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done.",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ScatterMax",
    "summary": "Reduces sparse updates into a variable reference using the `max` operation.",
    "description": "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] = max(ref[indices, ...], updates[...])\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] = max(ref[indices[i], ...], updates[i, ...])\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] = max(ref[indices[i, ..., j], ...], updates[i, ..., j, ...])\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions combine.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterAdd.png\" alt>\n</div>",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`, `int32`, `int64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, the update will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "description": "Should be from a `Variable` node.",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "indices",
        "description": "A tensor of indices into the first dimension of `ref`.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A tensor of updated values to reduce into `ref`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output_ref",
        "description": "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done.",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ScatterMin",
    "summary": "Reduces sparse updates into a variable reference using the `min` operation.",
    "description": "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] = min(ref[indices, ...], updates[...])\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] = min(ref[indices[i], ...], updates[i, ...])\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] = min(ref[indices[i, ..., j], ...], updates[i, ..., j, ...])\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions combine.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterAdd.png\" alt>\n</div>",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`, `int32`, `int64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, the update will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "description": "Should be from a `Variable` node.",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "indices",
        "description": "A tensor of indices into the first dimension of `ref`.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A tensor of updated values to reduce into `ref`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output_ref",
        "description": "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done.",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ScatterMul",
    "summary": "Multiplies sparse updates into a variable reference.",
    "description": "This operation computes\n\n```python\n    # Scalar indices\n    ref[indices, ...] *= updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] *= updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] *= updates[i, ..., j, ...]\n```\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions multiply.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, the operation will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "description": "Should be from a `Variable` node.",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "indices",
        "description": "A tensor of indices into the first dimension of `ref`.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A tensor of updated values to multiply to `ref`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output_ref",
        "description": "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done.",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ScatterNd",
    "summary": "Scatters `updates` into a tensor of shape `shape` according to `indices`.",
    "description": "Scatter sparse `updates` according to individual values at the specified\n`indices`. This op returns an output tensor with the `shape` you specify. This\nop is the inverse of the `tf.gather_nd` operator which extracts values or slices\nfrom a given tensor.\n\nThis operation is similar to `tf.tensor_scatter_nd_add`, except that the tensor\nis zero-initialized. Calling `tf.scatter_nd(indices, updates, shape)`\nis identical to calling\n`tf.tensor_scatter_nd_add(tf.zeros(shape, updates.dtype), indices, updates)`\n\nIf `indices` contains duplicates, the associated `updates` are accumulated\n(summed) into the output tensor.\n\n**WARNING**: For floating-point data types, the output may be nondeterministic.\nThis is because the order in which the updates are applied is nondeterministic\nand when floating-point numbers are added in different orders the resulting\nnumerical approximation error can be slightly different. However, the output\nwill be deterministic if op determinism is enabled via\n`tf.config.experimental.enable_op_determinism`.\n\n`indices` is an integer tensor containing indices into the output tensor. The\nlast dimension of `indices` can be at most the rank of `shape`:\n\n    indices.shape[-1] <= shape.rank\n\nThe last dimension of `indices` corresponds to indices of elements\n(if `indices.shape[-1] = shape.rank`) or slices\n(if `indices.shape[-1] < shape.rank`) along dimension `indices.shape[-1]` of\n`shape`.\n\n`updates` is a tensor with shape:\n\n    indices.shape[:-1] + shape[indices.shape[-1]:]\n\nThe simplest form of the scatter op is to insert individual elements in\na tensor by index. Consider an example where you want to insert 4 scattered\nelements in a rank-1 tensor with 8 elements.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterNd1.png\" alt>\n</div>\n\nIn Python, this scatter operation would look like this:\n\n```python\n    indices = tf.constant([[4], [3], [1], [7]])\n    updates = tf.constant([9, 10, 11, 12])\n    shape = tf.constant([8])\n    scatter = tf.scatter_nd(indices, updates, shape)\n    print(scatter)\n```\n\nThe resulting tensor would look like this:\n\n    [0, 11, 0, 10, 9, 0, 0, 12]\n\nYou can also insert entire slices of a higher rank tensor all at once. For\nexample, you can insert two slices in the first dimension of a rank-3 tensor\nwith two matrices of new values.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterNd2.png\" alt>\n</div>\n\nIn Python, this scatter operation would look like this:\n\n```python\n    indices = tf.constant([[1], [3]])\n    updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6],\n                            [7, 7, 7, 7], [8, 8, 8, 8]],\n                           [[5, 5, 5, 5], [6, 6, 6, 6],\n                            [7, 7, 7, 7], [8, 8, 8, 8]]])\n    shape = tf.constant([4, 4, 4])\n    scatter = tf.scatter_nd(indices, updates, shape)\n    print(scatter)\n```\n\nThe resulting tensor would look like this:\n\n    [[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],\n     [[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],\n     [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],\n     [[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]]]\n\nNote that on CPU, if an out of bound index is found, an error is returned.\nOn GPU, if an out of bound index is found, the index is ignored.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int16`, `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "indices",
        "description": "Tensor of indices.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "Values to scatter into the output tensor.",
        "typeAttr": "T"
      },
      {
        "name": "shape",
        "description": "1-D. The shape of the output tensor.",
        "typeAttr": "Tindices"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A new tensor with the given shape and updates applied according\nto the indices.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ScatterNdAdd",
    "summary": "Applies sparse addition to individual values or slices in a Variable.",
    "description": "`ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.\n\n`indices` must be integer tensor, containing indices into `ref`.\nIt must be shape `[d_0, ..., d_{Q-2}, K]` where `0 < K <= P`.\n\nThe innermost dimension of `indices` (with length `K`) corresponds to\nindices into elements (if `K = P`) or slices (if `K < P`) along the `K`th\ndimension of `ref`.\n\n`updates` is `Tensor` of rank `Q-1+P-K` with shape:\n\n```\n[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]]\n```\n\nFor example, say we want to add 4 scattered elements to a rank-1 tensor to\n8 elements. In Python, that addition would look like this:\n\n```python\nref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])\nindices = tf.constant([[4], [3], [1], [7]])\nupdates = tf.constant([9, 10, 11, 12])\nadd = tf.scatter_nd_add(ref, indices, updates)\nwith tf.Session() as sess:\n  print sess.run(add)\n```\n\nThe resulting update to ref would look like this:\n\n    [1, 13, 3, 14, 14, 6, 7, 20]\n\nSee `tf.scatter_nd` for more details about how to make updates to\nslices.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "An optional bool. Defaults to True. If True, the assignment will\nbe protected by a lock; otherwise the behavior is undefined,\nbut may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "description": "A mutable Tensor. Should be from a Variable node.",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "indices",
        "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into ref.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A Tensor. Must have the same type as ref. A tensor of updated values\nto add to ref.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output_ref",
        "description": "Same as ref. Returned as a convenience for operations that want\nto use the updated values after the update is done.",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ScatterNdMax",
    "summary": "Computes element-wise maximum.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "An optional bool. Defaults to True. If True, the assignment will\nbe protected by a lock; otherwise the behavior is undefined,\nbut may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "description": "A mutable Tensor. Should be from a Variable node.",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "indices",
        "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into ref.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A Tensor. Must have the same type as ref. A tensor of updated values\nto add to ref.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output_ref",
        "description": "Same as ref. Returned as a convenience for operations that want\nto use the updated values after the update is done.",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ScatterNdMin",
    "summary": "Computes element-wise minimum.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "An optional bool. Defaults to True. If True, the assignment will\nbe protected by a lock; otherwise the behavior is undefined,\nbut may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "description": "A mutable Tensor. Should be from a Variable node.",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "indices",
        "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into ref.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A Tensor. Must have the same type as ref. A tensor of updated values\nto add to ref.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output_ref",
        "description": "Same as ref. Returned as a convenience for operations that want\nto use the updated values after the update is done.",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ScatterNdNonAliasingAdd",
    "summary": "Applies sparse addition to `input` using individual values or slices",
    "description": "from `updates` according to indices `indices`.  The updates are non-aliasing:\n`input` is only modified in-place if no other operations will use it.\nOtherwise, a copy of `input` is made.  This operation has a gradient with\nrespect to both `input` and `updates`.\n\n`input` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.\n\n`indices` must be integer tensor, containing indices into `input`.\nIt must be shape \\\\([d_0, ..., d_{Q-2}, K]\\\\) where `0 < K <= P`.\n\nThe innermost dimension of `indices` (with length `K`) corresponds to\nindices into elements (if `K = P`) or `(P-K)`-dimensional slices\n(if `K < P`) along the `K`th dimension of `input`.\n\n`updates` is `Tensor` of rank `Q-1+P-K` with shape:\n\n$$[d_0, ..., d_{Q-2}, input.shape[K], ..., input.shape[P-1]].$$\n\nFor example, say we want to add 4 scattered elements to a rank-1 tensor to 8\nelements. In Python, that addition would look like this:\n\n    input = tf.constant([1, 2, 3, 4, 5, 6, 7, 8])\n    indices = tf.constant([[4], [3], [1], [7]])\n    updates = tf.constant([9, 10, 11, 12])\n    output = tf.scatter_nd_non_aliasing_add(input, indices, updates)\n    with tf.Session() as sess:\n      print(sess.run(output))\n\nThe resulting value `output` would look like this:\n\n    [1, 13, 3, 14, 14, 6, 7, 20]\n\nSee `tf.scatter_nd` for more details about how to make updates to slices.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`, `bool`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A Tensor.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A Tensor. Must be one of the following types: `int32`, `int64`.\nA tensor of indices into `input`.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A Tensor. Must have the same type as ref. A tensor of updated values\nto add to `input`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A `Tensor` with the same shape as `input`, containing values of `input`\nupdated with `updates`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ScatterNdSub",
    "summary": "Applies sparse subtraction to individual values or slices in a Variable.",
    "description": "within a given variable according to `indices`.\n\n`ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.\n\n`indices` must be integer tensor, containing indices into `ref`.\nIt must be shape `[d_0, ..., d_{Q-2}, K]` where `0 < K <= P`.\n\nThe innermost dimension of `indices` (with length `K`) corresponds to\nindices into elements (if `K = P`) or slices (if `K < P`) along the `K`th\ndimension of `ref`.\n\n`updates` is `Tensor` of rank `Q-1+P-K` with shape:\n\n```\n[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]]\n```\n\nFor example, say we want to subtract 4 scattered elements from a rank-1 tensor\nwith 8 elements. In Python, that subtraction would look like this:\n\n```python\nref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])\nindices = tf.constant([[4], [3], [1], [7]])\nupdates = tf.constant([9, 10, 11, 12])\nsub = tf.scatter_nd_sub(ref, indices, updates)\nwith tf.Session() as sess:\n  print sess.run(sub)\n```\n\nThe resulting update to ref would look like this:\n\n    [1, -9, 3, -6, -4, 6, 7, -4]\n\nSee `tf.scatter_nd` for more details about how to make updates to\nslices.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "An optional bool. Defaults to True. If True, the assignment will\nbe protected by a lock; otherwise the behavior is undefined,\nbut may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "description": "A mutable Tensor. Should be from a Variable node.",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "indices",
        "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into ref.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A Tensor. Must have the same type as ref. A tensor of updated values\nto subtract from ref.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output_ref",
        "description": "Same as ref. Returned as a convenience for operations that want\nto use the updated values after the update is done.",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ScatterNdUpdate",
    "summary": "Applies sparse `updates` to individual values or slices within a given",
    "description": "variable according to `indices`.\n\n`ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.\n\n`indices` must be integer tensor, containing indices into `ref`.\nIt must be shape \\\\([d_0, ..., d_{Q-2}, K]\\\\) where `0 < K <= P`.\n\nThe innermost dimension of `indices` (with length `K`) corresponds to\nindices into elements (if `K = P`) or slices (if `K < P`) along the `K`th\ndimension of `ref`.\n\n`updates` is `Tensor` of rank `Q-1+P-K` with shape:\n\n$$[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].$$\n\nFor example, say we want to update 4 scattered elements to a rank-1 tensor to\n8 elements. In Python, that update would look like this:\n\n```python\n    ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])\n    indices = tf.constant([[4], [3], [1] ,[7]])\n    updates = tf.constant([9, 10, 11, 12])\n    update = tf.scatter_nd_update(ref, indices, updates)\n    with tf.Session() as sess:\n      print sess.run(update)\n```\n\nThe resulting update to ref would look like this:\n\n    [1, 11, 3, 10, 9, 6, 7, 12]\n\nSee `tf.scatter_nd` for more details about how to make updates to\nslices.\n\nSee also `tf.scatter_update` and `tf.batch_scatter_update`.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "An optional bool. Defaults to True. If True, the assignment will\nbe protected by a lock; otherwise the behavior is undefined,\nbut may exhibit less contention.",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "description": "A mutable Tensor. Should be from a Variable node.",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "indices",
        "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into ref.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A Tensor. Must have the same type as ref. A tensor of updated\nvalues to add to ref.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output_ref",
        "description": "Same as ref. Returned as a convenience for operations that want to\nuse the updated values after the update is done.",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ScatterSub",
    "summary": "Subtracts sparse updates to a variable reference.",
    "description": "```python\n    # Scalar indices\n    ref[indices, ...] -= updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] -= updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] -= updates[i, ..., j, ...]\n```\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their (negated) contributions add.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterSub.png\" alt>\n</div>",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "description": "Should be from a `Variable` node.",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "indices",
        "description": "A tensor of indices into the first dimension of `ref`.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A tensor of updated values to subtract from `ref`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output_ref",
        "description": "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done.",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "ScatterUpdate",
    "summary": "Applies sparse updates to a variable reference.",
    "description": "This operation computes\n\n```python\n    # Scalar indices\n    ref[indices, ...] = updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] = updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] = updates[i, ..., j, ...]\n```\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nIf values in `ref` is to be updated more than once, because there are\nduplicate entries in `indices`, the order at which the updates happen\nfor each value is undefined.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterUpdate.png\" alt>\n</div>\n\nSee also `tf.batch_scatter_update` and `tf.scatter_nd_update`.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, the assignment will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "description": "Should be from a `Variable` node.",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "indices",
        "description": "A tensor of indices into the first dimension of `ref`.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "A tensor of updated values to store in `ref`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output_ref",
        "description": "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done.",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "SdcaFprint",
    "summary": "Computes fingerprints of the input strings.",
    "inputs": [
      {
        "name": "input",
        "description": "vector of strings to compute fingerprints on.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "a (N,2) shaped matrix where N is the number of elements in the input\nvector. Each row contains the low and high parts of the fingerprint.",
        "type": 9
      }
    ]
  },
  {
    "name": "SdcaOptimizer",
    "summary": "Distributed version of Stochastic Dual Coordinate Ascent (SDCA) optimizer for",
    "description": "linear models with L1 + L2 regularization. As global optimization objective is\nstrongly-convex, the optimizer optimizes the dual objective at each step. The\noptimizer applies each update one example at a time. Examples are sampled\nuniformly, and the optimizer is learning rate free and enjoys linear convergence\nrate.\n\n[Proximal Stochastic Dual Coordinate Ascent](http://arxiv.org/pdf/1211.2717v1.pdf).<br>\nShai Shalev-Shwartz, Tong Zhang. 2012\n\n$$Loss Objective = \\sum f_{i} (wx_{i}) + (l2 / 2) * |w|^2 + l1 * |w|$$\n\n[Adding vs. Averaging in Distributed Primal-Dual Optimization](http://arxiv.org/abs/1502.03508).<br>\nChenxin Ma, Virginia Smith, Martin Jaggi, Michael I. Jordan,\nPeter Richtarik, Martin Takac. 2015\n\n[Stochastic Dual Coordinate Ascent with Adaptive Probabilities](https://arxiv.org/abs/1502.08053).<br>\nDominik Csiba, Zheng Qu, Peter Richtarik. 2015",
    "attributes": [
      {
        "name": "loss_type",
        "type": "string",
        "description": "Type of the primal loss. Currently SdcaSolver supports logistic,\nsquared and hinge losses. Must be one of the following: `logistic_loss`, `squared_loss`, `hinge_loss`, `smooth_hinge_loss`, `poisson_loss`."
      },
      {
        "name": "adaptative",
        "type": "boolean",
        "description": "Whether to use Adaptive SDCA for the inner loop.",
        "default": false
      },
      {
        "name": "num_sparse_features",
        "type": "int64",
        "description": "Number of sparse feature groups to train on.",
        "minimum": 0
      },
      {
        "name": "num_sparse_features_with_values",
        "type": "int64",
        "description": "Number of sparse feature groups with values\nassociated with it, otherwise implicitly treats values as 1.0.",
        "minimum": 0
      },
      {
        "name": "num_dense_features",
        "type": "int64",
        "description": "Number of dense feature groups to train on.",
        "minimum": 0
      },
      {
        "name": "l1",
        "type": "float32",
        "description": "Symmetric l1 regularization strength."
      },
      {
        "name": "l2",
        "type": "float32",
        "description": "Symmetric l2 regularization strength."
      },
      {
        "name": "num_loss_partitions",
        "type": "int64",
        "description": "Number of partitions of the global loss function.",
        "minimum": 1
      },
      {
        "name": "num_inner_iterations",
        "type": "int64",
        "description": "Number of iterations per mini-batch.",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "sparse_example_indices",
        "description": "a list of vectors which contain example indices.",
        "numberAttr": "num_sparse_features",
        "type": 9
      },
      {
        "name": "sparse_feature_indices",
        "description": "a list of vectors which contain feature indices.",
        "numberAttr": "num_sparse_features",
        "type": 9
      },
      {
        "name": "sparse_feature_values",
        "description": "a list of vectors which contains feature value\nassociated with each feature group.",
        "numberAttr": "num_sparse_features_with_values",
        "type": 1
      },
      {
        "name": "dense_features",
        "description": "a list of matrices which contains the dense feature values.",
        "numberAttr": "num_dense_features",
        "type": 1
      },
      {
        "name": "example_weights",
        "description": "a vector which contains the weight associated with each\nexample.",
        "type": 1
      },
      {
        "name": "example_labels",
        "description": "a vector which contains the label/target associated with each\nexample.",
        "type": 1
      },
      {
        "name": "sparse_indices",
        "description": "a list of vectors where each value is the indices which has\ncorresponding weights in sparse_weights. This field maybe omitted for the\ndense approach.",
        "numberAttr": "num_sparse_features",
        "type": 9
      },
      {
        "name": "sparse_weights",
        "description": "a list of vectors where each value is the weight associated with\na sparse feature group.",
        "numberAttr": "num_sparse_features",
        "type": 1
      },
      {
        "name": "dense_weights",
        "description": "a list of vectors where the values are the weights associated\nwith a dense feature group.",
        "numberAttr": "num_dense_features",
        "type": 1
      },
      {
        "name": "example_state_data",
        "description": "a list of vectors containing the example state data.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "out_example_state_data",
        "description": "a list of vectors containing the updated example state\ndata.",
        "type": 1
      },
      {
        "name": "out_delta_sparse_weights",
        "description": "a list of vectors where each value is the delta\nweights associated with a sparse feature group.",
        "numberAttr": "num_sparse_features",
        "type": 1
      },
      {
        "name": "out_delta_dense_weights",
        "description": "a list of vectors where the values are the delta\nweights associated with a dense feature group.",
        "numberAttr": "num_dense_features",
        "type": 1
      }
    ]
  },
  {
    "name": "SdcaOptimizerV2",
    "summary": "Distributed version of Stochastic Dual Coordinate Ascent (SDCA) optimizer for",
    "description": "linear models with L1 + L2 regularization. As global optimization objective is\nstrongly-convex, the optimizer optimizes the dual objective at each step. The\noptimizer applies each update one example at a time. Examples are sampled\nuniformly, and the optimizer is learning rate free and enjoys linear convergence\nrate.\n\n[Proximal Stochastic Dual Coordinate Ascent](http://arxiv.org/pdf/1211.2717v1.pdf).<br>\nShai Shalev-Shwartz, Tong Zhang. 2012\n\n$$Loss Objective = \\sum f_{i} (wx_{i}) + (l2 / 2) * |w|^2 + l1 * |w|$$\n\n[Adding vs. Averaging in Distributed Primal-Dual Optimization](http://arxiv.org/abs/1502.03508).<br>\nChenxin Ma, Virginia Smith, Martin Jaggi, Michael I. Jordan,\nPeter Richtarik, Martin Takac. 2015\n\n[Stochastic Dual Coordinate Ascent with Adaptive Probabilities](https://arxiv.org/abs/1502.08053).<br>\nDominik Csiba, Zheng Qu, Peter Richtarik. 2015",
    "attributes": [
      {
        "name": "loss_type",
        "type": "string",
        "description": "Type of the primal loss. Currently SdcaSolver supports logistic,\nsquared and hinge losses. Must be one of the following: `logistic_loss`, `squared_loss`, `hinge_loss`, `smooth_hinge_loss`, `poisson_loss`."
      },
      {
        "name": "adaptive",
        "type": "boolean",
        "description": "Whether to use Adaptive SDCA for the inner loop.",
        "default": false
      },
      {
        "name": "num_sparse_features",
        "type": "int64",
        "description": "Number of sparse feature groups to train on.",
        "minimum": 0
      },
      {
        "name": "num_sparse_features_with_values",
        "type": "int64",
        "description": "Number of sparse feature groups with values\nassociated with it, otherwise implicitly treats values as 1.0.",
        "minimum": 0
      },
      {
        "name": "num_dense_features",
        "type": "int64",
        "description": "Number of dense feature groups to train on.",
        "minimum": 0
      },
      {
        "name": "l1",
        "type": "float32",
        "description": "Symmetric l1 regularization strength."
      },
      {
        "name": "l2",
        "type": "float32",
        "description": "Symmetric l2 regularization strength."
      },
      {
        "name": "num_loss_partitions",
        "type": "int64",
        "description": "Number of partitions of the global loss function.",
        "minimum": 1
      },
      {
        "name": "num_inner_iterations",
        "type": "int64",
        "description": "Number of iterations per mini-batch.",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "sparse_example_indices",
        "description": "a list of vectors which contain example indices.",
        "numberAttr": "num_sparse_features",
        "type": 9
      },
      {
        "name": "sparse_feature_indices",
        "description": "a list of vectors which contain feature indices.",
        "numberAttr": "num_sparse_features",
        "type": 9
      },
      {
        "name": "sparse_feature_values",
        "description": "a list of vectors which contains feature value\nassociated with each feature group.",
        "numberAttr": "num_sparse_features_with_values",
        "type": 1
      },
      {
        "name": "dense_features",
        "description": "a list of matrices which contains the dense feature values.",
        "numberAttr": "num_dense_features",
        "type": 1
      },
      {
        "name": "example_weights",
        "description": "a vector which contains the weight associated with each\nexample.",
        "type": 1
      },
      {
        "name": "example_labels",
        "description": "a vector which contains the label/target associated with each\nexample.",
        "type": 1
      },
      {
        "name": "sparse_indices",
        "description": "a list of vectors where each value is the indices which has\ncorresponding weights in sparse_weights. This field maybe omitted for the\ndense approach.",
        "numberAttr": "num_sparse_features",
        "type": 9
      },
      {
        "name": "sparse_weights",
        "description": "a list of vectors where each value is the weight associated with\na sparse feature group.",
        "numberAttr": "num_sparse_features",
        "type": 1
      },
      {
        "name": "dense_weights",
        "description": "a list of vectors where the values are the weights associated\nwith a dense feature group.",
        "numberAttr": "num_dense_features",
        "type": 1
      },
      {
        "name": "example_state_data",
        "description": "a list of vectors containing the example state data.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "out_example_state_data",
        "description": "a list of vectors containing the updated example state\ndata.",
        "type": 1
      },
      {
        "name": "out_delta_sparse_weights",
        "description": "a list of vectors where each value is the delta\nweights associated with a sparse feature group.",
        "numberAttr": "num_sparse_features",
        "type": 1
      },
      {
        "name": "out_delta_dense_weights",
        "description": "a list of vectors where the values are the delta\nweights associated with a dense feature group.",
        "numberAttr": "num_dense_features",
        "type": 1
      }
    ]
  },
  {
    "name": "SdcaShrinkL1",
    "summary": "Applies L1 regularization shrink step on the parameters.",
    "attributes": [
      {
        "name": "num_features",
        "type": "int64",
        "description": "Number of feature groups to apply shrinking step.",
        "minimum": 0
      },
      {
        "name": "l1",
        "type": "float32",
        "description": "Symmetric l1 regularization strength."
      },
      {
        "name": "l2",
        "type": "float32",
        "description": "Symmetric l2 regularization strength. Should be a positive float."
      }
    ],
    "inputs": [
      {
        "name": "weights",
        "description": "a list of vectors where each value is the weight associated with a\nfeature group.",
        "numberAttr": "num_features",
        "type": 1,
        "isRef": true
      }
    ]
  },
  {
    "name": "SegmentMax",
    "summary": "Computes the maximum along segments of a tensor.",
    "description": "Read\n[the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)\nfor an explanation of segments.\n\nComputes a tensor such that\n\\\\(output_i = \\max_j(data_j)\\\\) where `max` is over `j` such\nthat `segment_ids[j] == i`.\n\nIf the max is empty for a given segment ID `i`, `output[i] = 0`.\n\nCaution: On CPU, values in `segment_ids` are always validated to be sorted,\nand an error is thrown for indices that are not increasing. On GPU, this\ndoes not throw an error for unsorted indices. On GPU, out-of-order indices\nresult in safe but unspecified behavior, which may include treating\nout-of-order indices as the same as a smaller following index.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/SegmentMax.png\" alt>\n</div>\n\nFor example:\n\n>>> c = tf.constant([[1,2,3,4], [4, 3, 2, 1], [5,6,7,8]])\n>>> tf.math.segment_max(c, tf.constant([0, 0, 1])).numpy()\narray([[4, 3, 3, 4],\n       [5, 6, 7, 8]], dtype=int32)\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "data",
        "typeAttr": "T"
      },
      {
        "name": "segment_ids",
        "description": "A 1-D tensor whose size is equal to the size of `data`'s\nfirst dimension.  Values should be sorted and can be repeated.\n\nCaution: The values are always validated to be sorted on CPU, never validated\non GPU.",
        "typeAttr": "Tindices"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SegmentMaxV2",
    "summary": "Computes the maximum along segments of a tensor.",
    "description": "Read\n[the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)\nfor an explanation of segments.\n\nComputes a tensor such that\n\\\\(output_i = \\max_j(data_j)\\\\) where `max` is over `j` such\nthat `segment_ids[j] == i`.\n\nIf the maximum is empty for a given segment ID `i`, it outputs the smallest\npossible value for the specific numeric type,\n`output[i] = numeric_limits<T>::lowest()`.\n\nNote: That this op is currently only supported with jit_compile=True.\n\nCaution: On CPU, values in `segment_ids` are always validated to be sorted,\nand an error is thrown for indices that are not increasing. On GPU, this\ndoes not throw an error for unsorted indices. On GPU, out-of-order indices\nresult in safe but unspecified behavior, which may include treating\nout-of-order indices as the same as a smaller following index.\n\nThe only difference with SegmentMax is the additional input  `num_segments`.\nThis helps in evaluating the output shape in compile time.\n`num_segments` should be consistent with segment_ids.\ne.g. Max(segment_ids) should be equal to `num_segments` - 1 for a 1-d segment_ids\nWith inconsistent num_segments, the op still runs. only difference is,\nthe output takes the size of num_segments irrespective of size of segment_ids and data.\nfor num_segments less than expected output size, the last elements are ignored\nfor num_segments more than the expected output size, last elements are assigned \nsmallest possible value for the specific numeric type.\n\nFor example:\n\n>>> @tf.function(jit_compile=True)\n... def test(c):\n...   return tf.raw_ops.SegmentMaxV2(data=c, segment_ids=tf.constant([0, 0, 1]), num_segments=2)\n>>> c = tf.constant([[1,2,3,4], [4, 3, 2, 1], [5,6,7,8]])\n>>> test(c).numpy()\narray([[4, 3, 3, 4],\n       [5, 6, 7, 8]], dtype=int32)\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "Tnumsegments",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "data",
        "typeAttr": "T"
      },
      {
        "name": "segment_ids",
        "description": "A 1-D tensor whose size is equal to the size of `data`'s\nfirst dimension.  Values should be sorted and can be repeated.\nThe values must be less than `num_segments`.\n\nCaution: The values are always validated to be sorted on CPU, never validated\non GPU.",
        "typeAttr": "Tindices"
      },
      {
        "name": "num_segments",
        "typeAttr": "Tnumsegments"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Has same shape as data, except for the first `segment_ids.rank`\ndimensions, which are replaced with a single dimensionw which has size\n`num_segments`.\n",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SegmentMean",
    "summary": "Computes the mean along segments of a tensor.",
    "description": "Read\n[the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)\nfor an explanation of segments.\n\nComputes a tensor such that\n\\\\(output_i = \\frac{\\sum_j data_j}{N}\\\\) where `mean` is\nover `j` such that `segment_ids[j] == i` and `N` is the total number of\nvalues summed.\n\nIf the mean is empty for a given segment ID `i`, `output[i] = 0`.\n\nCaution: On CPU, values in `segment_ids` are always validated to be sorted,\nand an error is thrown for indices that are not increasing. On GPU, this\ndoes not throw an error for unsorted indices. On GPU, out-of-order indices\nresult in safe but unspecified behavior, which may include treating\nout-of-order indices as a smaller following index when computing the numerator\nof the mean.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/SegmentMean.png\" alt>\n</div>\n\nFor example:\n\n>>> c = tf.constant([[1.0,2,3,4], [4, 3, 2, 1], [5,6,7,8]])\n>>> tf.math.segment_mean(c, tf.constant([0, 0, 1])).numpy()\narray([[2.5, 2.5, 2.5, 2.5],\n       [5., 6., 7., 8.]], dtype=float32)\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "data",
        "typeAttr": "T"
      },
      {
        "name": "segment_ids",
        "description": "A 1-D tensor whose size is equal to the size of `data`'s\nfirst dimension.  Values should be sorted and can be repeated.\n\nCaution: The values are always validated to be sorted on CPU, never validated\non GPU.",
        "typeAttr": "Tindices"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SegmentMin",
    "summary": "Computes the minimum along segments of a tensor.",
    "description": "Read\n[the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)\nfor an explanation of segments.\n\nComputes a tensor such that\n\\\\(output_i = \\min_j(data_j)\\\\) where `min` is over `j` such\nthat `segment_ids[j] == i`.\n\nIf the min is empty for a given segment ID `i`, `output[i] = 0`.\n\nCaution: On CPU, values in `segment_ids` are always validated to be sorted,\nand an error is thrown for indices that are not increasing. On GPU, this\ndoes not throw an error for unsorted indices. On GPU, out-of-order indices\nresult in safe but unspecified behavior, which may include treating\nout-of-order indices as the same as a smaller following index.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/SegmentMin.png\" alt>\n</div>\n\nFor example:\n\n>>> c = tf.constant([[1,2,3,4], [4, 3, 2, 1], [5,6,7,8]])\n>>> tf.math.segment_min(c, tf.constant([0, 0, 1])).numpy()\narray([[1, 2, 2, 1],\n       [5, 6, 7, 8]], dtype=int32)\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "data",
        "typeAttr": "T"
      },
      {
        "name": "segment_ids",
        "description": "A 1-D tensor whose size is equal to the size of `data`'s\nfirst dimension.  Values should be sorted and can be repeated.\n\nCaution: The values are always validated to be sorted on CPU, never validated\non GPU.",
        "typeAttr": "Tindices"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SegmentMinV2",
    "summary": "Computes the minimum along segments of a tensor.",
    "description": "Read\n[the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)\nfor an explanation of segments.\n\nComputes a tensor such that\n\\\\(output_i = \\min_j(data_j)\\\\) where `min` is over `j` such\nthat `segment_ids[j] == i`.\n\nIf the minimum is empty for a given segment ID `i`, it outputs the largest\npossible value for the specific numeric type,\n`output[i] = numeric_limits<T>::max()`.\n\nNote: That this op is currently only supported with jit_compile=True.\n\nCaution: On CPU, values in `segment_ids` are always validated to be sorted,\nand an error is thrown for indices that are not increasing. On GPU, this\ndoes not throw an error for unsorted indices. On GPU, out-of-order indices\nresult in safe but unspecified behavior, which may include treating\nout-of-order indices as the same as a smaller following index.\n\nThe only difference with SegmentMin is the additional input  `num_segments`.\nThis helps in evaluating the output shape in compile time.\n`num_segments` should be consistent with segment_ids.\ne.g. Max(segment_ids) should be equal to `num_segments` - 1 for a 1-d segment_ids\nWith inconsistent num_segments, the op still runs. only difference is,\nthe output takes the size of num_segments irrespective of size of segment_ids and data.\nfor num_segments less than expected output size, the last elements are ignored\nfor num_segments more than the expected output size, last elements are assigned \nthe largest possible value for the specific numeric type.\n\nFor example:\n\n>>> @tf.function(jit_compile=True)\n... def test(c):\n...   return tf.raw_ops.SegmentMinV2(data=c, segment_ids=tf.constant([0, 0, 1]), num_segments=2)\n>>> c = tf.constant([[1,2,3,4], [4, 3, 2, 1], [5,6,7,8]])\n>>> test(c).numpy()\narray([[1, 2, 2, 1],\n       [5, 6, 7, 8]], dtype=int32)\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "Tnumsegments",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "data",
        "typeAttr": "T"
      },
      {
        "name": "segment_ids",
        "description": "A 1-D tensor whose size is equal to the size of `data`'s\nfirst dimension.  Values should be sorted and can be repeated.\nThe values must be less than `num_segments`.\n\nCaution: The values are always validated to be sorted on CPU, never validated\non GPU.",
        "typeAttr": "Tindices"
      },
      {
        "name": "num_segments",
        "typeAttr": "Tnumsegments"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Has same shape as data, except for the first `segment_ids.rank`\ndimensions, which are replaced with a single dimensionw which has size\n`num_segments`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SegmentProd",
    "summary": "Computes the product along segments of a tensor.",
    "description": "Read\n[the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)\nfor an explanation of segments.\n\nComputes a tensor such that\n\\\\(output_i = \\prod_j data_j\\\\) where the product is over `j` such\nthat `segment_ids[j] == i`.\n\nIf the product is empty for a given segment ID `i`, `output[i] = 1`.\n\nCaution: On CPU, values in `segment_ids` are always validated to be sorted,\nand an error is thrown for indices that are not increasing. On GPU, this\ndoes not throw an error for unsorted indices. On GPU, out-of-order indices\nresult in safe but unspecified behavior, which may include treating\nout-of-order indices as the same as a smaller following index.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/SegmentProd.png\" alt>\n</div>\n\nFor example:\n\n>>> c = tf.constant([[1,2,3,4], [4, 3, 2, 1], [5,6,7,8]])\n>>> tf.math.segment_prod(c, tf.constant([0, 0, 1])).numpy()\narray([[4, 6, 6, 4],\n       [5, 6, 7, 8]], dtype=int32)\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "data",
        "typeAttr": "T"
      },
      {
        "name": "segment_ids",
        "description": "A 1-D tensor whose size is equal to the size of `data`'s\nfirst dimension.  Values should be sorted and can be repeated.\n\nCaution: The values are always validated to be sorted on CPU, never validated\non GPU.",
        "typeAttr": "Tindices"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SegmentProdV2",
    "summary": "Computes the product along segments of a tensor.",
    "description": "Read\n[the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)\nfor an explanation of segments.\n\nComputes a tensor such that\n\\\\(output_i = \\prod_j data_j\\\\) where the product is over `j` such\nthat `segment_ids[j] == i`.\n\nIf the product is empty for a given segment ID `i`, `output[i] = 1`.\n\nNote: That this op is currently only supported with jit_compile=True.\n\nThe only difference with SegmentProd is the additional input  `num_segments`.\nThis helps in evaluating the output shape in compile time.\n`num_segments` should be consistent with segment_ids.\ne.g. Max(segment_ids) - 1 should be equal to `num_segments` for a 1-d segment_ids\nWith inconsistent num_segments, the op still runs. only difference is, \nthe output takes the size of num_segments irrespective of size of segment_ids and data.\nfor num_segments less than expected output size, the last elements are ignored\nfor num_segments more than the expected output size, last elements are assigned 1.\n\nFor example:\n\n>>> @tf.function(jit_compile=True)\n... def test(c):\n...   return tf.raw_ops.SegmentProdV2(data=c, segment_ids=tf.constant([0, 0, 1]), num_segments=2)\n>>> c = tf.constant([[1,2,3,4], [4, 3, 2, 1], [5,6,7,8]])\n>>> test(c).numpy()\narray([[4, 6, 6, 4],\n       [5, 6, 7, 8]], dtype=int32)\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "Tnumsegments",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "data",
        "typeAttr": "T"
      },
      {
        "name": "segment_ids",
        "description": "A 1-D tensor whose size is equal to the size of `data`'s\nfirst dimension.  Values should be sorted and can be repeated.\nThe values must be less than `num_segments`.\n\nCaution: The values are always validated to be sorted on CPU, never validated\non GPU.",
        "typeAttr": "Tindices"
      },
      {
        "name": "num_segments",
        "typeAttr": "Tnumsegments"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Has same shape as data, except for the first `segment_ids.rank`\ndimensions, which are replaced with a single dimensionw which has size\n`num_segments`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SegmentSum",
    "summary": "Computes the sum along segments of a tensor.",
    "description": "Read\n[the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)\nfor an explanation of segments.\n\nComputes a tensor such that\n\\\\(output_i = \\sum_j data_j\\\\) where sum is over `j` such\nthat `segment_ids[j] == i`.\n\nIf the sum is empty for a given segment ID `i`, `output[i] = 0`.\n\nCaution: On CPU, values in `segment_ids` are always validated to be sorted,\nand an error is thrown for indices that are not increasing. On GPU, this\ndoes not throw an error for unsorted indices. On GPU, out-of-order indices\nresult in safe but unspecified behavior, which may include treating\nout-of-order indices as the same as a smaller following index.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/SegmentSum.png\" alt>\n</div>\n\nFor example:\n\n>>> c = tf.constant([[1,2,3,4], [4, 3, 2, 1], [5,6,7,8]])\n>>> tf.math.segment_sum(c, tf.constant([0, 0, 1])).numpy()\narray([[5, 5, 5, 5],\n       [5, 6, 7, 8]], dtype=int32)\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "data",
        "typeAttr": "T"
      },
      {
        "name": "segment_ids",
        "description": "A 1-D tensor whose size is equal to the size of `data`'s\nfirst dimension.  Values should be sorted and can be repeated.\n\nCaution: The values are always validated to be sorted on CPU, never validated\non GPU.",
        "typeAttr": "Tindices"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SegmentSumV2",
    "summary": "Computes the sum along segments of a tensor.",
    "description": "Read\n[the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)\nfor an explanation of segments.\n\nComputes a tensor such that\n\\\\(output_i = \\sum_j data_j\\\\) where sum is over `j` such\nthat `segment_ids[j] == i`.\n\nIf the sum is empty for a given segment ID `i`, `output[i] = 0`.\n\nNote that this op is currently only supported with jit_compile=True.\n</div>\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "Tnumsegments",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "data",
        "typeAttr": "T"
      },
      {
        "name": "segment_ids",
        "description": "A 1-D tensor whose size is equal to the size of `data`'s\nfirst dimension.  Values should be sorted and can be repeated.\nThe values must be less than `num_segments`.\n\nCaution: The values are always validated to be sorted on CPU, never validated\non GPU.",
        "typeAttr": "Tindices"
      },
      {
        "name": "num_segments",
        "typeAttr": "Tnumsegments"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Has same shape as data, except for the first `segment_ids.rank`\ndimensions, which are replaced with a single dimension which has size\n`num_segments`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Select",
    "summary": "Selects elements from `t` or `e`, depending on `condition`.",
    "description": "The `t`, and `e` tensors must all have the same shape, and the\noutput will also have that shape.\n\nThe `condition` tensor must be a scalar if `t` and `e` are scalars.\nIf `t` and `e` are vectors or higher rank, then `condition` must be either a\nscalar, a vector with size matching the first dimension of `t`, or must have\nthe same shape as `t`.\n\nThe `condition` tensor acts as a mask that chooses, based on the value at each\nelement, whether the corresponding element / row in the output should be\ntaken from `t` (if true) or `e` (if false).\n\nIf `condition` is a vector and `t` and `e` are higher rank matrices, then\nit chooses which row (outer dimension) to copy from `t` and `e`.\nIf `condition` has the same shape as `t` and `e`, then it chooses which\nelement to copy from `t` and `e`.\n\nFor example:\n\n```python\n# 'condition' tensor is [[True,  False]\n#                        [False, True]]\n# 't' is [[1, 2],\n#         [3, 4]]\n# 'e' is [[5, 6],\n#         [7, 8]]\nselect(condition, t, e)  # => [[1, 6], [7, 4]]\n\n\n# 'condition' tensor is [True, False]\n# 't' is [[1, 2],\n#         [3, 4]]\n# 'e' is [[5, 6],\n#         [7, 8]]\nselect(condition, t, e) ==> [[1, 2],\n                             [7, 8]]\n\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "condition",
        "type": 10
      },
      {
        "name": "t",
        "description": "= A `Tensor` which may have the same shape as `condition`.\nIf `condition` is rank 1, `t` may have higher rank,\nbut its first dimension must match the size of `condition`.",
        "typeAttr": "T"
      },
      {
        "name": "e",
        "description": "= A `Tensor` with the same type and shape as `t`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "= A `Tensor` with the same type and shape as `t` and `e`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SelectV2",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "condition",
        "type": 10
      },
      {
        "name": "t",
        "typeAttr": "T"
      },
      {
        "name": "e",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SelfAdjointEig",
    "summary": "Computes the Eigen Decomposition of a batch of square self-adjoint matrices.",
    "description": "The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices, with the same constraints as the single matrix\nSelfAdjointEig.\n\nThe result is a [..., M+1, M] matrix with [..., 0,:] containing the\neigenvalues, and subsequent [...,1:, :] containing the eigenvectors. The eigenvalues\nare sorted in non-decreasing order.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float64`, `float32`, `float16`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Shape is `[..., M, M]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Shape is `[..., M+1, M]`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SelfAdjointEigV2",
    "summary": "Computes the eigen decomposition of one or more square self-adjoint matrices.",
    "description": "Computes the eigenvalues and (optionally) eigenvectors of each inner matrix in\n`input` such that `input[..., :, :] = v[..., :, :] * diag(e[..., :])`. The eigenvalues\nare sorted in non-decreasing order.\n\n```python\n# a is a tensor.\n# e is a tensor of eigenvalues.\n# v is a tensor of eigenvectors.\ne, v = self_adjoint_eig(a)\ne = self_adjoint_eig(a, compute_v=False)\n```",
    "attributes": [
      {
        "name": "compute_v",
        "type": "boolean",
        "description": "If `True` then eigenvectors will be computed and returned in `v`.\nOtherwise, only the eigenvalues will be computed.",
        "default": true
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float64`, `float32`, `float16`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "`Tensor` input of shape `[N, N]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "e",
        "description": "Eigenvalues. Shape is `[N]`.",
        "typeAttr": "T"
      },
      {
        "name": "v",
        "description": "Eigenvectors. Shape is `[N, N]`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Selu",
    "summary": "Computes scaled exponential linear: `scale * alpha * (exp(features) - 1)`",
    "description": "if < 0, `scale * features` otherwise.\n\nTo be used together with\n`initializer = tf.variance_scaling_initializer(factor=1.0, mode='FAN_IN')`.\nFor correct dropout, use `tf.contrib.nn.alpha_dropout`.\n\nSee [Self-Normalizing Neural Networks](https://arxiv.org/abs/1706.02515)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "features",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "activations",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SeluGrad",
    "summary": "Computes gradients for the scaled exponential linear (Selu) operation.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "gradients",
        "description": "The backpropagated gradients to the corresponding Selu operation.",
        "typeAttr": "T"
      },
      {
        "name": "outputs",
        "description": "The outputs of the corresponding Selu operation.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "backprops",
        "description": "The gradients: `gradients * (outputs + scale * alpha)`\nif outputs < 0, `scale * gradients` otherwise.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Send",
    "summary": "Sends the named tensor from send_device to recv_device.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "tensor_name",
        "type": "string",
        "description": "The name of the tensor to send."
      },
      {
        "name": "send_device",
        "type": "string",
        "description": "The name of the device sending the tensor."
      },
      {
        "name": "send_device_incarnation",
        "type": "int64",
        "description": "The current incarnation of send_device."
      },
      {
        "name": "recv_device",
        "type": "string",
        "description": "The name of the device receiving the tensor."
      },
      {
        "name": "client_terminated",
        "type": "boolean",
        "description": "If set to true, this indicates that the node was added\nto the graph as a result of a client-side feed or fetch of Tensor data,\nin which case the corresponding send or recv is expected to be managed\nlocally by the caller.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "tensor",
        "description": "The tensor to send.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SendTPUEmbeddingGradients",
    "summary": "Performs gradient updates of embedding tables.",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "NN",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "config",
        "type": "string",
        "description": "Serialized TPUEmbeddingConfiguration proto."
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "description": "A TensorList of gradients with which to update embedding tables.\nThis argument has the same length and shapes as the return value of\nRecvTPUEmbeddingActivations, but contains gradients of the model's loss\nwith respect to the embedding activations. The embedding tables are updated\nfrom these gradients via the optimizer specified in the TPU embedding\nconfiguration given to tpu.initialize_system.",
        "numberAttr": "N",
        "type": 1
      },
      {
        "name": "learning_rates",
        "description": "A TensorList of float32 scalars, one for each dynamic learning\nrate tag: see the comments in\n//third_party/tensorflow/core/protobuf/tpu/optimization_parameters.proto.\nMultiple tables can share the same dynamic learning rate tag as specified\nin the configuration. If the learning rates for all tables are constant,\nthis list should be empty.",
        "numberAttr": "NN",
        "type": 1
      }
    ]
  },
  {
    "name": "SerializeIterator",
    "summary": "Converts the given `resource_handle` representing an iterator to a variant tensor.",
    "attributes": [
      {
        "name": "external_state_policy",
        "type": "int64",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "resource_handle",
        "description": "A handle to an iterator resource.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "serialized",
        "description": "A variant tensor storing the state of the iterator contained in the\nresource.",
        "type": 21
      }
    ]
  },
  {
    "name": "SerializeManySparse",
    "summary": "Serialize an `N`-minibatch `SparseTensor` into an `[N, 3]` `Tensor` object.",
    "description": "The `SparseTensor` must have rank `R` greater than 1, and the first dimension\nis treated as the minibatch dimension.  Elements of the `SparseTensor`\nmust be sorted in increasing order of this first dimension.  The serialized\n`SparseTensor` objects going into each row of `serialized_sparse` will have\nrank `R-1`.\n\nThe minibatch size `N` is extracted from `sparse_shape[0]`.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "The `dtype` to use for serialization; the supported types are `string`\n(default) and `variant`. Must be one of the following: `string`, `variant`.",
        "default": {
          "type": "type",
          "value": 7
        }
      }
    ],
    "inputs": [
      {
        "name": "sparse_indices",
        "description": "2-D.  The `indices` of the minibatch `SparseTensor`.",
        "type": 9
      },
      {
        "name": "sparse_values",
        "description": "1-D.  The `values` of the minibatch `SparseTensor`.",
        "typeAttr": "T"
      },
      {
        "name": "sparse_shape",
        "description": "1-D.  The `shape` of the minibatch `SparseTensor`.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "serialized_sparse",
        "typeAttr": "out_type"
      }
    ]
  },
  {
    "name": "SerializeSparse",
    "summary": "Serialize a `SparseTensor` into a `[3]` `Tensor` object.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "The `dtype` to use for serialization; the supported types are `string`\n(default) and `variant`. Must be one of the following: `string`, `variant`.",
        "default": {
          "type": "type",
          "value": 7
        }
      }
    ],
    "inputs": [
      {
        "name": "sparse_indices",
        "description": "2-D.  The `indices` of the `SparseTensor`.",
        "type": 9
      },
      {
        "name": "sparse_values",
        "description": "1-D.  The `values` of the `SparseTensor`.",
        "typeAttr": "T"
      },
      {
        "name": "sparse_shape",
        "description": "1-D.  The `shape` of the `SparseTensor`.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "serialized_sparse",
        "typeAttr": "out_type"
      }
    ]
  },
  {
    "name": "SerializeTensor",
    "summary": "Transforms a Tensor into a serialized TensorProto proto.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "The type of the input tensor."
      }
    ],
    "inputs": [
      {
        "name": "tensor",
        "description": "A Tensor of type `T`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "serialized",
        "description": "A serialized TensorProto proto of the input tensor.",
        "type": 7
      }
    ]
  },
  {
    "name": "SetSize",
    "summary": "Number of unique elements along last dimension of input `set`.",
    "description": "Input `set` is a `SparseTensor` represented by `set_indices`, `set_values`,\nand `set_shape`. The last dimension contains values in a set, duplicates are\nallowed but ignored.\n\nIf `validate_indices` is `True`, this op validates the order and range of `set`\nindices. Setting is to `False` while passing invalid arguments results in\nundefined behavior.",
    "attributes": [
      {
        "name": "validate_indices",
        "type": "boolean",
        "default": true
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `string`."
      }
    ],
    "inputs": [
      {
        "name": "set_indices",
        "description": "2D `Tensor`, indices of a `SparseTensor`.",
        "type": 9
      },
      {
        "name": "set_values",
        "description": "1D `Tensor`, values of a `SparseTensor`.",
        "typeAttr": "T"
      },
      {
        "name": "set_shape",
        "description": "1D `Tensor`, shape of a `SparseTensor`.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "size",
        "description": "For `set` ranked `n`, this is a `Tensor` with rank `n-1`, and the same 1st\n`n-1` dimensions as `set`. Each value is the number of unique elements in\nthe corresponding `[0...n-1]` dimension of `set`.",
        "type": 3
      }
    ]
  },
  {
    "name": "SetStatsAggregatorDataset",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "stats_aggregator",
        "type": 20
      },
      {
        "name": "tag",
        "type": 7
      },
      {
        "name": "counter_prefix",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "Shape",
    "summary": "Returns the shape of a tensor.",
    "description": "This operation returns a 1-D integer tensor representing the shape of `input`.\n\nFor example:\n\n```\n# 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]\nshape(t) ==> [2, 2, 3]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "out_type"
      }
    ]
  },
  {
    "name": "ShapeN",
    "summary": "Returns shape of tensors.",
    "description": "This operation returns N 1-D integer tensors representing shape of `input[i]s`.",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "numberAttr": "N",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "numberAttr": "N",
        "typeAttr": "out_type"
      }
    ]
  },
  {
    "name": "ShardDataset",
    "summary": "Creates a `Dataset` that includes only 1/`num_shards` of this dataset.",
    "attributes": [
      {
        "name": "require_non_empty",
        "type": "boolean",
        "default": false
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "num_shards",
        "description": "An integer representing the number of shards operating in parallel.",
        "type": 9
      },
      {
        "name": "index",
        "description": "An integer representing the current worker index.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ShardedFilename",
    "summary": "Generate a sharded filename. The filename is printf formatted as",
    "description": "   %s-%05d-of-%05d, basename, shard, num_shards.",
    "inputs": [
      {
        "name": "basename",
        "type": 7
      },
      {
        "name": "shard",
        "type": 3
      },
      {
        "name": "num_shards",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "filename",
        "type": 7
      }
    ]
  },
  {
    "name": "ShardedFilespec",
    "summary": "Generate a glob pattern matching all sharded file names.",
    "inputs": [
      {
        "name": "basename",
        "type": 7
      },
      {
        "name": "num_shards",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "filename",
        "type": 7
      }
    ]
  },
  {
    "name": "ShuffleAndRepeatDataset",
    "summary": "Creates a dataset that shuffles and repeats elements from `input_dataset`",
    "description": "pseudorandomly.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "reshuffle_each_iteration",
        "type": "boolean",
        "default": true
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "buffer_size",
        "description": "The number of output elements to buffer in an iterator over\nthis dataset. Compare with the `min_after_dequeue` attr when creating a\n`RandomShuffleQueue`.",
        "type": 9
      },
      {
        "name": "seed",
        "description": "A scalar seed for the random number generator. If either `seed` or\n`seed2` is set to be non-zero, the random number generator is seeded\nby the given seed.  Otherwise, a random seed is used.",
        "type": 9
      },
      {
        "name": "seed2",
        "description": "A second scalar seed to avoid seed collision.",
        "type": 9
      },
      {
        "name": "count",
        "description": "A scalar representing the number of times the underlying dataset\nshould be repeated. The default is `-1`, which results in infinite repetition.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ShuffleAndRepeatDatasetV2",
    "attributes": [
      {
        "name": "reshuffle_each_iteration",
        "type": "boolean",
        "default": true
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "buffer_size",
        "type": 9
      },
      {
        "name": "seed",
        "type": 9
      },
      {
        "name": "seed2",
        "type": 9
      },
      {
        "name": "count",
        "type": 9
      },
      {
        "name": "seed_generator",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ShuffleDataset",
    "summary": "Creates a dataset that shuffles elements from `input_dataset` pseudorandomly.",
    "attributes": [
      {
        "name": "reshuffle_each_iteration",
        "type": "boolean",
        "description": "If true, each iterator over this dataset will be given\na different pseudorandomly generated seed, based on a sequence seeded by the\n`seed` and `seed2` inputs. If false, each iterator will be given the same\nseed, and repeated iteration over this dataset will yield the exact same\nsequence of results.",
        "default": true
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "buffer_size",
        "description": "The number of output elements to buffer in an iterator over\nthis dataset. Compare with the `min_after_dequeue` attr when creating a\n`RandomShuffleQueue`.",
        "type": 9
      },
      {
        "name": "seed",
        "description": "A scalar seed for the random number generator. If either `seed` or\n`seed2` is set to be non-zero, the random number generator is seeded\nby the given seed.  Otherwise, a random seed is used.",
        "type": 9
      },
      {
        "name": "seed2",
        "description": "A second scalar seed to avoid seed collision.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ShuffleDatasetV2",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "buffer_size",
        "type": 9
      },
      {
        "name": "seed_generator",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ShuffleDatasetV3",
    "attributes": [
      {
        "name": "reshuffle_each_iteration",
        "type": "boolean",
        "default": true
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "buffer_size",
        "type": 9
      },
      {
        "name": "seed",
        "type": 9
      },
      {
        "name": "seed2",
        "type": 9
      },
      {
        "name": "seed_generator",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ShutdownDistributedTPU",
    "summary": "Shuts down a running distributed TPU system.",
    "description": "The op returns an error if no system is running."
  },
  {
    "name": "ShutdownTPUSystem",
    "summary": "An op that shuts down the TPU system.",
    "outputs": [
      {
        "name": "success",
        "description": "A boolean that indicates if the shut down process succeeds.",
        "type": 10
      }
    ]
  },
  {
    "name": "Sigmoid",
    "category": "Activation",
    "summary": "Computes sigmoid of `x` element-wise.",
    "description": "Specifically, `y = 1 / (1 + exp(-x))`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SigmoidGrad",
    "summary": "Computes the gradient of the sigmoid of `x` wrt its input.",
    "description": "Specifically, `grad = dy * y * (1 - y)`, where `y = sigmoid(x)`, and\n`dy` is the corresponding input gradient.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "y",
        "typeAttr": "T"
      },
      {
        "name": "dy",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Sign",
    "summary": "Returns an element-wise indication of the sign of a number.",
    "description": "`y = sign(x) = -1` if `x < 0`; 0 if `x == 0`; 1 if `x > 0`.\n\nFor complex numbers, `y = sign(x) = x / |x|` if `x != 0`, otherwise `y = 0`.\n\nExample usage:\n>>> tf.math.sign([0., 2., -3.])\n<tf.Tensor: shape=(3,), dtype=float32, numpy=array([ 0.,  1., -1.], dtype=float32)>",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `int8`, `int16`, `int32`, `int64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Sin",
    "summary": "Computes sine of x element-wise.",
    "description": "  Given an input tensor, this function computes sine of every\n  element in the tensor. Input range is `(-inf, inf)` and\n  output range is `[-1,1]`.\n\n  ```python\n  x = tf.constant([-float(\"inf\"), -9, -0.5, 1, 1.2, 200, 10, float(\"inf\")])\n  tf.math.sin(x) ==> [nan -0.4121185 -0.47942555 0.84147096 0.9320391 -0.87329733 -0.54402107 nan]\n  ```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Sinh",
    "summary": "Computes hyperbolic sine of x element-wise.",
    "description": "  Given an input tensor, this function computes hyperbolic sine of every\n  element in the tensor. Input range is `[-inf,inf]` and output range\n  is `[-inf,inf]`.\n\n  ```python\n  x = tf.constant([-float(\"inf\"), -9, -0.5, 1, 1.2, 2, 10, float(\"inf\")])\n  tf.math.sinh(x) ==> [-inf -4.0515420e+03 -5.2109528e-01 1.1752012e+00 1.5094614e+00 3.6268604e+00 1.1013232e+04 inf]\n  ```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Size",
    "summary": "Returns the size of a tensor.",
    "description": "This operation returns an integer representing the number of elements in\n`input`.\n\nFor example:\n\n```\n# 't' is [[[1, 1,, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]]\nsize(t) ==> 12\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "out_type"
      }
    ]
  },
  {
    "name": "SkipDataset",
    "summary": "Creates a dataset that skips `count` elements from the `input_dataset`.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "count",
        "description": "A scalar representing the number of elements from the `input_dataset`\nthat should be skipped.  If count is -1, skips everything.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "Skipgram",
    "summary": "Parses a text file and creates a batch of examples.",
    "attributes": [
      {
        "name": "filename",
        "type": "string",
        "description": "The corpus's text file name."
      },
      {
        "name": "batch_size",
        "type": "int64",
        "description": "The size of produced batch."
      },
      {
        "name": "window_size",
        "type": "int64",
        "description": "The number of words to predict to the left and right of the target.",
        "default": 5
      },
      {
        "name": "min_count",
        "type": "int64",
        "description": "The minimum number of word occurrences for it to be included in the\nvocabulary.",
        "default": 5
      },
      {
        "name": "subsample",
        "type": "float32",
        "description": "Threshold for word occurrence. Words that appear with higher\nfrequency will be randomly down-sampled. Set to 0 to disable.",
        "default": 0.0010000000474974513
      }
    ],
    "outputs": [
      {
        "name": "vocab_word",
        "description": "A vector of words in the corpus.",
        "type": 7
      },
      {
        "name": "vocab_freq",
        "description": "Frequencies of words. Sorted in the non-ascending order.",
        "type": 3
      },
      {
        "name": "words_per_epoch",
        "description": "Number of words per epoch in the data file.",
        "type": 9
      },
      {
        "name": "current_epoch",
        "description": "The current epoch number.",
        "type": 3
      },
      {
        "name": "total_words_processed",
        "description": "The total number of words processed so far.",
        "type": 9
      },
      {
        "name": "examples",
        "description": "A vector of word ids.",
        "type": 3
      },
      {
        "name": "labels",
        "description": "A vector of word ids.",
        "type": 3
      }
    ]
  },
  {
    "name": "SleepDataset",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "sleep_microseconds",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "Slice",
    "category": "Tensor",
    "summary": "Return a slice from 'input'.",
    "description": "The output tensor is a tensor with dimensions described by 'size'\nwhose values are extracted from 'input' starting at the offsets in\n'begin'.\n\n*Requirements*:\n  0 <= begin[i] <= begin[i] + size[i] <= Di  for i in [0, n)",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Index",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "begin",
        "description": "begin[i] specifies the offset into the 'i'th dimension of\n'input' to slice from.",
        "typeAttr": "Index"
      },
      {
        "name": "size",
        "description": "size[i] specifies the number of elements of the 'i'th dimension\nof 'input' to slice. If size[i] is -1, all remaining elements in dimension\ni are included in the slice (i.e. this is equivalent to setting\nsize[i] = input.dim_size(i) - begin[i]).",
        "typeAttr": "Index"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SlidingWindowDataset",
    "summary": "Creates a dataset that passes a sliding window over `input_dataset`.",
    "attributes": [
      {
        "name": "drop_remainder",
        "type": "boolean",
        "default": true
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "window_size",
        "description": "A scalar representing the number of elements in the\nsliding window.",
        "type": 9
      },
      {
        "name": "window_shift",
        "description": "A scalar representing the steps moving the sliding window\nforward in one iteration. It must be positive.",
        "type": 9
      },
      {
        "name": "window_stride",
        "description": "A scalar representing the stride of the input elements of the sliding window.\nIt must be positive.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "Snapshot",
    "summary": "Returns a copy of the input tensor.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SnapshotChunkDataset",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "compression",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "chunk_file",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "SnapshotDataset",
    "summary": "Creates a dataset that will write to / read from a snapshot.",
    "description": "This dataset attempts to determine whether a valid snapshot exists at the\n`snapshot_path`, and reads from the snapshot in lieu of using `input_dataset`.\nIf not, it will run the preprocessing pipeline as usual, and write out a\nsnapshot of the data processed for future use.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "compression",
        "type": "string",
        "default": ""
      },
      {
        "name": "reader_path_prefix",
        "type": "string",
        "default": ""
      },
      {
        "name": "writer_path_prefix",
        "type": "string",
        "default": ""
      },
      {
        "name": "shard_size_bytes",
        "type": "int64",
        "default": 10737418240
      },
      {
        "name": "pending_snapshot_expiry_seconds",
        "type": "int64",
        "default": 86400
      },
      {
        "name": "num_reader_threads",
        "type": "int64",
        "default": 1
      },
      {
        "name": "reader_buffer_size",
        "type": "int64",
        "default": 1
      },
      {
        "name": "num_writer_threads",
        "type": "int64",
        "default": 1
      },
      {
        "name": "writer_buffer_size",
        "type": "int64",
        "default": 1
      },
      {
        "name": "shuffle_on_read",
        "type": "boolean",
        "default": false
      },
      {
        "name": "seed",
        "type": "int64",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "default": 0
      },
      {
        "name": "mode",
        "type": "string",
        "default": "auto"
      },
      {
        "name": "snapshot_name",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the input dataset.",
        "type": 21
      },
      {
        "name": "path",
        "description": "The path we should write snapshots to / read snapshots from.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "SnapshotDatasetReader",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "compression",
        "type": "string",
        "default": ""
      },
      {
        "name": "version",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "name": "shard_dir",
        "type": 7
      },
      {
        "name": "start_index",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "SnapshotDatasetV2",
    "summary": "Creates a dataset that will write to / read from a snapshot.",
    "description": "This dataset attempts to determine whether a valid snapshot exists at the\n`snapshot_path`, and reads from the snapshot in lieu of using `input_dataset`.\nIf not, it will run the preprocessing pipeline as usual, and write out a\nsnapshot of the data processed for future use.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "compression",
        "type": "string",
        "description": "The type of compression to be applied to the saved snapshot files.",
        "default": ""
      },
      {
        "name": "reader_prefix",
        "type": "string",
        "default": ""
      },
      {
        "name": "writer_prefix",
        "type": "string",
        "default": ""
      },
      {
        "name": "hash_valid",
        "type": "boolean",
        "default": false
      },
      {
        "name": "hash",
        "type": "int64",
        "default": 0
      },
      {
        "name": "reader_func",
        "type": "function",
        "description": "Optional. A function to control how to read data from snapshot shards."
      },
      {
        "name": "shard_func",
        "type": "function",
        "description": "Optional. A function to control how to shard data when writing a snapshot."
      },
      {
        "name": "Treader_func_args",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "Tshard_func_args",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "description": "A variant tensor representing the input dataset.",
        "type": 21
      },
      {
        "name": "path",
        "description": "The path we should write snapshots to / read snapshots from.",
        "type": 7
      },
      {
        "name": "reader_func_other_args",
        "typeListAttr": "Treader_func_args"
      },
      {
        "name": "shard_func_other_args",
        "typeListAttr": "Tshard_func_args"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "SnapshotNestedDatasetReader",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "numberAttr": "N",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "SobolSample",
    "summary": "Generates points from the Sobol sequence.",
    "description": "Creates a Sobol sequence with `num_results` samples. Each sample has dimension\n`dim`. Skips the first `skip` samples.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the sample. One of: `float32` or `float64`. Must be one of the following: `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "dim",
        "description": "Positive scalar `Tensor` representing each sample's dimension.",
        "type": 3
      },
      {
        "name": "num_results",
        "description": "Positive scalar `Tensor` of dtype int32. The number of Sobol points to return\nin the output.",
        "type": 3
      },
      {
        "name": "skip",
        "description": "Positive scalar `Tensor` of dtype int32. The number of initial points of the\nSobol sequence to skip.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "samples",
        "description": "`Tensor` of samples from Sobol sequence with `shape` [num_results, dim].",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "Softmax",
    "category": "Activation",
    "summary": "Computes softmax activations.",
    "description": "For each batch `i` and class `j` we have\n\n    $$softmax[i, j] = exp(logits[i, j]) / sum_j(exp(logits[i, j]))$$",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "logits",
        "description": "2-D with shape `[batch_size, num_classes]`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "softmax",
        "description": "Same shape as `logits`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SoftmaxCrossEntropyWithLogits",
    "summary": "Computes softmax cross entropy cost and gradients to backpropagate.",
    "description": "Inputs are the logits, not probabilities.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "features",
        "description": "batch_size x num_classes matrix",
        "typeAttr": "T"
      },
      {
        "name": "labels",
        "description": "batch_size x num_classes matrix\nThe caller must ensure that each batch of labels represents a valid\nprobability distribution.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "loss",
        "description": "Per example loss (batch_size vector).",
        "typeAttr": "T"
      },
      {
        "name": "backprop",
        "description": "backpropagated gradients (batch_size x num_classes matrix).",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Softplus",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "features",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "activations",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SoftplusGrad",
    "summary": "Computes softplus gradients for a softplus operation.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "gradients",
        "description": "The backpropagated gradients to the corresponding softplus operation.",
        "typeAttr": "T"
      },
      {
        "name": "features",
        "description": "The features passed as input to the corresponding softplus operation.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "backprops",
        "description": "The gradients: `gradients / (1 + exp(-features))`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Softsign",
    "summary": "Computes softsign: `features / (abs(features) + 1)`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "features",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "activations",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SoftsignGrad",
    "summary": "Computes softsign gradients for a softsign operation.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "gradients",
        "description": "The backpropagated gradients to the corresponding softsign operation.",
        "typeAttr": "T"
      },
      {
        "name": "features",
        "description": "The features passed as input to the corresponding softsign operation.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "backprops",
        "description": "The gradients: `gradients / (1 + abs(features)) ** 2`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SortListOfSparseCoreCooTensors",
    "attributes": [
      {
        "name": "sample_count_list",
        "type": "int64[]"
      },
      {
        "name": "col_offset_list",
        "type": "int64[]"
      },
      {
        "name": "num_replica",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "table_vocab_size",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "feature_width",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "num_sc_per_chip",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "max_ids_per_sparse_core",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "max_unique_ids_per_sparse_core",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "table_name",
        "type": "string"
      },
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "row_ids_list",
        "numberAttr": "N",
        "type": 3
      },
      {
        "name": "col_ids_list",
        "numberAttr": "N",
        "type": 3
      },
      {
        "name": "gains_list",
        "numberAttr": "N",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "sorted_row_ids",
        "type": 3
      },
      {
        "name": "sorted_col_ids",
        "type": 3
      },
      {
        "name": "sorted_gains",
        "type": 1
      },
      {
        "name": "id_counts",
        "type": 3
      }
    ]
  },
  {
    "name": "SpaceToBatch",
    "summary": "SpaceToBatch for 4-D tensors of type T.",
    "description": "This is a legacy version of the more general SpaceToBatchND.\n\nZero-pads and then rearranges (permutes) blocks of spatial data into batch.\nMore specifically, this op outputs a copy of the input tensor where values from\nthe `height` and `width` dimensions are moved to the `batch` dimension. After\nthe zero-padding, both `height` and `width` of the input must be divisible by the\nblock size.\n\nThe attr `block_size` must be greater than one. It indicates the block size.\n\n  * Non-overlapping blocks of size `block_size x block size` in the height and\n    width dimensions are rearranged into the batch dimension at each location.\n  * The batch of the output tensor is `batch * block_size * block_size`.\n  * Both height_pad and width_pad must be divisible by block_size.\n\nThe shape of the output will be:\n\n    [batch*block_size*block_size, height_pad/block_size, width_pad/block_size,\n     depth]\n\nSome examples:\n\n(1) For the following input of shape `[1, 2, 2, 1]` and block_size of 2:\n\n```\nx = [[[[1], [2]], [[3], [4]]]]\n```\n\nThe output tensor has shape `[4, 1, 1, 1]` and value:\n\n```\n[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]\n```\n\n(2) For the following input of shape `[1, 2, 2, 3]` and block_size of 2:\n\n```\nx = [[[[1, 2, 3], [4, 5, 6]],\n      [[7, 8, 9], [10, 11, 12]]]]\n```\n\nThe output tensor has shape `[4, 1, 1, 3]` and value:\n\n```\n[[[[1, 2, 3]]], [[[4, 5, 6]]], [[[7, 8, 9]]], [[[10, 11, 12]]]]\n```\n\n(3) For the following input of shape `[1, 4, 4, 1]` and block_size of 2:\n\n```\nx = [[[[1],   [2],  [3],  [4]],\n      [[5],   [6],  [7],  [8]],\n      [[9],  [10], [11],  [12]],\n      [[13], [14], [15],  [16]]]]\n```\n\nThe output tensor has shape `[4, 2, 2, 1]` and value:\n\n```\nx = [[[[1], [3]], [[9], [11]]],\n     [[[2], [4]], [[10], [12]]],\n     [[[5], [7]], [[13], [15]]],\n     [[[6], [8]], [[14], [16]]]]\n```\n\n(4) For the following input of shape `[2, 2, 4, 1]` and block_size of 2:\n\n```\nx = [[[[1],   [2],  [3],  [4]],\n      [[5],   [6],  [7],  [8]]],\n     [[[9],  [10], [11],  [12]],\n      [[13], [14], [15],  [16]]]]\n```\n\nThe output tensor has shape `[8, 1, 2, 1]` and value:\n\n```\nx = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]],\n     [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]]\n```\n\nAmong others, this operation is useful for reducing atrous convolution into\nregular convolution.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tpaddings",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "block_size",
        "type": "int64",
        "minimum": 2
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "4-D with shape `[batch, height, width, depth]`.",
        "typeAttr": "T"
      },
      {
        "name": "paddings",
        "description": "2-D tensor of non-negative integers with shape `[2, 2]`. It specifies\n  the padding of the input with zeros across the spatial dimensions as follows:\n\n      paddings = [[pad_top, pad_bottom], [pad_left, pad_right]]\n\n  The effective spatial dimensions of the zero-padded input tensor will be:\n\n      height_pad = pad_top + height + pad_bottom\n      width_pad = pad_left + width + pad_right",
        "typeAttr": "Tpaddings"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SpaceToBatchND",
    "summary": "SpaceToBatch for N-D tensors of type T.",
    "description": "This operation divides \"spatial\" dimensions `[1, ..., M]` of the input into a\ngrid of blocks of shape `block_shape`, and interleaves these blocks with the\n\"batch\" dimension (0) such that in the output, the spatial dimensions\n`[1, ..., M]` correspond to the position within the grid, and the batch\ndimension combines both the position within a spatial block and the original\nbatch position.  Prior to division into blocks, the spatial dimensions of the\ninput are optionally zero padded according to `paddings`. See below for a\nprecise description.\n\nThis operation is equivalent to the following steps:\n\n1. Zero-pad the start and end of dimensions `[1, ..., M]` of the\n   input according to `paddings` to produce `padded` of shape `padded_shape`.\n\n2. Reshape `padded` to `reshaped_padded` of shape:\n\n     [batch] +\n     [padded_shape[1] / block_shape[0],\n       block_shape[0],\n      ...,\n      padded_shape[M] / block_shape[M-1],\n      block_shape[M-1]] +\n     remaining_shape\n\n3. Permute dimensions of `reshaped_padded` to produce\n   `permuted_reshaped_padded` of shape:\n\n     block_shape +\n     [batch] +\n     [padded_shape[1] / block_shape[0],\n      ...,\n      padded_shape[M] / block_shape[M-1]] +\n     remaining_shape\n\n4. Reshape `permuted_reshaped_padded` to flatten `block_shape` into the batch\n   dimension, producing an output tensor of shape:\n\n     [batch * prod(block_shape)] +\n     [padded_shape[1] / block_shape[0],\n      ...,\n      padded_shape[M] / block_shape[M-1]] +\n     remaining_shape\n\nSome examples:\n\n(1) For the following input of shape `[1, 2, 2, 1]`, `block_shape = [2, 2]`, and\n    `paddings = [[0, 0], [0, 0]]`:\n\n```\nx = [[[[1], [2]], [[3], [4]]]]\n```\n\nThe output tensor has shape `[4, 1, 1, 1]` and value:\n\n```\n[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]\n```\n\n(2) For the following input of shape `[1, 2, 2, 3]`, `block_shape = [2, 2]`, and\n    `paddings = [[0, 0], [0, 0]]`:\n\n```\nx = [[[[1, 2, 3], [4, 5, 6]],\n      [[7, 8, 9], [10, 11, 12]]]]\n```\n\nThe output tensor has shape `[4, 1, 1, 3]` and value:\n\n```\n[[[[1, 2, 3]]], [[[4, 5, 6]]], [[[7, 8, 9]]], [[[10, 11, 12]]]]\n```\n\n(3) For the following input of shape `[1, 4, 4, 1]`, `block_shape = [2, 2]`, and\n    `paddings = [[0, 0], [0, 0]]`:\n\n```\nx = [[[[1],   [2],  [3],  [4]],\n      [[5],   [6],  [7],  [8]],\n      [[9],  [10], [11],  [12]],\n      [[13], [14], [15],  [16]]]]\n```\n\nThe output tensor has shape `[4, 2, 2, 1]` and value:\n\n```\nx = [[[[1], [3]], [[9], [11]]],\n     [[[2], [4]], [[10], [12]]],\n     [[[5], [7]], [[13], [15]]],\n     [[[6], [8]], [[14], [16]]]]\n```\n\n(4) For the following input of shape `[2, 2, 4, 1]`, block_shape = `[2, 2]`, and\n    paddings = `[[0, 0], [2, 0]]`:\n\n```\nx = [[[[1],   [2],  [3],  [4]],\n      [[5],   [6],  [7],  [8]]],\n     [[[9],  [10], [11],  [12]],\n      [[13], [14], [15],  [16]]]]\n```\n\nThe output tensor has shape `[8, 1, 3, 1]` and value:\n\n```\nx = [[[[0], [1], [3]]], [[[0], [9], [11]]],\n     [[[0], [2], [4]]], [[[0], [10], [12]]],\n     [[[0], [5], [7]]], [[[0], [13], [15]]],\n     [[[0], [6], [8]]], [[[0], [14], [16]]]]\n```\n\nAmong others, this operation is useful for reducing atrous convolution into\nregular convolution.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tblock_shape",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "Tpaddings",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "N-D with shape `input_shape = [batch] + spatial_shape + remaining_shape`,\nwhere spatial_shape has `M` dimensions.",
        "typeAttr": "T"
      },
      {
        "name": "block_shape",
        "description": "1-D with shape `[M]`, all values must be >= 1.",
        "typeAttr": "Tblock_shape"
      },
      {
        "name": "paddings",
        "description": "2-D with shape `[M, 2]`, all values must be >= 0.\n  `paddings[i] = [pad_start, pad_end]` specifies the padding for input dimension\n  `i + 1`, which corresponds to spatial dimension `i`.  It is required that\n  `block_shape[i]` divides `input_shape[i + 1] + pad_start + pad_end`.",
        "typeAttr": "Tpaddings"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SpaceToDepth",
    "summary": "SpaceToDepth for tensors of type T.",
    "description": "Rearranges blocks of spatial data, into depth. More specifically,\nthis op outputs a copy of the input tensor where values from the `height`\nand `width` dimensions are moved to the `depth` dimension.\nThe attr `block_size` indicates the input block size.\n\n  * Non-overlapping blocks of size `block_size x block size` are rearranged\n    into depth at each location.\n  * The depth of the output tensor is `block_size * block_size * input_depth`.\n  * The Y, X coordinates within each block of the input become the high order\n    component of the output channel index.\n  * The input tensor's height and width must be divisible by block_size.\n\nThe `data_format` attr specifies the layout of the input and output tensors\nwith the following options:\n  \"NHWC\": `[ batch, height, width, channels ]`\n  \"NCHW\": `[ batch, channels, height, width ]`\n  \"NCHW_VECT_C\":\n      `qint8 [ batch, channels / 4, height, width, 4 ]`\n\nIt is useful to consider the operation as transforming a 6-D Tensor.\ne.g. for data_format = NHWC,\n     Each element in the input tensor can be specified via 6 coordinates,\n     ordered by decreasing memory layout significance as:\n     n,oY,bY,oX,bX,iC  (where n=batch index, oX, oY means X or Y coordinates\n                        within the output image, bX, bY means coordinates\n                        within the input block, iC means input channels).\n     The output would be a transpose to the following layout:\n     n,oY,oX,bY,bX,iC\n\nThis operation is useful for resizing the activations between convolutions\n(but keeping all data), e.g. instead of pooling. It is also useful for training\npurely convolutional models.\n\nFor example, given an input of shape `[1, 2, 2, 1]`, data_format = \"NHWC\" and\nblock_size = 2:\n\n```\nx = [[[[1], [2]],\n      [[3], [4]]]]\n```\n\nThis operation will output a tensor of shape `[1, 1, 1, 4]`:\n\n```\n[[[[1, 2, 3, 4]]]]\n```\n\nHere, the input has a batch of 1 and each batch element has shape `[2, 2, 1]`,\nthe corresponding output will have a single element (i.e. width and height are\nboth 1) and will have a depth of 4 channels (1 * block_size * block_size).\nThe output element shape is `[1, 1, 4]`.\n\nFor an input tensor with larger depth, here of shape `[1, 2, 2, 3]`, e.g.\n\n```\nx = [[[[1, 2, 3], [4, 5, 6]],\n      [[7, 8, 9], [10, 11, 12]]]]\n```\n\nThis operation, for block_size of 2, will return the following tensor of shape\n`[1, 1, 1, 12]`\n\n```\n[[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]\n```\n\nSimilarly, for the following input of shape `[1 4 4 1]`, and a block size of 2:\n\n```\nx = [[[[1],   [2],  [5],  [6]],\n      [[3],   [4],  [7],  [8]],\n      [[9],  [10], [13],  [14]],\n      [[11], [12], [15],  [16]]]]\n```\n\nthe operator will return the following tensor of shape `[1 2 2 4]`:\n\n```\nx = [[[[1, 2, 3, 4],\n       [5, 6, 7, 8]],\n      [[9, 10, 11, 12],\n       [13, 14, 15, 16]]]]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "block_size",
        "type": "int64",
        "description": "The size of the spatial block.",
        "minimum": 2
      },
      {
        "name": "data_format",
        "type": "string",
        "description": "Must be one of the following: `NHWC`, `NCHW`, `NCHW_VECT_C`.",
        "default": "NHWC"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseAccumulatorApplyGradient",
    "summary": "Applies a sparse gradient to a given accumulator.",
    "description": "Does not add if local_step is smaller than the accumulator's\nglobal_step.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The data type of accumulated gradients. Needs to correspond to the type\nof the accumulator. Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "has_known_shape",
        "type": "boolean",
        "description": "Boolean indicating whether gradient_shape is unknown, in which\ncase the input is ignored during validation."
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a accumulator.",
        "type": 7,
        "isRef": true
      },
      {
        "name": "local_step",
        "description": "The local_step value at which the sparse gradient was computed.",
        "type": 9
      },
      {
        "name": "gradient_indices",
        "description": "Indices of the sparse gradient to be accumulated. Must be a\nvector.",
        "type": 9
      },
      {
        "name": "gradient_values",
        "description": "Values are the non-zero slices of the gradient, and must have\nthe same first dimension as indices, i.e., the nnz represented by indices and\nvalues must be consistent.",
        "typeAttr": "dtype"
      },
      {
        "name": "gradient_shape",
        "description": "Shape of the sparse gradient to be accumulated.",
        "type": 9
      }
    ]
  },
  {
    "name": "SparseAccumulatorTakeGradient",
    "summary": "Extracts the average sparse gradient in a SparseConditionalAccumulator.",
    "description": "The op will blocks until sufficient (i.e., more than num_required)\ngradients have been accumulated. If the accumulator has already\naggregated more than num_required gradients, it will return its\naverage of the accumulated gradients.  Also automatically increments\nthe recorded global_step in the accumulator by 1, and resets the\naggregate to 0.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The data type of accumulated gradients. Needs to correspond to the type\nof the accumulator. Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a SparseConditionalAccumulator.",
        "type": 7,
        "isRef": true
      },
      {
        "name": "num_required",
        "description": "Number of gradients required before we return an aggregate.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "indices",
        "description": "Indices of the average of the accumulated sparse gradients.",
        "type": 9
      },
      {
        "name": "values",
        "description": "Values of the average of the accumulated sparse gradients.",
        "typeAttr": "dtype"
      },
      {
        "name": "shape",
        "description": "Shape of the average of the accumulated sparse gradients.",
        "type": 9
      }
    ]
  },
  {
    "name": "SparseAdd",
    "summary": "Adds two `SparseTensor` objects to produce another `SparseTensor`.",
    "description": "The input `SparseTensor` objects' indices are assumed ordered in standard\nlexicographic order.  If this is not the case, before this step run\n`SparseReorder` to restore index ordering.\n\nBy default, if two values sum to zero at some index, the output `SparseTensor`\nwould still include that particular location in its index, storing a zero in the\ncorresponding value slot.  To override this, callers can specify `thresh`,\nindicating that if the sum has a magnitude strictly smaller than `thresh`, its\ncorresponding value and index would then not be included.  In particular,\n`thresh == 0` (default) means everything is kept and actual thresholding happens\nonly for a positive value.\n\nIn the following shapes, `nnz` is the count after taking `thresh` into account.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Treal",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "a_indices",
        "description": "2-D.  The `indices` of the first `SparseTensor`, size `[nnz, ndims]` Matrix.",
        "type": 9
      },
      {
        "name": "a_values",
        "description": "1-D.  The `values` of the first `SparseTensor`, size `[nnz]` Vector.",
        "typeAttr": "T"
      },
      {
        "name": "a_shape",
        "description": "1-D.  The `shape` of the first `SparseTensor`, size `[ndims]` Vector.",
        "type": 9
      },
      {
        "name": "b_indices",
        "description": "2-D.  The `indices` of the second `SparseTensor`, size `[nnz, ndims]` Matrix.",
        "type": 9
      },
      {
        "name": "b_values",
        "description": "1-D.  The `values` of the second `SparseTensor`, size `[nnz]` Vector.",
        "typeAttr": "T"
      },
      {
        "name": "b_shape",
        "description": "1-D.  The `shape` of the second `SparseTensor`, size `[ndims]` Vector.",
        "type": 9
      },
      {
        "name": "thresh",
        "description": "0-D.  The magnitude threshold that determines if an output value/index\npair takes space.",
        "typeAttr": "Treal"
      }
    ],
    "outputs": [
      {
        "name": "sum_indices",
        "type": 9
      },
      {
        "name": "sum_values",
        "typeAttr": "T"
      },
      {
        "name": "sum_shape",
        "type": 9
      }
    ]
  },
  {
    "name": "SparseAddGrad",
    "summary": "The gradient operator for the SparseAdd op.",
    "description": "The SparseAdd op calculates A + B, where A, B, and the sum are all represented\nas `SparseTensor` objects.  This op takes in the upstream gradient w.r.t.\nnon-empty values of the sum, and outputs the gradients w.r.t. the non-empty\nvalues of A and B.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "backprop_val_grad",
        "description": "1-D with shape `[nnz(sum)]`.  The gradient with respect to\nthe non-empty values of the sum.",
        "typeAttr": "T"
      },
      {
        "name": "a_indices",
        "description": "2-D.  The `indices` of the `SparseTensor` A, size `[nnz(A), ndims]`.",
        "type": 9
      },
      {
        "name": "b_indices",
        "description": "2-D.  The `indices` of the `SparseTensor` B, size `[nnz(B), ndims]`.",
        "type": 9
      },
      {
        "name": "sum_indices",
        "description": "2-D.  The `indices` of the sum `SparseTensor`, size\n`[nnz(sum), ndims]`.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "a_val_grad",
        "description": "1-D with shape `[nnz(A)]`. The gradient with respect to the\nnon-empty values of A.",
        "typeAttr": "T"
      },
      {
        "name": "b_val_grad",
        "description": "1-D with shape `[nnz(B)]`. The gradient with respect to the\nnon-empty values of B.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseApplyAdadelta",
    "summary": "var: Should be from a Variable().",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "accum_update",
        "description": ": Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "lr",
        "description": "Learning rate. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "rho",
        "description": "Decay factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "epsilon",
        "description": "Constant factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A vector of indices into the first dimension of var and accum.",
        "typeAttr": "Tindices"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "SparseApplyAdagrad",
    "summary": "Update relevant entries in '*var' and '*accum' according to the adagrad scheme.",
    "description": "That is for rows we have grad for, we update var and accum as follows:\n$$accum += grad * grad$$\n$$var -= lr * grad * (1 / sqrt(accum))$$",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "update_slots",
        "type": "boolean",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "lr",
        "description": "Learning rate. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A vector of indices into the first dimension of var and accum.",
        "typeAttr": "Tindices"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "SparseApplyAdagradDA",
    "summary": "Update entries in '*var' and '*accum' according to the proximal adagrad scheme.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "gradient_accumulator",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "gradient_squared_accumulator",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A vector of indices into the first dimension of var and accum.",
        "typeAttr": "Tindices"
      },
      {
        "name": "lr",
        "description": "Learning rate. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l1",
        "description": "L1 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2",
        "description": "L2 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "global_step",
        "description": "Training step number. Must be a scalar.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "SparseApplyAdagradV2",
    "summary": "Update relevant entries in '*var' and '*accum' according to the adagrad scheme.",
    "description": "That is for rows we have grad for, we update var and accum as follows:\n$$accum += grad * grad$$\n$$var -= lr * grad * (1 / sqrt(accum))$$",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "update_slots",
        "type": "boolean",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "lr",
        "description": "Learning rate. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "epsilon",
        "description": "Constant factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A vector of indices into the first dimension of var and accum.",
        "typeAttr": "Tindices"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "SparseApplyCenteredRMSProp",
    "summary": "Update '*var' according to the centered RMSProp algorithm.",
    "description": "The centered RMSProp algorithm uses an estimate of the centered second moment\n(i.e., the variance) for normalization, as opposed to regular RMSProp, which\nuses the (uncentered) second moment. This often helps with training, but is\nslightly more expensive in terms of computation and memory.\n\nNote that in dense implementation of this algorithm, mg, ms, and mom will\nupdate even if the grad is zero, but in this sparse implementation, mg, ms,\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nmean_grad = decay * mean_grad + (1-decay) * gradient\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)\n\n$$ms <- rho * ms_{t-1} + (1-rho) * grad * grad$$\n$$mom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)$$\n$$var <- var - mom$$",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var, mg, ms, and mom tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "mg",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "ms",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "mom",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "rho",
        "description": "Decay rate. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "momentum",
        "typeAttr": "T"
      },
      {
        "name": "epsilon",
        "description": "Ridge term. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A vector of indices into the first dimension of var, ms and mom.",
        "typeAttr": "Tindices"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "SparseApplyFtrl",
    "summary": "Update relevant entries in '*var' according to the Ftrl-proximal scheme.",
    "description": "That is for rows we have grad for, we update var, accum and linear as follows:\n$$accum_new = accum + grad * grad$$\n$$linear += grad + (accum_{new}^{-lr_{power}} - accum^{-lr_{power}} / lr * var$$\n$$quadratic = 1.0 / (accum_{new}^{lr_{power}} * lr) + 2 * l2$$\n$$var = (sign(linear) * l1 - linear) / quadratic\\ if\\ |linear| > l1\\ else\\ 0.0$$\n$$accum = accum_{new}$$",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "multiply_linear_by_lr",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "linear",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A vector of indices into the first dimension of var and accum.",
        "typeAttr": "Tindices"
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l1",
        "description": "L1 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2",
        "description": "L2 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "lr_power",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "SparseApplyFtrlV2",
    "summary": "Update relevant entries in '*var' according to the Ftrl-proximal scheme.",
    "description": "That is for rows we have grad for, we update var, accum and linear as follows:\ngrad_with_shrinkage = grad + 2 * l2_shrinkage * var\naccum_new = accum + grad * grad\nlinear += grad_with_shrinkage -\n    (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "multiply_linear_by_lr",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "linear",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A vector of indices into the first dimension of var and accum.",
        "typeAttr": "Tindices"
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l1",
        "description": "L1 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2",
        "description": "L2 shrinkage regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2_shrinkage",
        "typeAttr": "T"
      },
      {
        "name": "lr_power",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "SparseApplyMomentum",
    "summary": "Update relevant entries in '*var' and '*accum' according to the momentum scheme.",
    "description": "Set use_nesterov = True if you want to use Nesterov momentum.\n\nThat is for rows we have grad for, we update var and accum as follows:\n\n$$accum = accum * momentum + grad$$\n$$var -= lr * accum$$",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      },
      {
        "name": "use_nesterov",
        "type": "boolean",
        "description": "If `True`, the tensor passed to compute grad will be\nvar - lr * momentum * accum, so in the end, the var you get is actually\nvar - lr * momentum * accum.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "lr",
        "description": "Learning rate. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A vector of indices into the first dimension of var and accum.",
        "typeAttr": "Tindices"
      },
      {
        "name": "momentum",
        "description": "Momentum. Must be a scalar.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "SparseApplyProximalAdagrad",
    "summary": "Sparse update entries in '*var' and '*accum' according to FOBOS algorithm.",
    "description": "That is for rows we have grad for, we update var and accum as follows:\n$$accum += grad * grad$$\n$$prox_v = var$$\n$$prox_v -= lr * grad * (1 / sqrt(accum))$$\n$$var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}$$",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "accum",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "lr",
        "description": "Learning rate. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l1",
        "description": "L1 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2",
        "description": "L2 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A vector of indices into the first dimension of var and accum.",
        "typeAttr": "Tindices"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "SparseApplyProximalGradientDescent",
    "summary": "Sparse update '*var' as FOBOS algorithm with fixed learning rate.",
    "description": "That is for rows we have grad for, we update var as follows:\n$$prox_v = var - alpha * grad$$\n$$var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}$$",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "alpha",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l1",
        "description": "L1 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "l2",
        "description": "L2 regularization. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A vector of indices into the first dimension of var and accum.",
        "typeAttr": "Tindices"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "SparseApplyRMSProp",
    "summary": "Update '*var' according to the RMSProp algorithm.",
    "description": "Note that in dense implementation of this algorithm, ms and mom will\nupdate even if the grad is zero, but in this sparse implementation, ms\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon)\n\n$$ms <- rho * ms_{t-1} + (1-rho) * grad * grad$$\n$$mom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)$$\n$$var <- var - mom$$",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "use_locking",
        "type": "boolean",
        "description": "If `True`, updating of the var, ms, and mom tensors is protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "var",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "ms",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "mom",
        "description": "Should be from a Variable().",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "lr",
        "description": "Scaling factor. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "rho",
        "description": "Decay rate. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "momentum",
        "typeAttr": "T"
      },
      {
        "name": "epsilon",
        "description": "Ridge term. Must be a scalar.",
        "typeAttr": "T"
      },
      {
        "name": "grad",
        "description": "The gradient.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A vector of indices into the first dimension of var, ms and mom.",
        "typeAttr": "Tindices"
      }
    ],
    "outputs": [
      {
        "name": "out",
        "description": "Same as \"var\".",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "SparseBincount",
    "summary": "Counts the number of occurrences of each value in an integer array.",
    "description": "Outputs a vector with length `size` and the same dtype as `weights`. If\n`weights` are empty, then index `i` stores the number of times the value `i` is\ncounted in `arr`. If `weights` are non-empty, then index `i` stores the sum of\nthe value in `weights` at each index where the corresponding value in `arr` is\n`i`.\n\nValues in `arr` outside of the range [0, size) are ignored.",
    "attributes": [
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`, `float32`, `float64`."
      },
      {
        "name": "binary_output",
        "type": "boolean",
        "description": "bool; Whether the kernel should count the appearance or number of occurrences.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "indices",
        "description": "2D int64 `Tensor`.",
        "type": 9
      },
      {
        "name": "values",
        "description": "1D int `Tensor`.",
        "typeAttr": "Tidx"
      },
      {
        "name": "dense_shape",
        "description": "1D int64 `Tensor`.",
        "type": 9
      },
      {
        "name": "size",
        "description": "non-negative int scalar `Tensor`.",
        "typeAttr": "Tidx"
      },
      {
        "name": "weights",
        "description": "is an int32, int64, float32, or float64 `Tensor` with the same\nshape as `input`, or a length-0 `Tensor`, in which case it acts as all weights\nequal to 1.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "1D `Tensor` with length equal to `size` or 2D `Tensor` with [batch_size, `size`].\nThe counts or summed weights for each value in the range [0, size).",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseConcat",
    "summary": "Concatenates a list of `SparseTensor` along the specified dimension.",
    "description": "Concatenation is with respect to the dense versions of these sparse tensors.\nIt is assumed that each input is a `SparseTensor` whose elements are ordered\nalong increasing dimension number.\n\nAll inputs' shapes must match, except for the concat dimension.  The\n`indices`, `values`, and `shapes` lists must have the same length.\n\nThe output shape is identical to the inputs', except along the concat\ndimension, where it is the sum of the inputs' sizes along that dimension.\n\nThe output elements will be resorted to preserve the sort order along\nincreasing dimension number.\n\nThis op runs in `O(M log M)` time, where `M` is the total number of non-empty\nvalues across all inputs. This is due to the need for an internal sort in\norder to concatenate efficiently across an arbitrary dimension.\n\nFor example, if `concat_dim = 1` and the inputs are\n\n    sp_inputs[0]: shape = [2, 3]\n    [0, 2]: \"a\"\n    [1, 0]: \"b\"\n    [1, 1]: \"c\"\n\n    sp_inputs[1]: shape = [2, 4]\n    [0, 1]: \"d\"\n    [0, 2]: \"e\"\n\nthen the output will be\n\n    shape = [2, 7]\n    [0, 2]: \"a\"\n    [0, 4]: \"d\"\n    [0, 5]: \"e\"\n    [1, 0]: \"b\"\n    [1, 1]: \"c\"\n\nGraphically this is equivalent to doing\n\n    [    a] concat [  d e  ] = [    a   d e  ]\n    [b c  ]        [       ]   [b c          ]",
    "attributes": [
      {
        "name": "concat_dim",
        "type": "int64",
        "description": "Dimension to concatenate along. Must be in range [-rank, rank),\nwhere rank is the number of dimensions in each input `SparseTensor`."
      },
      {
        "name": "N",
        "type": "int64",
        "minimum": 2
      },
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "indices",
        "description": "2-D.  Indices of each input `SparseTensor`.",
        "numberAttr": "N",
        "type": 9
      },
      {
        "name": "values",
        "description": "1-D.  Non-empty values of each `SparseTensor`.",
        "numberAttr": "N",
        "typeAttr": "T"
      },
      {
        "name": "shapes",
        "description": "1-D.  Shapes of each `SparseTensor`.",
        "numberAttr": "N",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "output_indices",
        "description": "2-D.  Indices of the concatenated `SparseTensor`.",
        "type": 9
      },
      {
        "name": "output_values",
        "description": "1-D.  Non-empty values of the concatenated `SparseTensor`.",
        "typeAttr": "T"
      },
      {
        "name": "output_shape",
        "description": "1-D.  Shape of the concatenated `SparseTensor`.",
        "type": 9
      }
    ]
  },
  {
    "name": "SparseConditionalAccumulator",
    "summary": "A conditional accumulator for aggregating sparse gradients.",
    "description": "The accumulator accepts gradients marked with local_step greater or\nequal to the most recent global_step known to the accumulator. The\naverage can be extracted from the accumulator, provided sufficient\ngradients have been accumulated. Extracting the average automatically\nresets the aggregate to 0, and increments the global_step recorded by\nthe accumulator.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the value being accumulated. Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "shape",
        "type": "shape",
        "description": "The shape of the values."
      },
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this accumulator is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this accumulator will be shared under the given name\nacross multiple sessions.",
        "default": ""
      },
      {
        "name": "reduction_type",
        "type": "string",
        "description": "Must be one of the following: `MEAN`, `SUM`.",
        "default": "MEAN"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "The handle to the accumulator.",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "SparseCountSparseOutput",
    "summary": "Performs sparse-output bin counting for a sparse tensor input.",
    "description": "  Counts the number of times each value occurs in the input.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Dtype of the input values tensor. Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "minlength",
        "type": "int64",
        "description": "Minimum value to count. Can be set to -1 for no minimum.",
        "minimum": -1,
        "default": -1
      },
      {
        "name": "maxlength",
        "type": "int64",
        "description": "Maximum value to count. Can be set to -1 for no maximum.",
        "minimum": -1,
        "default": -1
      },
      {
        "name": "binary_output",
        "type": "boolean",
        "description": "Whether to output the number of occurrences of each value or 1."
      },
      {
        "name": "output_type",
        "type": "type",
        "description": "Dtype of the output values tensor. Must be one of the following: `int32`, `int64`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "indices",
        "description": "Tensor containing the indices of the sparse tensor to count.",
        "type": 9
      },
      {
        "name": "values",
        "description": "Tensor containing values of the sparse tensor to count.",
        "typeAttr": "T"
      },
      {
        "name": "dense_shape",
        "description": "Tensor containing the dense shape of the sparse tensor to count.",
        "type": 9
      },
      {
        "name": "weights",
        "description": "A Tensor of the same shape as indices containing per-index weight values.\nMay also be the empty tensor if no weights are used.",
        "typeAttr": "output_type"
      }
    ],
    "outputs": [
      {
        "name": "output_indices",
        "description": "Indices tensor for the resulting sparse tensor object.",
        "type": 9
      },
      {
        "name": "output_values",
        "description": "Values tensor for the resulting sparse tensor object.",
        "typeAttr": "output_type"
      },
      {
        "name": "output_dense_shape",
        "description": "Shape tensor for the resulting sparse tensor object.",
        "type": 9
      }
    ]
  },
  {
    "name": "SparseCross",
    "summary": "Generates sparse cross from a list of sparse and dense tensors.",
    "description": "The op takes two lists, one of 2D `SparseTensor` and one of 2D `Tensor`, each\nrepresenting features of one feature column. It outputs a 2D `SparseTensor` with\nthe batchwise crosses of these features.\n\nFor example, if the inputs are\n\n    inputs[0]: SparseTensor with shape = [2, 2]\n    [0, 0]: \"a\"\n    [1, 0]: \"b\"\n    [1, 1]: \"c\"\n\n    inputs[1]: SparseTensor with shape = [2, 1]\n    [0, 0]: \"d\"\n    [1, 0]: \"e\"\n\n    inputs[2]: Tensor [[\"f\"], [\"g\"]]\n\nthen the output will be\n\n    shape = [2, 2]\n    [0, 0]: \"a_X_d_X_f\"\n    [1, 0]: \"b_X_e_X_g\"\n    [1, 1]: \"c_X_e_X_g\"\n\nif hashed_output=true then the output will be\n\n    shape = [2, 2]\n    [0, 0]: FingerprintCat64(\n                Fingerprint64(\"f\"), FingerprintCat64(\n                    Fingerprint64(\"d\"), Fingerprint64(\"a\")))\n    [1, 0]: FingerprintCat64(\n                Fingerprint64(\"g\"), FingerprintCat64(\n                    Fingerprint64(\"e\"), Fingerprint64(\"b\")))\n    [1, 1]: FingerprintCat64(\n                Fingerprint64(\"g\"), FingerprintCat64(\n                    Fingerprint64(\"e\"), Fingerprint64(\"c\")))",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 0
      },
      {
        "name": "hashed_output",
        "type": "boolean",
        "description": "If true, returns the hash of the cross instead of the string.\nThis will allow us avoiding string manipulations."
      },
      {
        "name": "num_buckets",
        "type": "int64",
        "description": "It is used if hashed_output is true.\noutput = hashed_value%num_buckets if num_buckets > 0 else hashed_value.",
        "minimum": 0
      },
      {
        "name": "hash_key",
        "type": "int64",
        "description": "Specify the hash_key that will be used by the `FingerprintCat64`\nfunction to combine the crosses fingerprints."
      },
      {
        "name": "sparse_types",
        "type": "type[]",
        "minimum": 0,
        "description": "Must be one of the following: `int64`, `string`."
      },
      {
        "name": "dense_types",
        "type": "type[]",
        "minimum": 0,
        "description": "Must be one of the following: `int64`, `string`."
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `int64`, `string`."
      },
      {
        "name": "internal_type",
        "type": "type",
        "description": "Must be one of the following: `int64`, `string`."
      }
    ],
    "inputs": [
      {
        "name": "indices",
        "description": "2-D.  Indices of each input `SparseTensor`.",
        "numberAttr": "N",
        "type": 9
      },
      {
        "name": "values",
        "description": "1-D.   values of each `SparseTensor`.",
        "typeListAttr": "sparse_types"
      },
      {
        "name": "shapes",
        "description": "1-D.   Shapes of each `SparseTensor`.",
        "numberAttr": "N",
        "type": 9
      },
      {
        "name": "dense_inputs",
        "description": "2-D.    Columns represented by dense `Tensor`.",
        "typeListAttr": "dense_types"
      }
    ],
    "outputs": [
      {
        "name": "output_indices",
        "description": "2-D.  Indices of the concatenated `SparseTensor`.",
        "type": 9
      },
      {
        "name": "output_values",
        "description": "1-D.  Non-empty values of the concatenated or hashed\n`SparseTensor`.",
        "typeAttr": "out_type"
      },
      {
        "name": "output_shape",
        "description": "1-D.  Shape of the concatenated `SparseTensor`.",
        "type": 9
      }
    ]
  },
  {
    "name": "SparseCrossHashed",
    "summary": "Generates sparse cross from a list of sparse and dense tensors.",
    "description": "The op takes two lists, one of 2D `SparseTensor` and one of 2D `Tensor`, each\nrepresenting features of one feature column. It outputs a 2D `SparseTensor` with\nthe batchwise crosses of these features.\n\nFor example, if the inputs are\n\n    inputs[0]: SparseTensor with shape = [2, 2]\n    [0, 0]: \"a\"\n    [1, 0]: \"b\"\n    [1, 1]: \"c\"\n\n    inputs[1]: SparseTensor with shape = [2, 1]\n    [0, 0]: \"d\"\n    [1, 0]: \"e\"\n\n    inputs[2]: Tensor [[\"f\"], [\"g\"]]\n\nthen the output will be\n\n    shape = [2, 2]\n    [0, 0]: \"a_X_d_X_f\"\n    [1, 0]: \"b_X_e_X_g\"\n    [1, 1]: \"c_X_e_X_g\"\n\nif hashed_output=true then the output will be\n\n    shape = [2, 2]\n    [0, 0]: FingerprintCat64(\n                Fingerprint64(\"f\"), FingerprintCat64(\n                    Fingerprint64(\"d\"), Fingerprint64(\"a\")))\n    [1, 0]: FingerprintCat64(\n                Fingerprint64(\"g\"), FingerprintCat64(\n                    Fingerprint64(\"e\"), Fingerprint64(\"b\")))\n    [1, 1]: FingerprintCat64(\n                Fingerprint64(\"g\"), FingerprintCat64(\n                    Fingerprint64(\"e\"), Fingerprint64(\"c\")))",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 0
      },
      {
        "name": "sparse_types",
        "type": "type[]",
        "minimum": 0,
        "description": "Must be one of the following: `int64`, `string`."
      },
      {
        "name": "dense_types",
        "type": "type[]",
        "minimum": 0,
        "description": "Must be one of the following: `int64`, `string`."
      }
    ],
    "inputs": [
      {
        "name": "indices",
        "description": "2-D.  Indices of each input `SparseTensor`.",
        "numberAttr": "N",
        "type": 9
      },
      {
        "name": "values",
        "description": "1-D.   values of each `SparseTensor`.",
        "typeListAttr": "sparse_types"
      },
      {
        "name": "shapes",
        "description": "1-D.   Shapes of each `SparseTensor`.",
        "numberAttr": "N",
        "type": 9
      },
      {
        "name": "dense_inputs",
        "description": "2-D.    Columns represented by dense `Tensor`.",
        "typeListAttr": "dense_types"
      },
      {
        "name": "num_buckets",
        "description": "It is used if hashed_output is true.\noutput = hashed_value%num_buckets if num_buckets > 0 else hashed_value.",
        "type": 9
      },
      {
        "name": "strong_hash",
        "description": "boolean, if true, siphash with salt will be used instead of farmhash.",
        "type": 10
      },
      {
        "name": "salt",
        "description": "Specify the salt that will be used by the siphash function.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "output_indices",
        "description": "2-D.  Indices of the concatenated `SparseTensor`.",
        "type": 9
      },
      {
        "name": "output_values",
        "description": "1-D.  Non-empty values of the concatenated or hashed\n`SparseTensor`.",
        "type": 9
      },
      {
        "name": "output_shape",
        "description": "1-D.  Shape of the concatenated `SparseTensor`.",
        "type": 9
      }
    ]
  },
  {
    "name": "SparseCrossV2",
    "summary": "Generates sparse cross from a list of sparse and dense tensors.",
    "description": "The op takes two lists, one of 2D `SparseTensor` and one of 2D `Tensor`, each\nrepresenting features of one feature column. It outputs a 2D `SparseTensor` with\nthe batchwise crosses of these features.\n\nFor example, if the inputs are\n\n    inputs[0]: SparseTensor with shape = [2, 2]\n    [0, 0]: \"a\"\n    [1, 0]: \"b\"\n    [1, 1]: \"c\"\n\n    inputs[1]: SparseTensor with shape = [2, 1]\n    [0, 0]: \"d\"\n    [1, 0]: \"e\"\n\n    inputs[2]: Tensor [[\"f\"], [\"g\"]]\n\nthen the output will be\n\n    shape = [2, 2]\n    [0, 0]: \"a_X_d_X_f\"\n    [1, 0]: \"b_X_e_X_g\"\n    [1, 1]: \"c_X_e_X_g\"\n\nif hashed_output=true then the output will be\n\n    shape = [2, 2]\n    [0, 0]: FingerprintCat64(\n                Fingerprint64(\"f\"), FingerprintCat64(\n                    Fingerprint64(\"d\"), Fingerprint64(\"a\")))\n    [1, 0]: FingerprintCat64(\n                Fingerprint64(\"g\"), FingerprintCat64(\n                    Fingerprint64(\"e\"), Fingerprint64(\"b\")))\n    [1, 1]: FingerprintCat64(\n                Fingerprint64(\"g\"), FingerprintCat64(\n                    Fingerprint64(\"e\"), Fingerprint64(\"c\")))",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 0
      },
      {
        "name": "sparse_types",
        "type": "type[]",
        "minimum": 0,
        "description": "Must be one of the following: `int64`, `string`."
      },
      {
        "name": "dense_types",
        "type": "type[]",
        "minimum": 0,
        "description": "Must be one of the following: `int64`, `string`."
      }
    ],
    "inputs": [
      {
        "name": "indices",
        "description": "2-D.  Indices of each input `SparseTensor`.",
        "numberAttr": "N",
        "type": 9
      },
      {
        "name": "values",
        "description": "1-D.   values of each `SparseTensor`.",
        "typeListAttr": "sparse_types"
      },
      {
        "name": "shapes",
        "description": "1-D.   Shapes of each `SparseTensor`.",
        "numberAttr": "N",
        "type": 9
      },
      {
        "name": "dense_inputs",
        "description": "2-D.    Columns represented by dense `Tensor`.",
        "typeListAttr": "dense_types"
      },
      {
        "name": "sep",
        "description": "string used when joining a list of string inputs, can be used as separator later.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "output_indices",
        "description": "2-D.  Indices of the concatenated `SparseTensor`.",
        "type": 9
      },
      {
        "name": "output_values",
        "description": "1-D.  Non-empty values of the concatenated or hashed\n`SparseTensor`.",
        "type": 7
      },
      {
        "name": "output_shape",
        "description": "1-D.  Shape of the concatenated `SparseTensor`.",
        "type": 9
      }
    ]
  },
  {
    "name": "SparseDenseCwiseAdd",
    "summary": "Adds up a SparseTensor and a dense Tensor, using these special rules:",
    "description": "(1) Broadcasts the dense side to have the same shape as the sparse side, if\n    eligible;\n(2) Then, only the dense values pointed to by the indices of the SparseTensor\n    participate in the cwise addition.\n\nBy these rules, the result is a logical SparseTensor with exactly the same\nindices and shape, but possibly with different non-zero values.  The output of\nthis Op is the resultant non-zero values.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "sp_indices",
        "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
        "type": 9
      },
      {
        "name": "sp_values",
        "description": "1-D.  `N` non-empty values corresponding to `sp_indices`.",
        "typeAttr": "T"
      },
      {
        "name": "sp_shape",
        "description": "1-D.  Shape of the input SparseTensor.",
        "type": 9
      },
      {
        "name": "dense",
        "description": "`R`-D.  The dense Tensor operand.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "1-D.  The `N` values that are operated on.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseDenseCwiseDiv",
    "summary": "Component-wise divides a SparseTensor by a dense Tensor.",
    "description": "*Limitation*: this Op only broadcasts the dense side to the sparse side, but not\nthe other direction.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "sp_indices",
        "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
        "type": 9
      },
      {
        "name": "sp_values",
        "description": "1-D.  `N` non-empty values corresponding to `sp_indices`.",
        "typeAttr": "T"
      },
      {
        "name": "sp_shape",
        "description": "1-D.  Shape of the input SparseTensor.",
        "type": 9
      },
      {
        "name": "dense",
        "description": "`R`-D.  The dense Tensor operand.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "1-D.  The `N` values that are operated on.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseDenseCwiseMul",
    "summary": "Component-wise multiplies a SparseTensor by a dense Tensor.",
    "description": "The output locations corresponding to the implicitly zero elements in the sparse\ntensor will be zero (i.e., will not take up storage space), regardless of the\ncontents of the dense tensor (even if it's +/-INF and that INF*0 == NaN).\n\n*Limitation*: this Op only broadcasts the dense side to the sparse side, but not\nthe other direction.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "sp_indices",
        "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
        "type": 9
      },
      {
        "name": "sp_values",
        "description": "1-D.  `N` non-empty values corresponding to `sp_indices`.",
        "typeAttr": "T"
      },
      {
        "name": "sp_shape",
        "description": "1-D.  Shape of the input SparseTensor.",
        "type": 9
      },
      {
        "name": "dense",
        "description": "`R`-D.  The dense Tensor operand.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "1-D.  The `N` values that are operated on.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseFillEmptyRows",
    "summary": "Fills empty rows in the input 2-D `SparseTensor` with a default value.",
    "description": "The input `SparseTensor` is represented via the tuple of inputs\n(`indices`, `values`, `dense_shape`).  The output `SparseTensor` has the\nsame `dense_shape` but with indices `output_indices` and values\n`output_values`.\n\nThis op inserts a single entry for every row that doesn't have any values.\nThe index is created as `[row, 0, ..., 0]` and the inserted value\nis `default_value`.\n\nFor example, suppose `sp_input` has shape `[5, 6]` and non-empty values:\n\n    [0, 1]: a\n    [0, 3]: b\n    [2, 0]: c\n    [3, 1]: d\n\nRows 1 and 4 are empty, so the output will be of shape `[5, 6]` with values:\n\n    [0, 1]: a\n    [0, 3]: b\n    [1, 0]: default_value\n    [2, 0]: c\n    [3, 1]: d\n    [4, 0]: default_value\n\nThe output `SparseTensor` will be in row-major order and will have the\nsame shape as the input.\n\nThis op also returns an indicator vector shaped `[dense_shape[0]]` such that\n\n    empty_row_indicator[i] = True iff row i was an empty row.\n\nAnd a reverse index map vector shaped `[indices.shape[0]]` that is used during\nbackpropagation,\n\n    reverse_index_map[j] = out_j s.t. indices[j, :] == output_indices[out_j, :]",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "indices",
        "description": "2-D. the indices of the sparse tensor.",
        "type": 9
      },
      {
        "name": "values",
        "description": "1-D. the values of the sparse tensor.",
        "typeAttr": "T"
      },
      {
        "name": "dense_shape",
        "description": "1-D. the shape of the sparse tensor.",
        "type": 9
      },
      {
        "name": "default_value",
        "description": "0-D. default value to insert into location `[row, 0, ..., 0]`\n  for rows missing from the input sparse tensor.\noutput indices: 2-D. the indices of the filled sparse tensor.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output_indices",
        "type": 9
      },
      {
        "name": "output_values",
        "description": "1-D. the values of the filled sparse tensor.",
        "typeAttr": "T"
      },
      {
        "name": "empty_row_indicator",
        "description": "1-D. whether the dense row was missing in the\ninput sparse tensor.",
        "type": 10
      },
      {
        "name": "reverse_index_map",
        "description": "1-D. a map from the input indices to the output indices.",
        "type": 9
      }
    ]
  },
  {
    "name": "SparseFillEmptyRowsGrad",
    "summary": "The gradient of SparseFillEmptyRows.",
    "description": "Takes vectors reverse_index_map, shaped `[N]`, and grad_values,\nshaped `[N_full]`, where `N_full >= N` and copies data into either\n`d_values` or `d_default_value`.  Here `d_values` is shaped `[N]` and\n`d_default_value` is a scalar.\n\n  d_values[j] = grad_values[reverse_index_map[j]]\n  d_default_value = sum_{k : 0 .. N_full - 1} (\n     grad_values[k] * 1{k not in reverse_index_map})",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "reverse_index_map",
        "description": "1-D.  The reverse index map from SparseFillEmptyRows.",
        "type": 9
      },
      {
        "name": "grad_values",
        "description": "1-D.  The gradients from backprop.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "d_values",
        "description": "1-D.  The backprop into values.",
        "typeAttr": "T"
      },
      {
        "name": "d_default_value",
        "description": "0-D.  The backprop into default_value.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseMatMul",
    "summary": "Multiply matrix \"a\" by matrix \"b\".",
    "description": "The inputs must be two-dimensional matrices and the inner dimension of \"a\" must\nmatch the outer dimension of \"b\". Both \"a\" and \"b\" must be `Tensor`s not\n`SparseTensor`s.  This op is optimized for the case where at least one of \"a\" or\n\"b\" is sparse, in the sense that they have a large proportion of zero values.\nThe breakeven for using this versus a dense matrix multiply on one platform was\n30% zero values in the sparse matrix.\n\nThe gradient computation of this operation will only take advantage of sparsity\nin the input gradient when that gradient comes from a Relu.",
    "attributes": [
      {
        "name": "transpose_a",
        "type": "boolean",
        "default": false
      },
      {
        "name": "transpose_b",
        "type": "boolean",
        "default": false
      },
      {
        "name": "a_is_sparse",
        "type": "boolean",
        "default": false
      },
      {
        "name": "b_is_sparse",
        "type": "boolean",
        "default": false
      },
      {
        "name": "Ta",
        "type": "type",
        "description": "Must be one of the following: `float32`, `bfloat16`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "Tb",
        "type": "type",
        "description": "Must be one of the following: `float32`, `bfloat16`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "a",
        "typeAttr": "Ta"
      },
      {
        "name": "b",
        "typeAttr": "Tb"
      }
    ],
    "outputs": [
      {
        "name": "product",
        "type": 1
      }
    ]
  },
  {
    "name": "SparseMatrixAdd",
    "summary": "Sparse addition of two CSR matrices, C = alpha * A + beta * B.",
    "description": "The gradients of SparseMatrixAdd outputs with respect to alpha and beta are not\ncurrently defined (TensorFlow will return zeros for these entries).",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "a",
        "description": "A CSRSparseMatrix.",
        "type": 21
      },
      {
        "name": "b",
        "description": "A CSRSparseMatrix.",
        "type": 21
      },
      {
        "name": "alpha",
        "description": "A constant scalar.",
        "typeAttr": "T"
      },
      {
        "name": "beta",
        "description": "A constant scalar.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "c",
        "description": "A CSRSparseMatrix.",
        "type": 21
      }
    ]
  },
  {
    "name": "SparseMatrixMatMul",
    "summary": "Matrix-multiplies a sparse matrix with a dense matrix.",
    "description": "Returns a dense matrix.\nFor inputs A and B, where A is CSR and B is dense; this op returns a dense C;\n\nIf transpose_output is false, returns:\n```\n  C = A . B\n```\n\nIf transpose_output is `true`, returns:\n```\n  C = transpose(A . B) = transpose(B) . transpose(A)\n```\nwhere the transposition is performed along the two innermost (matrix)\ndimensions.\n\nIf conjugate_output is `true`, returns:\n```\n  C = conjugate(A . B) = conjugate(A) . conjugate(B)\n```\n\nIf both conjugate_output and transpose_output are `true`, returns:\n```\n  C = conjugate(transpose(A . B)) = conjugate(transpose(B)) .\n                                    conjugate(transpose(A))\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "transpose_a",
        "type": "boolean",
        "description": "Indicates whether `a` should be transposed.",
        "default": false
      },
      {
        "name": "transpose_b",
        "type": "boolean",
        "description": "Indicates whether `b` should be transposed.",
        "default": false
      },
      {
        "name": "adjoint_a",
        "type": "boolean",
        "description": "Indicates whether `a` should be conjugate-transposed.",
        "default": false
      },
      {
        "name": "adjoint_b",
        "type": "boolean",
        "description": "Indicates whether `b` should be conjugate-transposed.",
        "default": false
      },
      {
        "name": "transpose_output",
        "type": "boolean",
        "description": "Transposes the product of `a` and `b`.",
        "default": false
      },
      {
        "name": "conjugate_output",
        "type": "boolean",
        "description": "Conjugates the product of `a` and `b`.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "a",
        "description": "A CSRSparseMatrix.",
        "type": 21
      },
      {
        "name": "b",
        "description": "A dense tensor.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A dense output tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseMatrixMul",
    "summary": "Element-wise multiplication of a sparse matrix with a dense tensor.",
    "description": "Returns a sparse matrix.\n\nThe dense tensor `b` may be either a scalar; otherwise `a` must be a rank-3\n`SparseMatrix`; in this case `b` must be shaped `[batch_size, 1, 1]` and the\nmultiply operation broadcasts.\n\n**NOTE** even if `b` is zero, the sparsity structure of the output does not\nchange.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "a",
        "description": "A CSRSparseMatrix.",
        "type": 21
      },
      {
        "name": "b",
        "description": "A dense tensor.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A dense output tensor.",
        "type": 21
      }
    ]
  },
  {
    "name": "SparseMatrixNNZ",
    "summary": "Returns the number of nonzeroes of `sparse_matrix`.",
    "inputs": [
      {
        "name": "sparse_matrix",
        "description": "A CSRSparseMatrix.",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "nnz",
        "description": "The number of nonzeroes of `sparse_matrix`.",
        "type": 3
      }
    ]
  },
  {
    "name": "SparseMatrixOrderingAMD",
    "summary": "Computes the Approximate Minimum Degree (AMD) ordering of `input`.",
    "description": "Computes the Approximate Minimum Degree (AMD) ordering for a sparse matrix.\n\nThe returned permutation may be used to permute the rows and columns of the\ngiven sparse matrix. This typically results in permuted sparse matrix's sparse\nCholesky (or other decompositions) in having fewer zero fill-in compared to\ndecomposition of the original matrix.\n\nThe input sparse matrix may have rank 2 or rank 3. The output Tensor,\nrepresenting would then have rank 1 or 2 respectively, with the same batch\nshape as the input.\n\nEach component of the input sparse matrix must represent a square symmetric\nmatrix; only the lower triangular part of the matrix is read. The values of the\nsparse matrix does not affect the returned permutation, only the sparsity\npattern of the sparse matrix is used. Hence, a single AMD ordering may be\nreused for the Cholesky decompositions of sparse matrices with the same sparsity\npattern but with possibly different values.\n\nEach batch component of the output permutation represents a permutation of `N`\nelements, where the input sparse matrix components each have `N` rows. That is,\nthe component contains each of the integers `{0, .. N-1}` exactly once. The\n`i`th element represents the row index that the `i`th row maps to.\n\nUsage example:\n\n```python\n    from tensorflow.python.ops.linalg.sparse import sparse_csr_matrix_ops\n\n    a_indices = np.array([[0, 0], [1, 1], [2, 1], [2, 2], [3, 3]])\n    a_values = np.array([1.0, 2.0, 1.0, 3.0, 4.0], np.float32)\n    a_dense_shape = [4, 4]\n\n    with tf.Session() as sess:\n      # Define (COO format) SparseTensor over Numpy array.\n      a_st = tf.sparse.SparseTensor(a_indices, a_values, a_dense_shape)\n\n      # Convert SparseTensors to CSR SparseMatrix.\n      a_sm = sparse_csr_matrix_ops.sparse_tensor_to_csr_sparse_matrix(\n          a_st.indices, a_st.values, a_st.dense_shape)\n\n      # Obtain the AMD Ordering for the CSR SparseMatrix.\n      ordering_amd = sparse_csr_matrix_ops.sparse_matrix_ordering_amd(sparse_matrix)\n\n      ordering_amd_value = sess.run(ordering_amd)\n```\n\n`ordering_amd_value` stores the AMD ordering: `[1 2 3 0]`.\n\ninput: A `CSRSparseMatrix`.",
    "inputs": [
      {
        "name": "input",
        "description": "A `CSRSparseMatrix`.",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The Approximate Minimum Degree (AMD) ordering of `input`.",
        "type": 3
      }
    ]
  },
  {
    "name": "SparseMatrixSoftmax",
    "summary": "Calculates the softmax of a CSRSparseMatrix.",
    "description": "Calculate the softmax of the innermost dimensions of a SparseMatrix.\n\nMissing values are treated as `-inf` (i.e., logits of zero probability); and\nthe output has the same sparsity structure as the input (though missing values\nin the output may now be treated as having probability zero).",
    "attributes": [
      {
        "name": "type",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "logits",
        "description": "A CSRSparseMatrix.",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "softmax",
        "description": "A CSRSparseMatrix.",
        "type": 21
      }
    ]
  },
  {
    "name": "SparseMatrixSoftmaxGrad",
    "summary": "Calculates the gradient of the SparseMatrixSoftmax op.",
    "attributes": [
      {
        "name": "type",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "softmax",
        "description": "A CSRSparseMatrix.",
        "type": 21
      },
      {
        "name": "grad_softmax",
        "description": "The gradient of `softmax`.",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "gradient",
        "description": "The output gradient.",
        "type": 21
      }
    ]
  },
  {
    "name": "SparseMatrixSparseCholesky",
    "summary": "Computes the sparse Cholesky decomposition of `input`.",
    "description": "Computes the Sparse Cholesky decomposition of a sparse matrix, with the given\nfill-in reducing permutation.\n\nThe input sparse matrix and the fill-in reducing permutation `permutation` must\nhave compatible shapes. If the sparse matrix has rank 3; with the batch\ndimension `B`, then the `permutation` must be of rank 2; with the same batch\ndimension `B`. There is no support for broadcasting.\n\nFurthermore, each component vector of `permutation` must be of length `N`,\ncontaining each of the integers {0, 1, ..., N - 1} exactly once, where `N` is\nthe number of rows of each component of the sparse matrix.\n\nEach component of the input sparse matrix must represent a symmetric positive\ndefinite (SPD) matrix; although only the lower triangular part of the matrix is\nread. If any individual component is not SPD, then an InvalidArgument error is\nthrown.\n\nThe returned sparse matrix has the same dense shape as the input sparse matrix.\nFor each component `A` of the input sparse matrix, the corresponding output\nsparse matrix represents `L`, the lower triangular Cholesky factor satisfying\nthe following identity:\n\n```\n  A = L * Lt\n```\n\nwhere Lt denotes the transpose of L (or its conjugate transpose, if `type` is\n`complex64` or `complex128`).\n\nThe `type` parameter denotes the type of the matrix elements. The supported\ntypes are: `float32`, `float64`, `complex64` and `complex128`.\n\nUsage example:\n\n```python\n    from tensorflow.python.ops.linalg.sparse import sparse_csr_matrix_ops\n\n    a_indices = np.array([[0, 0], [1, 1], [2, 1], [2, 2], [3, 3]])\n    a_values = np.array([1.0, 2.0, 1.0, 3.0, 4.0], np.float32)\n    a_dense_shape = [4, 4]\n\n    with tf.Session() as sess:\n      # Define (COO format) SparseTensor over Numpy array.\n      a_st = tf.sparse.SparseTensor(a_indices, a_values, a_dense_shape)\n\n      # Convert SparseTensors to CSR SparseMatrix.\n      a_sm = sparse_csr_matrix_ops.sparse_tensor_to_csr_sparse_matrix(\n          a_st.indices, a_st.values, a_st.dense_shape)\n\n      # Obtain the Sparse Cholesky factor using AMD Ordering for reducing zero\n      # fill-in (number of structural non-zeros in the sparse Cholesky factor).\n      ordering_amd = sparse_csr_matrix_ops.sparse_matrix_ordering_amd(sparse_matrix)\n      cholesky_sparse_matrices = (\n          sparse_csr_matrix_ops.sparse_matrix_sparse_cholesky(\n              sparse_matrix, ordering_amd, type=tf.float32))\n\n      # Convert the CSRSparseMatrix Cholesky factor to a dense Tensor\n      dense_cholesky = sparse_csr_matrix_ops.csr_sparse_matrix_to_dense(\n          cholesky_sparse_matrices, tf.float32)\n\n      # Evaluate the dense Tensor value.\n      dense_cholesky_value = sess.run(dense_cholesky)\n```\n\n`dense_cholesky_value` stores the dense Cholesky factor:\n\n```\n    [[  1.  0.    0.    0.]\n     [  0.  1.41  0.    0.]\n     [  0.  0.70  1.58  0.]\n     [  0.  0.    0.    2.]]\n```\n\n\ninput: A `CSRSparseMatrix`.\npermutation: A `Tensor`.\ntype: The type of `input`.",
    "attributes": [
      {
        "name": "type",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A `CSRSparseMatrix`.",
        "type": 21
      },
      {
        "name": "permutation",
        "description": "A fill-in reducing permutation matrix.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The sparse Cholesky decompsition of `input`.",
        "type": 21
      }
    ]
  },
  {
    "name": "SparseMatrixSparseMatMul",
    "summary": "Sparse-matrix-multiplies two CSR matrices `a` and `b`.",
    "description": "Performs a matrix multiplication of a sparse matrix `a` with a sparse matrix\n`b`; returns a sparse matrix `a * b`, unless either `a` or `b` is transposed or\nadjointed.\n\nEach matrix may be transposed or adjointed (conjugated and transposed)\naccording to the Boolean parameters `transpose_a`, `adjoint_a`, `transpose_b`\nand `adjoint_b`. At most one of `transpose_a` or `adjoint_a` may be True.\nSimilarly, at most one of `transpose_b` or `adjoint_b` may be True.\n\nThe inputs must have compatible shapes. That is, the inner dimension of `a`\nmust be equal to the outer dimension of `b`. This requirement is adjusted\naccording to whether either `a` or `b` is transposed or adjointed.\n\nThe `type` parameter denotes the type of the matrix elements. Both `a` and `b`\nmust have the same type. The supported types are: `float32`, `float64`,\n`complex64` and `complex128`.\n\nBoth `a` and `b` must have the same rank. Broadcasting is not supported. If they\nhave rank 3, each batch of 2D CSRSparseMatrices within `a` and `b` must have the\nsame dense shape.\n\nThe sparse matrix product may have numeric (non-structural) zeros.\nTODO(anudhyan): Consider adding a boolean attribute to control whether to prune\nzeros.\n\nUsage example:\n\n```python\n    from tensorflow.python.ops.linalg.sparse import sparse_csr_matrix_ops\n\n    a_indices = np.array([[0, 0], [2, 3], [2, 4], [3, 0]])\n    a_values = np.array([1.0, 5.0, -1.0, -2.0], np.float32)\n    a_dense_shape = [4, 5]\n\n    b_indices = np.array([[0, 0], [3, 0], [3, 1]])\n    b_values = np.array([2.0, 7.0, 8.0], np.float32)\n    b_dense_shape = [5, 3]\n\n    with tf.Session() as sess:\n      # Define (COO format) Sparse Tensors over Numpy arrays\n      a_st = tf.sparse.SparseTensor(a_indices, a_values, a_dense_shape)\n      b_st = tf.sparse.SparseTensor(b_indices, b_values, b_dense_shape)\n\n      # Convert SparseTensors to CSR SparseMatrix\n      a_sm = sparse_csr_matrix_ops.sparse_tensor_to_csr_sparse_matrix(\n          a_st.indices, a_st.values, a_st.dense_shape)\n      b_sm = sparse_csr_matrix_ops.sparse_tensor_to_csr_sparse_matrix(\n          b_st.indices, b_st.values, b_st.dense_shape)\n\n      # Compute the CSR SparseMatrix matrix multiplication\n      c_sm = sparse_csr_matrix_ops.sparse_matrix_sparse_mat_mul(\n          a=a_sm, b=b_sm, type=tf.float32)\n\n      # Convert the CSR SparseMatrix product to a dense Tensor\n      c_sm_dense = sparse_csr_matrix_ops.csr_sparse_matrix_to_dense(\n          c_sm, tf.float32)\n      # Evaluate the dense Tensor value\n      c_sm_dense_value = sess.run(c_sm_dense)\n```\n\n`c_sm_dense_value` stores the dense matrix product:\n\n```\n    [[  2.   0.   0.]\n     [  0.   0.   0.]\n     [ 35.  40.   0.]\n     [ -4.   0.   0.]]\n```\n\na: A `CSRSparseMatrix`.\nb: A `CSRSparseMatrix` with the same type and rank as `a`.\ntype: The type of both `a` and `b`.\ntranspose_a: If True, `a` transposed before multiplication.\ntranspose_b: If True, `b` transposed before multiplication.\nadjoint_a: If True, `a` adjointed before multiplication.\nadjoint_b: If True, `b` adjointed before multiplication.",
    "attributes": [
      {
        "name": "type",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `complex64`, `complex128`."
      },
      {
        "name": "transpose_a",
        "type": "boolean",
        "description": "Indicates whether `a` should be transposed.",
        "default": false
      },
      {
        "name": "transpose_b",
        "type": "boolean",
        "description": "Indicates whether `b` should be transposed.",
        "default": false
      },
      {
        "name": "adjoint_a",
        "type": "boolean",
        "description": "Indicates whether `a` should be conjugate-transposed.",
        "default": false
      },
      {
        "name": "adjoint_b",
        "type": "boolean",
        "description": "Indicates whether `b` should be conjugate-transposed.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "a",
        "description": "A CSRSparseMatrix.",
        "type": 21
      },
      {
        "name": "b",
        "description": "A CSRSparseMatrix.",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "c",
        "description": "A CSRSparseMatrix.",
        "type": 21
      }
    ]
  },
  {
    "name": "SparseMatrixTranspose",
    "summary": "Transposes the inner (matrix) dimensions of a CSRSparseMatrix.",
    "description": "Transposes the inner (matrix) dimensions of a SparseMatrix and optionally\nconjugates its values.",
    "attributes": [
      {
        "name": "conjugate",
        "type": "boolean",
        "description": "Indicates whether `input` should be conjugated.",
        "default": false
      },
      {
        "name": "type",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A CSRSparseMatrix.",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A CSRSparseMatrix.",
        "type": 21
      }
    ]
  },
  {
    "name": "SparseMatrixZeros",
    "summary": "Creates an all-zeros CSRSparseMatrix with shape `dense_shape`.",
    "attributes": [
      {
        "name": "type",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "dense_shape",
        "description": "The desired matrix shape.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "sparse_matrix",
        "description": "An empty CSR matrix with shape `dense_shape`.",
        "type": 21
      }
    ]
  },
  {
    "name": "SparseReduceMax",
    "summary": "Computes the max of elements across dimensions of a SparseTensor.",
    "description": "This Op takes a SparseTensor and is the sparse counterpart to\n`tf.reduce_max()`.  In particular, this Op also returns a dense `Tensor`\ninstead of a sparse one.\n\nReduces `sp_input` along the dimensions given in `reduction_axes`.  Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_axes`. If `keep_dims` is true, the reduced dimensions are retained\nwith length 1.\n\nIf `reduction_axes` has no entries, all dimensions are reduced, and a tensor\nwith a single element is returned.  Additionally, the axes can be negative,\nwhich are interpreted according to the indexing rules in Python.",
    "attributes": [
      {
        "name": "keep_dims",
        "type": "boolean",
        "description": "If true, retain reduced dimensions with length 1.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "input_indices",
        "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
        "type": 9
      },
      {
        "name": "input_values",
        "description": "1-D.  `N` non-empty values corresponding to `input_indices`.",
        "typeAttr": "T"
      },
      {
        "name": "input_shape",
        "description": "1-D.  Shape of the input SparseTensor.",
        "type": 9
      },
      {
        "name": "reduction_axes",
        "description": "1-D.  Length-`K` vector containing the reduction axes.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "`R-K`-D.  The reduced Tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseReduceMaxSparse",
    "summary": "Computes the max of elements across dimensions of a SparseTensor.",
    "description": "This Op takes a SparseTensor and is the sparse counterpart to\n`tf.reduce_max()`.  In contrast to SparseReduceMax, this Op returns a\nSparseTensor.\n\nReduces `sp_input` along the dimensions given in `reduction_axes`.  Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_axes`. If `keep_dims` is true, the reduced dimensions are retained\nwith length 1.\n\nIf `reduction_axes` has no entries, all dimensions are reduced, and a tensor\nwith a single element is returned.  Additionally, the axes can be negative,\nwhich are interpreted according to the indexing rules in Python.",
    "attributes": [
      {
        "name": "keep_dims",
        "type": "boolean",
        "description": "If true, retain reduced dimensions with length 1.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "input_indices",
        "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
        "type": 9
      },
      {
        "name": "input_values",
        "description": "1-D.  `N` non-empty values corresponding to `input_indices`.",
        "typeAttr": "T"
      },
      {
        "name": "input_shape",
        "description": "1-D.  Shape of the input SparseTensor.",
        "type": 9
      },
      {
        "name": "reduction_axes",
        "description": "1-D.  Length-`K` vector containing the reduction axes.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output_indices",
        "type": 9
      },
      {
        "name": "output_values",
        "typeAttr": "T"
      },
      {
        "name": "output_shape",
        "type": 9
      }
    ]
  },
  {
    "name": "SparseReduceSum",
    "summary": "Computes the sum of elements across dimensions of a SparseTensor.",
    "description": "This Op takes a SparseTensor and is the sparse counterpart to\n`tf.reduce_sum()`.  In particular, this Op also returns a dense `Tensor`\ninstead of a sparse one.\n\nReduces `sp_input` along the dimensions given in `reduction_axes`.  Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_axes`. If `keep_dims` is true, the reduced dimensions are retained\nwith length 1.\n\nIf `reduction_axes` has no entries, all dimensions are reduced, and a tensor\nwith a single element is returned.  Additionally, the axes can be negative,\nwhich are interpreted according to the indexing rules in Python.",
    "attributes": [
      {
        "name": "keep_dims",
        "type": "boolean",
        "description": "If true, retain reduced dimensions with length 1.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "input_indices",
        "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
        "type": 9
      },
      {
        "name": "input_values",
        "description": "1-D.  `N` non-empty values corresponding to `input_indices`.",
        "typeAttr": "T"
      },
      {
        "name": "input_shape",
        "description": "1-D.  Shape of the input SparseTensor.",
        "type": 9
      },
      {
        "name": "reduction_axes",
        "description": "1-D.  Length-`K` vector containing the reduction axes.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "`R-K`-D.  The reduced Tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseReduceSumSparse",
    "summary": "Computes the sum of elements across dimensions of a SparseTensor.",
    "description": "This Op takes a SparseTensor and is the sparse counterpart to\n`tf.reduce_sum()`.  In contrast to SparseReduceSum, this Op returns a\nSparseTensor.\n\nReduces `sp_input` along the dimensions given in `reduction_axes`.  Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_axes`. If `keep_dims` is true, the reduced dimensions are retained\nwith length 1.\n\nIf `reduction_axes` has no entries, all dimensions are reduced, and a tensor\nwith a single element is returned.  Additionally, the axes can be negative,\nwhich are interpreted according to the indexing rules in Python.",
    "attributes": [
      {
        "name": "keep_dims",
        "type": "boolean",
        "description": "If true, retain reduced dimensions with length 1.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "input_indices",
        "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
        "type": 9
      },
      {
        "name": "input_values",
        "description": "1-D.  `N` non-empty values corresponding to `input_indices`.",
        "typeAttr": "T"
      },
      {
        "name": "input_shape",
        "description": "1-D.  Shape of the input SparseTensor.",
        "type": 9
      },
      {
        "name": "reduction_axes",
        "description": "1-D.  Length-`K` vector containing the reduction axes.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output_indices",
        "type": 9
      },
      {
        "name": "output_values",
        "typeAttr": "T"
      },
      {
        "name": "output_shape",
        "type": 9
      }
    ]
  },
  {
    "name": "SparseReorder",
    "summary": "Reorders a SparseTensor into the canonical, row-major ordering.",
    "description": "Note that by convention, all sparse ops preserve the canonical ordering along\nincreasing dimension number. The only time ordering can be violated is during\nmanual manipulation of the indices and values vectors to add entries.\n\nReordering does not affect the shape of the SparseTensor.\n\nIf the tensor has rank `R` and `N` non-empty values, `input_indices` has\nshape `[N, R]`, input_values has length `N`, and input_shape has length `R`.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input_indices",
        "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
        "type": 9
      },
      {
        "name": "input_values",
        "description": "1-D.  `N` non-empty values corresponding to `input_indices`.",
        "typeAttr": "T"
      },
      {
        "name": "input_shape",
        "description": "1-D.  Shape of the input SparseTensor.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "output_indices",
        "description": "2-D.  `N x R` matrix with the same indices as input_indices, but\nin canonical row-major ordering.",
        "type": 9
      },
      {
        "name": "output_values",
        "description": "1-D.  `N` non-empty values corresponding to `output_indices`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseReshape",
    "summary": "Reshapes a SparseTensor to represent values in a new dense shape.",
    "description": "This operation has the same semantics as reshape on the represented dense\ntensor.  The `input_indices` are recomputed based on the requested `new_shape`.\n\nIf one component of `new_shape` is the special value -1, the size of that\ndimension is computed so that the total dense size remains constant.  At\nmost one component of `new_shape` can be -1.  The number of dense elements\nimplied by `new_shape` must be the same as the number of dense elements\noriginally implied by `input_shape`.\n\nReshaping does not affect the order of values in the SparseTensor.\n\nIf the input tensor has rank `R_in` and `N` non-empty values, and `new_shape`\nhas length `R_out`, then `input_indices` has shape `[N, R_in]`,\n`input_shape` has length `R_in`, `output_indices` has shape `[N, R_out]`, and\n`output_shape` has length `R_out`.",
    "inputs": [
      {
        "name": "input_indices",
        "description": "2-D.  `N x R_in` matrix with the indices of non-empty values in a\nSparseTensor.",
        "type": 9
      },
      {
        "name": "input_shape",
        "description": "1-D.  `R_in` vector with the input SparseTensor's dense shape.",
        "type": 9
      },
      {
        "name": "new_shape",
        "description": "1-D.  `R_out` vector with the requested new dense shape.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "output_indices",
        "description": "2-D.  `N x R_out` matrix with the updated indices of non-empty\nvalues in the output SparseTensor.",
        "type": 9
      },
      {
        "name": "output_shape",
        "description": "1-D.  `R_out` vector with the full dense shape of the output\nSparseTensor.  This is the same as `new_shape` but with any -1 dimensions\nfilled in.",
        "type": 9
      }
    ]
  },
  {
    "name": "SparseSegmentMean",
    "summary": "Computes the mean along sparse segments of a tensor.",
    "description": "See `tf.sparse.segment_sum` for usage examples.\n\nLike `SegmentMean`, but `segment_ids` can have rank less than `data`'s first\ndimension, selecting a subset of dimension 0, specified by `indices`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "Tsegmentids",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "sparse_gradient",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "data",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A 1-D tensor. Has same rank as `segment_ids`.",
        "typeAttr": "Tidx"
      },
      {
        "name": "segment_ids",
        "description": "A 1-D tensor. Values should be sorted and can be repeated.",
        "typeAttr": "Tsegmentids"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseSegmentMeanGrad",
    "summary": "Computes gradients for SparseSegmentMean.",
    "description": "Returns tensor \"output\" with same shape as grad, except for dimension 0 whose\nvalue is output_dim0.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "Tsegmentids",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "grad",
        "description": "gradient propagated to the SparseSegmentMean op.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "indices passed to the corresponding SparseSegmentMean op.",
        "typeAttr": "Tidx"
      },
      {
        "name": "segment_ids",
        "description": "segment_ids passed to the corresponding SparseSegmentMean op.",
        "typeAttr": "Tsegmentids"
      },
      {
        "name": "output_dim0",
        "description": "dimension 0 of \"data\" passed to SparseSegmentMean op.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseSegmentMeanGradV2",
    "summary": "Computes gradients for SparseSegmentMean.",
    "description": "Returns tensor \"output\" with same shape as grad, except for dimension 0 whose\nvalue is the number of unique indexes in \"indices\". Also returns vector\n\"sorted_unique_indices\" containing the corresponding indexes from \"indices\".",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "Tsegmentids",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "grad",
        "description": "gradient propagated to the SparseSegmentMean op.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "indices passed to the corresponding SparseSegmentMean op.",
        "typeAttr": "Tidx"
      },
      {
        "name": "segment_ids",
        "description": "segment_ids passed to the corresponding SparseSegmentMean op.",
        "typeAttr": "Tsegmentids"
      },
      {
        "name": "dense_output_dim0",
        "description": "dimension 0 of \"data\" passed to SparseSegmentMean op.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      },
      {
        "name": "sorted_unique_indices",
        "typeAttr": "Tidx"
      }
    ]
  },
  {
    "name": "SparseSegmentMeanWithNumSegments",
    "summary": "Computes the mean along sparse segments of a tensor.",
    "description": "Like `SparseSegmentMean`, but allows missing ids in `segment_ids`. If an id is\nmissing, the `output` tensor at that position will be zeroed.\n\nRead\n[the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)\nfor an explanation of segments.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "Tnumsegments",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "Tsegmentids",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "sparse_gradient",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "data",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A 1-D tensor. Has same rank as `segment_ids`.",
        "typeAttr": "Tidx"
      },
      {
        "name": "segment_ids",
        "description": "A 1-D tensor. Values should be sorted and can be repeated.",
        "typeAttr": "Tsegmentids"
      },
      {
        "name": "num_segments",
        "description": "Should equal the number of distinct segment IDs.",
        "typeAttr": "Tnumsegments"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Has same shape as data, except for dimension 0 which has size\n`num_segments`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseSegmentSqrtN",
    "summary": "Computes the sum along sparse segments of a tensor divided by the sqrt of N.",
    "description": "N is the size of the segment being reduced.\n\nSee `tf.sparse.segment_sum` for usage examples.\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "Tsegmentids",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "sparse_gradient",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "data",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A 1-D tensor. Has same rank as `segment_ids`.",
        "typeAttr": "Tidx"
      },
      {
        "name": "segment_ids",
        "description": "A 1-D tensor. Values should be sorted and can be repeated.",
        "typeAttr": "Tsegmentids"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseSegmentSqrtNGrad",
    "summary": "Computes gradients for SparseSegmentSqrtN.",
    "description": "Returns tensor \"output\" with same shape as grad, except for dimension 0 whose\nvalue is output_dim0.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "Tsegmentids",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "grad",
        "description": "gradient propagated to the SparseSegmentSqrtN op.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "indices passed to the corresponding SparseSegmentSqrtN op.",
        "typeAttr": "Tidx"
      },
      {
        "name": "segment_ids",
        "description": "segment_ids passed to the corresponding SparseSegmentSqrtN op.",
        "typeAttr": "Tsegmentids"
      },
      {
        "name": "output_dim0",
        "description": "dimension 0 of \"data\" passed to SparseSegmentSqrtN op.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseSegmentSqrtNGradV2",
    "summary": "Computes gradients for SparseSegmentSqrtN.",
    "description": "Returns tensor \"output\" with same shape as grad, except for dimension 0 whose\nvalue is the number of unique indexes in \"indices\". Also returns vector\n\"sorted_unique_indices\" containing the corresponding indexes from \"indices\".",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "Tsegmentids",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "grad",
        "description": "gradient propagated to the SparseSegmentSqrtN op.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "indices passed to the corresponding SparseSegmentSqrtN op.",
        "typeAttr": "Tidx"
      },
      {
        "name": "segment_ids",
        "description": "segment_ids passed to the corresponding SparseSegmentSqrtN op.",
        "typeAttr": "Tsegmentids"
      },
      {
        "name": "dense_output_dim0",
        "description": "dimension 0 of \"data\" passed to SparseSegmentSqrtN op.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      },
      {
        "name": "sorted_unique_indices",
        "typeAttr": "Tidx"
      }
    ]
  },
  {
    "name": "SparseSegmentSqrtNWithNumSegments",
    "summary": "Computes the sum along sparse segments of a tensor divided by the sqrt of N.",
    "description": "N is the size of the segment being reduced.\n\nLike `SparseSegmentSqrtN`, but allows missing ids in `segment_ids`. If an id is\nmissing, the `output` tensor at that position will be zeroed.\n\nRead\n[the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)\nfor an explanation of segments.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "Tnumsegments",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "Tsegmentids",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "sparse_gradient",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "data",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A 1-D tensor. Has same rank as `segment_ids`.",
        "typeAttr": "Tidx"
      },
      {
        "name": "segment_ids",
        "description": "A 1-D tensor. Values should be sorted and can be repeated.",
        "typeAttr": "Tsegmentids"
      },
      {
        "name": "num_segments",
        "description": "Should equal the number of distinct segment IDs.",
        "typeAttr": "Tnumsegments"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseSegmentSum",
    "summary": "Computes the sum along sparse segments of a tensor.",
    "description": "Read\n[the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)\nfor an explanation of segments.\n\nLike `SegmentSum`, but `segment_ids` can have rank less than `data`'s first\ndimension, selecting a subset of dimension 0, specified by `indices`.\n\nFor example:\n\n```python\nc = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])\n\n# Select two rows, one segment.\ntf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 0]))\n# => [[0 0 0 0]]\n\n# Select two rows, two segment.\ntf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 1]))\n# => [[ 1  2  3  4]\n#     [-1 -2 -3 -4]]\n\n# Select all rows, two segments.\ntf.sparse_segment_sum(c, tf.constant([0, 1, 2]), tf.constant([0, 0, 1]))\n# => [[0 0 0 0]\n#     [5 6 7 8]]\n\n# Which is equivalent to:\ntf.segment_sum(c, tf.constant([0, 0, 1]))\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "Tsegmentids",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "sparse_gradient",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "data",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A 1-D tensor. Has same rank as `segment_ids`.",
        "typeAttr": "Tidx"
      },
      {
        "name": "segment_ids",
        "description": "A 1-D tensor. Values should be sorted and can be repeated.",
        "typeAttr": "Tsegmentids"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseSegmentSumGrad",
    "summary": "Computes gradients for SparseSegmentSum.",
    "description": "Returns tensor \"output\" with same shape as grad, except for dimension 0 whose\nvalue is output_dim0.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "Tsegmentids",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "grad",
        "description": "gradient propagated to the SparseSegmentSum op.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "indices passed to the corresponding SparseSegmentSum op.",
        "typeAttr": "Tidx"
      },
      {
        "name": "segment_ids",
        "description": "segment_ids passed to the corresponding SparseSegmentSum op.",
        "typeAttr": "Tsegmentids"
      },
      {
        "name": "output_dim0",
        "description": "dimension 0 of \"data\" passed to SparseSegmentSum op.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseSegmentSumGradV2",
    "summary": "Computes gradients for SparseSegmentSum.",
    "description": "Returns tensor \"output\" with same shape as grad, except for dimension 0 whose\nvalue is the number of unique indexes in \"indices\". Also returns vector\n\"sorted_unique_indices\" containing the corresponding indexes from \"indices\".",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "Tsegmentids",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "grad",
        "description": "gradient propagated to the SparseSegmentSum op.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "indices passed to the corresponding SparseSegmentSum op.",
        "typeAttr": "Tidx"
      },
      {
        "name": "segment_ids",
        "description": "segment_ids passed to the corresponding SparseSegmentSum op.",
        "typeAttr": "Tsegmentids"
      },
      {
        "name": "dense_output_dim0",
        "description": "dimension 0 of \"data\" passed to SparseSegmentSum op.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      },
      {
        "name": "sorted_unique_indices",
        "typeAttr": "Tidx"
      }
    ]
  },
  {
    "name": "SparseSegmentSumWithNumSegments",
    "summary": "Computes the sum along sparse segments of a tensor.",
    "description": "Like `SparseSegmentSum`, but allows missing ids in `segment_ids`. If an id is\nmissing, the `output` tensor at that position will be zeroed.\n\nRead\n[the section on segmentation](https://tensorflow.org/api_docs/python/tf/sparse#Segmentation)\nfor an explanation of segments.\n\nFor example:\n\n```python\nc = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])\n\ntf.sparse_segment_sum_with_num_segments(\n    c, tf.constant([0, 1]), tf.constant([0, 0]), num_segments=3)\n# => [[0 0 0 0]\n#     [0 0 0 0]\n#     [0 0 0 0]]\n\ntf.sparse_segment_sum_with_num_segments(c,\n                                        tf.constant([0, 1]),\n                                        tf.constant([0, 2],\n                                        num_segments=4))\n# => [[ 1  2  3  4]\n#     [ 0  0  0  0]\n#     [-1 -2 -3 -4]\n#     [ 0  0  0  0]]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "Tnumsegments",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "Tsegmentids",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "sparse_gradient",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "data",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "A 1-D tensor. Has same rank as `segment_ids`.",
        "typeAttr": "Tidx"
      },
      {
        "name": "segment_ids",
        "description": "A 1-D tensor. Values should be sorted and can be repeated.",
        "typeAttr": "Tsegmentids"
      },
      {
        "name": "num_segments",
        "description": "Should equal the number of distinct segment IDs.",
        "typeAttr": "Tnumsegments"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Has same shape as data, except for dimension 0 which\nhas size `num_segments`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseSlice",
    "summary": "Slice a `SparseTensor` based on the `start` and `size`.",
    "description": "For example, if the input is\n\n    input_tensor = shape = [2, 7]\n    [    a   d e  ]\n    [b c          ]\n\nGraphically the output tensors are:\n\n    sparse_slice([0, 0], [2, 4]) = shape = [2, 4]\n    [    a  ]\n    [b c    ]\n\n    sparse_slice([0, 4], [2, 3]) = shape = [2, 3]\n    [ d e  ]\n    [      ]",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "indices",
        "description": "2-D tensor represents the indices of the sparse tensor.",
        "type": 9
      },
      {
        "name": "values",
        "description": "1-D tensor represents the values of the sparse tensor.",
        "typeAttr": "T"
      },
      {
        "name": "shape",
        "description": "1-D. tensor represents the shape of the sparse tensor.",
        "type": 9
      },
      {
        "name": "start",
        "description": "1-D. tensor represents the start of the slice.",
        "type": 9
      },
      {
        "name": "size",
        "description": "1-D. tensor represents the size of the slice.\noutput indices: A list of 1-D tensors represents the indices of the output\nsparse tensors.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "output_indices",
        "type": 9
      },
      {
        "name": "output_values",
        "description": "A list of 1-D tensors represents the values of the output sparse\ntensors.",
        "typeAttr": "T"
      },
      {
        "name": "output_shape",
        "description": "A list of 1-D tensors represents the shape of the output sparse\ntensors.",
        "type": 9
      }
    ]
  },
  {
    "name": "SparseSliceGrad",
    "summary": "The gradient operator for the SparseSlice op.",
    "description": "This op takes in the upstream gradient w.r.t. non-empty values of\nthe sliced `SparseTensor`, and outputs the gradients w.r.t.\nthe non-empty values of input `SparseTensor`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "backprop_val_grad",
        "description": "1-D. The gradient with respect to\nthe non-empty values of the sliced `SparseTensor`.",
        "typeAttr": "T"
      },
      {
        "name": "input_indices",
        "description": "2-D.  The `indices` of the input `SparseTensor`.",
        "type": 9
      },
      {
        "name": "input_start",
        "description": "1-D. tensor represents the start of the slice.",
        "type": 9
      },
      {
        "name": "output_indices",
        "description": "2-D.  The `indices` of the sliced `SparseTensor`.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "val_grad",
        "description": "1-D. The gradient with respect to the non-empty values of input `SparseTensor`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseSoftmax",
    "summary": "Applies softmax to a batched N-D `SparseTensor`.",
    "description": "The inputs represent an N-D SparseTensor  with logical shape `[..., B, C]`\n(where `N >= 2`), and with indices sorted in the canonical lexicographic order.\n\nThis op is equivalent to applying the normal `tf.nn.softmax()` to each innermost\nlogical submatrix with shape `[B, C]`, but with the catch that *the implicitly\nzero elements do not participate*.  Specifically, the algorithm is equivalent\nto the following:\n\n  (1) Applies `tf.nn.softmax()` to a densified view of each innermost submatrix\n      with shape `[B, C]`, along the size-C dimension;\n  (2) Masks out the original implicitly-zero locations;\n  (3) Renormalizes the remaining elements.\n\nHence, the `SparseTensor` result has exactly the same non-zero indices and\nshape.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "sp_indices",
        "description": "2-D.  `NNZ x R` matrix with the indices of non-empty values in a\nSparseTensor, in canonical ordering.",
        "type": 9
      },
      {
        "name": "sp_values",
        "description": "1-D.  `NNZ` non-empty values corresponding to `sp_indices`.",
        "typeAttr": "T"
      },
      {
        "name": "sp_shape",
        "description": "1-D.  Shape of the input SparseTensor.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "1-D.  The `NNZ` values for the result `SparseTensor`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseSoftmaxCrossEntropyWithLogits",
    "summary": "Computes softmax cross entropy cost and gradients to backpropagate.",
    "description": "Unlike `SoftmaxCrossEntropyWithLogits`, this operation does not accept\na matrix of label probabilities, but rather a single label per row\nof features.  This label is considered to have probability 1.0 for the\ngiven row.\n\nInputs are the logits, not probabilities.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      },
      {
        "name": "Tlabels",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "features",
        "description": "batch_size x num_classes matrix",
        "typeAttr": "T"
      },
      {
        "name": "labels",
        "description": "batch_size vector with values in [0, num_classes).\nThis is the label for the given minibatch entry.",
        "typeAttr": "Tlabels"
      }
    ],
    "outputs": [
      {
        "name": "loss",
        "description": "Per example loss (batch_size vector).",
        "typeAttr": "T"
      },
      {
        "name": "backprop",
        "description": "backpropagated gradients (batch_size x num_classes matrix).",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseSparseMaximum",
    "summary": "Returns the element-wise max of two SparseTensors.",
    "description": "Assumes the two SparseTensors have the same shape, i.e., no broadcasting.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "a_indices",
        "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, in the canonical lexicographic ordering.",
        "type": 9
      },
      {
        "name": "a_values",
        "description": "1-D.  `N` non-empty values corresponding to `a_indices`.",
        "typeAttr": "T"
      },
      {
        "name": "a_shape",
        "description": "1-D.  Shape of the input SparseTensor.",
        "type": 9
      },
      {
        "name": "b_indices",
        "description": "counterpart to `a_indices` for the other operand.",
        "type": 9
      },
      {
        "name": "b_values",
        "description": "counterpart to `a_values` for the other operand; must be of the same dtype.",
        "typeAttr": "T"
      },
      {
        "name": "b_shape",
        "description": "counterpart to `a_shape` for the other operand; the two shapes must be equal.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "output_indices",
        "description": "2-D.  The indices of the output SparseTensor.",
        "type": 9
      },
      {
        "name": "output_values",
        "description": "1-D.  The values of the output SparseTensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseSparseMinimum",
    "summary": "Returns the element-wise min of two SparseTensors.",
    "description": "Assumes the two SparseTensors have the same shape, i.e., no broadcasting.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "a_indices",
        "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, in the canonical lexicographic ordering.",
        "type": 9
      },
      {
        "name": "a_values",
        "description": "1-D.  `N` non-empty values corresponding to `a_indices`.",
        "typeAttr": "T"
      },
      {
        "name": "a_shape",
        "description": "1-D.  Shape of the input SparseTensor.",
        "type": 9
      },
      {
        "name": "b_indices",
        "description": "counterpart to `a_indices` for the other operand.",
        "type": 9
      },
      {
        "name": "b_values",
        "description": "counterpart to `a_values` for the other operand; must be of the same dtype.",
        "typeAttr": "T"
      },
      {
        "name": "b_shape",
        "description": "counterpart to `a_shape` for the other operand; the two shapes must be equal.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "output_indices",
        "description": "2-D.  The indices of the output SparseTensor.",
        "type": 9
      },
      {
        "name": "output_values",
        "description": "1-D.  The values of the output SparseTensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseSplit",
    "summary": "Split a `SparseTensor` into `num_split` tensors along one dimension.",
    "description": "If the `shape[split_dim]` is not an integer multiple of `num_split`. Slices\n`[0 : shape[split_dim] % num_split]` gets one extra dimension.\nFor example, if `split_dim = 1` and `num_split = 2` and the input is\n\n    input_tensor = shape = [2, 7]\n    [    a   d e  ]\n    [b c          ]\n\nGraphically the output tensors are:\n\n    output_tensor[0] = shape = [2, 4]\n    [    a  ]\n    [b c    ]\n\n    output_tensor[1] = shape = [2, 3]\n    [ d e  ]\n    [      ]",
    "attributes": [
      {
        "name": "num_split",
        "type": "int64",
        "description": "The number of ways to split.",
        "minimum": 1
      },
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "split_dim",
        "description": "0-D.  The dimension along which to split.  Must be in the range\n`[0, rank(shape))`.",
        "type": 9
      },
      {
        "name": "indices",
        "description": "2-D tensor represents the indices of the sparse tensor.",
        "type": 9
      },
      {
        "name": "values",
        "description": "1-D tensor represents the values of the sparse tensor.",
        "typeAttr": "T"
      },
      {
        "name": "shape",
        "description": "1-D. tensor represents the shape of the sparse tensor.\noutput indices: A list of 1-D tensors represents the indices of the output\nsparse tensors.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "output_indices",
        "numberAttr": "num_split",
        "type": 9
      },
      {
        "name": "output_values",
        "description": "A list of 1-D tensors represents the values of the output sparse\ntensors.",
        "numberAttr": "num_split",
        "typeAttr": "T"
      },
      {
        "name": "output_shape",
        "description": "A list of 1-D tensors represents the shape of the output sparse\ntensors.",
        "numberAttr": "num_split",
        "type": 9
      }
    ]
  },
  {
    "name": "SparseTensorDenseAdd",
    "summary": "Adds up a `SparseTensor` and a dense `Tensor`, producing a dense `Tensor`.",
    "description": "This Op does not require `a_indices` be sorted in standard lexicographic order.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "a_indices",
        "description": "2-D.  The `indices` of the `SparseTensor`, with shape `[nnz, ndims]`.",
        "typeAttr": "Tindices"
      },
      {
        "name": "a_values",
        "description": "1-D.  The `values` of the `SparseTensor`, with shape `[nnz]`.",
        "typeAttr": "T"
      },
      {
        "name": "a_shape",
        "description": "1-D.  The `shape` of the `SparseTensor`, with shape `[ndims]`.",
        "typeAttr": "Tindices"
      },
      {
        "name": "b",
        "description": "`ndims`-D Tensor.  With shape `a_shape`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseTensorDenseMatMul",
    "summary": "Multiply SparseTensor (of rank 2) \"A\" by dense matrix \"B\".",
    "description": "No validity checking is performed on the indices of A.  However, the following\ninput format is recommended for optimal behavior:\n\nif adjoint_a == false:\n  A should be sorted in lexicographically increasing order.  Use SparseReorder\n  if you're not sure.\nif adjoint_a == true:\n  A should be sorted in order of increasing dimension 1 (i.e., \"column major\"\n  order instead of \"row major\" order).",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      },
      {
        "name": "adjoint_a",
        "type": "boolean",
        "description": "Use the adjoint of A in the matrix multiply.  If A is complex, this\nis transpose(conj(A)).  Otherwise it's transpose(A).",
        "default": false
      },
      {
        "name": "adjoint_b",
        "type": "boolean",
        "description": "Use the adjoint of B in the matrix multiply.  If B is complex, this\nis transpose(conj(B)).  Otherwise it's transpose(B).",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "a_indices",
        "description": "2-D.  The `indices` of the `SparseTensor`, size `[nnz, 2]` Matrix.",
        "typeAttr": "Tindices"
      },
      {
        "name": "a_values",
        "description": "1-D.  The `values` of the `SparseTensor`, size `[nnz]` Vector.",
        "typeAttr": "T"
      },
      {
        "name": "a_shape",
        "description": "1-D.  The `shape` of the `SparseTensor`, size `[2]` Vector.",
        "type": 9
      },
      {
        "name": "b",
        "description": "2-D.  A dense Matrix.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "product",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseTensorSliceDataset",
    "summary": "Creates a dataset that splits a SparseTensor into elements row-wise.",
    "attributes": [
      {
        "name": "Tvalues",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "indices",
        "type": 9
      },
      {
        "name": "values",
        "typeAttr": "Tvalues"
      },
      {
        "name": "dense_shape",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "SparseTensorToCSRSparseMatrix",
    "summary": "Converts a SparseTensor to a (possibly batched) CSRSparseMatrix.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "indices",
        "description": "SparseTensor indices.",
        "type": 9
      },
      {
        "name": "values",
        "description": "SparseTensor values.",
        "typeAttr": "T"
      },
      {
        "name": "dense_shape",
        "description": "SparseTensor dense shape.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "sparse_matrix",
        "description": "A (possibly batched) CSRSparseMatrix.",
        "type": 21
      }
    ]
  },
  {
    "name": "SparseToDense",
    "summary": "Converts a sparse representation into a dense tensor.",
    "description": "Builds an array `dense` with shape `output_shape` such that\n\n```\n# If sparse_indices is scalar\ndense[i] = (i == sparse_indices ? sparse_values : default_value)\n\n# If sparse_indices is a vector, then for each i\ndense[sparse_indices[i]] = sparse_values[i]\n\n# If sparse_indices is an n by d matrix, then for each i in [0, n)\ndense[sparse_indices[i][0], ..., sparse_indices[i][d-1]] = sparse_values[i]\n```\n\nAll other values in `dense` are set to `default_value`.  If `sparse_values` is a\nscalar, all sparse indices are set to this single value.\n\nIndices should be sorted in lexicographic order, and indices must not\ncontain any repeats. If `validate_indices` is true, these properties\nare checked during execution.",
    "attributes": [
      {
        "name": "validate_indices",
        "type": "boolean",
        "description": "If true, indices are checked to make sure they are sorted in\nlexicographic order and that there are no repeats.",
        "default": true
      },
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "sparse_indices",
        "description": "0-D, 1-D, or 2-D.  `sparse_indices[i]` contains the complete\nindex where `sparse_values[i]` will be placed.",
        "typeAttr": "Tindices"
      },
      {
        "name": "output_shape",
        "description": "1-D.  Shape of the dense output tensor.",
        "typeAttr": "Tindices"
      },
      {
        "name": "sparse_values",
        "description": "1-D.  Values corresponding to each row of `sparse_indices`,\nor a scalar value to be used for all sparse indices.",
        "typeAttr": "T"
      },
      {
        "name": "default_value",
        "description": "Scalar value to set for indices not specified in\n`sparse_indices`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "dense",
        "description": "Dense output tensor of shape `output_shape`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SparseToSparseSetOperation",
    "summary": "Applies set operation along last dimension of 2 `SparseTensor` inputs.",
    "description": "See SetOperationOp::SetOperationFromContext for values of `set_operation`.\n\nIf `validate_indices` is `True`, `SparseToSparseSetOperation` validates the\norder and range of `set1` and `set2` indices.\n\nInput `set1` is a `SparseTensor` represented by `set1_indices`, `set1_values`,\nand `set1_shape`. For `set1` ranked `n`, 1st `n-1` dimensions must be the same\nas `set2`. Dimension `n` contains values in a set, duplicates are allowed but\nignored.\n\nInput `set2` is a `SparseTensor` represented by `set2_indices`, `set2_values`,\nand `set2_shape`. For `set2` ranked `n`, 1st `n-1` dimensions must be the same\nas `set1`. Dimension `n` contains values in a set, duplicates are allowed but\nignored.\n\nIf `validate_indices` is `True`, this op validates the order and range of `set1`\nand `set2` indices.\n\nOutput `result` is a `SparseTensor` represented by `result_indices`,\n`result_values`, and `result_shape`. For `set1` and `set2` ranked `n`, this\nhas rank `n` and the same 1st `n-1` dimensions as `set1` and `set2`. The `nth`\ndimension contains the result of `set_operation` applied to the corresponding\n`[0...n-1]` dimension of `set`.",
    "attributes": [
      {
        "name": "set_operation",
        "type": "string"
      },
      {
        "name": "validate_indices",
        "type": "boolean",
        "default": true
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `string`."
      }
    ],
    "inputs": [
      {
        "name": "set1_indices",
        "description": "2D `Tensor`, indices of a `SparseTensor`. Must be in row-major\norder.",
        "type": 9
      },
      {
        "name": "set1_values",
        "description": "1D `Tensor`, values of a `SparseTensor`. Must be in row-major\norder.",
        "typeAttr": "T"
      },
      {
        "name": "set1_shape",
        "description": "1D `Tensor`, shape of a `SparseTensor`. `set1_shape[0...n-1]` must\nbe the same as `set2_shape[0...n-1]`, `set1_shape[n]` is the\nmax set size across `0...n-1` dimensions.",
        "type": 9
      },
      {
        "name": "set2_indices",
        "description": "2D `Tensor`, indices of a `SparseTensor`. Must be in row-major\norder.",
        "type": 9
      },
      {
        "name": "set2_values",
        "description": "1D `Tensor`, values of a `SparseTensor`. Must be in row-major\norder.",
        "typeAttr": "T"
      },
      {
        "name": "set2_shape",
        "description": "1D `Tensor`, shape of a `SparseTensor`. `set2_shape[0...n-1]` must\nbe the same as `set1_shape[0...n-1]`, `set2_shape[n]` is the\nmax set size across `0...n-1` dimensions.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "result_indices",
        "description": "2D indices of a `SparseTensor`.",
        "type": 9
      },
      {
        "name": "result_values",
        "description": "1D values of a `SparseTensor`.",
        "typeAttr": "T"
      },
      {
        "name": "result_shape",
        "description": "1D `Tensor` shape of a `SparseTensor`. `result_shape[0...n-1]` is\nthe same as the 1st `n-1` dimensions of `set1` and `set2`, `result_shape[n]`\nis the max result set size across all `0...n-1` dimensions.",
        "type": 9
      }
    ]
  },
  {
    "name": "Spence",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Split",
    "category": "Tensor",
    "summary": "Splits a tensor into `num_split` tensors along one dimension.",
    "attributes": [
      {
        "name": "num_split",
        "type": "int64",
        "description": "The number of ways to split.  Must evenly divide\n`value.shape[split_dim]`.",
        "minimum": 1
      },
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "split_dim",
        "description": "0-D.  The dimension along which to split.  Must be in the range\n`[-rank(value), rank(value))`.",
        "type": 3
      },
      {
        "name": "value",
        "description": "The tensor to split.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "They are identically shaped tensors, whose shape matches that of `value`\nexcept along `split_dim`, where their sizes are\n`values.shape[split_dim] / num_split`.",
        "numberAttr": "num_split",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SplitDedupData",
    "summary": "An op splits input deduplication data XLA tuple into integer and floating point\ntensors.",
    "description": "Deduplication data is an XLA tuple, which consists of integer and floating point\nvalues. This op is to split these values into two groups for two types, and\nconstruct each group as one tensor to return.",
    "attributes": [
      {
        "name": "integer_type",
        "type": "type",
        "description": "integer_tensor type. Allowed types: int32, int64, uint32, uint64. Must be one of the following: `int32`, `int64`, `uint32`, `uint64`."
      },
      {
        "name": "float_type",
        "type": "type",
        "description": "float_tensor type. Allowed types: half, bfloat16, float. Must be one of the following: `float16`, `bfloat16`, `float32`."
      },
      {
        "name": "tuple_mask",
        "type": "string",
        "description": "A serialized TensorProto string of output tuple mask. This mask is a 2-D tensor,\nwith first column as tuple element type, and second column as span of this type.\nFor example, an output tuple of (1, 2, 0.1, 3), its mask is [[0, 2], [1, 1], [0,\n1]]. We expect only two types of elements: integer(0) and float(1)."
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "An XLA tuple including integer and float elements as deduplication data tuple.",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "integer_tensor",
        "description": "A 1-D integer tensor, includes integer elements of deduplication data tuple.",
        "typeAttr": "integer_type"
      },
      {
        "name": "float_tensor",
        "description": "A 1-D float tensor, includes float elements of deduplication data tuple.",
        "typeAttr": "float_type"
      }
    ]
  },
  {
    "name": "SplitV",
    "summary": "Splits a tensor into `num_split` tensors along one dimension.",
    "attributes": [
      {
        "name": "num_split",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tlen",
        "type": "type",
        "description": "Must be one of the following: `int8`, `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "value",
        "description": "The tensor to split.",
        "typeAttr": "T"
      },
      {
        "name": "size_splits",
        "description": "list containing the sizes of each output tensor along the split\ndimension. Must sum to the dimension of value along split_dim.\nCan contain one -1 indicating that dimension is to be inferred.",
        "typeAttr": "Tlen"
      },
      {
        "name": "split_dim",
        "description": "0-D.  The dimension along which to split.  Must be in the range\n`[-rank(value), rank(value))`.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Tensors whose shape matches that of `value`\nexcept along `split_dim`, where their sizes are\n`size_splits[i]`.",
        "numberAttr": "num_split",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SqlDataset",
    "summary": "Creates a dataset that executes a SQL query and emits rows of the result set.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "driver_name",
        "description": "The database type. Currently, the only supported type is 'sqlite'.",
        "type": 7
      },
      {
        "name": "data_source_name",
        "description": "A connection string to connect to the database.",
        "type": 7
      },
      {
        "name": "query",
        "description": "A SQL query to execute.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "Sqrt",
    "summary": "Computes square root of x element-wise.",
    "description": "I.e., \\\\(y = \\sqrt{x} = x^{1/2}\\\\).",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SqrtGrad",
    "summary": "Computes the gradient for the sqrt of `x` wrt its input.",
    "description": "Specifically, `grad = dy * 0.5 / y`, where `y = sqrt(x)`, and `dy`\nis the corresponding input gradient.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "y",
        "typeAttr": "T"
      },
      {
        "name": "dy",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Square",
    "summary": "Computes square of x element-wise.",
    "description": "I.e., \\\\(y = x * x = x^2\\\\).",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `uint32`, `uint64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SquaredDifference",
    "summary": "Returns conj(x - y)(x - y) element-wise.",
    "description": "*NOTE*: `SquaredDifference` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `int32`, `int64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Squeeze",
    "category": "Transform",
    "summary": "Removes dimensions of size 1 from the shape of a tensor.",
    "description": "Given a tensor `input`, this operation returns a tensor of the same type with\nall dimensions of size 1 removed. If you don't want to remove all size 1\ndimensions, you can remove specific size 1 dimensions by specifying\n`squeeze_dims`.\n\nFor example:\n\n```\n# 't' is a tensor of shape [1, 2, 1, 3, 1, 1]\nshape(squeeze(t)) ==> [2, 3]\n```\n\nOr, to remove specific size 1 dimensions:\n\n```\n# 't' is a tensor of shape [1, 2, 1, 3, 1, 1]\nshape(squeeze(t, [2, 4])) ==> [1, 2, 3, 1]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "squeeze_dims",
        "type": "int64[]",
        "description": "If specified, only squeezes the dimensions listed. The dimension\nindex starts at 0. It is an error to squeeze a dimension that is not 1. Must\nbe in the range `[-rank(input), rank(input))`.",
        "minimum": 0,
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The `input` to squeeze.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Contains the same data as `input`, but has one or more dimensions of\nsize 1 removed.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Stack",
    "summary": "Deprecated, use StackV2.",
    "attributes": [
      {
        "name": "elem_type",
        "type": "type"
      },
      {
        "name": "stack_name",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "StackClose",
    "summary": "Deprecated, use StackCloseV2.",
    "inputs": [
      {
        "name": "handle",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "StackCloseV2",
    "summary": "Delete the stack from its resource container.",
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a stack.",
        "type": 20
      }
    ]
  },
  {
    "name": "StackPop",
    "summary": "Deprecated, use StackPopV2.",
    "attributes": [
      {
        "name": "elem_type",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "type": 7,
        "isRef": true
      }
    ],
    "outputs": [
      {
        "name": "elem",
        "typeAttr": "elem_type"
      }
    ]
  },
  {
    "name": "StackPopV2",
    "summary": "Pop the element at the top of the stack.",
    "attributes": [
      {
        "name": "elem_type",
        "type": "type",
        "description": "The type of the elem that is popped."
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a stack.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "elem",
        "description": "The tensor that is popped from the top of the stack.",
        "typeAttr": "elem_type"
      }
    ]
  },
  {
    "name": "StackPush",
    "summary": "Deprecated, use StackPushV2.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "swap_memory",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "type": 7,
        "isRef": true
      },
      {
        "name": "elem",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "StackPushV2",
    "summary": "Push an element onto the stack.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "swap_memory",
        "type": "boolean",
        "description": "Swap `elem` to CPU. Default to false.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a stack.",
        "type": 20
      },
      {
        "name": "elem",
        "description": "The tensor to be pushed onto the stack.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The same tensor as the input 'elem'.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "StackV2",
    "summary": "A stack that produces elements in first-in last-out order.",
    "attributes": [
      {
        "name": "elem_type",
        "type": "type",
        "description": "The type of the elements on the stack."
      },
      {
        "name": "stack_name",
        "type": "string",
        "description": "Overrides the name used for the temporary stack resource. Default\nvalue is the name of the 'Stack' op (which is guaranteed unique).",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "max_size",
        "description": "The maximum size of the stack if non-negative. If negative, the stack\nsize is unlimited.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "The handle to the stack.",
        "type": 20
      }
    ]
  },
  {
    "name": "Stage",
    "summary": "Stage values similar to a lightweight Enqueue.",
    "description": "The basic functionality of this Op is similar to a queue with many\nfewer capabilities and options.  This Op is optimized for performance.",
    "attributes": [
      {
        "name": "capacity",
        "type": "int64",
        "description": "Maximum number of elements in the Staging Area. If > 0, inserts\non the container will block when the capacity is reached.",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "memory_limit",
        "type": "int64",
        "description": "The maximum number of bytes allowed for Tensors in the Staging Area.\nIf > 0, inserts will block until sufficient space is available.",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "dtypes",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this queue is placed in the given container. Otherwise,\na default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "It is necessary to match this name to the matching Unstage Op.",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "values",
        "description": "a list of tensors\ndtypes A list of data types that inserted values should adhere to.",
        "typeListAttr": "dtypes"
      }
    ]
  },
  {
    "name": "StageClear",
    "summary": "Op removes all elements in the underlying container.",
    "attributes": [
      {
        "name": "capacity",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "memory_limit",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "dtypes",
        "type": "type[]"
      },
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ]
  },
  {
    "name": "StagePeek",
    "summary": "Op peeks at the values at the specified index.  If the",
    "description": "underlying container does not contain sufficient elements\nthis op will block until it does.   This Op is optimized for\nperformance.",
    "attributes": [
      {
        "name": "capacity",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "memory_limit",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "dtypes",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "index",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "values",
        "typeListAttr": "dtypes"
      }
    ]
  },
  {
    "name": "StageSize",
    "summary": "Op returns the number of elements in the underlying container.",
    "attributes": [
      {
        "name": "capacity",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "memory_limit",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "dtypes",
        "type": "type[]"
      },
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "size",
        "type": 3
      }
    ]
  },
  {
    "name": "StatefulPartitionedCall",
    "summary": "returns `f(inputs)`, where `f`'s body is placed and partitioned.",
    "attributes": [
      {
        "name": "Tin",
        "type": "type[]",
        "description": "A list of input types.",
        "minimum": 0
      },
      {
        "name": "Tout",
        "type": "type[]",
        "description": "A list of output types.",
        "minimum": 0
      },
      {
        "name": "f",
        "type": "function",
        "description": "      A function that takes 'args', a list of tensors, and returns 'output',\n      another list of tensors. Input and output types are specified by 'Tin'\n      and 'Tout'. The function body of f will be placed and partitioned across\n      devices, setting this op apart from the regular Call op. This op is\n      stateful."
      },
      {
        "name": "config",
        "type": "string",
        "default": ""
      },
      {
        "name": "config_proto",
        "type": "string",
        "default": ""
      },
      {
        "name": "executor_type",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "args",
        "description": "A list of input tensors.",
        "typeListAttr": "Tin"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A list of return values.",
        "typeListAttr": "Tout"
      }
    ]
  },
  {
    "name": "StatefulRandomBinomial",
    "attributes": [
      {
        "name": "S",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`, `float64`, `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 2
        }
      },
      {
        "name": "dtype",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`, `float64`, `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "type": 20
      },
      {
        "name": "algorithm",
        "type": 9
      },
      {
        "name": "shape",
        "typeAttr": "S"
      },
      {
        "name": "counts",
        "typeAttr": "T"
      },
      {
        "name": "probs",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "StatefulStandardNormal",
    "summary": "Outputs random values from a normal distribution. This op is deprecated in favor of op 'StatefulStandardNormalV2'",
    "description": "The generated values will have mean 0 and standard deviation 1.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "shape_dtype",
        "type": "type",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "description": "The handle of the resource variable that stores the state of the RNG.",
        "type": 20
      },
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "shape_dtype"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A tensor of the specified shape filled with random normal values.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "StatefulStandardNormalV2",
    "summary": "Outputs random values from a normal distribution.",
    "description": "The generated values will have mean 0 and standard deviation 1.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "shape_dtype",
        "type": "type",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "description": "The handle of the resource variable that stores the state of the RNG.",
        "type": 20
      },
      {
        "name": "algorithm",
        "description": "The RNG algorithm.",
        "type": 9
      },
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "shape_dtype"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A tensor of the specified shape filled with random normal values.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "StatefulTruncatedNormal",
    "summary": "Outputs random values from a truncated normal distribution.",
    "description": "The generated values follow a normal distribution with mean 0 and standard\ndeviation 1, except that values whose magnitude is more than 2 standard\ndeviations from the mean are dropped and re-picked.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "shape_dtype",
        "type": "type",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "description": "The handle of the resource variable that stores the state of the RNG.",
        "type": 20
      },
      {
        "name": "algorithm",
        "description": "The RNG algorithm.",
        "type": 9
      },
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "shape_dtype"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Random values with specified shape.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "StatefulUniform",
    "summary": "Outputs random values from a uniform distribution.",
    "description": "The generated values follow a uniform distribution in the range `[0, 1)`. The\nlower bound 0 is included in the range, while the upper bound 1 is excluded.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "shape_dtype",
        "type": "type",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "description": "The handle of the resource variable that stores the state of the RNG.",
        "type": 20
      },
      {
        "name": "algorithm",
        "description": "The RNG algorithm.",
        "type": 9
      },
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "shape_dtype"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Random values with specified shape.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "StatefulUniformFullInt",
    "summary": "Outputs random integers from a uniform distribution.",
    "description": "The generated values are uniform integers covering the whole range of `dtype`.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output.",
        "default": {
          "type": "type",
          "value": 23
        }
      },
      {
        "name": "shape_dtype",
        "type": "type",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "description": "The handle of the resource variable that stores the state of the RNG.",
        "type": 20
      },
      {
        "name": "algorithm",
        "description": "The RNG algorithm.",
        "type": 9
      },
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "shape_dtype"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Random values with specified shape.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "StatefulUniformInt",
    "summary": "Outputs random integers from a uniform distribution.",
    "description": "The generated values are uniform integers in the range `[minval, maxval)`.\nThe lower bound `minval` is included in the range, while the upper bound\n`maxval` is excluded.\n\nThe random integers are slightly biased unless `maxval - minval` is an exact\npower of two.  The bias is small for values of `maxval - minval` significantly\nsmaller than the range of the output (either `2^32` or `2^64`).",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output.",
        "default": {
          "type": "type",
          "value": 9
        }
      },
      {
        "name": "shape_dtype",
        "type": "type",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "resource",
        "description": "The handle of the resource variable that stores the state of the RNG.",
        "type": 20
      },
      {
        "name": "algorithm",
        "description": "The RNG algorithm.",
        "type": 9
      },
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "shape_dtype"
      },
      {
        "name": "minval",
        "description": "Minimum value (inclusive, scalar).",
        "typeAttr": "dtype"
      },
      {
        "name": "maxval",
        "description": "Maximum value (exclusive, scalar).",
        "typeAttr": "dtype"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Random values with specified shape.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "StatelessCase",
    "summary": "An n-way switch statement which calls a single branch function.",
    "description": "    An n-way switch statement, implementing the following:\n    ```\n    switch (branch_index) {\n      case 0:\n        output = branches[0](input);\n        break;\n      case 1:\n        output = branches[1](input);\n        break;\n      ...\n      case [[nbranches-1]]:\n      default:\n        output = branches[nbranches-1](input);\n        break;\n    }\n    ```\n\n    This should only be used when the none of branches has stateful ops.",
    "attributes": [
      {
        "name": "Tin",
        "type": "type[]",
        "description": "A list of input types.",
        "minimum": 0
      },
      {
        "name": "Tout",
        "type": "type[]",
        "description": "A list of output types.",
        "minimum": 0
      },
      {
        "name": "branches",
        "type": "function[]",
        "description": "      A list of functions each of which takes 'inputs' and returns a list of\n      tensors, whose types are the same as what every other branch returns.",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "branch_index",
        "description": "The branch selector, an int32 Tensor.",
        "type": 3
      },
      {
        "name": "input",
        "description": "A list of input tensors passed to the branch function.",
        "typeListAttr": "Tin"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A list of return values.",
        "typeListAttr": "Tout"
      }
    ]
  },
  {
    "name": "StatelessIf",
    "summary": "output = cond ? then_branch(input) : else_branch(input)",
    "attributes": [
      {
        "name": "Tcond",
        "type": "type"
      },
      {
        "name": "Tin",
        "type": "type[]",
        "description": "A list of input types.",
        "minimum": 0
      },
      {
        "name": "Tout",
        "type": "type[]",
        "description": "A list of output types.",
        "minimum": 0
      },
      {
        "name": "then_branch",
        "type": "function",
        "description": "      A function that takes 'inputs' and returns a list of tensors, whose\n      types are the same as what else_branch returns."
      },
      {
        "name": "else_branch",
        "type": "function",
        "description": "    A function that takes 'inputs' and returns a list of tensors, whose\n    types are the same as what then_branch returns."
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "cond",
        "description": "      A Tensor. If the tensor is a scalar of non-boolean type, the\n      scalar is converted to a boolean according to the\n      following rule: if the scalar is a numerical value, non-zero means\n      `True` and zero means False; if the scalar is a string, non-empty\n      means `True` and empty means `False`. If the tensor is not a scalar,\n      being empty means False and being non-empty means True.\n\n      This should only be used when the if then/else body functions do not\n      have stateful ops.",
        "typeAttr": "Tcond"
      },
      {
        "name": "input",
        "description": "A list of input tensors.",
        "typeListAttr": "Tin"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A list of return values.",
        "typeListAttr": "Tout"
      }
    ]
  },
  {
    "name": "StatelessMultinomial",
    "summary": "Draws samples from a multinomial distribution.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tseed",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      },
      {
        "name": "output_dtype",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "logits",
        "description": "2-D Tensor with shape `[batch_size, num_classes]`.  Each slice `[i, :]`\nrepresents the unnormalized log probabilities for all classes.",
        "typeAttr": "T"
      },
      {
        "name": "num_samples",
        "description": "0-D.  Number of independent samples to draw for each row slice.",
        "type": 3
      },
      {
        "name": "seed",
        "description": "2 seeds (shape [2]).",
        "typeAttr": "Tseed"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "2-D Tensor with shape `[batch_size, num_samples]`.  Each slice `[i, :]`\ncontains the drawn class labels with range `[0, num_classes)`.",
        "typeAttr": "output_dtype"
      }
    ]
  },
  {
    "name": "StatelessParameterizedTruncatedNormal",
    "attributes": [
      {
        "name": "S",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "Tseed",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      },
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "S"
      },
      {
        "name": "seed",
        "description": "2 seeds (shape [2]).",
        "typeAttr": "Tseed"
      },
      {
        "name": "means",
        "description": "The mean parameter of each batch.",
        "typeAttr": "dtype"
      },
      {
        "name": "stddevs",
        "description": "The standard deviation parameter of each batch. Must be greater than 0.",
        "typeAttr": "dtype"
      },
      {
        "name": "minvals",
        "description": "The minimum cutoff. May be -infinity.",
        "typeAttr": "dtype"
      },
      {
        "name": "maxvals",
        "description": "The maximum cutoff. May be +infinity, and must be more than the minval\nfor each batch.",
        "typeAttr": "dtype"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The outputs are truncated normal samples and are a deterministic function of\n`shape`, `seed`, `minvals`, `maxvals`, `means` and `stddevs`.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "StatelessRandomBinomial",
    "summary": "Outputs deterministic pseudorandom random numbers from a binomial distribution.",
    "description": "Outputs random values from a binomial distribution.\n\nThe outputs are a deterministic function of `shape`, `seed`, `counts`, and `probs`.",
    "attributes": [
      {
        "name": "S",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "Tseed",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`, `float64`, `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 2
        }
      },
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `float16`, `float32`, `float64`, `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "S"
      },
      {
        "name": "seed",
        "description": "2 seeds (shape [2]).",
        "typeAttr": "Tseed"
      },
      {
        "name": "counts",
        "description": "The counts of the binomial distribution. Must be broadcastable with `probs`,\nand broadcastable with the rightmost dimensions of `shape`.",
        "typeAttr": "T"
      },
      {
        "name": "probs",
        "description": "The probability of success for the binomial distribution. Must be broadcastable\nwith `counts` and broadcastable with the rightmost dimensions of `shape`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Random values with specified shape.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "StatelessRandomGammaV2",
    "summary": "Outputs deterministic pseudorandom random numbers from a gamma distribution.",
    "description": "Outputs random values from a gamma distribution.\n\nThe outputs are a deterministic function of `shape`, `seed`, and `alpha`.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `float16`, `float32`, `float64`."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "Tseed",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "T"
      },
      {
        "name": "seed",
        "description": "2 seeds (shape [2]).",
        "typeAttr": "Tseed"
      },
      {
        "name": "alpha",
        "description": "The concentration of the gamma distribution. Shape must match the rightmost\ndimensions of `shape`.",
        "typeAttr": "dtype"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Random values with specified shape.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "StatelessRandomGammaV3",
    "summary": "Outputs deterministic pseudorandom random numbers from a gamma distribution.",
    "description": "Outputs random values from a gamma distribution.\n\nThe outputs are a deterministic function of the inputs.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `float16`, `float32`, `float64`."
      },
      {
        "name": "shape_dtype",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "shape_dtype"
      },
      {
        "name": "key",
        "description": "Key for the counter-based RNG algorithm (shape uint64[1]).",
        "type": 23
      },
      {
        "name": "counter",
        "description": "Initial counter for the counter-based RNG algorithm (shape uint64[2] or uint64[1] depending on the algorithm). If a larger vector is given, only the needed portion on the left (i.e. [:N]) will be used.",
        "type": 23
      },
      {
        "name": "alg",
        "description": "The RNG algorithm (shape int32[]).",
        "type": 3
      },
      {
        "name": "alpha",
        "description": "The concentration of the gamma distribution. Shape must match the rightmost\ndimensions of `shape`.",
        "typeAttr": "dtype"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Random values with specified shape.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "StatelessRandomGetAlg",
    "summary": "Picks the best counter-based RNG algorithm based on device.",
    "description": "This op picks the best counter-based RNG algorithm based on device.",
    "outputs": [
      {
        "name": "alg",
        "description": "The RNG algorithm (shape int32[]).",
        "type": 3
      }
    ]
  },
  {
    "name": "StatelessRandomGetKeyCounter",
    "summary": "Scrambles seed into key and counter, using the best algorithm based on device.",
    "description": "This op scrambles a shape-[2] seed into a key and a counter, both needed by counter-based RNG algorithms. The scrambing uses the best algorithm based on device. The scrambling is opaque but approximately satisfies the property that different seed results in different key/counter pair (which will in turn result in different random numbers).",
    "attributes": [
      {
        "name": "Tseed",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "seed",
        "description": "2 seeds (shape [2]).",
        "typeAttr": "Tseed"
      }
    ],
    "outputs": [
      {
        "name": "key",
        "description": "Key for the counter-based RNG algorithm (shape uint64[1]).",
        "type": 23
      },
      {
        "name": "counter",
        "description": "Counter for the counter-based RNG algorithm. Since counter size is algorithm-dependent, this output will be right-padded with zeros to reach shape uint64[2] (the current maximal counter size among algorithms).",
        "type": 23
      }
    ]
  },
  {
    "name": "StatelessRandomGetKeyCounterAlg",
    "summary": "Picks the best algorithm based on device, and scrambles seed into key and counter.",
    "description": "This op picks the best counter-based RNG algorithm based on device, and scrambles a shape-[2] seed into a key and a counter, both needed by the counter-based algorithm. The scrambling is opaque but approximately satisfies the property that different seed results in different key/counter pair (which will in turn result in different random numbers).",
    "attributes": [
      {
        "name": "Tseed",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "seed",
        "description": "2 seeds (shape [2]).",
        "typeAttr": "Tseed"
      }
    ],
    "outputs": [
      {
        "name": "key",
        "description": "Key for the counter-based RNG algorithm (shape uint64[1]).",
        "type": 23
      },
      {
        "name": "counter",
        "description": "Counter for the counter-based RNG algorithm. Since counter size is algorithm-dependent, this output will be right-padded with zeros to reach shape uint64[2] (the current maximal counter size among algorithms).",
        "type": 23
      },
      {
        "name": "alg",
        "description": "The RNG algorithm (shape int32[]).",
        "type": 3
      }
    ]
  },
  {
    "name": "StatelessRandomNormal",
    "summary": "Outputs deterministic pseudorandom values from a normal distribution.",
    "description": "The generated values will have mean 0 and standard deviation 1.\n\nThe outputs are a deterministic function of `shape` and `seed`.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "Tseed",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "T"
      },
      {
        "name": "seed",
        "description": "2 seeds (shape [2]).",
        "typeAttr": "Tseed"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Random values with specified shape.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "StatelessRandomNormalV2",
    "summary": "Outputs deterministic pseudorandom values from a normal distribution.",
    "description": "The generated values will have mean 0 and standard deviation 1.\n\nThe outputs are a deterministic function of `shape`, `key`, `counter` and `alg`.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "Tshape",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "Tshape"
      },
      {
        "name": "key",
        "description": "Key for the counter-based RNG algorithm (shape uint64[1]).",
        "type": 23
      },
      {
        "name": "counter",
        "description": "Initial counter for the counter-based RNG algorithm (shape uint64[2] or uint64[1] depending on the algorithm). If a larger vector is given, only the needed portion on the left (i.e. [:N]) will be used.",
        "type": 23
      },
      {
        "name": "alg",
        "description": "The RNG algorithm (shape int32[]).",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Random values with specified shape.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "StatelessRandomPoisson",
    "summary": "Outputs deterministic pseudorandom random numbers from a Poisson distribution.",
    "description": "Outputs random values from a Poisson distribution.\n\nThe outputs are a deterministic function of `shape`, `seed`, and `lam`.",
    "attributes": [
      {
        "name": "Rtype",
        "type": "type",
        "description": "Must be one of the following: `float16`, `float32`, `float64`, `int32`, `int64`."
      },
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `float16`, `float32`, `float64`, `int32`, `int64`."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "Tseed",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "T"
      },
      {
        "name": "seed",
        "description": "2 seeds (shape [2]).",
        "typeAttr": "Tseed"
      },
      {
        "name": "lam",
        "description": "The rate of the Poisson distribution. Shape must match the rightmost dimensions\nof `shape`.",
        "typeAttr": "Rtype"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Random values with specified shape.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "StatelessRandomUniform",
    "summary": "Outputs deterministic pseudorandom random values from a uniform distribution.",
    "description": "The generated values follow a uniform distribution in the range `[0, 1)`. The\nlower bound 0 is included in the range, while the upper bound 1 is excluded.\n\nThe outputs are a deterministic function of `shape` and `seed`.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "Tseed",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "T"
      },
      {
        "name": "seed",
        "description": "2 seeds (shape [2]).",
        "typeAttr": "Tseed"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Random values with specified shape.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "StatelessRandomUniformFullInt",
    "summary": "Outputs deterministic pseudorandom random integers from a uniform distribution.",
    "description": "The generated values are uniform integers covering the whole range of `dtype`.\n\nThe outputs are a deterministic function of `shape` and `seed`.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `int32`, `int64`, `uint32`, `uint64`.",
        "default": {
          "type": "type",
          "value": 23
        }
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "Tseed",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`, `uint32`, `uint64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "T"
      },
      {
        "name": "seed",
        "description": "2 seeds (shape [2]).",
        "typeAttr": "Tseed"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Random values with specified shape.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "StatelessRandomUniformFullIntV2",
    "summary": "Outputs deterministic pseudorandom random integers from a uniform distribution.",
    "description": "The generated values are uniform integers covering the whole range of `dtype`.\n\nThe outputs are a deterministic function of `shape`, `key`, `counter` and `alg`.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `int32`, `int64`, `uint32`, `uint64`.",
        "default": {
          "type": "type",
          "value": 23
        }
      },
      {
        "name": "Tshape",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "Tshape"
      },
      {
        "name": "key",
        "description": "Key for the counter-based RNG algorithm (shape uint64[1]).",
        "type": 23
      },
      {
        "name": "counter",
        "description": "Initial counter for the counter-based RNG algorithm (shape uint64[2] or uint64[1] depending on the algorithm). If a larger vector is given, only the needed portion on the left (i.e. [:N]) will be used.",
        "type": 23
      },
      {
        "name": "alg",
        "description": "The RNG algorithm (shape int32[]).",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Random values with specified shape.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "StatelessRandomUniformInt",
    "summary": "Outputs deterministic pseudorandom random integers from a uniform distribution.",
    "description": "The generated values follow a uniform distribution in the range `[minval, maxval)`.\n\nThe outputs are a deterministic function of `shape`, `seed`, `minval`, and `maxval`.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "Tseed",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "T"
      },
      {
        "name": "seed",
        "description": "2 seeds (shape [2]).",
        "typeAttr": "Tseed"
      },
      {
        "name": "minval",
        "description": "Minimum value (inclusive, scalar).",
        "typeAttr": "dtype"
      },
      {
        "name": "maxval",
        "description": "Maximum value (exclusive, scalar).",
        "typeAttr": "dtype"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Random values with specified shape.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "StatelessRandomUniformIntV2",
    "summary": "Outputs deterministic pseudorandom random integers from a uniform distribution.",
    "description": "The generated values follow a uniform distribution in the range `[minval, maxval)`.\n\nThe outputs are a deterministic function of `shape`, `key`, `counter`, `alg`, `minval` and `maxval`.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `int32`, `int64`, `uint32`, `uint64`."
      },
      {
        "name": "Tshape",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "Tshape"
      },
      {
        "name": "key",
        "description": "Key for the counter-based RNG algorithm (shape uint64[1]).",
        "type": 23
      },
      {
        "name": "counter",
        "description": "Initial counter for the counter-based RNG algorithm (shape uint64[2] or uint64[1] depending on the algorithm). If a larger vector is given, only the needed portion on the left (i.e. [:N]) will be used.",
        "type": 23
      },
      {
        "name": "alg",
        "description": "The RNG algorithm (shape int32[]).",
        "type": 3
      },
      {
        "name": "minval",
        "description": "Minimum value (inclusive, scalar).",
        "typeAttr": "dtype"
      },
      {
        "name": "maxval",
        "description": "Maximum value (exclusive, scalar).",
        "typeAttr": "dtype"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Random values with specified shape.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "StatelessRandomUniformV2",
    "summary": "Outputs deterministic pseudorandom random values from a uniform distribution.",
    "description": "The generated values follow a uniform distribution in the range `[0, 1)`. The\nlower bound 0 is included in the range, while the upper bound 1 is excluded.\n\nThe outputs are a deterministic function of `shape`, `key`, `counter` and `alg`.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "Tshape",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "Tshape"
      },
      {
        "name": "key",
        "description": "Key for the counter-based RNG algorithm (shape uint64[1]).",
        "type": 23
      },
      {
        "name": "counter",
        "description": "Initial counter for the counter-based RNG algorithm (shape uint64[2] or uint64[1] depending on the algorithm). If a larger vector is given, only the needed portion on the left (i.e. [:N]) will be used.",
        "type": 23
      },
      {
        "name": "alg",
        "description": "The RNG algorithm (shape int32[]).",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Random values with specified shape.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "StatelessSampleDistortedBoundingBox",
    "summary": "Generate a randomly distorted bounding box for an image deterministically.",
    "description": "Bounding box annotations are often supplied in addition to ground-truth labels\nin image recognition or object localization tasks. A common technique for\ntraining such a system is to randomly distort an image while preserving its\ncontent, i.e. *data augmentation*. This Op, given the same `seed`,\ndeterministically outputs a randomly distorted localization of an object, i.e.\nbounding box, given an `image_size`, `bounding_boxes` and a series of\nconstraints.\n\nThe output of this Op is a single bounding box that may be used to crop the\noriginal image. The output is returned as 3 tensors: `begin`, `size` and\n`bboxes`. The first 2 tensors can be fed directly into `tf.slice` to crop the\nimage. The latter may be supplied to `tf.image.draw_bounding_boxes` to visualize\nwhat the bounding box looks like.\n\nBounding boxes are supplied and returned as `[y_min, x_min, y_max, x_max]`. The\nbounding box coordinates are floats in `[0.0, 1.0]` relative to the width and\nthe height of the underlying image.\n\nThe output of this Op is guaranteed to be the same given the same `seed` and is\nindependent of how many times the function is called, and independent of global\nseed settings (e.g. `tf.random.set_seed`).\n\nExample usage:\n\n>>> image = np.array([[[1], [2], [3]], [[4], [5], [6]], [[7], [8], [9]]])\n>>> bbox = tf.constant(\n...   [0.0, 0.0, 1.0, 1.0], dtype=tf.float32, shape=[1, 1, 4])\n>>> seed = (1, 2)\n>>> # Generate a single distorted bounding box.\n>>> bbox_begin, bbox_size, bbox_draw = (\n...   tf.image.stateless_sample_distorted_bounding_box(\n...     tf.shape(image), bounding_boxes=bbox, seed=seed))\n>>> # Employ the bounding box to distort the image.\n>>> tf.slice(image, bbox_begin, bbox_size)\n<tf.Tensor: shape=(2, 2, 1), dtype=int64, numpy=\narray([[[1],\n        [2]],\n       [[4],\n        [5]]])>\n>>> # Draw the bounding box in an image summary.\n>>> colors = np.array([[1.0, 0.0, 0.0], [0.0, 0.0, 1.0]])\n>>> tf.image.draw_bounding_boxes(\n...   tf.expand_dims(tf.cast(image, tf.float32),0), bbox_draw, colors)\n<tf.Tensor: shape=(1, 3, 3, 1), dtype=float32, numpy=\narray([[[[1.],\n         [1.],\n         [3.]],\n        [[1.],\n         [1.],\n         [6.]],\n        [[7.],\n         [8.],\n         [9.]]]], dtype=float32)>\n\nNote that if no bounding box information is available, setting\n`use_image_if_no_bounding_boxes = true` will assume there is a single implicit\nbounding box covering the whole image. If `use_image_if_no_bounding_boxes` is\nfalse and no bounding boxes are supplied, an error is raised.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `uint8`, `int8`, `int16`, `int32`, `int64`."
      },
      {
        "name": "Tseed",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "aspect_ratio_range",
        "type": "float32[]",
        "description": "The cropped area of the image must have an aspect ratio =\nwidth / height within this range.",
        "default": [
          0.75,
          1.3300000429153442
        ]
      },
      {
        "name": "area_range",
        "type": "float32[]",
        "description": "The cropped area of the image must contain a fraction of the\nsupplied image within this range.",
        "default": [
          0.05000000074505806,
          1.0
        ]
      },
      {
        "name": "max_attempts",
        "type": "int64",
        "description": "Number of attempts at generating a cropped region of the image\nof the specified constraints. After `max_attempts` failures, return the entire\nimage.",
        "default": 100
      },
      {
        "name": "use_image_if_no_bounding_boxes",
        "type": "boolean",
        "description": "Controls behavior if no bounding boxes supplied.\nIf true, assume an implicit bounding box covering the whole input. If false,\nraise an error.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "image_size",
        "description": "1-D, containing `[height, width, channels]`.",
        "typeAttr": "T"
      },
      {
        "name": "bounding_boxes",
        "description": "3-D with shape `[batch, N, 4]` describing the N bounding boxes\nassociated with the image.",
        "type": 1
      },
      {
        "name": "min_object_covered",
        "description": "The cropped area of the image must contain at least this\nfraction of any bounding box supplied. The value of this parameter should be\nnon-negative. In the case of 0, the cropped area does not need to overlap\nany of the bounding boxes supplied.",
        "type": 1
      },
      {
        "name": "seed",
        "description": "1-D with shape `[2]`. The seed to the random number generator. Must have dtype\n`int32` or `int64`. (When using XLA, only `int32` is allowed.)",
        "typeAttr": "Tseed"
      }
    ],
    "outputs": [
      {
        "name": "begin",
        "description": "1-D, containing `[offset_height, offset_width, 0]`. Provide as input to\n`tf.slice`.",
        "typeAttr": "T"
      },
      {
        "name": "size",
        "description": "1-D, containing `[target_height, target_width, -1]`. Provide as input to\n`tf.slice`.",
        "typeAttr": "T"
      },
      {
        "name": "bboxes",
        "description": "3-D with shape `[1, 1, 4]` containing the distorted bounding box.\nProvide as input to `tf.image.draw_bounding_boxes`.",
        "type": 1
      }
    ]
  },
  {
    "name": "StatelessShuffle",
    "summary": "Randomly and deterministically shuffles a tensor along its first dimension.",
    "description": "The tensor is shuffled along dimension 0, such that each `value[j]` is mapped\nto one and only one `output[i]`. For example, a mapping that might occur for a\n3x2 tensor is:\n\n```\n[[1, 2],       [[5, 6],\n [3, 4],  ==>   [1, 2],\n [5, 6]]        [3, 4]]\n```\n\nThe outputs are a deterministic function of `value`, `key`, `counter` and `alg`.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "value",
        "description": "The tensor to be shuffled.",
        "typeAttr": "T"
      },
      {
        "name": "key",
        "description": "Key for the counter-based RNG algorithm (shape uint64[1]).",
        "type": 23
      },
      {
        "name": "counter",
        "description": "Initial counter for the counter-based RNG algorithm (shape uint64[2] or uint64[1] depending on the algorithm). If a larger vector is given, only the needed portion on the left (i.e. [:N]) will be used.",
        "type": 23
      },
      {
        "name": "alg",
        "description": "The RNG algorithm (shape int32[]).",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A tensor of same shape and type as `value`, shuffled along its first\ndimension.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "StatelessTruncatedNormal",
    "summary": "Outputs deterministic pseudorandom values from a truncated normal distribution.",
    "description": "The generated values follow a normal distribution with mean 0 and standard\ndeviation 1, except that values whose magnitude is more than 2 standard\ndeviations from the mean are dropped and re-picked.\n\nThe outputs are a deterministic function of `shape` and `seed`.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "Tseed",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "T"
      },
      {
        "name": "seed",
        "description": "2 seeds (shape [2]).",
        "typeAttr": "Tseed"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Random values with specified shape.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "StatelessTruncatedNormalV2",
    "summary": "Outputs deterministic pseudorandom values from a truncated normal distribution.",
    "description": "The generated values follow a normal distribution with mean 0 and standard\ndeviation 1, except that values whose magnitude is more than 2 standard\ndeviations from the mean are dropped and re-picked.\n\nThe outputs are a deterministic function of `shape`, `key`, `counter` and `alg`.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      },
      {
        "name": "Tshape",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "Tshape"
      },
      {
        "name": "key",
        "description": "Key for the counter-based RNG algorithm (shape uint64[1]).",
        "type": 23
      },
      {
        "name": "counter",
        "description": "Initial counter for the counter-based RNG algorithm (shape uint64[2] or uint64[1] depending on the algorithm). If a larger vector is given, only the needed portion on the left (i.e. [:N]) will be used.",
        "type": 23
      },
      {
        "name": "alg",
        "description": "The RNG algorithm (shape int32[]).",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Random values with specified shape.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "StatelessWhile",
    "summary": "output = input; While (Cond(output)) { output = Body(output) }",
    "attributes": [
      {
        "name": "T",
        "type": "type[]",
        "description": "dtype in use.",
        "minimum": 0
      },
      {
        "name": "cond",
        "type": "function",
        "description": "      A function takes 'input' and returns a tensor.  If the tensor is\n      a scalar of non-boolean, the scalar is converted to a boolean\n      according to the following rule: if the scalar is a numerical\n      value, non-zero means True and zero means False; if the scalar is\n      a string, non-empty means True and empty means False. If the\n      tensor is not a scalar, non-emptiness means True and False\n      otherwise.\n\n      This should only be used when the while condition and body functions\n      do not have stateful ops."
      },
      {
        "name": "body",
        "type": "function",
        "description": "      A function that takes a list of tensors and returns another\n      list of tensors. Both lists have the same types as specified\n      by T."
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "default": []
      },
      {
        "name": "parallel_iterations",
        "type": "int64",
        "default": 10
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A list of input tensors whose types are T.",
        "typeListAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A list of output tensors whose types are T.",
        "typeListAttr": "T"
      }
    ]
  },
  {
    "name": "StaticRegexFullMatch",
    "summary": "Check if the input matches the regex pattern.",
    "description": "The input is a string tensor of any shape. The pattern is the\nregular expression to be matched with every element of the input tensor.\nThe boolean values (True or False) of the output tensor indicate\nif the input matches the regex pattern provided.\n\nThe pattern follows the re2 syntax (https://github.com/google/re2/wiki/Syntax)",
    "attributes": [
      {
        "name": "pattern",
        "type": "string",
        "description": "The regular expression to match the input."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A string tensor of the text to be processed.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A bool tensor with the same shape as `input`.",
        "type": 10
      }
    ]
  },
  {
    "name": "StaticRegexReplace",
    "summary": "Replaces the match of pattern in input with rewrite.",
    "description": "It follows the re2 syntax (https://github.com/google/re2/wiki/Syntax)",
    "attributes": [
      {
        "name": "pattern",
        "type": "string",
        "description": "The regular expression to match the input."
      },
      {
        "name": "rewrite",
        "type": "string",
        "description": "The rewrite to be applied to the matched expression."
      },
      {
        "name": "replace_global",
        "type": "boolean",
        "description": "If True, the replacement is global, otherwise the replacement\nis done only on the first match.",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The text to be processed.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The text after applying pattern and rewrite.",
        "type": 7
      }
    ]
  },
  {
    "name": "StatsAggregatorHandle",
    "summary": "Creates a statistics manager resource.",
    "attributes": [
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 20
      }
    ]
  },
  {
    "name": "StatsAggregatorHandleV2",
    "attributes": [
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 20
      }
    ]
  },
  {
    "name": "StatsAggregatorSetSummaryWriter",
    "summary": "Set a summary_writer_interface to record statistics using given stats_aggregator.",
    "inputs": [
      {
        "name": "stats_aggregator",
        "type": 20
      },
      {
        "name": "summary",
        "type": 20
      }
    ]
  },
  {
    "name": "StatsAggregatorSummary",
    "summary": "Produces a summary of any statistics recorded by the given statistics manager.",
    "inputs": [
      {
        "name": "iterator",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "summary",
        "type": 7
      }
    ]
  },
  {
    "name": "StochasticCastToInt",
    "summary": "Stochastically cast a given tensor from floats to ints.",
    "description": "The values are cast with a deterministic pseudo-random tensor from a uniform distribution generated from user given key, counter, algorithm. Values will saturate if out of the specified integer type range, and will become zero if inputs are NaN.  \n\nThe outputs are a deterministic function of `input`, `key`, `counter`, `alg`.\n",
    "attributes": [
      {
        "name": "Tin",
        "type": "type",
        "description": "The type of the input. Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      },
      {
        "name": "Tout",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `int8`, `int16`, `int32`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The operand to stochastically cast to int.",
        "typeAttr": "Tin"
      },
      {
        "name": "key",
        "description": "Key for the counter-based RNG algorithm (shape uint64[1]).",
        "type": 23
      },
      {
        "name": "counter",
        "description": "Initial counter for the counter-based RNG algorithm (shape uint64[2] or uint64[1] depending on the algorithm). If a larger vector is given, only the needed portion on the left (i.e. [:N]) will be used.",
        "type": 23
      },
      {
        "name": "alg",
        "description": "The RNG algorithm (shape int32[]).",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The cast result with the same shape as the input.",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "StopGradient",
    "summary": "Stops gradient computation.",
    "description": "When executed in a graph, this op outputs its input tensor as-is.\n\nWhen building ops to compute gradients, this op prevents the contribution of\nits inputs to be taken into account.  Normally, the gradient generator adds ops\nto a graph to compute the derivatives of a specified 'loss' by recursively\nfinding out inputs that contributed to its computation.  If you insert this op\nin the graph it inputs are masked from the gradient generator.  They are not\ntaken into account for computing gradients.\n\nThis is useful any time you want to compute a value with TensorFlow but need\nto pretend that the value was a constant. For example, the softmax function\nfor a vector x can be written as\n\n```python\n\n  def softmax(x):\n    numerator = tf.exp(x)\n    denominator = tf.reduce_sum(numerator)\n    return numerator / denominator\n```\n\nThis however is susceptible to overflow if the values in x are large. An\nalternative more stable way is to subtract the maximum of x from each of the\nvalues.\n\n```python\n\n  def stable_softmax(x):\n    z = x - tf.reduce_max(x)\n    numerator = tf.exp(z)\n    denominator = tf.reduce_sum(numerator)\n    return numerator / denominator\n```\n\nHowever, when we backprop through the softmax to x, we dont want to backprop\nthrough the `tf.reduce_max(x)` (if the max values are not unique then the\ngradient could flow to the wrong input) calculation and treat that as a\nconstant. Therefore, we should write this out as\n\n```python\n\n  def stable_softmax(x):\n    z = x - tf.stop_gradient(tf.reduce_max(x))\n    numerator = tf.exp(z)\n    denominator = tf.reduce_sum(numerator)\n    return numerator / denominator\n```\n\nSome other examples include:\n\n*  The *EM* algorithm where the *M-step* should not involve backpropagation\n   through the output of the *E-step*.\n*  Contrastive divergence training of Boltzmann machines where, when\n   differentiating the energy function, the training must not backpropagate\n   through the graph that generated the samples from the model.\n*  Adversarial training, where no backprop should happen through the adversarial\n   example generation process.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "StoreMinibatchStatisticsInFdo",
    "attributes": [
      {
        "name": "sample_count",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "num_replica",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "feature_width",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "num_sc_per_chip",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "table_name",
        "type": "string"
      },
      {
        "name": "mini_batch_splits",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "name": "program_key",
        "type": 7
      },
      {
        "name": "max_ids",
        "type": 3
      },
      {
        "name": "max_uniques",
        "type": 3
      }
    ]
  },
  {
    "name": "StridedSlice",
    "category": "Tensor",
    "summary": "Return a strided slice from `input`.",
    "description": "Note, most python users will want to use the Python `Tensor.__getitem__`\nor `Variable.__getitem__` rather than this op directly.\n\nThe goal of this op is to produce a new tensor with a subset of\nthe elements from the `n` dimensional `input` tensor. The subset is chosen using\na sequence of `m` sparse range specifications encoded into the arguments\nof this function. Note, in some cases\n`m` could be equal to `n`, but this need not be the case. Each\nrange specification entry can be one of the following:\n\n- An ellipsis (...). Ellipses are used to imply zero or more\n  dimensions of full-dimension selection and are produced using\n  `ellipsis_mask`. For example, `foo[...]` is the identity slice.\n\n- A new axis. This is used to insert a new shape=1 dimension and is\n  produced using `new_axis_mask`. For example, `foo[:, ...]` where\n  `foo` is shape `(3, 4)` produces a `(1, 3, 4)` tensor.\n\n\n- A range `begin:end:stride`. This is used to specify how much to choose from\n  a given dimension. `stride` can be any integer but 0.  `begin` is an integer\n  which represents the index of the first value to select while `end` represents\n  the index of the last value to select. The number of values selected in each\n  dimension is `end - begin` if `stride > 0` and `begin - end` if `stride < 0`.\n  `begin` and `end` can be negative where `-1` is the last element, `-2` is\n  the second to last. `begin_mask` controls whether to replace the explicitly\n  given `begin` with an implicit effective value of `0` if `stride > 0` and\n  `-1` if `stride < 0`. `end_mask` is analogous but produces the number\n  required to create the largest open interval. For example, given a shape\n  `(3,)` tensor `foo[:]`, the effective `begin` and `end` are `0` and `3`. Do\n  not assume this is equivalent to `foo[0:-1]` which has an effective `begin`\n  and `end` of `0` and `2`. Another example is `foo[-2::-1]` which reverses the\n  first dimension of a tensor while dropping the last two (in the original\n  order elements). For example `foo = [1,2,3,4]; foo[-2::-1]` is `[4,3]`.\n\n- A single index. This is used to keep only elements that have a given\n  index. For example (`foo[2, :]` on a shape `(5,6)` tensor produces a\n  shape `(6,)` tensor. This is encoded in `begin` and `end` and\n  `shrink_axis_mask`.\n\nEach conceptual range specification is encoded in the op's argument. This\nencoding is best understand by considering a non-trivial example. In\nparticular,\n`foo[1, 2:4, None, ..., :-3:-1, :]` will be encoded as\n\n```\nbegin = [1, 2, x, x, 0, x] # x denotes don't care (usually 0)\nend = [2, 4, x, x, -3, x]\nstrides = [1, 1, x, x, -1, 1]\nbegin_mask = 1<<4 | 1<<5 = 48\nend_mask = 1<<5 = 32\nellipsis_mask = 1<<3 = 8\nnew_axis_mask = 1<<2 = 4\nshrink_axis_mask = 1<<0 = 1\n```\n\nIn this case if `foo.shape` is (5, 5, 5, 5, 5, 5) the final shape of\nthe slice becomes (2, 1, 5, 5, 2, 5).\nLet us walk step by step through each argument specification.\n\n1.  The first argument in the example slice is turned into `begin = 1` and\n`end = begin + 1 = 2`. To disambiguate from the original spec `2:4` we\nalso set the appropriate bit in `shrink_axis_mask`.\n\n2. `2:4` is contributes 2, 4, 1 to begin, end, and stride. All masks have\nzero bits contributed.\n\n3. None is a synonym for `tf.newaxis`. This means insert a dimension of size 1\ndimension in the final shape. Dummy values are contributed to begin,\nend and stride, while the new_axis_mask bit is set.\n\n4. `...` grab the full ranges from as many dimensions as needed to\nfully specify a slice for every dimension of the input shape.\n\n5. `:-3:-1` shows the use of negative indices. A negative index `i` associated\nwith a dimension that has shape `s` is converted to a positive index\n`s + i`. So `-1` becomes `s-1` (i.e. the last element). This conversion\nis done internally so begin, end and strides receive x, -3, and -1.\nThe appropriate begin_mask bit is set to indicate the start range is the\nfull range (ignoring the x).\n\n6. `:` indicates that the entire contents of the corresponding dimension\nis selected. This is equivalent to `::` or `0::1`. begin, end, and strides\nreceive 0, 0, and 1, respectively. The appropriate bits in `begin_mask` and\n`end_mask` are also set.\n\n*Requirements*:\n  `0 != strides[i] for i in [0, m)`\n  `ellipsis_mask must be a power of two (only one ellipsis)`",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Index",
        "type": "type",
        "description": "Must be one of the following: `int16`, `int32`, `int64`."
      },
      {
        "name": "begin_mask",
        "type": "int64",
        "description": "a bitmask where a bit i being 1 means to ignore the begin\nvalue and instead use the largest interval possible. At runtime\nbegin[i] will be replaced with `[0, n-1)` if `stride[i] > 0` or\n`[-1, n-1]` if `stride[i] < 0`",
        "default": 0
      },
      {
        "name": "end_mask",
        "type": "int64",
        "description": "analogous to `begin_mask`",
        "default": 0
      },
      {
        "name": "ellipsis_mask",
        "type": "int64",
        "description": "a bitmask where bit `i` being 1 means the `i`th\nposition is actually an ellipsis. One bit at most can be 1.\nIf `ellipsis_mask == 0`, then an implicit ellipsis mask of `1 << (m+1)`\nis provided. This means that `foo[3:5] == foo[3:5, ...]`. An ellipsis\nimplicitly creates as many range specifications as necessary to fully\nspecify the sliced range for every dimension. For example for a 4-dimensional\ntensor `foo` the slice `foo[2, ..., 5:8]` implies `foo[2, :, :, 5:8]`.",
        "default": 0
      },
      {
        "name": "new_axis_mask",
        "type": "int64",
        "description": "a bitmask where bit `i` being 1 means the `i`th\nspecification creates a new shape 1 dimension. For example\n`foo[:4, tf.newaxis, :2]` would produce a shape `(4, 1, 2)` tensor.",
        "default": 0
      },
      {
        "name": "shrink_axis_mask",
        "type": "int64",
        "description": "a bitmask where bit `i` implies that the `i`th\nspecification should shrink the dimensionality. begin and end\nmust imply a slice of size 1 in the dimension. For example in\npython one might do `foo[:, 3, :]` which would result in\n`shrink_axis_mask` being 2.",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "begin",
        "description": "`begin[k]` specifies the offset into the `k`th range specification.\nThe exact dimension this corresponds to will be determined by context.\nOut-of-bounds values will be silently clamped. If the `k`th bit of\n`begin_mask` then `begin[k]` is ignored and the full range of the\nappropriate dimension is used instead. Negative values causes indexing\nto start from the highest element e.g. If `foo==[1,2,3]` then `foo[-1]==3`.",
        "typeAttr": "Index"
      },
      {
        "name": "end",
        "description": "`end[i]` is like `begin` with the exception that `end_mask` is\nused to determine full ranges.",
        "typeAttr": "Index"
      },
      {
        "name": "strides",
        "description": "`strides[i]` specifies the increment in the `i`th specification\nafter extracting a given element. Negative indices will reverse\nthe original order. Out or range values are\nclamped to `[0,dim[i]) if slice[i]>0` or `[-1,dim[i]-1] if slice[i] < 0`",
        "typeAttr": "Index"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "StridedSliceAssign",
    "summary": "Assign `value` to the sliced l-value reference of `ref`.",
    "description": "The values of `value` are assigned to the positions in the variable\n`ref` that are selected by the slice parameters. The slice parameters\n`begin`, `end`, `strides`, etc. work exactly as in `StridedSlice`.\n\nNOTE this op currently does not support broadcasting and so `value`'s\nshape must be exactly the shape produced by the slice of `ref`.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Index",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "begin_mask",
        "type": "int64",
        "default": 0
      },
      {
        "name": "end_mask",
        "type": "int64",
        "default": 0
      },
      {
        "name": "ellipsis_mask",
        "type": "int64",
        "default": 0
      },
      {
        "name": "new_axis_mask",
        "type": "int64",
        "default": 0
      },
      {
        "name": "shrink_axis_mask",
        "type": "int64",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "ref",
        "typeAttr": "T",
        "isRef": true
      },
      {
        "name": "begin",
        "typeAttr": "Index"
      },
      {
        "name": "end",
        "typeAttr": "Index"
      },
      {
        "name": "strides",
        "typeAttr": "Index"
      },
      {
        "name": "value",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output_ref",
        "typeAttr": "T",
        "isRef": true
      }
    ]
  },
  {
    "name": "StridedSliceGrad",
    "summary": "Returns the gradient of `StridedSlice`.",
    "description": "Since `StridedSlice` cuts out pieces of its `input` which is size\n`shape`, its gradient will have the same shape (which is passed here\nas `shape`). The gradient will be zero in any element that the slice\ndoes not select.\n\nArguments are the same as StridedSliceGrad with the exception that\n`dy` is the input gradient to be propagated and `shape` is the\nshape of `StridedSlice`'s `input`.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Index",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "begin_mask",
        "type": "int64",
        "default": 0
      },
      {
        "name": "end_mask",
        "type": "int64",
        "default": 0
      },
      {
        "name": "ellipsis_mask",
        "type": "int64",
        "default": 0
      },
      {
        "name": "new_axis_mask",
        "type": "int64",
        "default": 0
      },
      {
        "name": "shrink_axis_mask",
        "type": "int64",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "typeAttr": "Index"
      },
      {
        "name": "begin",
        "typeAttr": "Index"
      },
      {
        "name": "end",
        "typeAttr": "Index"
      },
      {
        "name": "strides",
        "typeAttr": "Index"
      },
      {
        "name": "dy",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "StringFormat",
    "summary": "Formats a string template using a list of tensors.",
    "description": "Formats a string template using a list of tensors, pretty-printing tensor summaries.",
    "attributes": [
      {
        "name": "T",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "template",
        "type": "string",
        "description": "A string, the template to format tensor summaries into.",
        "default": "%s"
      },
      {
        "name": "placeholder",
        "type": "string",
        "description": "A string, at each placeholder in the template a subsequent tensor summary will be inserted.",
        "default": "%s"
      },
      {
        "name": "summarize",
        "type": "int64",
        "description": "When formatting the tensor summaries print the first and last summarize entries of each tensor dimension.",
        "default": 3
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "description": "The list of tensors to format into the placeholder string.",
        "typeListAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "= The resulting string scalar.",
        "type": 7
      }
    ]
  },
  {
    "name": "StringJoin",
    "summary": "Joins the strings in the given list of string tensors into one tensor;",
    "description": "with the given separator (default is an empty separator).\n\nExamples:\n\n>>> s = [\"hello\", \"world\", \"tensorflow\"]\n>>> tf.strings.join(s, \" \")\n<tf.Tensor: shape=(), dtype=string, numpy=b'hello world tensorflow'>",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 0
      },
      {
        "name": "separator",
        "type": "string",
        "description": "string, an optional join separator.",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "description": "A list of string tensors.  The tensors must all have the same shape,\nor be scalars.  Scalars may be mixed in; these will be broadcast to the shape\nof non-scalar inputs.",
        "numberAttr": "N",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 7
      }
    ]
  },
  {
    "name": "StringLength",
    "summary": "String lengths of `input`.",
    "description": "Computes the length of each string given in the input tensor.\n\n>>> strings = tf.constant(['Hello','TensorFlow', '\\U0001F642'])\n>>> tf.strings.length(strings).numpy() # default counts bytes\narray([ 5, 10, 4], dtype=int32)\n>>> tf.strings.length(strings, unit=\"UTF8_CHAR\").numpy()\narray([ 5, 10, 1], dtype=int32)\n",
    "attributes": [
      {
        "name": "unit",
        "type": "string",
        "description": "The unit that is counted to compute string length.  One of: `\"BYTE\"` (for\nthe number of bytes in each string) or `\"UTF8_CHAR\"` (for the number of UTF-8\nencoded Unicode code points in each string).  Results are undefined\nif `unit=UTF8_CHAR` and the `input` strings do not contain structurally\nvalid UTF-8. Must be one of the following: `BYTE`, `UTF8_CHAR`.",
        "default": "BYTE"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The strings for which to compute the length for each element.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Integer tensor that has the same shape as `input`. The output contains the\nelement-wise string lengths of `input`.",
        "type": 3
      }
    ]
  },
  {
    "name": "StringLower",
    "summary": "Converts all uppercase characters into their respective lowercase replacements.",
    "description": "Example:\n\n>>> tf.strings.lower(\"CamelCase string and ALL CAPS\")\n<tf.Tensor: shape=(), dtype=string, numpy=b'camelcase string and all caps'>\n",
    "attributes": [
      {
        "name": "encoding",
        "type": "string",
        "description": "Character encoding of `input`. Allowed values are '' and 'utf-8'.\nValue '' is interpreted as ASCII.",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The input to be lower-cased.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 7
      }
    ]
  },
  {
    "name": "StringNGrams",
    "summary": "Creates ngrams from ragged string data.",
    "description": "This op accepts a ragged tensor with 1 ragged dimension containing only\nstrings and outputs a ragged tensor with 1 ragged dimension containing ngrams\nof that string, joined along the innermost axis.",
    "attributes": [
      {
        "name": "separator",
        "type": "string",
        "description": "The string to append between elements of the token. Use \"\" for no separator."
      },
      {
        "name": "ngram_widths",
        "type": "int64[]",
        "description": "The sizes of the ngrams to create.",
        "minimum": 0
      },
      {
        "name": "left_pad",
        "type": "string",
        "description": "The string to use to pad the left side of the ngram sequence. Only used if\npad_width != 0."
      },
      {
        "name": "right_pad",
        "type": "string",
        "description": "The string to use to pad the right side of the ngram sequence. Only used if\npad_width != 0."
      },
      {
        "name": "pad_width",
        "type": "int64",
        "description": "The number of padding elements to add to each side of each\nsequence. Note that padding will never be greater than 'ngram_widths'-1\nregardless of this value. If `pad_width=-1`, then add `max(ngram_widths)-1`\nelements."
      },
      {
        "name": "preserve_short_sequences",
        "type": "boolean"
      },
      {
        "name": "Tsplits",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "data",
        "description": "The values tensor of the ragged string tensor to make ngrams out of. Must be a\n1D string tensor.",
        "type": 7
      },
      {
        "name": "data_splits",
        "description": "The splits tensor of the ragged string tensor to make ngrams out of.",
        "typeAttr": "Tsplits"
      }
    ],
    "outputs": [
      {
        "name": "ngrams",
        "description": "The values tensor of the output ngrams ragged tensor.",
        "type": 7
      },
      {
        "name": "ngrams_splits",
        "description": "The splits tensor of the output ngrams ragged tensor.",
        "typeAttr": "Tsplits"
      }
    ]
  },
  {
    "name": "StringSplit",
    "summary": "Split elements of `input` based on `delimiter` into a `SparseTensor`.",
    "description": "Let N be the size of source (typically N will be the batch size). Split each\nelement of `input` based on `delimiter` and return a `SparseTensor`\ncontaining the splitted tokens. Empty tokens are ignored.\n\n`delimiter` can be empty, or a string of split characters. If `delimiter` is an\n empty string, each element of `input` is split into individual single-byte\n character strings, including splitting of UTF-8 multibyte sequences. Otherwise\n every character of `delimiter` is a potential split point.\n\nFor example:\n  N = 2, input[0] is 'hello world' and input[1] is 'a b c', then the output\n  will be\n\n  indices = [0, 0;\n             0, 1;\n             1, 0;\n             1, 1;\n             1, 2]\n  shape = [2, 3]\n  values = ['hello', 'world', 'a', 'b', 'c']",
    "attributes": [
      {
        "name": "skip_empty",
        "type": "boolean",
        "description": "A `bool`. If `True`, skip the empty strings from the result.",
        "default": true
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "1-D. Strings to split.",
        "type": 7
      },
      {
        "name": "delimiter",
        "description": "0-D. Delimiter characters (bytes), or empty string.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "indices",
        "description": "A dense matrix of int64 representing the indices of the sparse tensor.",
        "type": 9
      },
      {
        "name": "values",
        "description": "A vector of strings corresponding to the splited values.",
        "type": 7
      },
      {
        "name": "shape",
        "description": "a length-2 vector of int64 representing the shape of the sparse\ntensor, where the first value is N and the second value is the maximum number\nof tokens in a single input entry.",
        "type": 9
      }
    ]
  },
  {
    "name": "StringSplitV2",
    "summary": "Split elements of `source` based on `sep` into a `SparseTensor`.",
    "description": "Let N be the size of source (typically N will be the batch size). Split each\nelement of `source` based on `sep` and return a `SparseTensor`\ncontaining the split tokens. Empty tokens are ignored.\n\nFor example, N = 2, source[0] is 'hello world' and source[1] is 'a b c',\nthen the output will be\n```\nst.indices = [0, 0;\n              0, 1;\n              1, 0;\n              1, 1;\n              1, 2]\nst.shape = [2, 3]\nst.values = ['hello', 'world', 'a', 'b', 'c']\n```\n\nIf `sep` is given, consecutive delimiters are not grouped together and are\ndeemed to delimit empty strings. For example, source of `\"1<>2<><>3\"` and\nsep of `\"<>\"` returns `[\"1\", \"2\", \"\", \"3\"]`. If `sep` is None or an empty\nstring, consecutive whitespace are regarded as a single separator, and the\nresult will contain no empty strings at the startor end if the string has\nleading or trailing whitespace.\n\nNote that the above mentioned behavior matches python's str.split.",
    "attributes": [
      {
        "name": "maxsplit",
        "type": "int64",
        "description": "An `int`. If `maxsplit > 0`, limit of the split of the result.",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "`1-D` string `Tensor`, the strings to split.",
        "type": 7
      },
      {
        "name": "sep",
        "description": "`0-D` string `Tensor`, the delimiter character.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "indices",
        "type": 9
      },
      {
        "name": "values",
        "type": 7
      },
      {
        "name": "shape",
        "type": 9
      }
    ]
  },
  {
    "name": "StringStrip",
    "summary": "Strip leading and trailing whitespaces from the Tensor.",
    "description": "Examples:\n\n>>> tf.strings.strip([\"\\nTensorFlow\", \"     The python library    \"]).numpy()\narray([b'TensorFlow', b'The python library'], dtype=object)",
    "inputs": [
      {
        "name": "input",
        "description": "A string `Tensor` of any shape.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A string `Tensor` of the same shape as the input.",
        "type": 7
      }
    ]
  },
  {
    "name": "StringToHashBucket",
    "summary": "Converts each string in the input Tensor to its hash mod by a number of buckets.",
    "description": "The hash function is deterministic on the content of the string within the\nprocess.\n\nNote that the hash function may change from time to time.\nThis functionality will be deprecated and it's recommended to use\n`tf.string_to_hash_bucket_fast()` or `tf.string_to_hash_bucket_strong()`.",
    "attributes": [
      {
        "name": "num_buckets",
        "type": "int64",
        "description": "The number of buckets.",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "string_tensor",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A Tensor of the same shape as the input `string_tensor`.",
        "type": 9
      }
    ]
  },
  {
    "name": "StringToHashBucketFast",
    "summary": "Converts each string in the input Tensor to its hash mod by a number of buckets.",
    "description": "The hash function is deterministic on the content of the string within the\nprocess and will never change. However, it is not suitable for cryptography.\nThis function may be used when CPU time is scarce and inputs are trusted or\nunimportant. There is a risk of adversaries constructing inputs that all hash\nto the same bucket. To prevent this problem, use a strong hash function with\n`tf.string_to_hash_bucket_strong`.\n\nExamples:\n\n>>> tf.strings.to_hash_bucket_fast([\"Hello\", \"TensorFlow\", \"2.x\"], 3).numpy()\narray([0, 2, 2])",
    "attributes": [
      {
        "name": "num_buckets",
        "type": "int64",
        "description": "The number of buckets.",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The strings to assign a hash bucket.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A Tensor of the same shape as the input `string_tensor`.",
        "type": 9
      }
    ]
  },
  {
    "name": "StringToHashBucketStrong",
    "summary": "Converts each string in the input Tensor to its hash mod by a number of buckets.",
    "description": "The hash function is deterministic on the content of the string within the\nprocess. The hash function is a keyed hash function, where attribute `key`\ndefines the key of the hash function. `key` is an array of 2 elements.\n\nA strong hash is important when inputs may be malicious, e.g. URLs with\nadditional components. Adversaries could try to make their inputs hash to the\nsame bucket for a denial-of-service attack or to skew the results. A strong\nhash can be used to make it difficult to find inputs with a skewed hash value\ndistribution over buckets. This requires that the hash function is\nseeded by a high-entropy (random) \"key\" unknown to the adversary.\n\nThe additional robustness comes at a cost of roughly 4x higher compute\ntime than `tf.string_to_hash_bucket_fast`.\n\nExamples:\n\n>>> tf.strings.to_hash_bucket_strong([\"Hello\", \"TF\"], 3, [1, 2]).numpy()\narray([2, 0])",
    "attributes": [
      {
        "name": "num_buckets",
        "type": "int64",
        "description": "The number of buckets.",
        "minimum": 1
      },
      {
        "name": "key",
        "type": "int64[]",
        "description": "The key used to seed the hash function, passed as a list of two uint64\nelements."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The strings to assign a hash bucket.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A Tensor of the same shape as the input `string_tensor`.",
        "type": 9
      }
    ]
  },
  {
    "name": "StringToNumber",
    "summary": "Converts each string in the input Tensor to the specified numeric type.",
    "description": "(Note that int32 overflow results in an error while float overflow\nresults in a rounded value.)\n\nExample:\n\n>>> strings = [\"5.0\", \"3.0\", \"7.0\"]\n>>> tf.strings.to_number(strings)\n<tf.Tensor: shape=(3,), dtype=float32, numpy=array([5., 3., 7.], dtype=float32)>\n",
    "attributes": [
      {
        "name": "out_type",
        "type": "type",
        "description": "The numeric type to interpret each string in `string_tensor` as. Must be one of the following: `float32`, `float64`, `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "string_tensor",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A Tensor of the same shape as the input `string_tensor`.",
        "typeAttr": "out_type"
      }
    ]
  },
  {
    "name": "StringUpper",
    "summary": "Converts all lowercase characters into their respective uppercase replacements.",
    "description": "Example:\n\n>>> tf.strings.upper(\"CamelCase string and ALL CAPS\")\n<tf.Tensor: shape=(), dtype=string, numpy=b'CAMELCASE STRING AND ALL CAPS'>\n",
    "attributes": [
      {
        "name": "encoding",
        "type": "string",
        "description": "Character encoding of `input`. Allowed values are '' and 'utf-8'.\nValue '' is interpreted as ASCII.",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The input to be upper-cased.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 7
      }
    ]
  },
  {
    "name": "Sub",
    "summary": "Returns x - y element-wise.",
    "description": "*NOTE*: `Sub` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `uint8`, `int8`, `uint16`, `int16`, `int32`, `int64`, `complex64`, `complex128`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Substr",
    "summary": "Return substrings from `Tensor` of strings.",
    "description": "For each string in the input `Tensor`, creates a substring starting at index\n`pos` with a total length of `len`.\n\nIf `len` defines a substring that would extend beyond the length of the input\nstring, or if `len` is negative, then as many characters as possible are used.\n\nA negative `pos` indicates distance within the string backwards from the end.\n\nIf `pos` specifies an index which is out of range for any of the input strings,\nthen an `InvalidArgumentError` is thrown.\n\n`pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on\nOp creation.\n\n*NOTE*: `Substr` supports broadcasting up to two dimensions. More about\nbroadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)\n\n---\n\nExamples\n\nUsing scalar `pos` and `len`:\n\n```python\ninput = [b'Hello', b'World']\nposition = 1\nlength = 3\n\noutput = [b'ell', b'orl']\n```\n\nUsing `pos` and `len` with same shape as `input`:\n\n```python\ninput = [[b'ten', b'eleven', b'twelve'],\n         [b'thirteen', b'fourteen', b'fifteen'],\n         [b'sixteen', b'seventeen', b'eighteen']]\nposition = [[1, 2, 3],\n            [1, 2, 3],\n            [1, 2, 3]]\nlength =   [[2, 3, 4],\n            [4, 3, 2],\n            [5, 5, 5]]\n\noutput = [[b'en', b'eve', b'lve'],\n          [b'hirt', b'urt', b'te'],\n          [b'ixtee', b'vente', b'hteen']]\n```\n\nBroadcasting `pos` and `len` onto `input`:\n\n```\ninput = [[b'ten', b'eleven', b'twelve'],\n         [b'thirteen', b'fourteen', b'fifteen'],\n         [b'sixteen', b'seventeen', b'eighteen'],\n         [b'nineteen', b'twenty', b'twentyone']]\nposition = [1, 2, 3]\nlength =   [1, 2, 3]\n\noutput = [[b'e', b'ev', b'lve'],\n          [b'h', b'ur', b'tee'],\n          [b'i', b've', b'hte'],\n          [b'i', b'en', b'nty']]\n```\n\nBroadcasting `input` onto `pos` and `len`:\n\n```\ninput = b'thirteen'\nposition = [1, 5, 7]\nlength =   [3, 2, 1]\n\noutput = [b'hir', b'ee', b'n']\n```\n\nRaises:\n\n  * `ValueError`: If the first argument cannot be converted to a\n     Tensor of `dtype string`.\n  * `InvalidArgumentError`: If indices are out of range.\n  * `ValueError`: If `pos` and `len` are not the same shape.\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "unit",
        "type": "string",
        "description": "The unit that is used to create the substring.  One of: `\"BYTE\"` (for\ndefining position and length by bytes) or `\"UTF8_CHAR\"` (for the UTF-8\nencoded Unicode code points).  The default is `\"BYTE\"`. Results are undefined if\n`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid\nUTF-8. Must be one of the following: `BYTE`, `UTF8_CHAR`.",
        "default": "BYTE"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Tensor of strings",
        "type": 7
      },
      {
        "name": "pos",
        "description": "Scalar defining the position of first character in each substring",
        "typeAttr": "T"
      },
      {
        "name": "len",
        "description": "Scalar defining the number of characters to include in each substring",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Tensor of substrings",
        "type": 7
      }
    ]
  },
  {
    "name": "Sum",
    "summary": "Computes the sum of elements across dimensions of a tensor.",
    "description": "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1.",
    "attributes": [
      {
        "name": "keep_dims",
        "type": "boolean",
        "description": "If true, retain reduced dimensions with length 1.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The tensor to reduce.",
        "typeAttr": "T"
      },
      {
        "name": "reduction_indices",
        "description": "The dimensions to reduce. Must be in the range\n`[-rank(input), rank(input))`.",
        "typeAttr": "Tidx"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The reduced tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SummaryWriter",
    "attributes": [
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "container",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "writer",
        "type": 20
      }
    ]
  },
  {
    "name": "Svd",
    "summary": "Computes the singular value decompositions of one or more matrices.",
    "description": "Computes the SVD of each inner matrix in `input` such that\n`input[..., :, :] = u[..., :, :] * diag(s[..., :, :]) * transpose(v[..., :, :])`\n\n```python\n# a is a tensor containing a batch of matrices.\n# s is a tensor of singular values for each matrix.\n# u is the tensor containing the left singular vectors for each matrix.\n# v is the tensor containing the right singular vectors for each matrix.\ns, u, v = svd(a)\ns, _, _ = svd(a, compute_uv=False)\n```",
    "attributes": [
      {
        "name": "compute_uv",
        "type": "boolean",
        "description": "If true, left and right singular vectors will be\ncomputed and returned in `u` and `v`, respectively.\nIf false, `u` and `v` are not set and should never referenced.",
        "default": true
      },
      {
        "name": "full_matrices",
        "type": "boolean",
        "description": "If true, compute full-sized `u` and `v`. If false\n(the default), compute only the leading `P` singular vectors.\nIgnored if `compute_uv` is `False`.",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float64`, `float32`, `float16`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A tensor of shape `[..., M, N]` whose inner-most 2 dimensions\nform matrices of size `[M, N]`. Let `P` be the minimum of `M` and `N`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "s",
        "description": "Singular values. Shape is `[..., P]`.",
        "typeAttr": "T"
      },
      {
        "name": "u",
        "description": "Left singular vectors. If `full_matrices` is `False` then shape is\n`[..., M, P]`; if `full_matrices` is `True` then shape is\n`[..., M, M]`. Undefined if `compute_uv` is `False`.",
        "typeAttr": "T"
      },
      {
        "name": "v",
        "description": "Left singular vectors. If `full_matrices` is `False` then shape is\n`[..., N, P]`. If `full_matrices` is `True` then shape is `[..., N, N]`.\nUndefined if `compute_uv` is false.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Switch",
    "summary": "Forwards `data` to the output port determined by `pred`.",
    "description": "If `pred` is true, the `data` input is forwarded to `output_true`. Otherwise,\nthe data goes to `output_false`.\n\nSee also `RefSwitch` and `Merge`.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "data",
        "description": "The tensor to be forwarded to the appropriate output.",
        "typeAttr": "T"
      },
      {
        "name": "pred",
        "description": "A scalar that specifies which output port will receive data.",
        "type": 10
      }
    ],
    "outputs": [
      {
        "name": "output_false",
        "description": "If `pred` is false, data will be forwarded to this output.",
        "typeAttr": "T"
      },
      {
        "name": "output_true",
        "description": "If `pred` is true, data will be forwarded to this output.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "SymbolicGradient",
    "summary": "Computes the gradient function for function f via backpropagation.",
    "attributes": [
      {
        "name": "Tin",
        "type": "type[]",
        "description": "the type list for the input list.",
        "minimum": 1
      },
      {
        "name": "Tout",
        "type": "type[]",
        "description": "the type list for the input list.",
        "minimum": 1
      },
      {
        "name": "f",
        "type": "function",
        "description": "The function we want to compute the gradient for.\n\nThe function 'f' must be a numerical function which takes N inputs and\nproduces M outputs. Its gradient function 'g', which is computed by\nthis SymbolicGradient op is a function taking N + M inputs and\nproduces N outputs.\n\nI.e. if we have\n   (y1, y2, ..., y_M) = f(x1, x2, ..., x_N),\nthen, g is\n   (dL/dx1, dL/dx2, ..., dL/dx_N) = g(x1, x2, ..., x_N,\n                                     dL/dy1, dL/dy2, ..., dL/dy_M),\n\nwhere L is a scalar-value function of (x1, x2, ..., xN) (e.g., the\nloss function). dL/dx_i is the partial derivative of L with respect\nto x_i.\n\n(Needs some math expert to say the comment above better.)"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "a list of input tensors of size N + M;",
        "typeListAttr": "Tin"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "a list of output tensors of size N;",
        "typeListAttr": "Tout"
      }
    ]
  },
  {
    "name": "SyncDevice",
    "summary": "Synchronizes the device this op is run on.",
    "description": "Only GPU ops are asynchrous in TensorFlow, and so this only has an effect when\nrun on GPUs. On GPUs, this op synchronizes the GPU's compute stream."
  },
  {
    "name": "TFRecordDataset",
    "summary": "Creates a dataset that emits the records from one or more TFRecord files.",
    "attributes": [
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "filenames",
        "description": "A scalar or vector containing the name(s) of the file(s) to be\nread.",
        "type": 7
      },
      {
        "name": "compression_type",
        "description": "A scalar containing either (i) the empty string (no\ncompression), (ii) \"ZLIB\", or (iii) \"GZIP\".",
        "type": 7
      },
      {
        "name": "buffer_size",
        "description": "A scalar representing the number of bytes to buffer. A value of\n0 means no buffering will be performed.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "TFRecordDatasetV2",
    "summary": "Creates a dataset that emits the records from one or more TFRecord files.",
    "attributes": [
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "filenames",
        "description": "A scalar or vector containing the name(s) of the file(s) to be\nread.",
        "type": 7
      },
      {
        "name": "compression_type",
        "description": "A scalar containing either (i) the empty string (no\ncompression), (ii) \"ZLIB\", or (iii) \"GZIP\".",
        "type": 7
      },
      {
        "name": "buffer_size",
        "description": "A scalar representing the number of bytes to buffer. A value of\n0 means no buffering will be performed.",
        "type": 9
      },
      {
        "name": "byte_offsets",
        "description": "A scalar or vector containing the number of bytes for each file\nthat will be skipped prior to reading.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "TFRecordReader",
    "summary": "A Reader that outputs the records from a TensorFlow Records file.",
    "attributes": [
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
        "default": ""
      },
      {
        "name": "compression_type",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "reader_handle",
        "description": "The handle to reference the Reader.",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "TFRecordReaderV2",
    "summary": "A Reader that outputs the records from a TensorFlow Records file.",
    "attributes": [
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
        "default": ""
      },
      {
        "name": "compression_type",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "reader_handle",
        "description": "The handle to reference the Reader.",
        "type": 20
      }
    ]
  },
  {
    "name": "TPUAnnotateTensorsWithDynamicShape",
    "attributes": [
      {
        "name": "T",
        "type": "type[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "tensors",
        "typeListAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "tpu_tensors",
        "typeListAttr": "T"
      }
    ]
  },
  {
    "name": "TPUCompilationResult",
    "summary": "Returns the result of a TPU compilation.",
    "description": "This operation returns the result of a TPU compilation as a serialized\nCompilationResultProto, which holds a status and an error message if an error\noccurred during compilation.",
    "outputs": [
      {
        "name": "output",
        "type": 7
      }
    ]
  },
  {
    "name": "TPUCompile",
    "summary": "Compiles a computations for execution on one or more TPU devices.",
    "description": "For the internal use of the distributed TPU compiler.\n\n'num_computations' is the number of computations to be compiled.\n'function' is a function containing the computation to compile.\n'dynamic_shapes' contains dynamic shapes of arguments whose shapes were not\nknown statically at TPUReplication rewrite time.\n'guaranteed_constants' is a list of tensors which have been guaranteed to not\nchange their values during the session lifetime. These contain tensors marked as\nconstant using the GuaranteeConstOp.\n'metadata' is a serialized TPUCompileMetadataProto describing\nthe shapes and types of the inputs to the computation, as well as a mapping onto\nthe TPU pod topology.\nEach 'program' output is a string key that is passed to the _TPUExecute op and\nused to look up the program in the compilation cache.\n'may_modify_variables' indicates whether variables may be modified.",
    "attributes": [
      {
        "name": "num_computations",
        "type": "int64",
        "minimum": 0
      },
      {
        "name": "function",
        "type": "function"
      },
      {
        "name": "metadata",
        "type": "string"
      },
      {
        "name": "NumDynamicShapes",
        "type": "int64",
        "minimum": 0
      },
      {
        "name": "Tguaranteed_constants",
        "type": "type[]",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "dynamic_shapes",
        "numberAttr": "NumDynamicShapes",
        "type": 9
      },
      {
        "name": "guaranteed_constants",
        "typeListAttr": "Tguaranteed_constants"
      }
    ],
    "outputs": [
      {
        "name": "compilation_status",
        "type": 7
      },
      {
        "name": "program",
        "numberAttr": "num_computations",
        "type": 7
      },
      {
        "name": "may_modify_variables",
        "numberAttr": "num_computations",
        "type": 10
      }
    ]
  },
  {
    "name": "TPUCompileSucceededAssert",
    "summary": "Asserts that compilation succeeded.",
    "description": "This op produces no output and closes the device during failure to ensure all\npending device interactions fail.\n\n'compilation_status' is a serialized CompilationResultProto.",
    "inputs": [
      {
        "name": "compilation_status",
        "type": 7
      }
    ]
  },
  {
    "name": "TPUCopyWithDynamicShape",
    "summary": "Op that copies host tensor to device with dynamic shape support.\nFor internal use only.",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 0
      },
      {
        "name": "T",
        "type": "type[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "tensors",
        "typeListAttr": "T"
      },
      {
        "name": "unpadded_sizes",
        "numberAttr": "N",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "tpu_tensors",
        "typeListAttr": "T"
      }
    ]
  },
  {
    "name": "TPUEmbeddingActivations",
    "summary": "An op enabling differentiation of TPU Embeddings.",
    "description": "This op simply returns its first input, which is assumed to have been sliced\nfrom the Tensors returned by TPUEmbeddingDequeueActivations. The presence of\nthis op, and its first argument being a trainable Variable, enables automatic\ndifferentiation of graphs containing embeddings via the TPU Embedding Python\nlibraries.",
    "attributes": [
      {
        "name": "table_id",
        "type": "int64",
        "description": "The id of the table in the embedding layer configuration from which\nthese activations were computed.",
        "minimum": 0
      },
      {
        "name": "lookup_id",
        "type": "int64",
        "description": "Identifier of the set of embedding indices which produced these\nactivations.",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "embedding_variable",
        "description": "A trainable variable, enabling optimizers to find this op.",
        "type": 1
      },
      {
        "name": "sliced_activations",
        "description": "The embedding activations Tensor to return.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 1
      }
    ]
  },
  {
    "name": "TPUExecute",
    "summary": "Op that loads and executes a TPU program on a TPU device.",
    "description": "For the internal use of the distributed TPU compiler.",
    "attributes": [
      {
        "name": "Targs",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "Tresults",
        "type": "type[]",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "args",
        "typeListAttr": "Targs"
      },
      {
        "name": "key",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "results",
        "typeListAttr": "Tresults"
      }
    ]
  },
  {
    "name": "TPUExecuteAndUpdateVariables",
    "summary": "Op that executes a program with optional in-place variable updates.",
    "description": "It (optionally) reads device variables, loads and executes a TPU program on a\nTPU device, and then (optionally) in-place updates variables using the program\noutputs, as specified in attributes device_var_reads_indices (program input\nindices from directly reading variables) and device_var_updates_indices (program\noutput indices used to update variables, -1 means no-update/read-only). Such\nprogram outputs are consumed by these variables will not appear in the op\noutput. For the internal use of the distributed TPU compiler.",
    "attributes": [
      {
        "name": "Targs",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "Tresults",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "device_var_reads_indices",
        "type": "int64[]",
        "minimum": 0
      },
      {
        "name": "device_var_updates_indices",
        "type": "int64[]",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "args",
        "typeListAttr": "Targs"
      },
      {
        "name": "key",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "results",
        "typeListAttr": "Tresults"
      }
    ]
  },
  {
    "name": "TPUOrdinalSelector",
    "summary": "A TPU core selector Op.",
    "description": "This Op produces a set of TPU cores (for warm-up) or a single TPU core\n(for regular inference) to execute the TPU program on. The output is\nconsumed by TPUPartitionedCall.",
    "outputs": [
      {
        "name": "device_ordinals",
        "description": "A vector 1 or more TPU cores.",
        "type": 3
      }
    ]
  },
  {
    "name": "TPUPartitionedCall",
    "summary": "Calls a function placed on a specified TPU device.",
    "attributes": [
      {
        "name": "Tin",
        "type": "type[]",
        "description": "The types of the arguments to the function.",
        "minimum": 0
      },
      {
        "name": "Tout",
        "type": "type[]",
        "description": "The types of the outputs of the function.",
        "minimum": 0
      },
      {
        "name": "f",
        "type": "function",
        "description": "The function to call."
      },
      {
        "name": "autotuner_thresh",
        "type": "int64",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "args",
        "description": "The arguments to the function.",
        "typeListAttr": "Tin"
      },
      {
        "name": "device_ordinal",
        "description": "The TPU device ordinal to run the function on.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The output of the function call.",
        "typeListAttr": "Tout"
      }
    ]
  },
  {
    "name": "TPUPartitionedInput",
    "summary": "An op that groups a list of partitioned inputs together. This op",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "partition_dim",
        "type": "int64",
        "description": "An integer describles which dimension is partitioned. -1 means\nthose inputs are replicated.",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "description": "A list of partitioned inputs which must have the same shape.",
        "numberAttr": "N",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A handle which represents the full shape of partitioned tensors.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "TPUPartitionedInputV2",
    "summary": "An op that groups a list of partitioned inputs together. Supports ND sharding.",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "partition_dims",
        "type": "int64[]",
        "description": "A list of integers describing how each dimension is partitioned. Emptiness\nindicates the inputs are replicated."
      },
      {
        "name": "is_packed",
        "type": "boolean",
        "description": "Indicates whether the input is a packed resource.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "description": "A list of partitioned inputs which must have the same shape.",
        "numberAttr": "N",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A handle which represents the full shape of partitioned tensors.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "TPUPartitionedOutput",
    "summary": "An op that demultiplexes a tensor to be sharded by XLA to a list of partitioned",
    "description": "outputs outside the XLA computation.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "num_splits",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "partition_dim",
        "type": "int64",
        "description": "An integer describles which dimension is partitioned.",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "description": "A tensor which represents the full shape of partitioned tensors.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A list of partitioned inputs which must have the same shape.",
        "numberAttr": "num_splits",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "TPUPartitionedOutputV2",
    "summary": "An op that demultiplexes a tensor to be sharded by XLA to a list of partitioned",
    "description": "outputs outside the XLA computation. Supports ND sharding.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "num_splits",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "partition_dims",
        "type": "int64[]",
        "description": "A list of integers describing how each dimension is partitioned. Emptiness\nindicates the inputs are replicated."
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "description": "A tensor which represents the full shape of partitioned tensors.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A list of partitioned outputs which have the same shape.",
        "numberAttr": "num_splits",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "TPUReplicateMetadata",
    "summary": "Metadata indicating how the TPU computation should be replicated.",
    "description": "This operation holds the metadata common to operations of a `tpu.replicate()` computation subgraph.",
    "attributes": [
      {
        "name": "num_replicas",
        "type": "int64",
        "description": "Number of replicas of the computation",
        "minimum": 0
      },
      {
        "name": "num_cores_per_replica",
        "type": "int64",
        "description": "Number of cores per replica. Used for model parallelism.",
        "default": 1
      },
      {
        "name": "topology",
        "type": "string",
        "description": "TopologyProto indicating the topology of the TPU pod slice.",
        "default": ""
      },
      {
        "name": "use_tpu",
        "type": "boolean",
        "description": "Whether to place the computation on the TPU.",
        "default": true
      },
      {
        "name": "device_assignment",
        "type": "int64[]",
        "description": "The assignment of devices for the computation.",
        "default": []
      },
      {
        "name": "computation_shape",
        "type": "int64[]",
        "description": "DEPRECATED. Use num_cores_per_replica instead.",
        "default": []
      },
      {
        "name": "host_compute_core",
        "type": "string[]",
        "default": []
      },
      {
        "name": "padding_map",
        "type": "string[]",
        "default": []
      },
      {
        "name": "step_marker_location",
        "type": "string",
        "default": "STEP_MARK_AT_ENTRY"
      },
      {
        "name": "allow_soft_placement",
        "type": "boolean",
        "default": false
      },
      {
        "name": "use_spmd_for_xla_partitioning",
        "type": "boolean",
        "default": false
      },
      {
        "name": "tpu_compile_options_proto",
        "type": "string",
        "default": ""
      }
    ]
  },
  {
    "name": "TPUReplicatedInput",
    "summary": "Connects N inputs to an N-way replicated TPU computation.",
    "description": "This operation holds a replicated input to a `tpu.replicate()` computation subgraph.\nEach replicated input has the same shape and type alongside the output.\n\nFor example:\n```\n%a = \"tf.opA\"()\n%b = \"tf.opB\"()\n%replicated_input = \"tf.TPUReplicatedInput\"(%a, %b)\n%computation = \"tf.Computation\"(%replicated_input)\n```\nThe above computation has a replicated input of two replicas.",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "is_mirrored_variable",
        "type": "boolean",
        "default": false
      },
      {
        "name": "index",
        "type": "int64",
        "default": -1
      },
      {
        "name": "is_packed",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "numberAttr": "N",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "TPUReplicatedOutput",
    "summary": "Connects N outputs from an N-way replicated TPU computation.",
    "description": "This operation holds a replicated output from a `tpu.replicate()` computation subgraph.\nEach replicated output has the same shape and type alongside the input.\n\nFor example:\n```\n%computation = \"tf.Computation\"()\n%replicated_output:2 = \"tf.TPUReplicatedOutput\"(%computation)\n```\nThe above computation has a replicated output of two replicas.",
    "attributes": [
      {
        "name": "num_replicas",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "outputs",
        "numberAttr": "num_replicas",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "TPUReshardVariables",
    "summary": "Op that reshards on-device TPU variables to specified state.",
    "description": "Op that reshards on-device TPU variables to specified state. Internal use only.\n\nThe sharding state is represented as the key of the compilation that generated\nthe sharding/unsharding programs along with the main program. new_format_key\nspecifies the desired state, and format_state_var is the current state of the\nvariables.",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "vars",
        "numberAttr": "N",
        "type": 20
      },
      {
        "name": "new_format_key",
        "type": 7
      },
      {
        "name": "format_state_var",
        "type": 20
      }
    ]
  },
  {
    "name": "TPURoundRobin",
    "summary": "Round-robin load balancing on TPU cores.",
    "description": "A load balancing op that round-robins among TPU cores.\n\nThis op round-robins between the integers in [0, NumTPUCoresVisiblePerHost]. It\nis useful for interfacing with TensorFlow ops that take as input a TPU core on\nwhich to execute computations, such as `TPUPartitionedCall`.\n\ndevice_ordinal: An integer in [0, NumTPUCoresVisiblePerHost].",
    "outputs": [
      {
        "name": "device_ordinal",
        "type": 3
      }
    ]
  },
  {
    "name": "TakeDataset",
    "summary": "Creates a dataset that contains `count` elements from the `input_dataset`.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "count",
        "description": "A scalar representing the number of elements from the `input_dataset`\nthat should be taken. A value of `-1` indicates that all of `input_dataset`\nis taken.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "TakeManySparseFromTensorsMap",
    "summary": "Read `SparseTensors` from a `SparseTensorsMap` and concatenate them.",
    "description": "The input `sparse_handles` must be an `int64` matrix of shape `[N, 1]` where\n`N` is the minibatch size and the rows correspond to the output handles of\n`AddSparseToTensorsMap` or `AddManySparseToTensorsMap`.  The ranks of the\noriginal `SparseTensor` objects that went into the given input ops must all\nmatch.  When the final `SparseTensor` is created, it has rank one\nhigher than the ranks of the incoming `SparseTensor` objects\n(they have been concatenated along a new row dimension on the left).\n\nThe output `SparseTensor` object's shape values for all dimensions but the\nfirst are the max across the input `SparseTensor` objects' shape values\nfor the corresponding dimensions.  Its first shape value is `N`, the minibatch\nsize.\n\nThe input `SparseTensor` objects' indices are assumed ordered in\nstandard lexicographic order.  If this is not the case, after this\nstep run `SparseReorder` to restore index ordering.\n\nFor example, if the handles represent an input, which is a `[2, 3]` matrix\nrepresenting two original `SparseTensor` objects:\n\n```\n    index = [ 0]\n            [10]\n            [20]\n    values = [1, 2, 3]\n    shape = [50]\n```\n\nand\n\n```\n    index = [ 2]\n            [10]\n    values = [4, 5]\n    shape = [30]\n```\n\nthen the final `SparseTensor` will be:\n\n```\n    index = [0  0]\n            [0 10]\n            [0 20]\n            [1  2]\n            [1 10]\n    values = [1, 2, 3, 4, 5]\n    shape = [2 50]\n```",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The `dtype` of the `SparseTensor` objects stored in the\n`SparseTensorsMap`."
      },
      {
        "name": "container",
        "type": "string",
        "description": "The container name for the `SparseTensorsMap` read by this op.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "The shared name for the `SparseTensorsMap` read by this op.\nIt should not be blank; rather the `shared_name` or unique Operation name\nof the Op that created the original `SparseTensorsMap` should be used.",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "sparse_handles",
        "description": "1-D, The `N` serialized `SparseTensor` objects.\nShape: `[N]`.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "sparse_indices",
        "description": "2-D.  The `indices` of the minibatch `SparseTensor`.",
        "type": 9
      },
      {
        "name": "sparse_values",
        "description": "1-D.  The `values` of the minibatch `SparseTensor`.",
        "typeAttr": "dtype"
      },
      {
        "name": "sparse_shape",
        "description": "1-D.  The `shape` of the minibatch `SparseTensor`.",
        "type": 9
      }
    ]
  },
  {
    "name": "TakeWhileDataset",
    "summary": "Creates a dataset that stops iteration when predicate` is false.",
    "description": "The `predicate` function must return a scalar boolean and accept the\nfollowing arguments:\n\n* One tensor for each component of an element of `input_dataset`.\n* One tensor for each value in `other_arguments`.",
    "attributes": [
      {
        "name": "predicate",
        "type": "function",
        "description": "A function returning a scalar boolean."
      },
      {
        "name": "Targuments",
        "type": "type[]",
        "minimum": 0
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "other_arguments",
        "description": "A list of tensors, typically values that were captured when\nbuilding a closure for `predicate`.",
        "typeListAttr": "Targuments"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "Tan",
    "summary": "Computes tan of x element-wise.",
    "description": "  Given an input tensor, this function computes tangent of every\n  element in the tensor. Input range is `(-inf, inf)` and\n  output range is `(-inf, inf)`. If input lies outside the boundary, `nan`\n  is returned.\n\n  ```python\n  x = tf.constant([-float(\"inf\"), -9, -0.5, 1, 1.2, 200, 10000, float(\"inf\")])\n  tf.math.tan(x) ==> [nan 0.45231566 -0.5463025 1.5574077 2.572152 -1.7925274 0.32097113 nan]\n  ```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Tanh",
    "summary": "Computes hyperbolic tangent of `x` element-wise.",
    "description": "  Given an input tensor, this function computes hyperbolic tangent of every\n  element in the tensor. Input range is `[-inf, inf]` and\n  output range is `[-1,1]`.\n\n  >>> x = tf.constant([-float(\"inf\"), -5, -0.5, 1, 1.2, 2, 3, float(\"inf\")])\n  >>> tf.math.tanh(x)\n  <tf.Tensor: shape=(8,), dtype=float32, numpy=\n  array([-1.0, -0.99990916, -0.46211717,  0.7615942 ,  0.8336547 ,\n          0.9640276 ,  0.9950547 ,  1.0], dtype=float32)>\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "TanhGrad",
    "summary": "Computes the gradient for the tanh of `x` wrt its input.",
    "description": "Specifically, `grad = dy * (1 - y*y)`, where `y = tanh(x)`, and `dy`\nis the corresponding input gradient.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "y",
        "typeAttr": "T"
      },
      {
        "name": "dy",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "TemporaryVariable",
    "summary": "Returns a tensor that may be mutated, but only persists within a single step.",
    "description": "This is an experimental op for internal use only and it is possible to use this\nop in unsafe ways.  DO NOT USE unless you fully understand the risks.\n\nIt is the caller's responsibility to ensure that 'ref' is eventually passed to a\nmatching 'DestroyTemporaryVariable' op after all other uses have completed.\n\nOutputs a ref to the tensor state so it may be read or modified.\n\n  E.g.\n      var = state_ops._temporary_variable([1, 2], types.float_)\n      var_name = var.op.name\n      var = state_ops.assign(var, [[4.0, 5.0]])\n      var = state_ops.assign_add(var, [[6.0, 7.0]])\n      final = state_ops._destroy_temporary_variable(var, var_name=var_name)",
    "attributes": [
      {
        "name": "shape",
        "type": "shape",
        "description": "The shape of the variable tensor."
      },
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of elements in the variable tensor."
      },
      {
        "name": "var_name",
        "type": "string",
        "description": "Overrides the name used for the temporary variable resource. Default\nvalue is the name of the 'TemporaryVariable' op (which is guaranteed unique).",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "ref",
        "description": "A reference to the variable tensor.",
        "typeAttr": "dtype",
        "isRef": true
      }
    ]
  },
  {
    "name": "TensorArray",
    "attributes": [
      {
        "name": "dtype",
        "type": "type"
      },
      {
        "name": "dynamic_size",
        "type": "boolean",
        "default": false
      },
      {
        "name": "clear_after_read",
        "type": "boolean",
        "default": true
      },
      {
        "name": "tensor_array_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "element_shape",
        "type": "shape",
        "default": {
          "type": "shape",
          "value": "?"
        }
      }
    ],
    "inputs": [
      {
        "name": "size",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "TensorArrayClose",
    "inputs": [
      {
        "name": "handle",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "TensorArrayCloseV2",
    "summary": "Deprecated. Use TensorArrayCloseV3",
    "inputs": [
      {
        "name": "handle",
        "type": 7
      }
    ]
  },
  {
    "name": "TensorArrayCloseV3",
    "summary": "Delete the TensorArray from its resource container.",
    "description": "This enables the user to close and release the resource in the middle\nof a step/run.",
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a TensorArray (output of TensorArray or TensorArrayGrad).",
        "type": 20
      }
    ]
  },
  {
    "name": "TensorArrayConcat",
    "attributes": [
      {
        "name": "dtype",
        "type": "type"
      },
      {
        "name": "element_shape_except0",
        "type": "shape",
        "default": {
          "type": "shape",
          "value": "?"
        }
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "type": 7,
        "isRef": true
      },
      {
        "name": "flow_in",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "value",
        "typeAttr": "dtype"
      },
      {
        "name": "lengths",
        "type": 9
      }
    ]
  },
  {
    "name": "TensorArrayConcatV2",
    "summary": "Deprecated. Use TensorArrayConcatV3",
    "attributes": [
      {
        "name": "dtype",
        "type": "type"
      },
      {
        "name": "element_shape_except0",
        "type": "shape",
        "default": {
          "type": "shape",
          "value": "?"
        }
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "type": 7
      },
      {
        "name": "flow_in",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "value",
        "typeAttr": "dtype"
      },
      {
        "name": "lengths",
        "type": 9
      }
    ]
  },
  {
    "name": "TensorArrayConcatV3",
    "summary": "Concat the elements from the TensorArray into value `value`.",
    "description": "Takes `T` elements of shapes\n\n  ```\n  (n0 x d0 x d1 x ...), (n1 x d0 x d1 x ...), ..., (n(T-1) x d0 x d1 x ...)\n  ```\n\nand concatenates them into a Tensor of shape:\n\n  ```\n  (n0 + n1 + ... + n(T-1) x d0 x d1 x ...)\n  ```\n\nAll elements must have the same shape (excepting the first dimension).",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the elem that is returned."
      },
      {
        "name": "element_shape_except0",
        "type": "shape",
        "description": "The expected shape of an element, if known,\nexcluding the first dimension. Used to validate the shapes of\nTensorArray elements. If this shape is not fully specified, concatenating\nzero-size TensorArrays is an error.",
        "default": {
          "type": "shape",
          "value": "?"
        }
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a TensorArray.",
        "type": 20
      },
      {
        "name": "flow_in",
        "description": "A float scalar that enforces proper chaining of operations.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "value",
        "description": "All of the elements in the TensorArray, concatenated along the first\naxis.",
        "typeAttr": "dtype"
      },
      {
        "name": "lengths",
        "description": "A vector of the row sizes of the original T elements in the\nvalue output.  In the example above, this would be the values:\n`(n1, n2, ..., n(T-1))`.",
        "type": 9
      }
    ]
  },
  {
    "name": "TensorArrayGather",
    "attributes": [
      {
        "name": "dtype",
        "type": "type"
      },
      {
        "name": "element_shape",
        "type": "shape",
        "default": {
          "type": "shape",
          "value": "?"
        }
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "type": 7,
        "isRef": true
      },
      {
        "name": "indices",
        "type": 3
      },
      {
        "name": "flow_in",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "value",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "TensorArrayGatherV2",
    "summary": "Deprecated. Use TensorArrayGatherV3",
    "attributes": [
      {
        "name": "dtype",
        "type": "type"
      },
      {
        "name": "element_shape",
        "type": "shape",
        "default": {
          "type": "shape",
          "value": "?"
        }
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "type": 7
      },
      {
        "name": "indices",
        "type": 3
      },
      {
        "name": "flow_in",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "value",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "TensorArrayGatherV3",
    "summary": "Gather specific elements from the TensorArray into output `value`.",
    "description": "All elements selected by `indices` must have the same shape.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the elem that is returned."
      },
      {
        "name": "element_shape",
        "type": "shape",
        "description": "The expected shape of an element, if known. Used to\nvalidate the shapes of TensorArray elements. If this shape is not\nfully specified, gathering zero-size TensorArrays is an error.",
        "default": {
          "type": "shape",
          "value": "?"
        }
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a TensorArray.",
        "type": 20
      },
      {
        "name": "indices",
        "description": "The locations in the TensorArray from which to read tensor elements.",
        "type": 3
      },
      {
        "name": "flow_in",
        "description": "A float scalar that enforces proper chaining of operations.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "value",
        "description": "All of the elements in the TensorArray, concatenated along a new\naxis (the new dimension 0).",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "TensorArrayGrad",
    "attributes": [
      {
        "name": "source",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "type": 7
      },
      {
        "name": "flow_in",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "grad_handle",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "TensorArrayGradV2",
    "summary": "Deprecated. Use TensorArrayGradV3",
    "attributes": [
      {
        "name": "source",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "type": 7
      },
      {
        "name": "flow_in",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "grad_handle",
        "type": 7
      }
    ]
  },
  {
    "name": "TensorArrayGradV3",
    "summary": "Creates a TensorArray for storing the gradients of values in the given handle.",
    "description": "If the given TensorArray gradient already exists, returns a reference to it.\n\nLocks the size of the original TensorArray by disabling its dynamic size flag.\n\n**A note about the input flow_in:**\n\nThe handle flow_in forces the execution of the gradient lookup to occur\nonly after certain other operations have occurred.  For example, when\nthe forward TensorArray is dynamically sized, writes to this TensorArray\nmay resize the object.  The gradient TensorArray is statically sized based\non the size of the forward TensorArray when this operation executes.\nFurthermore, the size of the forward TensorArray is frozen by this call.\nAs a result, the flow is used to ensure that the call to generate the gradient\nTensorArray only happens after all writes are executed.\n\nIn the case of dynamically sized TensorArrays, gradient computation should\nonly be performed on read operations that have themselves been chained via\nflow to occur only after all writes have executed. That way the final size\nof the forward TensorArray is known when this operation is called.\n\n**A note about the source attribute:**\n\nTensorArray gradient calls use an accumulator TensorArray object.  If\nmultiple gradients are calculated and run in the same session, the multiple\ngradient nodes may accidentally flow through the same accumulator TensorArray.\nThis double counts and generally breaks the TensorArray gradient flow.\n\nThe solution is to identify which gradient call this particular\nTensorArray gradient is being called in.  This is performed by identifying\na unique string (e.g. \"gradients\", \"gradients_1\", ...) from the input\ngradient Tensor's name.  This string is used as a suffix when creating\nthe TensorArray gradient object here (the attribute `source`).\n\nThe attribute `source` is added as a suffix to the forward TensorArray's\nname when performing the creation / lookup, so that each separate gradient\ncalculation gets its own TensorArray accumulator.",
    "attributes": [
      {
        "name": "source",
        "type": "string",
        "description": "The gradient source string, used to decide which gradient TensorArray\nto return."
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to the forward TensorArray.",
        "type": 20
      },
      {
        "name": "flow_in",
        "description": "A float scalar that enforces proper chaining of operations.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "grad_handle",
        "type": 20
      },
      {
        "name": "flow_out",
        "type": 1
      }
    ]
  },
  {
    "name": "TensorArrayGradWithShape",
    "summary": "Creates a TensorArray for storing multiple gradients of values in the given handle.",
    "description": "Similar to TensorArrayGradV3. However it creates an accumulator with an\nexpanded shape compared to the input TensorArray whose gradient is being\ncomputed. This enables multiple gradients for the same TensorArray to be\ncalculated using the same accumulator.",
    "attributes": [
      {
        "name": "source",
        "type": "string",
        "description": "The gradient source string, used to decide which gradient TensorArray\nto return."
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to the forward TensorArray.",
        "type": 20
      },
      {
        "name": "flow_in",
        "description": "A float scalar that enforces proper chaining of operations.",
        "type": 1
      },
      {
        "name": "shape_to_prepend",
        "description": "An int32 vector representing a shape. Elements in the gradient accumulator will\nhave shape which is this shape_to_prepend value concatenated with shape of the\nelements in the TensorArray corresponding to the input handle.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "grad_handle",
        "type": 20
      },
      {
        "name": "flow_out",
        "type": 1
      }
    ]
  },
  {
    "name": "TensorArrayPack",
    "attributes": [
      {
        "name": "dtype",
        "type": "type"
      },
      {
        "name": "element_shape",
        "type": "shape",
        "default": {
          "type": "shape",
          "value": "?"
        }
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "type": 7,
        "isRef": true
      },
      {
        "name": "flow_in",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "value",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "TensorArrayRead",
    "attributes": [
      {
        "name": "dtype",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "type": 7,
        "isRef": true
      },
      {
        "name": "index",
        "type": 3
      },
      {
        "name": "flow_in",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "value",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "TensorArrayReadV2",
    "summary": "Deprecated. Use TensorArrayReadV3",
    "attributes": [
      {
        "name": "dtype",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "type": 7
      },
      {
        "name": "index",
        "type": 3
      },
      {
        "name": "flow_in",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "value",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "TensorArrayReadV3",
    "summary": "Read an element from the TensorArray into output `value`.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the elem that is returned."
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a TensorArray.",
        "type": 20
      },
      {
        "name": "index",
        "type": 3
      },
      {
        "name": "flow_in",
        "description": "A float scalar that enforces proper chaining of operations.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "value",
        "description": "The tensor that is read from the TensorArray.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "TensorArrayScatter",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "type": 7,
        "isRef": true
      },
      {
        "name": "indices",
        "type": 3
      },
      {
        "name": "value",
        "typeAttr": "T"
      },
      {
        "name": "flow_in",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "flow_out",
        "type": 1
      }
    ]
  },
  {
    "name": "TensorArrayScatterV2",
    "summary": "Deprecated. Use TensorArrayScatterV3",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "type": 7
      },
      {
        "name": "indices",
        "type": 3
      },
      {
        "name": "value",
        "typeAttr": "T"
      },
      {
        "name": "flow_in",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "flow_out",
        "type": 1
      }
    ]
  },
  {
    "name": "TensorArrayScatterV3",
    "summary": "Scatter the data from the input value into specific TensorArray elements.",
    "description": "`indices` must be a vector, its length must match the first dim of `value`.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a TensorArray.",
        "type": 20
      },
      {
        "name": "indices",
        "description": "The locations at which to write the tensor elements.",
        "type": 3
      },
      {
        "name": "value",
        "description": "The concatenated tensor to write to the TensorArray.",
        "typeAttr": "T"
      },
      {
        "name": "flow_in",
        "description": "A float scalar that enforces proper chaining of operations.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "flow_out",
        "description": "A float scalar that enforces proper chaining of operations.",
        "type": 1
      }
    ]
  },
  {
    "name": "TensorArraySize",
    "inputs": [
      {
        "name": "handle",
        "type": 7,
        "isRef": true
      },
      {
        "name": "flow_in",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "size",
        "type": 3
      }
    ]
  },
  {
    "name": "TensorArraySizeV2",
    "summary": "Deprecated. Use TensorArraySizeV3",
    "inputs": [
      {
        "name": "handle",
        "type": 7
      },
      {
        "name": "flow_in",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "size",
        "type": 3
      }
    ]
  },
  {
    "name": "TensorArraySizeV3",
    "summary": "Get the current size of the TensorArray.",
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a TensorArray (output of TensorArray or TensorArrayGrad).",
        "type": 20
      },
      {
        "name": "flow_in",
        "description": "A float scalar that enforces proper chaining of operations.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "size",
        "description": "The current size of the TensorArray.",
        "type": 3
      }
    ]
  },
  {
    "name": "TensorArraySplit",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "type": 7,
        "isRef": true
      },
      {
        "name": "value",
        "typeAttr": "T"
      },
      {
        "name": "lengths",
        "type": 9
      },
      {
        "name": "flow_in",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "flow_out",
        "type": 1
      }
    ]
  },
  {
    "name": "TensorArraySplitV2",
    "summary": "Deprecated. Use TensorArraySplitV3",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "type": 7
      },
      {
        "name": "value",
        "typeAttr": "T"
      },
      {
        "name": "lengths",
        "type": 9
      },
      {
        "name": "flow_in",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "flow_out",
        "type": 1
      }
    ]
  },
  {
    "name": "TensorArraySplitV3",
    "summary": "Split the data from the input value into TensorArray elements.",
    "description": "Assuming that `lengths` takes on values\n\n  ```\n  (n0, n1, ..., n(T-1))\n  ```\n\nand that `value` has shape\n\n  ```\n  (n0 + n1 + ... + n(T-1) x d0 x d1 x ...),\n  ```\n\nthis splits values into a TensorArray with T tensors.\n\nTensorArray index t will be the subtensor of values with starting position\n\n  ```\n  (n0 + n1 + ... + n(t-1), 0, 0, ...)\n  ```\n\nand having size\n\n  ```\n  nt x d0 x d1 x ...\n  ```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a TensorArray.",
        "type": 20
      },
      {
        "name": "value",
        "description": "The concatenated tensor to write to the TensorArray.",
        "typeAttr": "T"
      },
      {
        "name": "lengths",
        "description": "The vector of lengths, how to split the rows of value into the\nTensorArray.",
        "type": 9
      },
      {
        "name": "flow_in",
        "description": "A float scalar that enforces proper chaining of operations.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "flow_out",
        "description": "A float scalar that enforces proper chaining of operations.",
        "type": 1
      }
    ]
  },
  {
    "name": "TensorArrayUnpack",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "type": 7,
        "isRef": true
      },
      {
        "name": "value",
        "typeAttr": "T"
      },
      {
        "name": "flow_in",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "flow_out",
        "type": 1
      }
    ]
  },
  {
    "name": "TensorArrayV2",
    "summary": "Deprecated. Use TensorArrayV3",
    "attributes": [
      {
        "name": "dtype",
        "type": "type"
      },
      {
        "name": "element_shape",
        "type": "shape",
        "default": {
          "type": "shape",
          "value": "?"
        }
      },
      {
        "name": "dynamic_size",
        "type": "boolean",
        "default": false
      },
      {
        "name": "clear_after_read",
        "type": "boolean",
        "default": true
      },
      {
        "name": "tensor_array_name",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "size",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 7
      }
    ]
  },
  {
    "name": "TensorArrayV3",
    "summary": "An array of Tensors of given size.",
    "description": "Write data via Write and read via Read or Pack.",
    "attributes": [
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the elements on the tensor_array."
      },
      {
        "name": "element_shape",
        "type": "shape",
        "description": "The expected shape of an element, if known. Used to\nvalidate the shapes of TensorArray elements. If this shape is not\nfully specified, gathering zero-size TensorArrays is an error.",
        "default": {
          "type": "shape",
          "value": "?"
        }
      },
      {
        "name": "dynamic_size",
        "type": "boolean",
        "description": "A boolean that determines whether writes to the TensorArray\nare allowed to grow the size.  By default, this is not allowed.",
        "default": false
      },
      {
        "name": "clear_after_read",
        "type": "boolean",
        "description": "If true (default), Tensors in the TensorArray are cleared\nafter being read.  This disables multiple read semantics but allows early\nrelease of memory.",
        "default": true
      },
      {
        "name": "identical_element_shapes",
        "type": "boolean",
        "description": "If true (default is false), then all\nelements in the TensorArray will be expected to have identical shapes.\nThis allows certain behaviors, like dynamically checking for\nconsistent shapes on write, and being able to fill in properly\nshaped zero tensors on stack -- even if the element_shape attribute\nis not fully defined.",
        "default": false
      },
      {
        "name": "tensor_array_name",
        "type": "string",
        "description": "Overrides the name used for the temporary tensor_array\nresource. Default value is the name of the 'TensorArray' op (which\nis guaranteed unique).",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "size",
        "description": "The size of the array.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "The handle to the TensorArray.",
        "type": 20
      },
      {
        "name": "flow",
        "description": "A scalar used to control gradient flow.",
        "type": 1
      }
    ]
  },
  {
    "name": "TensorArrayWrite",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "type": 7,
        "isRef": true
      },
      {
        "name": "index",
        "type": 3
      },
      {
        "name": "value",
        "typeAttr": "T"
      },
      {
        "name": "flow_in",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "flow_out",
        "type": 1
      }
    ]
  },
  {
    "name": "TensorArrayWriteV2",
    "summary": "Deprecated. Use TensorArrayGradV3",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "type": 7
      },
      {
        "name": "index",
        "type": 3
      },
      {
        "name": "value",
        "typeAttr": "T"
      },
      {
        "name": "flow_in",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "flow_out",
        "type": 1
      }
    ]
  },
  {
    "name": "TensorArrayWriteV3",
    "summary": "Push an element onto the tensor_array.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "handle",
        "description": "The handle to a TensorArray.",
        "type": 20
      },
      {
        "name": "index",
        "description": "The position to write to inside the TensorArray.",
        "type": 3
      },
      {
        "name": "value",
        "description": "The tensor to write to the TensorArray.",
        "typeAttr": "T"
      },
      {
        "name": "flow_in",
        "description": "A float scalar that enforces proper chaining of operations.",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "flow_out",
        "description": "A float scalar that enforces proper chaining of operations.",
        "type": 1
      }
    ]
  },
  {
    "name": "TensorDataset",
    "summary": "Creates a dataset that emits `components` as a tuple of tensors once.",
    "attributes": [
      {
        "name": "Toutput_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "components",
        "typeListAttr": "Toutput_types"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "TensorListConcat",
    "summary": "Concats all tensors in the list along the 0th dimension.",
    "description": "Requires that all tensors have the same shape except the first dimension.\n\ninput_handle: The input list.\ntensor: The concated result.\nlengths: Output tensor containing sizes of the 0th dimension of tensors in the list, used for computing the gradient.\n",
    "attributes": [
      {
        "name": "element_dtype",
        "type": "type"
      },
      {
        "name": "element_shape",
        "type": "shape",
        "default": {
          "type": "shape",
          "value": "?"
        }
      }
    ],
    "inputs": [
      {
        "name": "input_handle",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "tensor",
        "typeAttr": "element_dtype"
      },
      {
        "name": "lengths",
        "type": 9
      }
    ]
  },
  {
    "name": "TensorListConcatLists",
    "attributes": [
      {
        "name": "element_dtype",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input_a",
        "type": 21
      },
      {
        "name": "input_b",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 21
      }
    ]
  },
  {
    "name": "TensorListConcatV2",
    "summary": "Concats all tensors in the list along the 0th dimension.",
    "description": "Requires that all tensors have the same shape except the first dimension.\n\ninput_handle: The input list.\nelement_shape: The shape of the uninitialized elements in the list. If the first\n  dimension is not -1, it is assumed that all list elements have the same\n  leading dim.\nleading_dims: The list of leading dims of uninitialized list elements. Used if\n  the leading dim of input_handle.element_shape or the element_shape input arg\n  is not already set.\ntensor: The concated result.\nlengths: Output tensor containing sizes of the 0th dimension of tensors in the list, used for computing the gradient.\n",
    "attributes": [
      {
        "name": "element_dtype",
        "type": "type"
      },
      {
        "name": "shape_type",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "input_handle",
        "type": 21
      },
      {
        "name": "element_shape",
        "typeAttr": "shape_type"
      },
      {
        "name": "leading_dims",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "tensor",
        "typeAttr": "element_dtype"
      },
      {
        "name": "lengths",
        "type": 9
      }
    ]
  },
  {
    "name": "TensorListElementShape",
    "summary": "The shape of the elements of the given list, as a tensor.",
    "description": "  input_handle: the list\n  element_shape: the shape of elements of the list",
    "attributes": [
      {
        "name": "shape_type",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "input_handle",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "element_shape",
        "typeAttr": "shape_type"
      }
    ]
  },
  {
    "name": "TensorListFromTensor",
    "summary": "Creates a TensorList which, when stacked, has the value of `tensor`.",
    "description": "Each tensor in the result list corresponds to one row of the input tensor.\n\ntensor: The input tensor.\noutput_handle: The list.",
    "attributes": [
      {
        "name": "element_dtype",
        "type": "type"
      },
      {
        "name": "shape_type",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "tensor",
        "typeAttr": "element_dtype"
      },
      {
        "name": "element_shape",
        "typeAttr": "shape_type"
      }
    ],
    "outputs": [
      {
        "name": "output_handle",
        "type": 21
      }
    ]
  },
  {
    "name": "TensorListGather",
    "summary": "Creates a Tensor by indexing into the TensorList.",
    "description": "Each row in the produced Tensor corresponds to the element in the TensorList\nspecified by the given index (see `tf.gather`).\n\ninput_handle: The input tensor list.\nindices: The indices used to index into the list.\nvalues: The tensor.",
    "attributes": [
      {
        "name": "element_dtype",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input_handle",
        "type": 21
      },
      {
        "name": "indices",
        "type": 3
      },
      {
        "name": "element_shape",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "values",
        "typeAttr": "element_dtype"
      }
    ]
  },
  {
    "name": "TensorListGetItem",
    "attributes": [
      {
        "name": "element_dtype",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input_handle",
        "type": 21
      },
      {
        "name": "index",
        "type": 3
      },
      {
        "name": "element_shape",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "item",
        "typeAttr": "element_dtype"
      }
    ]
  },
  {
    "name": "TensorListLength",
    "summary": "Returns the number of tensors in the input tensor list.",
    "description": "input_handle: the input list\nlength: the number of tensors in the list",
    "inputs": [
      {
        "name": "input_handle",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "length",
        "type": 3
      }
    ]
  },
  {
    "name": "TensorListPopBack",
    "summary": "Returns the last element of the input list as well as a list with all but that element.",
    "description": "Fails if the list is empty.\n\ninput_handle: the input list\ntensor: the withdrawn last element of the list\nelement_dtype: the type of elements in the list\nelement_shape: the shape of the output tensor",
    "attributes": [
      {
        "name": "element_dtype",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input_handle",
        "type": 21
      },
      {
        "name": "element_shape",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output_handle",
        "type": 21
      },
      {
        "name": "tensor",
        "typeAttr": "element_dtype"
      }
    ]
  },
  {
    "name": "TensorListPushBack",
    "summary": "Returns a list which has the passed-in `Tensor` as last element and the other elements of the given list in `input_handle`.",
    "description": "tensor: The tensor to put on the list.\ninput_handle: The old list.\noutput_handle: A list with the elements of the old list followed by tensor.\nelement_dtype: the type of elements in the list.\nelement_shape: a shape compatible with that of elements in the list.",
    "attributes": [
      {
        "name": "element_dtype",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input_handle",
        "type": 21
      },
      {
        "name": "tensor",
        "typeAttr": "element_dtype"
      }
    ],
    "outputs": [
      {
        "name": "output_handle",
        "type": 21
      }
    ]
  },
  {
    "name": "TensorListPushBackBatch",
    "attributes": [
      {
        "name": "element_dtype",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input_handles",
        "type": 21
      },
      {
        "name": "tensor",
        "typeAttr": "element_dtype"
      }
    ],
    "outputs": [
      {
        "name": "output_handles",
        "type": 21
      }
    ]
  },
  {
    "name": "TensorListReserve",
    "summary": "List of the given size with empty elements.",
    "description": "element_shape: the shape of the future elements of the list\nnum_elements: the number of elements to reserve\nhandle: the output list\nelement_dtype: the desired type of elements in the list.",
    "attributes": [
      {
        "name": "element_dtype",
        "type": "type"
      },
      {
        "name": "shape_type",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "element_shape",
        "typeAttr": "shape_type"
      },
      {
        "name": "num_elements",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "TensorListResize",
    "summary": "Resizes the list.",
    "description": "\ninput_handle: the input list\nsize: size of the output list\n",
    "inputs": [
      {
        "name": "input_handle",
        "type": 21
      },
      {
        "name": "size",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output_handle",
        "type": 21
      }
    ]
  },
  {
    "name": "TensorListScatter",
    "summary": "Creates a TensorList by indexing into a Tensor.",
    "description": "Each member of the TensorList corresponds to one row of the input tensor,\nspecified by the given index (see `tf.gather`).\n\ntensor: The input tensor.\nindices: The indices used to index into the list.\nelement_shape: The shape of the elements in the list (can be less specified than\n  the shape of the tensor).\noutput_handle: The TensorList.",
    "attributes": [
      {
        "name": "element_dtype",
        "type": "type"
      },
      {
        "name": "shape_type",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "tensor",
        "typeAttr": "element_dtype"
      },
      {
        "name": "indices",
        "type": 3
      },
      {
        "name": "element_shape",
        "typeAttr": "shape_type"
      }
    ],
    "outputs": [
      {
        "name": "output_handle",
        "type": 21
      }
    ]
  },
  {
    "name": "TensorListScatterIntoExistingList",
    "summary": "Scatters tensor at indices in an input list.",
    "description": "Each member of the TensorList corresponds to one row of the input tensor,\nspecified by the given index (see `tf.gather`).\n\ninput_handle: The list to scatter into.\ntensor: The input tensor.\nindices: The indices used to index into the list.\noutput_handle: The TensorList.",
    "attributes": [
      {
        "name": "element_dtype",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input_handle",
        "type": 21
      },
      {
        "name": "tensor",
        "typeAttr": "element_dtype"
      },
      {
        "name": "indices",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output_handle",
        "type": 21
      }
    ]
  },
  {
    "name": "TensorListScatterV2",
    "summary": "Creates a TensorList by indexing into a Tensor.",
    "description": "Each member of the TensorList corresponds to one row of the input tensor,\nspecified by the given index (see `tf.gather`).\n\ntensor: The input tensor.\nindices: The indices used to index into the list.\nelement_shape: The shape of the elements in the list (can be less specified than\n  the shape of the tensor).\nnum_elements: The size of the output list. Must be large enough to accommodate\n  the largest index in indices. If -1, the list is just large enough to include\n  the largest index in indices.\noutput_handle: The TensorList.",
    "attributes": [
      {
        "name": "element_dtype",
        "type": "type"
      },
      {
        "name": "shape_type",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "tensor",
        "typeAttr": "element_dtype"
      },
      {
        "name": "indices",
        "type": 3
      },
      {
        "name": "element_shape",
        "typeAttr": "shape_type"
      },
      {
        "name": "num_elements",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output_handle",
        "type": 21
      }
    ]
  },
  {
    "name": "TensorListSetItem",
    "summary": "Sets the index-th position of the list to contain the given tensor.",
    "description": "input_handle: the list\nindex: the position in the list to which the tensor will be assigned\nitem: the element to be assigned to that position\noutput_handle: the new list, with the element in the proper position\n",
    "attributes": [
      {
        "name": "element_dtype",
        "type": "type"
      },
      {
        "name": "resize_if_index_out_of_bounds",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "input_handle",
        "type": 21
      },
      {
        "name": "index",
        "type": 3
      },
      {
        "name": "item",
        "typeAttr": "element_dtype"
      }
    ],
    "outputs": [
      {
        "name": "output_handle",
        "type": 21
      }
    ]
  },
  {
    "name": "TensorListSplit",
    "summary": "Splits a tensor into a list.",
    "description": "list[i] corresponds to lengths[i] tensors from the input tensor.\nThe tensor must have rank at least 1 and contain exactly sum(lengths) elements.\n\ntensor: The input tensor.\nelement_shape: A shape compatible with that of elements in the tensor.\nlengths: Vector of sizes of the 0th dimension of tensors in the list.\noutput_handle: The list.",
    "attributes": [
      {
        "name": "element_dtype",
        "type": "type"
      },
      {
        "name": "shape_type",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "tensor",
        "typeAttr": "element_dtype"
      },
      {
        "name": "element_shape",
        "typeAttr": "shape_type"
      },
      {
        "name": "lengths",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "output_handle",
        "type": 21
      }
    ]
  },
  {
    "name": "TensorListStack",
    "summary": "Stacks all tensors in the list.",
    "description": "Requires that all tensors have the same shape.\n\ninput_handle: the input list\ntensor: the gathered result\nnum_elements: optional. If not -1, the number of elements in the list.\n",
    "attributes": [
      {
        "name": "element_dtype",
        "type": "type"
      },
      {
        "name": "num_elements",
        "type": "int64",
        "default": -1
      }
    ],
    "inputs": [
      {
        "name": "input_handle",
        "type": 21
      },
      {
        "name": "element_shape",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "tensor",
        "typeAttr": "element_dtype"
      }
    ]
  },
  {
    "name": "TensorMapErase",
    "summary": "Returns a tensor map with item from given key erased.",
    "description": "input_handle: the original map\noutput_handle: the map with value from given key removed\nkey: the key of the value to be erased",
    "attributes": [
      {
        "name": "key_dtype",
        "type": "type"
      },
      {
        "name": "value_dtype",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input_handle",
        "type": 21
      },
      {
        "name": "key",
        "typeAttr": "key_dtype"
      }
    ],
    "outputs": [
      {
        "name": "output_handle",
        "type": 21
      }
    ]
  },
  {
    "name": "TensorMapHasKey",
    "summary": "Returns whether the given key exists in the map.",
    "description": "input_handle: the input map\nkey: the key to check\nhas_key: whether the key is already in the map or not",
    "attributes": [
      {
        "name": "key_dtype",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input_handle",
        "type": 21
      },
      {
        "name": "key",
        "typeAttr": "key_dtype"
      }
    ],
    "outputs": [
      {
        "name": "has_key",
        "type": 10
      }
    ]
  },
  {
    "name": "TensorMapInsert",
    "summary": "Returns a map that is the 'input_handle' with the given key-value pair inserted.",
    "description": "input_handle: the original map\noutput_handle: the map with key and value inserted\nkey: the key to be inserted\nvalue: the value to be inserted",
    "attributes": [
      {
        "name": "key_dtype",
        "type": "type"
      },
      {
        "name": "value_dtype",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input_handle",
        "type": 21
      },
      {
        "name": "key",
        "typeAttr": "key_dtype"
      },
      {
        "name": "value",
        "typeAttr": "value_dtype"
      }
    ],
    "outputs": [
      {
        "name": "output_handle",
        "type": 21
      }
    ]
  },
  {
    "name": "TensorMapLookup",
    "summary": "Returns the value from a given key in a tensor map.",
    "description": "input_handle: the input map\nkey: the key to be looked up\nvalue: the value found from the given key",
    "attributes": [
      {
        "name": "key_dtype",
        "type": "type"
      },
      {
        "name": "value_dtype",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input_handle",
        "type": 21
      },
      {
        "name": "key",
        "typeAttr": "key_dtype"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "typeAttr": "value_dtype"
      }
    ]
  },
  {
    "name": "TensorMapSize",
    "summary": "Returns the number of tensors in the input tensor map.",
    "description": "input_handle: the input map\nsize: the number of tensors in the map",
    "inputs": [
      {
        "name": "input_handle",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "size",
        "type": 3
      }
    ]
  },
  {
    "name": "TensorMapStackKeys",
    "summary": "Returns a Tensor stack of all keys in a tensor map.",
    "description": "input_handle: the input map\nkeys: the returned Tensor of all keys in the map",
    "attributes": [
      {
        "name": "key_dtype",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input_handle",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "keys",
        "typeAttr": "key_dtype"
      }
    ]
  },
  {
    "name": "TensorScatterAdd",
    "summary": "Adds sparse `updates` to an existing tensor according to `indices`.",
    "description": "This operation creates a new tensor by adding sparse `updates` to the passed\nin `tensor`.\nThis operation is very similar to `tf.compat.v1.scatter_nd_add`, except that the\nupdates are added onto an existing tensor (as opposed to a variable). If the\nmemory for the existing tensor cannot be re-used, a copy is made and updated.\n\n`indices` is an integer tensor containing indices into a new tensor of shape\n`tensor.shape`.  The last dimension of `indices` can be at most the rank of\n`tensor.shape`:\n\n```\nindices.shape[-1] <= tensor.shape.rank\n```\n\nThe last dimension of `indices` corresponds to indices into elements\n(if `indices.shape[-1] = tensor.shape.rank`) or slices\n(if `indices.shape[-1] < tensor.shape.rank`) along dimension\n`indices.shape[-1]` of `tensor.shape`.  `updates` is a tensor with shape\n\n```\nindices.shape[:-1] + tensor.shape[indices.shape[-1]:]\n```\n\nThe simplest form of `tensor_scatter_nd_add` is to add individual elements to a\ntensor by index. For example, say we want to add 4 elements in a rank-1\ntensor with 8 elements.\n\nIn Python, this scatter add operation would look like this:\n\n>>> indices = tf.constant([[4], [3], [1], [7]])\n>>> updates = tf.constant([9, 10, 11, 12])\n>>> tensor = tf.ones([8], dtype=tf.int32)\n>>> updated = tf.tensor_scatter_nd_add(tensor, indices, updates)\n>>> updated\n<tf.Tensor: shape=(8,), dtype=int32,\nnumpy=array([ 1, 12,  1, 11, 10,  1,  1, 13], dtype=int32)>\n\nWe can also, insert entire slices of a higher rank tensor all at once. For\nexample, if we wanted to insert two slices in the first dimension of a\nrank-3 tensor with two matrices of new values.\n\nIn Python, this scatter add operation would look like this:\n\n>>> indices = tf.constant([[0], [2]])\n>>> updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6],\n...                         [7, 7, 7, 7], [8, 8, 8, 8]],\n...                        [[5, 5, 5, 5], [6, 6, 6, 6],\n...                         [7, 7, 7, 7], [8, 8, 8, 8]]])\n>>> tensor = tf.ones([4, 4, 4],dtype=tf.int32)\n>>> updated = tf.tensor_scatter_nd_add(tensor, indices, updates)\n>>> updated\n<tf.Tensor: shape=(4, 4, 4), dtype=int32,\nnumpy=array([[[6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8], [9, 9, 9, 9]],\n             [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\n             [[6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8], [9, 9, 9, 9]],\n             [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]], dtype=int32)>\n\nNote: on CPU, if an out of bound index is found, an error is returned.\nOn GPU, if an out of bound index is found, the index is ignored.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "tensor",
        "description": "Tensor to copy/update.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "Index tensor.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "Updates to scatter into output.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A new tensor copied from tensor and updates added according to the indices.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "TensorScatterMax",
    "summary": "Apply a sparse update to a tensor taking the element-wise maximum.",
    "description": "Returns a new tensor copied from `tensor` whose values are element-wise maximum between\ntensor and updates according to the indices.\n\n>>> tensor = [0, 0, 0, 0, 0, 0, 0, 0]\n>>> indices = [[1], [4], [5]]\n>>> updates = [1, -1, 1]\n>>> tf.tensor_scatter_nd_max(tensor, indices, updates).numpy()\narray([0, 1, 0, 0, 0, 1, 0, 0], dtype=int32)\n\nRefer to `tf.tensor_scatter_nd_update` for more details.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "tensor",
        "description": "Tensor to update.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "Index tensor.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "Updates to scatter into output.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A new tensor copied from tensor whose values are element-wise maximum between tensor and updates according to the indices.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "TensorScatterMin",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "tensor",
        "description": "Tensor to update.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "Index tensor.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "Updates to scatter into output.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A new tensor copied from tensor whose values are element-wise minimum between tensor and updates according to the indices.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "TensorScatterSub",
    "summary": "Subtracts sparse `updates` from an existing tensor according to `indices`.",
    "description": "This operation creates a new tensor by subtracting sparse `updates` from the\npassed in `tensor`.\nThis operation is very similar to `tf.scatter_nd_sub`, except that the updates\nare subtracted from an existing tensor (as opposed to a variable). If the memory\nfor the existing tensor cannot be re-used, a copy is made and updated.\n\n`indices` is an integer tensor containing indices into a new tensor of shape\n`shape`.  The last dimension of `indices` can be at most the rank of `shape`:\n\n    indices.shape[-1] <= shape.rank\n\nThe last dimension of `indices` corresponds to indices into elements\n(if `indices.shape[-1] = shape.rank`) or slices\n(if `indices.shape[-1] < shape.rank`) along dimension `indices.shape[-1]` of\n`shape`.  `updates` is a tensor with shape\n\n    indices.shape[:-1] + shape[indices.shape[-1]:]\n\nThe simplest form of tensor_scatter_sub is to subtract individual elements\nfrom a tensor by index. For example, say we want to insert 4 scattered elements\nin a rank-1 tensor with 8 elements.\n\nIn Python, this scatter subtract operation would look like this:\n\n```python\n    indices = tf.constant([[4], [3], [1], [7]])\n    updates = tf.constant([9, 10, 11, 12])\n    tensor = tf.ones([8], dtype=tf.int32)\n    updated = tf.tensor_scatter_nd_sub(tensor, indices, updates)\n    print(updated)\n```\n\nThe resulting tensor would look like this:\n\n    [1, -10, 1, -9, -8, 1, 1, -11]\n\nWe can also, insert entire slices of a higher rank tensor all at once. For\nexample, if we wanted to insert two slices in the first dimension of a\nrank-3 tensor with two matrices of new values.\n\nIn Python, this scatter add operation would look like this:\n\n```python\n    indices = tf.constant([[0], [2]])\n    updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6],\n                            [7, 7, 7, 7], [8, 8, 8, 8]],\n                           [[5, 5, 5, 5], [6, 6, 6, 6],\n                            [7, 7, 7, 7], [8, 8, 8, 8]]])\n    tensor = tf.ones([4, 4, 4],dtype=tf.int32)\n    updated = tf.tensor_scatter_nd_sub(tensor, indices, updates)\n    print(updated)\n```\n\nThe resulting tensor would look like this:\n\n    [[[-4, -4, -4, -4], [-5, -5, -5, -5], [-6, -6, -6, -6], [-7, -7, -7, -7]],\n     [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\n     [[-4, -4, -4, -4], [-5, -5, -5, -5], [-6, -6, -6, -6], [-7, -7, -7, -7]],\n     [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]]\n\nNote that on CPU, if an out of bound index is found, an error is returned.\nOn GPU, if an out of bound index is found, the index is ignored.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "tensor",
        "description": "Tensor to copy/update.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "Index tensor.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "Updates to scatter into output.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A new tensor copied from tensor and updates subtracted according to the indices.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "TensorScatterUpdate",
    "summary": "Scatter `updates` into an existing tensor according to `indices`.",
    "description": "This operation creates a new tensor by applying sparse `updates` to the passed\nin `tensor`.\nThis operation is very similar to `tf.scatter_nd`, except that the updates are\nscattered onto an existing tensor (as opposed to a zero-tensor). If the memory\nfor the existing tensor cannot be re-used, a copy is made and updated.\n\nIf `indices` contains duplicates, then we pick the last update for the index.\n\nIf an out of bound index is found on CPU, an error is returned.\n\n**WARNING**: There are some GPU specific semantics for this operation.\n- If an out of bound index is found, the index is ignored.\n- The order in which updates are applied is nondeterministic, so the output\nwill be nondeterministic if `indices` contains duplicates.\n\n`indices` is an integer tensor containing indices into a new tensor of shape\n`shape`.\n\n* `indices` must have at least 2 axes: `(num_updates, index_depth)`.\n* The last axis of `indices` is how deep to index into `tensor` so  this index\n  depth must be less than the rank of `tensor`: `indices.shape[-1] <= tensor.ndim`\n\nif `indices.shape[-1] = tensor.rank` this Op indexes and updates scalar elements.\nif `indices.shape[-1] < tensor.rank` it indexes and updates slices of the input\n`tensor`.\n\nEach `update` has a rank of `tensor.rank - indices.shape[-1]`.\nThe overall shape of `updates` is:\n\n```\nindices.shape[:-1] + tensor.shape[indices.shape[-1]:]\n```\n\nFor usage examples see the python [tf.tensor_scatter_nd_update](\nhttps://www.tensorflow.org/api_docs/python/tf/tensor_scatter_nd_update) function\n",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int16`, `int32`, `int64`, `uint16`."
      }
    ],
    "inputs": [
      {
        "name": "tensor",
        "description": "Tensor to copy/update.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "Index tensor.",
        "typeAttr": "Tindices"
      },
      {
        "name": "updates",
        "description": "Updates to scatter into output.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A new tensor with the given shape and updates applied according\nto the indices.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "TensorSliceDataset",
    "summary": "Creates a dataset that emits each dim-0 slice of `components` once.",
    "attributes": [
      {
        "name": "Toutput_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "is_files",
        "type": "boolean",
        "default": false
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      },
      {
        "name": "replicate_on_split",
        "type": "boolean",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "components",
        "typeListAttr": "Toutput_types"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "TensorStridedSliceUpdate",
    "summary": "Assign `value` to the sliced l-value reference of `input`.",
    "description": "The values of `value` are assigned to the positions in the tensor `input` that\nare selected by the slice parameters. The slice parameters `begin` `end`\n`strides` etc. work exactly as in `StridedSlice`.\n\nNOTE this op currently does not support broadcasting and so `value`'s shape\nmust be exactly the shape produced by the slice of `input`.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Index",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "begin_mask",
        "type": "int64",
        "default": 0
      },
      {
        "name": "end_mask",
        "type": "int64",
        "default": 0
      },
      {
        "name": "ellipsis_mask",
        "type": "int64",
        "default": 0
      },
      {
        "name": "new_axis_mask",
        "type": "int64",
        "default": 0
      },
      {
        "name": "shrink_axis_mask",
        "type": "int64",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "begin",
        "typeAttr": "Index"
      },
      {
        "name": "end",
        "typeAttr": "Index"
      },
      {
        "name": "strides",
        "typeAttr": "Index"
      },
      {
        "name": "value",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "TensorSummary",
    "summary": "Outputs a `Summary` protocol buffer with a tensor.",
    "description": "This op is being phased out in favor of TensorSummaryV2, which lets callers pass\na tag as well as a serialized SummaryMetadata proto string that contains\nplugin-specific data. We will keep this op to maintain backwards compatibility.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "description",
        "type": "string",
        "description": "A json-encoded SummaryDescription proto.",
        "default": ""
      },
      {
        "name": "labels",
        "type": "string[]",
        "description": "An unused list of strings.",
        "default": []
      },
      {
        "name": "display_name",
        "type": "string",
        "description": "An unused string.",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "tensor",
        "description": "A tensor to serialize.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "summary",
        "type": 7
      }
    ]
  },
  {
    "name": "TensorSummaryV2",
    "summary": "Outputs a `Summary` protocol buffer with a tensor and per-plugin data.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "tag",
        "description": "A string attached to this summary. Used for organization in TensorBoard.",
        "type": 7
      },
      {
        "name": "tensor",
        "description": "A tensor to serialize.",
        "typeAttr": "T"
      },
      {
        "name": "serialized_summary_metadata",
        "description": "A serialized SummaryMetadata proto. Contains plugin\ndata.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "summary",
        "type": 7
      }
    ]
  },
  {
    "name": "TextLineDataset",
    "summary": "Creates a dataset that emits the lines of one or more text files.",
    "attributes": [
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "filenames",
        "description": "A scalar or a vector containing the name(s) of the file(s) to be\nread.",
        "type": 7
      },
      {
        "name": "compression_type",
        "description": "A scalar containing either (i) the empty string (no\ncompression), (ii) \"ZLIB\", or (iii) \"GZIP\".",
        "type": 7
      },
      {
        "name": "buffer_size",
        "description": "A scalar containing the number of bytes to buffer.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "TextLineReader",
    "summary": "A Reader that outputs the lines of a file delimited by '\\n'.",
    "attributes": [
      {
        "name": "skip_header_lines",
        "type": "int64",
        "description": "Number of lines to skip from the beginning of every file.",
        "default": 0
      },
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "reader_handle",
        "description": "The handle to reference the Reader.",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "TextLineReaderV2",
    "summary": "A Reader that outputs the lines of a file delimited by '\\n'.",
    "attributes": [
      {
        "name": "skip_header_lines",
        "type": "int64",
        "description": "Number of lines to skip from the beginning of every file.",
        "default": 0
      },
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "reader_handle",
        "description": "The handle to reference the Reader.",
        "type": 20
      }
    ]
  },
  {
    "name": "ThreadPoolDataset",
    "summary": "Creates a dataset that uses a custom thread pool to compute `input_dataset`.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "thread_pool",
        "description": "A resource produced by the ThreadPoolHandle op.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "ThreadPoolHandle",
    "summary": "Creates a dataset that uses a custom thread pool to compute `input_dataset`.",
    "attributes": [
      {
        "name": "num_threads",
        "type": "int64",
        "description": "The number of threads in the thread pool."
      },
      {
        "name": "max_intra_op_parallelism",
        "type": "int64",
        "description": "The maximum degree of parallelism to use within operations that execute on this\nthreadpool.",
        "default": 1
      },
      {
        "name": "display_name",
        "type": "string",
        "description": "A human-readable name for the threads that may be visible in some\nvisualizations.\nthreadpool."
      },
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "description": "A resource that can be consumed by one or more ExperimentalThreadPoolDataset\nops.",
        "type": 20
      }
    ]
  },
  {
    "name": "ThreadUnsafeUnigramCandidateSampler",
    "summary": "Generates labels for candidate sampling with a learned unigram distribution.",
    "description": "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels.",
    "attributes": [
      {
        "name": "num_true",
        "type": "int64",
        "description": "Number of true labels per context.",
        "minimum": 1
      },
      {
        "name": "num_sampled",
        "type": "int64",
        "description": "Number of candidates to randomly sample.",
        "minimum": 1
      },
      {
        "name": "unique",
        "type": "boolean",
        "description": "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities."
      },
      {
        "name": "range_max",
        "type": "int64",
        "description": "The sampler will sample integers from the interval [0, range_max).",
        "minimum": 1
      },
      {
        "name": "seed",
        "type": "int64",
        "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "description": "An second seed to avoid seed collision.",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "true_classes",
        "description": "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "sampled_candidates",
        "description": "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate.",
        "type": 9
      },
      {
        "name": "true_expected_count",
        "description": "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability.",
        "type": 1
      },
      {
        "name": "sampled_expected_count",
        "description": "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability.",
        "type": 1
      }
    ]
  },
  {
    "name": "Tile",
    "summary": "Constructs a tensor by tiling a given tensor.",
    "description": "This operation creates a new tensor by replicating `input` `multiples` times.\nThe output tensor's i'th dimension has `input.dims(i) * multiples[i]` elements,\nand the values of `input` are replicated `multiples[i]` times along the 'i'th\ndimension. For example, tiling `[a b c d]` by `[2]` produces\n`[a b c d a b c d]`.\n\n>>> a = tf.constant([[1,2,3],[4,5,6]], tf.int32)\n>>> b = tf.constant([1,2], tf.int32)\n>>> tf.tile(a, b)\n<tf.Tensor: shape=(2, 6), dtype=int32, numpy=\narray([[1, 2, 3, 1, 2, 3],\n       [4, 5, 6, 4, 5, 6]], dtype=int32)>\n>>> c = tf.constant([2,1], tf.int32)\n>>> tf.tile(a, c)\n<tf.Tensor: shape=(4, 3), dtype=int32, numpy=\narray([[1, 2, 3],\n       [4, 5, 6],\n       [1, 2, 3],\n       [4, 5, 6]], dtype=int32)>\n>>> d = tf.constant([2,2], tf.int32)\n>>> tf.tile(a, d)\n<tf.Tensor: shape=(4, 6), dtype=int32, numpy=\narray([[1, 2, 3, 1, 2, 3],\n       [4, 5, 6, 4, 5, 6],\n       [1, 2, 3, 1, 2, 3],\n       [4, 5, 6, 4, 5, 6]], dtype=int32)>",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tmultiples",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Can be of any rank.",
        "typeAttr": "T"
      },
      {
        "name": "multiples",
        "description": "1-D. Length must be the same as the number of dimensions in `input`",
        "typeAttr": "Tmultiples"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "TileGrad",
    "summary": "Returns the gradient of `Tile`.",
    "description": "Since `Tile` takes an input and repeats the input `multiples` times\nalong each dimension, `TileGrad` takes in `multiples` and aggregates\neach repeated tile of `input` into `output`.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      },
      {
        "name": "multiples",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Timestamp",
    "summary": "Provides the time since epoch in seconds.",
    "description": "Returns the timestamp as a `float64` for seconds since the Unix epoch.\n\nCommon usages include:\n* Logging\n* Providing a random number seed\n* Debugging graph execution\n* Generating timing information, mainly through comparison of timestamps\n\nNote: In graph mode, the timestamp is computed when the op is executed,\nnot when it is added to the graph.  In eager mode, the timestamp is computed\nwhen the op is eagerly executed.",
    "outputs": [
      {
        "name": "ts",
        "type": 2
      }
    ]
  },
  {
    "name": "ToBool",
    "summary": "Converts a tensor to a scalar predicate.",
    "description": "Converts a tensor to a scalar predicate with the following rules:\n\n- For 0D tensors, truthiness is determined by comparing against a \"zero\"\n  value. For numerical types it is the obvious zero. For strings it is the\n  empty string.\n\n- For >0D tensors, truthiness is determined by looking at the number of\n  elements. If has zero elements, then the result is false. Otherwise the\n  result is true.\n\nThis matches the behavior of If and While for determining if a tensor counts\nas true/false for a branch condition.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 10
      }
    ]
  },
  {
    "name": "TopK",
    "summary": "Finds values and indices of the `k` largest elements for the last dimension.",
    "description": "If the input is a vector (rank-1), finds the `k` largest entries in the vector\nand outputs their values and indices as vectors.  Thus `values[j]` is the\n`j`-th largest entry in `input`, and its index is `indices[j]`.\n\nFor matrices (resp. higher rank input), computes the top `k` entries in each\nrow (resp. vector along the last dimension).  Thus,\n\n    values.shape = indices.shape = input.shape[:-1] + [k]\n\nIf two elements are equal, the lower-index element appears first.\n\nIf `k` varies dynamically, use `TopKV2` below.",
    "attributes": [
      {
        "name": "k",
        "type": "int64",
        "description": "Number of top elements to look for along the last dimension (along each\nrow for matrices).",
        "minimum": 0
      },
      {
        "name": "sorted",
        "type": "boolean",
        "description": "If true the resulting `k` elements will be sorted by the values in\ndescending order.",
        "default": true
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "1-D or higher with last dimension at least `k`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "values",
        "description": "The `k` largest elements along each last dimensional slice.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "The indices of `values` within the last dimension of `input`.",
        "type": 3
      }
    ]
  },
  {
    "name": "TopKUnique",
    "summary": "Returns the TopK unique values in the array in sorted order.",
    "description": "The running time is proportional to the product of K and the input\nsize. Sorting the whole array is more efficient for sufficiently large\nvalues of K. The median-of-medians algorithm is probably faster, but\ndifficult to implement efficiently in XLA. If there are fewer than K\nunique numbers (not NANs), the results are padded with negative\ninfinity. NaNs are never returned. Subnormal numbers are flushed to\nzero. If an element appears at multiple indices, the highest index is\nreturned. If a TopK element never appears in the input due to padding\nvalues, the indices are padded with negative one. If a padding value\nappears in the input and padding is needed, the highest index of the\npadding value will be returned. The semantics are not the same as\nkth_order_statistic.",
    "attributes": [
      {
        "name": "k",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "topk",
        "type": 1
      },
      {
        "name": "topk_indices",
        "type": 3
      }
    ]
  },
  {
    "name": "TopKV2",
    "summary": "Finds values and indices of the `k` largest elements for the last dimension.",
    "description": "If the input is a vector (rank-1), finds the `k` largest entries in the vector\nand outputs their values and indices as vectors.  Thus `values[j]` is the\n`j`-th largest entry in `input`, and its index is `indices[j]`.\n\nFor matrices (resp. higher rank input), computes the top `k` entries in each\nrow (resp. vector along the last dimension).  Thus,\n\n    values.shape = indices.shape = input.shape[:-1] + [k]\n\nIf two elements are equal, the lower-index element appears first.",
    "attributes": [
      {
        "name": "sorted",
        "type": "boolean",
        "description": "If true the resulting `k` elements will be sorted by the values in\ndescending order.",
        "default": true
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tk",
        "type": "type",
        "description": "Must be one of the following: `int16`, `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      },
      {
        "name": "index_type",
        "type": "type",
        "description": "Must be one of the following: `int16`, `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "1-D or higher with last dimension at least `k`.",
        "typeAttr": "T"
      },
      {
        "name": "k",
        "description": "0-D.  Number of top elements to look for along the last dimension (along each\nrow for matrices).",
        "typeAttr": "Tk"
      }
    ],
    "outputs": [
      {
        "name": "values",
        "description": "The `k` largest elements along each last dimensional slice.",
        "typeAttr": "T"
      },
      {
        "name": "indices",
        "description": "The indices of `values` within the last dimension of `input`.",
        "typeAttr": "index_type"
      }
    ]
  },
  {
    "name": "TopKWithUnique",
    "summary": "Returns the TopK values in the array in sorted order.",
    "description": "This is a combination of MakeUnique and TopKUnique. The returned top-K will\nhave its lower bits replaced by iota, thus it will be close to the original\nvalue but not exactly the same. The running time is proportional to the product\nof K and the input size. NaNs are never returned. Subnormal numbers are flushed\nto zero.",
    "attributes": [
      {
        "name": "k",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "topk",
        "type": 1
      },
      {
        "name": "topk_indices",
        "type": 3
      }
    ]
  },
  {
    "name": "TpuHandleToProtoKey",
    "summary": "Converts XRT's uid handles to TensorFlow-friendly input format.",
    "description": "Converts a uid handle for a compiled program into a vector of proto keys.\n\nXRT compile ops return uids, and the TensorFlow execute op takes a proto\nkey. This op enables a client to compile on TPU using XRT and execute using the\nstandard TensorFlow execute op.\n\n'uid' is the input handle.\n'proto_keys' is a vector of proto keys, one for each core program.",
    "inputs": [
      {
        "name": "uid",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "proto_keys",
        "type": 7
      }
    ]
  },
  {
    "name": "Transpose",
    "summary": "Shuffle dimensions of x according to a permutation.",
    "description": "The output `y` has the same rank as `x`. The shapes of `x` and `y` satisfy:\n  `y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]`",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Tperm",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "perm",
        "typeAttr": "Tperm"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "TridiagonalMatMul",
    "summary": "Calculate product with tridiagonal matrix.",
    "description": "Calculates product of two matrices, where left matrix is a tridiagonal matrix.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float64`, `float32`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "superdiag",
        "description": "Tensor of shape `[..., 1, M]`, representing superdiagonals of\ntri-diagonal matrices to the left of multiplication. Last element is ignored.",
        "typeAttr": "T"
      },
      {
        "name": "maindiag",
        "description": "Tensor of shape `[..., 1, M]`, representing main diagonals of tri-diagonal\nmatrices to the left of multiplication.",
        "typeAttr": "T"
      },
      {
        "name": "subdiag",
        "description": "Tensor of shape `[..., 1, M]`, representing subdiagonals of tri-diagonal\nmatrices to the left of multiplication. First element is ignored.",
        "typeAttr": "T"
      },
      {
        "name": "rhs",
        "description": "Tensor of shape `[..., M, N]`, representing MxN matrices to the right of\nmultiplication.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Tensor of shape `[..., M, N]` containing the product.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "TridiagonalSolve",
    "summary": "Solves tridiagonal systems of equations.",
    "description": "  Solves tridiagonal systems of equations.\n  Supports batch dimensions and multiple right-hand sides per each left-hand\n  side.\n  On CPU, solution is computed via Gaussian elimination with or without partial\n  pivoting, depending on `partial_pivoting` attribute. On GPU, Nvidia's cuSPARSE\n  library is used: https://docs.nvidia.com/cuda/cusparse/index.html#gtsv\n  Partial pivoting is not yet supported by XLA backends.",
    "attributes": [
      {
        "name": "partial_pivoting",
        "type": "boolean",
        "description": "Whether to apply partial pivoting. Partial pivoting makes the procedure more\nstable, but slower.",
        "default": true
      },
      {
        "name": "perturb_singular",
        "type": "boolean",
        "default": false
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float64`, `float32`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "diagonals",
        "description": "Tensor of shape `[..., 3, M]` whose innermost 2 dimensions represent the\ntridiagonal matrices with three rows being the superdiagonal, diagonals, and\nsubdiagonals, in order. The last element of the superdiagonal and the first\nelement of the subdiagonal is ignored.",
        "typeAttr": "T"
      },
      {
        "name": "rhs",
        "description": "Tensor of shape `[..., M, K]`, representing K right-hand sides per each\nleft-hand side.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Tensor of shape `[..., M, K]` containing the solutions",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "TruncateDiv",
    "summary": "Returns x / y element-wise, rounded towards zero.",
    "description": "Truncation designates that negative numbers will round fractional quantities\ntoward zero. I.e. -7 / 5 = -1. This matches C semantics but it is different\nthan Python semantics. See `FloorDiv` for a division function that matches\nPython Semantics.\n\n*NOTE*: `TruncateDiv` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `bfloat16`, `float16`, `float32`, `float64`, `uint8`, `int8`, `uint16`, `int16`, `int32`, `uint32`, `uint64`, `int64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "TruncateMod",
    "summary": "Returns element-wise remainder of division. This emulates C semantics in that",
    "description": "the result here is consistent with a truncating divide. E.g. `truncate(x / y) *\ny + truncate_mod(x, y) = x`.\n\n*NOTE*: `TruncateMod` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`, `bfloat16`, `float16`, `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "TruncatedNormal",
    "summary": "Outputs random values from a truncated normal distribution.",
    "description": "The generated values follow a normal distribution with mean 0 and standard\ndeviation 1, except that values whose magnitude is more than 2 standard\ndeviations from the mean are dropped and re-picked.",
    "attributes": [
      {
        "name": "seed",
        "type": "int64",
        "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "description": "A second seed to avoid seed collision.",
        "default": 0
      },
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of the output. Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`."
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      }
    ],
    "inputs": [
      {
        "name": "shape",
        "description": "The shape of the output tensor.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A tensor of the specified shape filled with random truncated normal\nvalues.",
        "typeAttr": "dtype"
      }
    ]
  },
  {
    "name": "Unbatch",
    "summary": "Reverses the operation of Batch for a single output Tensor.",
    "description": "An instance of Unbatch either receives an empty batched_tensor, in which case it\nasynchronously waits until the values become available from a concurrently\nrunning instance of Unbatch with the same container and shared_name, or receives\na non-empty batched_tensor in which case it finalizes all other concurrently\nrunning instances and outputs its own element from the batch.\n\nbatched_tensor: The possibly transformed output of Batch. The size of the first\n dimension should remain unchanged by the transformations for the operation to\n work.\nbatch_index: The matching batch_index obtained from Batch.\nid: The id scalar emitted by Batch.\nunbatched_tensor: The Tensor corresponding to this execution.\ntimeout_micros: Maximum amount of time (in microseconds) to wait to receive the\n batched input tensor associated with a given invocation of the op.\ncontainer: Container to control resource sharing.\nshared_name: Instances of Unbatch with the same container and shared_name are\n assumed to possibly belong to the same batch. If left empty, the op name will\n be used as the shared name.",
    "attributes": [
      {
        "name": "timeout_micros",
        "type": "int64"
      },
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "batched_tensor",
        "typeAttr": "T"
      },
      {
        "name": "batch_index",
        "type": 9
      },
      {
        "name": "id",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "unbatched_tensor",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "UnbatchDataset",
    "summary": "A dataset that splits the elements of its input into multiple elements.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "UnbatchGrad",
    "summary": "Gradient of Unbatch.",
    "description": "Acts like Batch but using the given batch_index index of batching things as they\nbecome available. This ensures that the gradients are propagated back in the\nsame session which did the forward pass.\n\noriginal_input: The input to the Unbatch operation this is the gradient of.\nbatch_index: The batch_index given to the Unbatch operation this is the gradient\nof.\ngrad: The downstream gradient.\nid: The id scalar emitted by Batch.\nbatched_grad: The return value, either an empty tensor or the batched gradient.\ncontainer: Container to control resource sharing.\nshared_name: Instances of UnbatchGrad with the same container and shared_name\n are assumed to possibly belong to the same batch. If left empty, the op name\n will be used as the shared name.",
    "attributes": [
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      },
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "original_input",
        "typeAttr": "T"
      },
      {
        "name": "batch_index",
        "type": 9
      },
      {
        "name": "grad",
        "typeAttr": "T"
      },
      {
        "name": "id",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "batched_grad",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "UncompressElement",
    "summary": "Uncompresses a compressed dataset element.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "compressed",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "components",
        "typeListAttr": "output_types"
      }
    ]
  },
  {
    "name": "UnicodeDecode",
    "summary": "Decodes each string in `input` into a sequence of Unicode code points.",
    "description": "The character codepoints for all strings are returned using a single vector\n`char_values`, with strings expanded to characters in row-major order.\n\nThe `row_splits` tensor indicates where the codepoints for\neach input string begin and end within the `char_values` tensor.\nIn particular, the values for the `i`th\nstring (in row-major order) are stored in the slice\n`[row_splits[i]:row_splits[i+1]]`. Thus:\n\n* `char_values[row_splits[i]+j]` is the Unicode codepoint for the `j`th\n  character in the `i`th string (in row-major order).\n* `row_splits[i+1] - row_splits[i]` is the number of characters in the `i`th\n  string (in row-major order).",
    "attributes": [
      {
        "name": "input_encoding",
        "type": "string",
        "description": "Text encoding of the input strings. This is any of the encodings supported\nby ICU ucnv algorithmic converters. Examples: `\"UTF-16\", \"US ASCII\", \"UTF-8\"`."
      },
      {
        "name": "errors",
        "type": "string",
        "description": "Error handling policy when there is invalid formatting found in the input.\nThe value of 'strict' will cause the operation to produce a InvalidArgument\nerror on any invalid input formatting. A value of 'replace' (the default) will\ncause the operation to replace any invalid formatting in the input with the\n`replacement_char` codepoint. A value of 'ignore' will cause the operation to\nskip any invalid formatting in the input and produce no corresponding output\ncharacter. Must be one of the following: `strict`, `replace`, `ignore`.",
        "default": "replace"
      },
      {
        "name": "replacement_char",
        "type": "int64",
        "description": "The replacement character codepoint to be used in place of any invalid\nformatting in the input when `errors='replace'`. Any valid unicode codepoint may\nbe used. The default value is the default unicode replacement character is\n0xFFFD or U+65533.)",
        "default": 65533
      },
      {
        "name": "replace_control_characters",
        "type": "boolean",
        "description": "Whether to replace the C0 control characters (00-1F) with the\n`replacement_char`. Default is false.",
        "default": false
      },
      {
        "name": "Tsplits",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The text to be decoded. Can have any shape. Note that the output is flattened\nto a vector of char values.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "row_splits",
        "description": "A 1D int32 tensor containing the row splits.",
        "typeAttr": "Tsplits"
      },
      {
        "name": "char_values",
        "description": "A 1D int32 Tensor containing the decoded codepoints.",
        "type": 3
      }
    ]
  },
  {
    "name": "UnicodeDecodeWithOffsets",
    "summary": "Decodes each string in `input` into a sequence of Unicode code points.",
    "description": "The character codepoints for all strings are returned using a single vector\n`char_values`, with strings expanded to characters in row-major order.\nSimilarly, the character start byte offsets are returned using a single vector\n`char_to_byte_starts`, with strings expanded in row-major order.\n\nThe `row_splits` tensor indicates where the codepoints and start offsets for\neach input string begin and end within the `char_values` and\n`char_to_byte_starts` tensors.  In particular, the values for the `i`th\nstring (in row-major order) are stored in the slice\n`[row_splits[i]:row_splits[i+1]]`. Thus:\n\n* `char_values[row_splits[i]+j]` is the Unicode codepoint for the `j`th\n  character in the `i`th string (in row-major order).\n* `char_to_bytes_starts[row_splits[i]+j]` is the start byte offset for the `j`th\n  character in the `i`th string (in row-major order).\n* `row_splits[i+1] - row_splits[i]` is the number of characters in the `i`th\n  string (in row-major order).",
    "attributes": [
      {
        "name": "input_encoding",
        "type": "string",
        "description": "Text encoding of the input strings. This is any of the encodings supported\nby ICU ucnv algorithmic converters. Examples: `\"UTF-16\", \"US ASCII\", \"UTF-8\"`."
      },
      {
        "name": "errors",
        "type": "string",
        "description": "Error handling policy when there is invalid formatting found in the input.\nThe value of 'strict' will cause the operation to produce a InvalidArgument\nerror on any invalid input formatting. A value of 'replace' (the default) will\ncause the operation to replace any invalid formatting in the input with the\n`replacement_char` codepoint. A value of 'ignore' will cause the operation to\nskip any invalid formatting in the input and produce no corresponding output\ncharacter. Must be one of the following: `strict`, `replace`, `ignore`.",
        "default": "replace"
      },
      {
        "name": "replacement_char",
        "type": "int64",
        "description": "The replacement character codepoint to be used in place of any invalid\nformatting in the input when `errors='replace'`. Any valid unicode codepoint may\nbe used. The default value is the default unicode replacement character is\n0xFFFD or U+65533.)",
        "default": 65533
      },
      {
        "name": "replace_control_characters",
        "type": "boolean",
        "description": "Whether to replace the C0 control characters (00-1F) with the\n`replacement_char`. Default is false.",
        "default": false
      },
      {
        "name": "Tsplits",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The text to be decoded. Can have any shape. Note that the output is flattened\nto a vector of char values.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "row_splits",
        "description": "A 1D int32 tensor containing the row splits.",
        "typeAttr": "Tsplits"
      },
      {
        "name": "char_values",
        "description": "A 1D int32 Tensor containing the decoded codepoints.",
        "type": 3
      },
      {
        "name": "char_to_byte_starts",
        "description": "A 1D int32 Tensor containing the byte index in the input string where each\ncharacter in `char_values` starts.",
        "type": 9
      }
    ]
  },
  {
    "name": "UnicodeEncode",
    "summary": "Encode a tensor of ints into unicode strings.",
    "description": "Returns a vector of strings, where `output[i]` is constructed by encoding the\nUnicode codepoints in `input_values[input_splits[i]:input_splits[i+1]]`\nusing `output_encoding`.\n\n---\n\nExample:\n\n```\ninput_values = [72, 101, 108, 108, 111, 87, 111, 114, 108, 100]\ninput_splits = [0, 5, 10]\noutput_encoding = 'UTF-8'\n\noutput = ['Hello', 'World']\n```",
    "attributes": [
      {
        "name": "errors",
        "type": "string",
        "description": "Error handling policy when there is invalid formatting found in the input.\nThe value of 'strict' will cause the operation to produce a InvalidArgument\nerror on any invalid input formatting. A value of 'replace' (the default) will\ncause the operation to replace any invalid formatting in the input with the\n`replacement_char` codepoint. A value of 'ignore' will cause the operation to\nskip any invalid formatting in the input and produce no corresponding output\ncharacter. Must be one of the following: `ignore`, `replace`, `strict`.",
        "default": "replace"
      },
      {
        "name": "output_encoding",
        "type": "string",
        "description": "Unicode encoding of the output strings. Valid encodings are: `\"UTF-8\",\n\"UTF-16-BE\", and \"UTF-32-BE\"`. Must be one of the following: `UTF-8`, `UTF-16-BE`, `UTF-32-BE`."
      },
      {
        "name": "replacement_char",
        "type": "int64",
        "description": "The replacement character codepoint to be used in place of any invalid\nformatting in the input when `errors='replace'`. Any valid unicode codepoint may\nbe used. The default value is the default unicode replacement character is\n0xFFFD (U+65533).",
        "default": 65533
      },
      {
        "name": "Tsplits",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      }
    ],
    "inputs": [
      {
        "name": "input_values",
        "description": "A 1D tensor containing the unicode codepoints that should be encoded.",
        "type": 3
      },
      {
        "name": "input_splits",
        "description": "A 1D tensor specifying how the unicode codepoints should be split into strings.\nIn particular, `output[i]` is constructed by encoding the codepoints in the\nslice `input_values[input_splits[i]:input_splits[i+1]]`.",
        "typeAttr": "Tsplits"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The 1-D Tensor of strings encoded from the provided unicode codepoints.",
        "type": 7
      }
    ]
  },
  {
    "name": "UnicodeScript",
    "summary": "Determine the script codes of a given tensor of Unicode integer code points.",
    "description": "This operation converts Unicode code points to script codes corresponding to\neach code point. Script codes correspond to International Components for\nUnicode (ICU) UScriptCode values.\n\nSee\n[ICU project docs](http://icu-project.org/apiref/icu4c/uscript_8h.html)\nfor more details on script codes.\n\nFor an example, see the unicode strings guide on [unicode scripts]\n(https://www.tensorflow.org/tutorials/load_data/unicode#representing_unicode).\n\nReturns -1 (USCRIPT_INVALID_CODE) for invalid codepoints. Output shape will\nmatch input shape.\n\nExamples:\n\n>>> tf.strings.unicode_script([1, 31, 38])\n<tf.Tensor: shape=(3,), dtype=int32, numpy=array([0, 0, 0], dtype=int32)>",
    "inputs": [
      {
        "name": "input",
        "description": "A Tensor of int32 Unicode code points.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A Tensor of int32 script codes corresponding to each input code point.",
        "type": 3
      }
    ]
  },
  {
    "name": "UnicodeTranscode",
    "summary": "Transcode the input text from a source encoding to a destination encoding.",
    "description": "The input is a string tensor of any shape. The output is a string tensor of\nthe same shape containing the transcoded strings. Output strings are always\nvalid unicode. If the input contains invalid encoding positions, the\n`errors` attribute sets the policy for how to deal with them. If the default\nerror-handling policy is used, invalid formatting will be substituted in the\noutput by the `replacement_char`. If the errors policy is to `ignore`, any\ninvalid encoding positions in the input are skipped and not included in the\noutput. If it set to `strict` then any invalid formatting will result in an\nInvalidArgument error.\n\nThis operation can be used with `output_encoding = input_encoding` to enforce\ncorrect formatting for inputs even if they are already in the desired encoding.\n\nIf the input is prefixed by a Byte Order Mark needed to determine encoding\n(e.g. if the encoding is UTF-16 and the BOM indicates big-endian), then that\nBOM will be consumed and not emitted into the output. If the input encoding\nis marked with an explicit endianness (e.g. UTF-16-BE), then the BOM is\ninterpreted as a non-breaking-space and is preserved in the output (including\nalways for UTF-8).\n\nThe end result is that if the input is marked as an explicit endianness the\ntranscoding is faithful to all codepoints in the source. If it is not marked\nwith an explicit endianness, the BOM is not considered part of the string itself\nbut as metadata, and so is not preserved in the output.\n\nExamples:\n\n>>> tf.strings.unicode_transcode([\"Hello\", \"TensorFlow\", \"2.x\"], \"UTF-8\", \"UTF-16-BE\")\n<tf.Tensor: shape=(3,), dtype=string, numpy=\narray([b'\\x00H\\x00e\\x00l\\x00l\\x00o',\n       b'\\x00T\\x00e\\x00n\\x00s\\x00o\\x00r\\x00F\\x00l\\x00o\\x00w',\n       b'\\x002\\x00.\\x00x'], dtype=object)>\n>>> tf.strings.unicode_transcode([\"A\", \"B\", \"C\"], \"US ASCII\", \"UTF-8\").numpy()\narray([b'A', b'B', b'C'], dtype=object)",
    "attributes": [
      {
        "name": "input_encoding",
        "type": "string",
        "description": "Text encoding of the input strings. This is any of the encodings supported\nby ICU ucnv algorithmic converters. Examples: `\"UTF-16\", \"US ASCII\", \"UTF-8\"`."
      },
      {
        "name": "output_encoding",
        "type": "string",
        "description": "The unicode encoding to use in the output. Must be one of\n`\"UTF-8\", \"UTF-16-BE\", \"UTF-32-BE\"`. Multi-byte encodings will be big-endian. Must be one of the following: `UTF-8`, `UTF-16-BE`, `UTF-32-BE`."
      },
      {
        "name": "errors",
        "type": "string",
        "description": "Error handling policy when there is invalid formatting found in the input.\nThe value of 'strict' will cause the operation to produce a InvalidArgument\nerror on any invalid input formatting. A value of 'replace' (the default) will\ncause the operation to replace any invalid formatting in the input with the\n`replacement_char` codepoint. A value of 'ignore' will cause the operation to\nskip any invalid formatting in the input and produce no corresponding output\ncharacter. Must be one of the following: `strict`, `replace`, `ignore`.",
        "default": "replace"
      },
      {
        "name": "replacement_char",
        "type": "int64",
        "description": "The replacement character codepoint to be used in place of any invalid\nformatting in the input when `errors='replace'`. Any valid unicode codepoint may\nbe used. The default value is the default unicode replacement character is\n0xFFFD or U+65533.)\n\nNote that for UTF-8, passing a replacement character expressible in 1 byte, such\nas ' ', will preserve string alignment to the source since invalid bytes will be\nreplaced with a 1-byte replacement. For UTF-16-BE and UTF-16-LE, any 1 or 2 byte\nreplacement character will preserve byte alignment to the source.",
        "default": 65533
      },
      {
        "name": "replace_control_characters",
        "type": "boolean",
        "description": "Whether to replace the C0 control characters (00-1F) with the\n`replacement_char`. Default is false.",
        "default": false
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "The text to be processed. Can have any shape.",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A string tensor containing unicode text encoded using `output_encoding`.",
        "type": 7
      }
    ]
  },
  {
    "name": "UniformCandidateSampler",
    "summary": "Generates labels for candidate sampling with a uniform distribution.",
    "description": "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels.",
    "attributes": [
      {
        "name": "num_true",
        "type": "int64",
        "description": "Number of true labels per context.",
        "minimum": 1
      },
      {
        "name": "num_sampled",
        "type": "int64",
        "description": "Number of candidates to randomly sample.",
        "minimum": 1
      },
      {
        "name": "unique",
        "type": "boolean",
        "description": "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities."
      },
      {
        "name": "range_max",
        "type": "int64",
        "description": "The sampler will sample integers from the interval [0, range_max).",
        "minimum": 1
      },
      {
        "name": "seed",
        "type": "int64",
        "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
        "default": 0
      },
      {
        "name": "seed2",
        "type": "int64",
        "description": "An second seed to avoid seed collision.",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "true_classes",
        "description": "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label.",
        "type": 9
      }
    ],
    "outputs": [
      {
        "name": "sampled_candidates",
        "description": "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate.",
        "type": 9
      },
      {
        "name": "true_expected_count",
        "description": "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability.",
        "type": 1
      },
      {
        "name": "sampled_expected_count",
        "description": "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability.",
        "type": 1
      }
    ]
  },
  {
    "name": "UniformDequantize",
    "summary": "Perform dequantization on the quantized Tensor `input`.",
    "description": "Given quantized `input` which was quantized using `scales` and `zero_points`, performs dequantization using the formula:\ndequantized_data = (quantized_data - zero_point) * scale.",
    "attributes": [
      {
        "name": "Tin",
        "type": "type",
        "description": "The type of input Tensor. A tf.DType from: tf.float32 Must be one of the following: `qint8`, `qint32`."
      },
      {
        "name": "Tout",
        "type": "type",
        "description": "The type of output Tensor. A tf.DType from: tf.qint8, tf.qint32 Must be one of the following: `float32`."
      },
      {
        "name": "quantization_axis",
        "type": "int64",
        "description": "Indicates the dimension index of the tensor where per-axis quantization is applied for the slices along that dimension.\nIf set to -1 (default), this indicates per-tensor quantization. Otherwise, it must be set within range [0, input.dims()).",
        "default": -1
      },
      {
        "name": "quantization_min_val",
        "type": "int64",
        "description": "The quantization min value that was used when input was quantized.\nThe purpose of this attribute is typically (but not limited to) to indicate narrow range, where this is set to:\n`(Tin lowest) + 1` if narrow range, and `(Tin lowest)` otherwise.\nFor example, if Tin is qint8, this is set to -127 if narrow range quantized or -128 if not."
      },
      {
        "name": "quantization_max_val",
        "type": "int64",
        "description": "The quantization max value that was used when input was quantized.\nThe purpose of this attribute is typically (but not limited to) indicate narrow range, where this is set to:\n`(Tout max)` for both narrow range and not narrow range.\nFor example, if Tin is qint8, this is set to 127."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Must be a Tensor of Tin.",
        "typeAttr": "Tin"
      },
      {
        "name": "scales",
        "description": "The float value(s) used as scale(s) when quantizing original data that input represents.\nMust be a scalar Tensor if quantization_axis is -1 (per-tensor quantization), otherwise 1D Tensor of size (input.dim_size(quantization_axis),) (per-axis quantization).",
        "type": 1
      },
      {
        "name": "zero_points",
        "description": "The int32 value(s) used as zero_point(s) when quantizing original data that input represents.\nSame shape condition as scales.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The output dequantized Tensor of Tout, whose shape is same as input.",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "UniformQuantize",
    "summary": "Perform quantization on Tensor `input`.",
    "description": "Given `input`, `scales` and `zero_points`, performs quantization using the formula:\nquantized_data = floor(input_data * (1.0f / scale) + 0.5f) + zero_point",
    "attributes": [
      {
        "name": "Tin",
        "type": "type",
        "description": "The type of input Tensor. A tf.DType from: tf.qint8, tf.qint32 Must be one of the following: `float32`."
      },
      {
        "name": "Tout",
        "type": "type",
        "description": "The type of output Tensor. A tf.DType from: tf.float32 Must be one of the following: `qint8`, `qint32`."
      },
      {
        "name": "quantization_axis",
        "type": "int64",
        "description": "Indicates the dimension index of the tensor where per-axis quantization is applied for the slices along that dimension.\nIf set to -1 (default), this indicates per-tensor quantization. Otherwise, it must be set within range [0, input.dims()).",
        "default": -1
      },
      {
        "name": "quantization_min_val",
        "type": "int64",
        "description": "The quantization min value to quantize `input`.\nThe purpose of this attribute is typically (but not limited to) to indicate narrow range, where this is set to:\n`(Tin lowest) + 1` if narrow range, and `(Tin lowest)` otherwise.\nFor example, if Tin is qint8, this is set to -127 if narrow range quantized or -128 if not."
      },
      {
        "name": "quantization_max_val",
        "type": "int64",
        "description": "The quantization max value to quantize `input`.\nThe purpose of this attribute is typically (but not limited to) indicate narrow range, where this is set to:\n`(Tout max)` for both narrow range and not narrow range.\nFor example, if Tin is qint8, this is set to 127."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Must be a Tensor of Tin.",
        "typeAttr": "Tin"
      },
      {
        "name": "scales",
        "description": "The float value(s) to use as scale(s) to quantize `input`.\nMust be a scalar Tensor if quantization_axis is -1 (per-tensor quantization), otherwise 1D Tensor of size (input.dim_size(quantization_axis),) (per-axis quantization).",
        "type": 1
      },
      {
        "name": "zero_points",
        "description": "The int32 value(s) to use as zero_point(s) to quantize `input`.\nSame shape condition as scales.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The output quantized Tensor of Tout, whose shape is same as input.",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "UniformQuantizedAdd",
    "summary": "Perform quantized add of quantized Tensor `lhs` and quantized Tensor `rhs` to make quantized `output`.",
    "description": "Given quantized `lhs` and quantized `rhs`, performs quantized add on `lhs` and `rhs` to make quantized `output`.\n\n`UniformQuantizedAdd` follows Numpy broadcasting rules.\nThe two input array shapes are compared element-wise.\nStarting with the trailing dimensions, the two dimensions either have to be equal or one of them needs to be 1.\n\n`lhs` and `rhs` must be quantized Tensor, where data value is quantized using the formula:\n```\nquantized_data = clip(original_data / scale + zero_point, quantization_min_val, quantization_max_val)\n```\n`output` is also quantized, using the same formula.\n\nIf `lhs` and `output` is both per-axis quantized, the quantization axis must match.\nAlso, if `rhs` and `output` is both per-axis quantized, the quantization axis must match.\n*Match* means the axis must match when adding, regarding the broadcasting.\ni.e. For both operands `lhs` and `rhs`,\nif `operand.quantization_axis` >= 0 and `output.quantization_axis` >= 0,\n`operand.dims` - `operand.quantization_axis` must be equal to `output.dims` - `output.quantization_axis`.",
    "attributes": [
      {
        "name": "lhs_quantization_axis",
        "type": "int64",
        "description": "Indicates the dimension index of the tensor where per-axis quantization is applied for the slices along that dimension.\nIf set to -1 (default), this indicates per-tensor quantization.\nFor the `lhs`, only per-tensor quantization is supported.\nThus, this must be set to -1.\nOther values will raise error at OpKernel construction.",
        "default": -1
      },
      {
        "name": "lhs_quantization_min_val",
        "type": "int64",
        "description": "The min value of the quantized data stored in `lhs`.\nFor example, if `Tin` is `qint8`, this must be set to -127 if narrow range quantized or -128 if not."
      },
      {
        "name": "lhs_quantization_max_val",
        "type": "int64",
        "description": "The max value of the quantized data stored in `lhs`.\nFor example, if `Tin` is `qint8`, this must be set to 127."
      },
      {
        "name": "rhs_quantization_axis",
        "type": "int64",
        "description": "Indicates the dimension index of the tensor where per-axis quantization is applied for the slices along that dimension.\nIf set to -1 (default), this indicates per-tensor quantization.\nFor the `rhs`, only per-tensor quantization\nor per-channel quantization along `kernel_output_feature_dimension` is supported.\nThus, this must be set to -1 or `dimension_numbers.kernel_output_feature_dimension`.\nOther values will raise error at OpKernel construction.",
        "default": -1
      },
      {
        "name": "rhs_quantization_min_val",
        "type": "int64",
        "description": "The min value of the quantized data stored in `rhs`.\nFor example, if `Tin` is `qint8`, this must be set to -127 if narrow range quantized or -128 if not."
      },
      {
        "name": "rhs_quantization_max_val",
        "type": "int64",
        "description": "The max value of the quantized data stored in `rhs`.\nFor example, if `Tin` is `qint8`, this must be set to 127."
      },
      {
        "name": "output_quantization_axis",
        "type": "int64",
        "description": "Indicates the dimension index of the tensor where per-axis quantization is applied for the slices along that dimension.\nIf set to -1 (default), this indicates per-tensor quantization.\nFor the `output`, only per-tensor quantization or per-channel quantization along `output_feature_dimension` is supported.\nThus, this must be set to -1 or `dimension_numbers.output_feature_dimension`.\nOther values will raise error at OpKernel construction.",
        "default": -1
      },
      {
        "name": "output_quantization_min_val",
        "type": "int64",
        "description": "The min value of the quantized data stored in `output`.\nFor example, if  `Tout` is `qint8`, this must be set to -127 if narrow range quantized or -128 if not."
      },
      {
        "name": "output_quantization_max_val",
        "type": "int64",
        "description": "The max value of the quantized data stored in `output`.\nFor example, if `Tout` is `qint8`, this must be set to 127."
      },
      {
        "name": "T",
        "type": "type",
        "description": "The type of `lhs`, `rhs`, and `output`. Must be one of the following: `qint32`."
      }
    ],
    "inputs": [
      {
        "name": "lhs",
        "description": "Must be a quantized tensor.",
        "typeAttr": "T"
      },
      {
        "name": "rhs",
        "description": "Must be a quantized tensor.",
        "typeAttr": "T"
      },
      {
        "name": "lhs_scales",
        "description": "The float value(s) used as scale factors when quantizing the original data that `lhs` represents.",
        "type": 1
      },
      {
        "name": "lhs_zero_points",
        "description": "The int32 value(s) used as zero points when quantizing original data that `lhs` represents.\nMust have same shape with `lhs_scales`.",
        "type": 3
      },
      {
        "name": "rhs_scales",
        "description": "The float value(s) used as scale factors when quantizing the original data that `rhs` represents.",
        "type": 1
      },
      {
        "name": "rhs_zero_points",
        "description": "The int32 value(s) used as zero points when quantizing original data that `rhs` represents.\nMust have same shape with `rhs_scales`.",
        "type": 3
      },
      {
        "name": "output_scales",
        "description": "The float value(s) to use as scale factors when quantizing original data that `output` represents.",
        "type": 1
      },
      {
        "name": "output_zero_points",
        "description": "The int32 value(s) used as zero points when quantizing original data that output represents.\nMust have same shape with `output_scales`.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The output quantized tensor.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "UniformQuantizedClipByValue",
    "summary": "Perform clip by value on the quantized Tensor `operand`.",
    "description": "Given quantized `operand` which was quantized using `scales` and `zero_points`, performs clip by value using `min` and `max` values.\nIf quantization_axis is -1 (per-tensor quantized), the entire operand is clipped using scalar min, max.\nOtherwise (per-channel quantized), the clipping is also done per-channel.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "The type of operand, min, max, and output. A tf.DType from: tf.qint32 Must be one of the following: `qint32`."
      },
      {
        "name": "quantization_axis",
        "type": "int64",
        "description": "Indicates the dimension index of the tensor where per-axis quantization is applied for the slices along that dimension.\nIf set to -1 (default), this indicates per-tensor quantization. Otherwise, it must be set within range [0, operand.dims()).",
        "default": -1
      },
      {
        "name": "quantization_min_val",
        "type": "int64",
        "description": "The quantization min value that was used when operand was quantized."
      },
      {
        "name": "quantization_max_val",
        "type": "int64",
        "description": "The quantization max value that was used when operand was quantized."
      }
    ],
    "inputs": [
      {
        "name": "operand",
        "description": "Must be a Tensor of T.",
        "typeAttr": "T"
      },
      {
        "name": "min",
        "description": "The min value(s) to clip operand. Must be a Tensor of T.\nMust be a scalar Tensor if quantization_axis is -1 (per-tensor quantization), otherwise 1D Tensor of size (operand.dim_size(quantization_axis),) (per-axis quantization).",
        "typeAttr": "T"
      },
      {
        "name": "max",
        "description": "The min value(s) to clip operand. Must be a Tensor of T.\nMust be a scalar Tensor if quantization_axis is -1 (per-tensor quantization), otherwise 1D Tensor of size (operand.dim_size(quantization_axis),) (per-axis quantization).",
        "typeAttr": "T"
      },
      {
        "name": "scales",
        "description": "The float value(s) used as scale(s) when quantizing `operand`, `min` and `max`.\nMust be a scalar Tensor if quantization_axis is -1 (per-tensor quantization), otherwise 1D Tensor of size (operand.dim_size(quantization_axis),) (per-axis quantization).",
        "type": 1
      },
      {
        "name": "zero_points",
        "description": "The int32 value(s) used as zero_point(s) when quantizing `operand`, `min` and `max`.\nSame shape condition as scales.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The output clipped Tensor of T, whose shape is same as operand.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "UniformQuantizedConvolution",
    "summary": "Perform quantized convolution of quantized Tensor `lhs` and quantized Tensor `rhs`. to make quantized `output`.",
    "description": "Given quantized `lhs` and quantized `rhs`, performs quantized dot on `lhs` and `rhs` to make quantized `output`.\n\n`lhs` and `rhs` must be Tensors of same rank, and meet following shape conditions.\n- `lhs_feature` % `feature_group_count` == 0\n- `lhs_feature` % `rhs_input_feature` == 0\n- `lhs_feature` / `feature_group_count` == `rhs_input_feature`\n- `rhs_output_feature` % `feature_group_count` == 0\n- `lhs_batch` % `batch_group_count` == 0\n- `rhs_output_feature` % `batch_group_count` == 0\n\n`lhs` and `rhs` must be quantized Tensor, where data value is quantized using the formula:\n```\nquantized_data = clip(original_data / scale + zero_point, quantization_min_val, quantization_max_val)\n```\n`output` is also quantized, using the same formula.\nIf `rhs` is per-tensor quantized, `output` must be also per-tensor quantized.",
    "attributes": [
      {
        "name": "Tin",
        "type": "type",
        "description": "The type of `lhs` and `rhs` input `Tensor`. Must be one of the following: `qint8`."
      },
      {
        "name": "Tout",
        "type": "type",
        "description": "The type of `output` `Tensor`. Must be one of the following: `qint32`."
      },
      {
        "name": "window_strides",
        "type": "int64[]",
        "description": "The stride of the sliding window for each spatial dimension of `lhs`.\nMust be an empty list (default) or a list of size (number of spatial dimensions).\nIf an empty list is provided, the stride for each spatial dimension is set to 1.",
        "default": []
      },
      {
        "name": "padding",
        "type": "string",
        "description": "string from: `\"SAME\"`, `\"VALID\"`, or `\"EXPLICIT\"`, indicating the type of padding algorithm to use."
      },
      {
        "name": "explicit_padding",
        "type": "int64[]",
        "description": "If `padding` is `\"EXPLICIT\"`, must be set as a list indicating\nthe explicit paddings at the start and end of each `lhs` spatial dimension.\nOtherwise, this must be empty.\n\n(If used,) Must be a list of size `2 * (number of lhs spatial dimensions)`,\nwhere `(explicit_padding[2 * i], explicit_padding[2 * i + 1])` indicates\n`(start_padding, end_padding)` of `spatial_dimensions[i]`.",
        "default": []
      },
      {
        "name": "lhs_dilation",
        "type": "int64[]",
        "description": "The dilation factor to apply in each spatial dimension of `lhs`.\nMust be an empty list (default) or a list of size (number of `lhs` spatial dimensions).\nIf empty list, the dilation for each `lhs` spatial dimension is set to 1.",
        "default": []
      },
      {
        "name": "rhs_dilation",
        "type": "int64[]",
        "description": "The dilation factor to apply in each spatial dimension of `rhs`.\nMust be an empty list (default) or a list of size (number of `rhs` spatial dimensions).\nIf empty list, the dilation for each `rhs` spatial dimension is set to 1.",
        "default": []
      },
      {
        "name": "batch_group_count",
        "type": "int64",
        "description": "The number of batch groups. Used for grouped filters.\nMust be a divisor of `output_feature`.",
        "default": 1
      },
      {
        "name": "feature_group_count",
        "type": "int64",
        "description": "The number of feature groups. Used for grouped convolutions.\nMust be a divisor of both `lhs_feature` and `output_feature`.",
        "default": 1
      },
      {
        "name": "dimension_numbers",
        "type": "string",
        "description": "Structure of dimension information for the convolution op.\nMust be an empty string (default) or a serialized string of `tensorflow.UniformQuantizedConvolutionDimensionNumbersAttr` proto.\nIf empty string, the default is `(\"NCHW\", \"OIHW\", \"NCHW\")` (for a 2D convolution).",
        "default": ""
      },
      {
        "name": "lhs_quantization_axis",
        "type": "int64",
        "description": "Indicates the dimension index of the tensor where per-axis quantization is applied for the slices along that dimension.\nIf set to -1 (default), this indicates per-tensor quantization.\nFor the `lhs`, only per-tensor quantization is supported.\nThus, this must be set to -1.\nOther values will raise error at OpKernel construction.",
        "default": -1
      },
      {
        "name": "lhs_quantization_min_val",
        "type": "int64",
        "description": "The min value of the quantized data stored in `lhs`.\nFor example, if `Tin` is `qint8`, this must be set to -127 if narrow range quantized or -128 if not."
      },
      {
        "name": "lhs_quantization_max_val",
        "type": "int64",
        "description": "The max value of the quantized data stored in `lhs`.\nFor example, if `Tin` is `qint8`, this must be set to 127."
      },
      {
        "name": "rhs_quantization_axis",
        "type": "int64",
        "description": "Indicates the dimension index of the tensor where per-axis quantization is applied for the slices along that dimension.\nIf set to -1 (default), this indicates per-tensor quantization.\nFor the `rhs`, only per-tensor quantization\nor per-channel quantization along `kernel_output_feature_dimension` is supported.\nThus, this must be set to -1 or `dimension_numbers.kernel_output_feature_dimension`.\nOther values will raise error at OpKernel construction.",
        "default": -1
      },
      {
        "name": "rhs_quantization_min_val",
        "type": "int64",
        "description": "The min value of the quantized data stored in `rhs`.\nFor example, if `Tin` is `qint8`, this must be set to -127 if narrow range quantized or -128 if not."
      },
      {
        "name": "rhs_quantization_max_val",
        "type": "int64",
        "description": "The max value of the quantized data stored in `rhs`.\nFor example, if `Tin` is `qint8`, this must be set to 127."
      },
      {
        "name": "output_quantization_axis",
        "type": "int64",
        "description": "Indicates the dimension index of the tensor where per-axis quantization is applied for the slices along that dimension.\nIf set to -1 (default), this indicates per-tensor quantization.\nFor the `output`, only per-tensor quantization or per-channel quantization along `output_feature_dimension` is supported.\nThus, this must be set to -1 or `dimension_numbers.output_feature_dimension`.\nOther values will raise error at OpKernel construction.",
        "default": -1
      },
      {
        "name": "output_quantization_min_val",
        "type": "int64",
        "description": "The min value of the quantized data stored in `output`.\nFor example, if  `Tout` is `qint8`, this must be set to -127 if narrow range quantized or -128 if not."
      },
      {
        "name": "output_quantization_max_val",
        "type": "int64",
        "description": "The max value of the quantized data stored in `output`.\nFor example, if `Tout` is `qint8`, this must be set to 127."
      }
    ],
    "inputs": [
      {
        "name": "lhs",
        "description": "Must be a quantized tensor, rank >= 3.",
        "typeAttr": "Tin"
      },
      {
        "name": "rhs",
        "description": "Must be a quantized tensor, same rank as `lhs`.",
        "typeAttr": "Tin"
      },
      {
        "name": "lhs_scales",
        "description": "The float value(s) used as scale factors when quantizing the original data that `lhs` represents.\nMust be a scalar `Tensor` (`lhs` supports only per-tensor quantization).",
        "type": 1
      },
      {
        "name": "lhs_zero_points",
        "description": "The int32 value(s) used as zero points when quantizing original data that `lhs` represents.\nSame shape condition as `lhs_scales`.",
        "type": 3
      },
      {
        "name": "rhs_scales",
        "description": "The float value(s) used as scale factors when quantizing the original data that `rhs` represents.\nMust be a scalar `Tensor` for per-tensor quantization,\nor 1D `Tensor` of size `rhs.dim_size(kernel_output_feature_dimension)`, for per-channel quantization.",
        "type": 1
      },
      {
        "name": "rhs_zero_points",
        "description": "The int32 value(s) used as zero points when quantizing original data that `rhs` represents.\nSame shape condition as `rhs_scales`.",
        "type": 3
      },
      {
        "name": "output_scales",
        "description": "The float value(s) to use as scale factors when quantizing original data that `output` represents.\nMust be a scalar `Tensor` for per-tensor quantization,\nor 1D `Tensor` of size `rhs.dim_size(kernel_output_feature_dimension)`\n- which is equal to `output.dim_size(output_feature_dimension)`,\nfor per-channel quantization.\nIf `rhs` is per-tensor quantized, output must be also per-tensor quantized.\nThis means that if `rhs_scales` and `rhs_zero_points` are scalar `Tensor`s, `output_scales` and `output_zero_points` must be scalar `Tensor`s as well.",
        "type": 1
      },
      {
        "name": "output_zero_points",
        "description": "The int32 value(s) used as zero points when quantizing original data that output represents.\nSame shape condition as `output_scales`.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The output quantized tensor of `Tout`, same rank as `lhs` and `rhs`.",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "UniformQuantizedConvolutionHybrid",
    "summary": "Perform hybrid quantized convolution of float Tensor `lhs` and quantized Tensor `rhs`.",
    "description": "Given float `lhs` and quantized `rhs`, internally performs quantization on `lhs`,\nand then performs quantized convolution on quantized `lhs` and `rhs`.\n\nThe internal quantization on `lhs` is a quantization to `Trhs`, dynamic range,\nper-batch (per-axis along axis `dimension_numbers.input_batch_dimension`), asymmetric,\nand not narrow range (the range is [Trhs_MIN, Trhs_MAX]).\n\n`lhs` and `rhs` must be Tensors of same rank, and meet following shape conditions.\n- lhs_feature % feature_group_count == 0\n- lhs_feature % rhs_input_feature == 0\n- lhs_feature / feature_group_count == rhs_input_feature\n- rhs_output_feature % feature_group_count == 0\n- lhs_batch % batch_group_count == 0\n- rhs_output_feature % batch_group_count == 0\n\n`rhs` must be quantized Tensor, where its data value is quantized using the formula:\nquantized_data = clip(original_data / scale + zero_point, quantization_min_val, quantization_max_val).",
    "attributes": [
      {
        "name": "Tlhs",
        "type": "type",
        "description": "The type of `lhs` input Tensor. Must be one of the following: `float32`."
      },
      {
        "name": "Trhs",
        "type": "type",
        "description": "The type of `rhs` (quantized) input Tensor. Must be one of the following: `qint8`."
      },
      {
        "name": "Tout",
        "type": "type",
        "description": "The type of output Tensor. Must be one of the following: `float32`."
      },
      {
        "name": "window_strides",
        "type": "int64[]",
        "description": "The stride of the sliding window for each spatial dimension of `lhs`.\nMust be an empty list (default) or a list of size (number of spatial dimensions).\nIf an empty list is provided, the stride for each spatial dimension is set to 1.",
        "default": []
      },
      {
        "name": "padding",
        "type": "string",
        "description": "string from: `\"SAME\"`, `\"VALID\"`, or `\"EXPLICIT\"`, indicating the type of padding algorithm to use."
      },
      {
        "name": "explicit_padding",
        "type": "int64[]",
        "description": "If `padding` Attr is `\"EXPLICIT\"`, must be set as a list indicating\nthe explicit paddings at the start and end of each lhs spatial dimension.\nOtherwise, this Attr is must be empty.\n\n(If used,) Must be a list of size 2 * (number of lhs spatial dimensions),\nwhere (explicit_padding[2 * i], explicit_padding[2 * i + 1]) indicates\nspatial_dimensions[i] (start_padding, end_padding).",
        "default": []
      },
      {
        "name": "lhs_dilation",
        "type": "int64[]",
        "description": "The dilation factor to apply in each spatial dimension of `lhs`.\nMust be an empty list (default) or a list of size (number of lhs spatial dimensions).\nIf empty list, the dilation for each lhs spatial dimension is set to 1.",
        "default": []
      },
      {
        "name": "rhs_dilation",
        "type": "int64[]",
        "description": "The dilation factor to apply in each spatial dimension of `rhs`.\nMust be an empty list (default) or a list of size (number of rhs spatial dimensions).\nIf empty list, the dilation for each rhs spatial dimension is set to 1.",
        "default": []
      },
      {
        "name": "batch_group_count",
        "type": "int64",
        "description": "The number of batch groups. Used for grouped filters.\nMust be a divisor of output_feature.",
        "default": 1
      },
      {
        "name": "feature_group_count",
        "type": "int64",
        "description": "The number of feature groups. Used for grouped convolutions.\nMust be a divisor of both lhs_feature and output_feature.",
        "default": 1
      },
      {
        "name": "dimension_numbers",
        "type": "string",
        "description": "Structure of dimension information for the convolution op.\nMust be an empty string (default) or a serialized string of tensorflow.UniformQuantizedConvolutionDimensionNumbersAttr proto.\nIf empty string, the default is `(\"NCHW\", \"OIHW\", \"NCHW\")` (for a 2D convolution).",
        "default": ""
      },
      {
        "name": "rhs_quantization_axis",
        "type": "int64",
        "description": "Indicates the dimension index of the tensor where per-axis quantization is applied for the slices along that dimension.\nIf set to -1 (default), this indicates per-tensor quantization.\nFor the `rhs`, only per-tensor quantization\nor per-channel quantization along kernel_output_feature_dimension is supported.\nThus, this attribute must be set to -1 or `dimension_numbers.kernel_output_feature_dimension`.\nOther values will raise error at OpKernel construction.",
        "default": -1
      },
      {
        "name": "rhs_quantization_min_val",
        "type": "int64",
        "description": "The min value of the quantized data stored in `rhs`.\nFor example, if `Trhs` is qint8, this must be set to -127 if narrow range quantized or -128 if not."
      },
      {
        "name": "rhs_quantization_max_val",
        "type": "int64",
        "description": "The max value of the quantized data stored in `rhs`.\nFor example, if `Trhs` is qint8, this must be set to 127."
      }
    ],
    "inputs": [
      {
        "name": "lhs",
        "description": "Must be a non-quantized Tensor of `Tlhs`, rank >= 3.",
        "typeAttr": "Tlhs"
      },
      {
        "name": "rhs",
        "description": "Must be a quantized Tensor of `Trhs`, same rank as `lhs`.",
        "typeAttr": "Trhs"
      },
      {
        "name": "rhs_scales",
        "description": "The float value(s) used as scale factors when quantizing the original data that `rhs` represents.\nMust be a scalar Tensor for per-tensor quantization,\nor 1D Tensor of size `rhs.dim_size(kernel_output_feature_dimension)`, for per-channel quantization.",
        "type": 1
      },
      {
        "name": "rhs_zero_points",
        "description": "The int32 value(s) used as zero_point when quantizing original data that `rhs` represents.\nSame shape condition as `rhs_scales`.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The output Tensor of `Tout`, same rank as `lhs` and `rhs`.\nThe output data is the non-quantized output data.",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "UniformQuantizedDot",
    "summary": "Perform quantized dot of quantized Tensor `lhs` and quantized Tensor `rhs` to make quantized `output`.",
    "description": "Given quantized `lhs` and quantized `rhs`, performs quantized dot on `lhs` and `rhs` to make quantized `output`.\n`lhs` and `rhs` must be 2D Tensors and the lhs.dim_size(1) must match rhs.dim_size(0).\n`lhs` and `rhs` must be quantized Tensor, where data value is quantized using the formula:\nquantized_data = clip(original_data / scale + zero_point, quantization_min_val, quantization_max_val).\n`output` is also quantized, using the same formula.\nIf `rhs` is per-tensor quantized, `output` must be also per-tensor quantized.",
    "attributes": [
      {
        "name": "Tin",
        "type": "type",
        "description": "The type of lhs and rhs input Tensor. Must be one of the following: `qint8`."
      },
      {
        "name": "Tout",
        "type": "type",
        "description": "The type of output Tensor. Must be one of the following: `qint32`."
      },
      {
        "name": "lhs_quantization_axis",
        "type": "int64",
        "description": "Indicates the dimension index of the tensor where per-axis quantization is applied for the slices along that dimension.\nIf set to -1 (default), this indicates per-tensor quantization.\nFor dot op lhs, only per-tensor quantization is supported.\nThus, this attribute must be set to -1. Other values are rejected.",
        "default": -1
      },
      {
        "name": "lhs_quantization_min_val",
        "type": "int64",
        "description": "The min value of the quantized data stored in lhs.\nFor example, if Tin is qint8, this must be set to -127 if narrow range quantized or -128 if not."
      },
      {
        "name": "lhs_quantization_max_val",
        "type": "int64",
        "description": "The max value of the quantized data stored in rhs.\nFor example, if Tin is qint8, this must be set to 127."
      },
      {
        "name": "rhs_quantization_axis",
        "type": "int64",
        "description": "Indicates the dimension index of the tensor where per-axis quantization is applied for the slices along that dimension.\nIf set to -1 (default), this indicates per-tensor quantization.\nFor dot op rhs, only per-tensor quantization or per-channel quantization along dimension 1 is supported.\nThus, this attribute must be set to -1 or 1. Other values are rejected.",
        "default": -1
      },
      {
        "name": "rhs_quantization_min_val",
        "type": "int64",
        "description": "The min value of the quantized data stored in rhs.\nFor example, if Trhs is qint8, this must be set to -127 if narrow range quantized or -128 if not."
      },
      {
        "name": "rhs_quantization_max_val",
        "type": "int64",
        "description": "The max value of the quantized data stored in rhs.\nFor example, if Trhs is qint8, this must be set to 127."
      },
      {
        "name": "output_quantization_axis",
        "type": "int64",
        "description": "Indicates the dimension index of the tensor where per-axis quantization is applied for the slices along that dimension.\nIf set to -1 (default), this indicates per-tensor quantization.\nFor dot op output, only per-tensor quantization or per-channel quantization along dimension 1 is supported.\nThus, this attribute must be set to -1 or 1. Other values are rejected.",
        "default": -1
      },
      {
        "name": "output_quantization_min_val",
        "type": "int64",
        "description": "The min value of the quantized data stored in output.\nFor example, if Tout is qint8, this must be set to -127 if narrow range quantized or -128 if not."
      },
      {
        "name": "output_quantization_max_val",
        "type": "int64",
        "description": "The max value of the quantized data stored in output.\nFor example, if Tout is qint8, this must be set to 127."
      }
    ],
    "inputs": [
      {
        "name": "lhs",
        "description": "Must be a 2D Tensor of Tin.",
        "typeAttr": "Tin"
      },
      {
        "name": "rhs",
        "description": "Must be a 2D Tensor of Tin.",
        "typeAttr": "Tin"
      },
      {
        "name": "lhs_scales",
        "description": "The float value(s) used as scale when quantizing original data that lhs represents.\nMust be a scalar Tensor (lhs supports only per-tensor quantization).",
        "type": 1
      },
      {
        "name": "lhs_zero_points",
        "description": "The int32 value(s) used as zero_point when quantizing original data that lhs represents.\nSame shape condition as lhs_scales.",
        "type": 3
      },
      {
        "name": "rhs_scales",
        "description": "The float value(s) used as scale when quantizing original data that rhs represents.\nMust be a scalar Tensor (per-tensor quantization) or 1D Tensor of size (rhs.dim_size(1),) (per-channel quantization).",
        "type": 1
      },
      {
        "name": "rhs_zero_points",
        "description": "The int32 value(s) used as zero_point when quantizing original data that rhs represents.\nSame shape condition as rhs_scales.",
        "type": 3
      },
      {
        "name": "output_scales",
        "description": "The float value(s) to use as scales when quantizing original data that output represents.\nMust be a scalar Tensor (per-tensor quantization) or 1D Tensor of size (output.dim_size(1),) (per-channel quantization).\nIf rhs is per-tensor quantized, output must be also per-tensor quantized.\nThis means that if rhs_scales and rhs_zero_points are scalar Tensors, output_scales and output_zero_points must be scalar Tensors as well.",
        "type": 1
      },
      {
        "name": "output_zero_points",
        "description": "The int32 value(s) used as zero_point when quantizing original data that output represents.\nSame shape condition as rhs_scales.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The output 2D Tensor of Tout, whose shape is (lhs.dim_size(0), rhs.dim_size(1)).",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "UniformQuantizedDotHybrid",
    "summary": "Perform hybrid quantized dot of float Tensor `lhs` and quantized Tensor `rhs`.",
    "description": "Given float `lhs` and quantized `rhs`, internally performs quantization on `lhs`, and then performs quantized dot on quantized lhs and `rhs`.\nThe internal quantization on `lhs` is a quantization to qint8, dynamic range, per-batch (per-axis along axis 0), asymmetric, and not narrow range (the range is [-128, 127]).\n`lhs` and `rhs` must be 2D Tensors and the lhs.dim_size(1) must match rhs.dim_size(0).\n`rhs` must be quantized Tensor, where its data value is quantized using the formula:\nquantized_data = clip(original_data / scale + zero_point, quantization_min_val, quantization_max_val).",
    "attributes": [
      {
        "name": "Tlhs",
        "type": "type",
        "description": "The type of lhs input Tensor. Must be one of the following: `float32`."
      },
      {
        "name": "Trhs",
        "type": "type",
        "description": "The type of rhs (quantized) input Tensor. Must be one of the following: `qint8`."
      },
      {
        "name": "Tout",
        "type": "type",
        "description": "The type of output Tensor. Must be one of the following: `float32`."
      },
      {
        "name": "rhs_quantization_axis",
        "type": "int64",
        "description": "Indicates the dimension index of the tensor where per-axis quantization is applied for the slices along that dimension.\nIf set to -1 (default), this indicates per-tensor quantization.\nFor dot op rhs, only per-tensor quantization or per-channel quantization along dimension 1 is supported.\nThus, this attribute must be set to -1 or 1. Other values are rejected.",
        "default": -1
      },
      {
        "name": "rhs_quantization_min_val",
        "type": "int64",
        "description": "The min value of the quantized data stored in rhs.\nFor example, if Trhs is qint8, this must be set to -127 if narrow range quantized or -128 if not."
      },
      {
        "name": "rhs_quantization_max_val",
        "type": "int64",
        "description": "The max value of the quantized data stored in rhs.\nFor example, if Trhs is qint8, this must be set to 127."
      }
    ],
    "inputs": [
      {
        "name": "lhs",
        "description": "Must be a 2D Tensor of Tlhs.",
        "typeAttr": "Tlhs"
      },
      {
        "name": "rhs",
        "description": "Must be a 2D Tensor of Trhs.",
        "typeAttr": "Trhs"
      },
      {
        "name": "rhs_scales",
        "description": "The float value(s) used as scale when quantizing original data that rhs represents.\nMust be a scalar Tensor (per-tensor quantization) or 1D Tensor of size (rhs.dim_size(1),) (per-channel quantization).",
        "type": 1
      },
      {
        "name": "rhs_zero_points",
        "description": "The int32 value(s) used as zero_point when quantizing original data that rhs represents.\nSame shape condition as rhs_scales.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The output 2D Tensor of Tout, whose shape is (lhs.dim_size(0), rhs.dim_size(1)).\nThe output data is the original output data itself (Not quantized).",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "UniformRequantize",
    "summary": "Given quantized tensor `input`, requantize it with new quantization parameters.",
    "description": "Given quantized tensor `input`, which was quantized using {input_scales, input_zero_points, input_quantization_axis, input_quantization_min_val, input_quantization_max_val},\nrequantize it to a tensor, which is quantized using {output_scales, output_zero_points, output_quantization_axis, output_quantization_min_val, output_quantization_max_val}.\nThe requantization is done by using the formula:\noutput_quantized_data = clip(\n  (input_quantized_data - input_zero_point) * (input_scale / output_scale) + output_zero_point,\n  output_quantization_min_val,\n  output_quantization_max_val)\n\nPer-tensor and per-axis quantization supported cases are followings:\n* per-tensor -> per-tensor\n* per-tensor -> per-axis\n* per-axis -> per-axis where input_quantization_axis equals output_quantization_axis.\ni.e. At least one among input_quantization_axis and output_quantization_axis must be -1, or two must be equal.",
    "attributes": [
      {
        "name": "Tin",
        "type": "type",
        "description": "The type of input Tensor. A tf.DType from: tf.qint8, tf.qint32 Must be one of the following: `qint8`, `qint32`."
      },
      {
        "name": "Tout",
        "type": "type",
        "description": "The type of output Tensor. A tf.DType from: tf.qint8, tf.qint32 Must be one of the following: `qint8`, `qint32`."
      },
      {
        "name": "input_quantization_axis",
        "type": "int64",
        "description": "The quantization axis that was used when quantizing original data that `input` represents.\nIndicates the dimension index of the tensor where per-axis quantization is applied for the slices along that dimension.\nIf set to -1 (default), this indicates per-tensor quantization. Otherwise, it must be set within range [0, input.dims()).",
        "default": -1
      },
      {
        "name": "input_quantization_min_val",
        "type": "int64",
        "description": "The quantization min value that was used when quantizing original data that `input` represents.\nThe purpose of this attribute is typically (but not limited to) to indicate narrow range, where this is set to:\n`(Tin lowest) + 1` if narrow range, and `(Tin lowest)` otherwise.\nFor example, if Tin is qint8, this is set to -127 if narrow range quantized or -128 if not."
      },
      {
        "name": "input_quantization_max_val",
        "type": "int64",
        "description": "The quantization max value that was used when quantizing original data that `input` represents.\nThe purpose of this attribute is typically (but not limited to) indicate narrow range, where this is set to:\n`(Tout max)` for both narrow range and not narrow range.\nFor example, if Tin is qint8, this is set to 127."
      },
      {
        "name": "output_quantization_axis",
        "type": "int64",
        "description": "The new quantization axis to use to quantize original data that `input` represents.",
        "default": -1
      },
      {
        "name": "output_quantization_min_val",
        "type": "int64",
        "description": "The new quantization min value to quantize original data that `input` represents."
      },
      {
        "name": "output_quantization_max_val",
        "type": "int64",
        "description": "The new quantization max value to quantize original data that `input` represents."
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Must be a Tensor of Tin.",
        "typeAttr": "Tin"
      },
      {
        "name": "input_scales",
        "description": "The float value(s) used as scale(s) when quantizing original data that `input` represents.\nMust be a scalar Tensor if quantization_axis is -1 (per-tensor quantization), otherwise 1D Tensor of size (input.dim_size(quantization_axis),) (per-axis quantization).",
        "type": 1
      },
      {
        "name": "input_zero_points",
        "description": "The int32 value(s) used as zero_point(s) when quantizing original data that `input` represents.\nSame shape condition as scales.",
        "type": 3
      },
      {
        "name": "output_scales",
        "description": "The float value(s) to use as new scale(s) to quantize original data that `input` represents.\nMust be a scalar Tensor if quantization_axis is -1 (per-tensor quantization), otherwise 1D Tensor of size (input.dim_size(quantization_axis),) (per-axis quantization).",
        "type": 1
      },
      {
        "name": "output_zero_points",
        "description": "The int32 value(s) to use as new zero_point(s) to quantize original data that `input` represents.\nSame shape condition as scales.",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The output quantized Tensor of Tout, whose shape is same as input.",
        "typeAttr": "Tout"
      }
    ]
  },
  {
    "name": "Unique",
    "summary": "Finds unique elements in a 1-D tensor.",
    "description": "This operation returns a tensor `y` containing all of the unique elements of `x`\nsorted in the same order that they occur in `x`; `x` does not need to be sorted.\nThis operation also returns a tensor `idx` the same size as `x` that contains\nthe index of each value of `x` in the unique output `y`. In other words:\n\n`y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`\n\nExamples:\n\n```\n# tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]\ny, idx = unique(x)\ny ==> [1, 2, 4, 7, 8]\nidx ==> [0, 0, 1, 2, 2, 2, 3, 4, 4]\n```\n\n```\n# tensor 'x' is [4, 5, 1, 2, 3, 3, 4, 5]\ny, idx = unique(x)\ny ==> [4, 5, 1, 2, 3]\nidx ==> [0, 1, 2, 3, 4, 4, 0, 1]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "out_idx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "1-D.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "description": "1-D.",
        "typeAttr": "T"
      },
      {
        "name": "idx",
        "description": "1-D.",
        "typeAttr": "out_idx"
      }
    ]
  },
  {
    "name": "UniqueDataset",
    "summary": "Creates a dataset that contains the unique elements of `input_dataset`.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "UniqueV2",
    "summary": "Finds unique elements along an axis of a tensor.",
    "description": "This operation either returns a tensor `y` containing unique elements\nalong the `axis` of a tensor. The returned unique elements is sorted\nin the same order as they occur along `axis` in `x`.\nThis operation also returns a tensor `idx` that is the same size as\nthe number of the elements in `x` along the `axis` dimension. It\ncontains the index in the unique output `y`.\nIn other words, for an `1-D` tensor `x` with `axis = None:\n\n`y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`\n\nFor example:\n\n```\n# tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]\ny, idx = unique(x)\ny ==> [1, 2, 4, 7, 8]\nidx ==> [0, 0, 1, 2, 2, 2, 3, 4, 4]\n```\n\nFor an `2-D` tensor `x` with `axis = 0`:\n\n```\n# tensor 'x' is [[1, 0, 0],\n#                [1, 0, 0],\n#                [2, 0, 0]]\ny, idx = unique(x, axis=0)\ny ==> [[1, 0, 0],\n       [2, 0, 0]]\nidx ==> [0, 0, 1]\n```\n\nFor an `2-D` tensor `x` with `axis = 1`:\n\n```\n# tensor 'x' is [[1, 0, 0],\n#                [1, 0, 0],\n#                [2, 0, 0]]\ny, idx = unique(x, axis=1)\ny ==> [[1, 0],\n       [1, 0],\n       [2, 0]]\nidx ==> [0, 1, 1]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Taxis",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      },
      {
        "name": "out_idx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "A `Tensor`.",
        "typeAttr": "T"
      },
      {
        "name": "axis",
        "description": "A `Tensor` of type `int32` (default: None). The axis of the Tensor to\nfind the unique elements.",
        "typeAttr": "Taxis"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "description": "A `Tensor`. Unique elements along the `axis` of `Tensor` x.",
        "typeAttr": "T"
      },
      {
        "name": "idx",
        "description": "A 1-D Tensor. Has the same type as x that contains the index of each\nvalue of x in the output y.",
        "typeAttr": "out_idx"
      }
    ]
  },
  {
    "name": "UniqueWithCounts",
    "summary": "Finds unique elements in a 1-D tensor.",
    "description": "This operation returns a tensor `y` containing all of the unique elements of `x`\nsorted in the same order that they occur in `x`. This operation also returns a\ntensor `idx` the same size as `x` that contains the index of each value of `x`\nin the unique output `y`. Finally, it returns a third tensor `count` that\ncontains the count of each element of `y` in `x`. In other words:\n\n`y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`\n\nFor example:\n\n```\n# tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]\ny, idx, count = unique_with_counts(x)\ny ==> [1, 2, 4, 7, 8]\nidx ==> [0, 0, 1, 2, 2, 2, 3, 4, 4]\ncount ==> [2, 1, 3, 1, 2]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "out_idx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "1-D.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "description": "1-D.",
        "typeAttr": "T"
      },
      {
        "name": "idx",
        "description": "1-D.",
        "typeAttr": "out_idx"
      },
      {
        "name": "count",
        "description": "1-D.",
        "typeAttr": "out_idx"
      }
    ]
  },
  {
    "name": "UniqueWithCountsV2",
    "summary": "Finds unique elements along an axis of a tensor.",
    "description": "This operation either returns a tensor `y` containing unique elements\nalong the `axis` of a tensor. The returned unique elements is sorted\nin the same order as they occur along `axis` in `x`.\nThis operation also returns a tensor `idx` and a tensor `count`\nthat are the same size as the number of the elements in `x` along the\n`axis` dimension. The `idx` contains the index in the unique output `y`\nand the `count` contains the count in the unique output `y`.\nIn other words, for an `1-D` tensor `x` with `axis = None:\n\n`y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`\n\nFor example:\n\n```\nx = tf.constant([1, 1, 2, 4, 4, 4, 7, 8, 8])\ny, idx, count = tf.raw_ops.UniqueWithCountsV2(x=x, axis = [0])\ny ==> [1, 2, 4, 7, 8]\nidx ==> [0, 0, 1, 2, 2, 2, 3, 4, 4]\ncount ==> [2, 1, 3, 1, 2]\n```\n\nFor a `2-D` tensor `x` with `axis = 0`:\n\n```\nx = tf.constant([[1, 0, 0],\n                [1, 0, 0],\n                [2, 0, 0]])\ny, idx, count = tf.raw_ops.UniqueWithCountsV2(x=x, axis=[0])\ny ==> [[1, 0, 0],\n       [2, 0, 0]]\nidx ==> [0, 0, 1]\ncount ==> [2, 1]\n```\n\nFor a `2-D` tensor `x` with `axis = 1`:\n\n```\nx = tf.constant([[1, 0, 0],\n                [1, 0, 0],\n                [2, 0, 0]])\ny, idx, count = tf.raw_ops.UniqueWithCountsV2(x=x, axis=[1])\ny ==> [[1, 0],\n       [1, 0],\n       [2, 0]]\nidx ==> [0, 1, 1]\ncount ==> [1, 2]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "Taxis",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 9
        }
      },
      {
        "name": "out_idx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "A `Tensor`.",
        "typeAttr": "T"
      },
      {
        "name": "axis",
        "description": "A `Tensor` of type `int32` (default: None). The axis of the Tensor to\nfind the unique elements.",
        "typeAttr": "Taxis"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "description": "A `Tensor`. Unique elements along the `axis` of `Tensor` x.",
        "typeAttr": "T"
      },
      {
        "name": "idx",
        "description": "A 1-D Tensor. Has the same type as x that contains the index of each\nvalue of x in the output y.",
        "typeAttr": "out_idx"
      },
      {
        "name": "count",
        "description": "A 1-D Tensor. The count of each value of x in the output y.",
        "typeAttr": "out_idx"
      }
    ]
  },
  {
    "name": "Unpack",
    "summary": "Unpacks a given dimension of a rank-`R` tensor into `num` rank-`(R-1)` tensors.",
    "description": "Unpacks `num` tensors from `value` by chipping it along the `axis` dimension.\nFor example, given a tensor of shape `(A, B, C, D)`;\n\nIf `axis == 0` then the i'th tensor in `output` is the slice `value[i, :, :, :]`\n  and each tensor in `output` will have shape `(B, C, D)`. (Note that the\n  dimension unpacked along is gone, unlike `split`).\n\nIf `axis == 1` then the i'th tensor in `output` is the slice `value[:, i, :, :]`\n  and each tensor in `output` will have shape `(A, C, D)`.\nEtc.\n\nThis is the opposite of `pack`.",
    "attributes": [
      {
        "name": "num",
        "type": "int64",
        "minimum": 0
      },
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "axis",
        "type": "int64",
        "description": "Dimension along which to unpack.  Negative values wrap around, so the\nvalid range is `[-R, R)`.",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "value",
        "description": "1-D or higher, with `axis` dimension size equal to `num`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "The list of tensors unpacked from `value`.",
        "numberAttr": "num",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "UnravelIndex",
    "summary": "Converts an array of flat indices into a tuple of coordinate arrays.",
    "description": "\nExample:\n\n```\ny = tf.unravel_index(indices=[2, 5, 7], dims=[3, 3])\n# 'dims' represent a hypothetical (3, 3) tensor of indices:\n# [[0, 1, *2*],\n#  [3, 4, *5*],\n#  [6, *7*, 8]]\n# For each entry from 'indices', this operation returns\n# its coordinates (marked with '*'), such as\n# 2 ==> (0, 2)\n# 5 ==> (1, 2)\n# 7 ==> (2, 1)\ny ==> [[0, 1, 2], [2, 2, 1]]\n```\n\n@compatibility(numpy)\nEquivalent to np.unravel_index\n@end_compatibility",
    "attributes": [
      {
        "name": "Tidx",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "indices",
        "description": "An 0-D or 1-D `int` Tensor whose elements are indices into the\nflattened version of an array of dimensions dims.",
        "typeAttr": "Tidx"
      },
      {
        "name": "dims",
        "description": "An 1-D `int` Tensor. The shape of the array to use for unraveling\nindices.",
        "typeAttr": "Tidx"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "An 2-D (or 1-D if indices is 0-D) tensor where each row has the\nsame shape as the indices array.",
        "typeAttr": "Tidx"
      }
    ]
  },
  {
    "name": "UnsortedSegmentJoin",
    "attributes": [
      {
        "name": "separator",
        "type": "string",
        "default": ""
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "Tnumsegments",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "type": 7
      },
      {
        "name": "segment_ids",
        "typeAttr": "Tindices"
      },
      {
        "name": "num_segments",
        "typeAttr": "Tnumsegments"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 7
      }
    ]
  },
  {
    "name": "UnsortedSegmentMax",
    "summary": "Computes the maximum along segments of a tensor.",
    "description": "Read\n[the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)\nfor an explanation of segments.\n\nThis operator is similar to `tf.math.unsorted_segment_sum`,\nInstead of computing the sum over segments, it computes the maximum such that:\n\n\\\\(output_i = \\max_{j...} data[j...]\\\\) where max is over tuples `j...` such\nthat `segment_ids[j...] == i`.\n\nIf the maximum is empty for a given segment ID `i`, it outputs the smallest\npossible value for the specific numeric type,\n`output[i] = numeric_limits<T>::lowest()`.\n\nIf the given segment ID `i` is negative, then the corresponding value is\ndropped, and will not be included in the result.\n\nCaution: On CPU, values in `segment_ids` are always validated to be less than\n`num_segments`, and an error is thrown for out-of-bound indices. On GPU, this\ndoes not throw an error for out-of-bound indices. On Gpu, out-of-bound indices\nresult in safe but unspecified behavior, which may include ignoring\nout-of-bound indices or outputting a tensor with a 0 stored in the first\ndimension of its shape if `num_segments` is 0.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/UnsortedSegmentMax.png\" alt>\n</div>\n\nFor example:\n\n>>> c = tf.constant([[1,2,3,4], [5,6,7,8], [4,3,2,1]])\n>>> tf.math.unsorted_segment_max(c, tf.constant([0, 1, 0]), num_segments=2).numpy()\narray([[4, 3, 3, 4],\n       [5,  6, 7, 8]], dtype=int32)\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "Tnumsegments",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "data",
        "typeAttr": "T"
      },
      {
        "name": "segment_ids",
        "description": "A tensor whose shape is a prefix of `data.shape`.\nThe values must be less than `num_segments`.\n\nCaution: The values are always validated to be in range on CPU, never validated\non GPU.",
        "typeAttr": "Tindices"
      },
      {
        "name": "num_segments",
        "typeAttr": "Tnumsegments"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Has same shape as data, except for the first `segment_ids.rank`\ndimensions, which are replaced with a single dimension which has size\n`num_segments`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "UnsortedSegmentMin",
    "summary": "Computes the minimum along segments of a tensor.",
    "description": "Read\n[the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)\nfor an explanation of segments.\n\nThis operator is similar to `tf.math.unsorted_segment_sum`,\nInstead of computing the sum over segments, it computes the minimum such that:\n\n\\\\(output_i = \\min_{j...} data_[j...]\\\\) where min is over tuples `j...` such\nthat `segment_ids[j...] == i`.\n\nIf the minimum is empty for a given segment ID `i`, it outputs the largest\npossible value for the specific numeric type,\n`output[i] = numeric_limits<T>::max()`.\n\nFor example:\n\n>>> c = tf.constant([[1,2,3,4], [5,6,7,8], [4,3,2,1]])\n>>> tf.math.unsorted_segment_min(c, tf.constant([0, 1, 0]), num_segments=2).numpy()\narray([[1, 2, 2, 1],\n       [5, 6, 7, 8]], dtype=int32)\n\nIf the given segment ID `i` is negative, then the corresponding value is\ndropped, and will not be included in the result.\n\nCaution: On CPU, values in `segment_ids` are always validated to be less than\n`num_segments`, and an error is thrown for out-of-bound indices. On GPU, this\ndoes not throw an error for out-of-bound indices. On Gpu, out-of-bound indices\nresult in safe but unspecified behavior, which may include ignoring\nout-of-bound indices or outputting a tensor with a 0 stored in the first\ndimension of its shape if `num_segments` is 0.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "Tnumsegments",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "data",
        "typeAttr": "T"
      },
      {
        "name": "segment_ids",
        "description": "A tensor whose shape is a prefix of `data.shape`.\nThe values must be less than `num_segments`.\n\nCaution: The values are always validated to be in range on CPU, never validated\non GPU.",
        "typeAttr": "Tindices"
      },
      {
        "name": "num_segments",
        "typeAttr": "Tnumsegments"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Has same shape as data, except for the first `segment_ids.rank`\ndimensions, which are replaced with a single dimension which has size\n`num_segments`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "UnsortedSegmentProd",
    "summary": "Computes the product along segments of a tensor.",
    "description": "Read\n[the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)\nfor an explanation of segments.\n\nThis operator is similar to `tf.math.unsorted_segment_sum`,\nInstead of computing the sum over segments, it computes the product of all\nentries belonging to a segment such that:\n\n\\\\(output_i = \\prod_{j...} data[j...]\\\\) where the product is over tuples\n`j...` such that `segment_ids[j...] == i`.\n\nFor example:\n\n>>> c = tf.constant([[1,2,3,4], [5,6,7,8], [4,3,2,1]])\n>>> tf.math.unsorted_segment_prod(c, tf.constant([0, 1, 0]), num_segments=2).numpy()\narray([[4, 6, 6, 4],\n       [5, 6, 7, 8]], dtype=int32)\n\nIf there is no entry for a given segment ID `i`, it outputs 1.\n\nIf the given segment ID `i` is negative, then the corresponding value is\ndropped, and will not be included in the result.\nCaution: On CPU, values in `segment_ids` are always validated to be less than\n`num_segments`, and an error is thrown for out-of-bound indices. On GPU, this\ndoes not throw an error for out-of-bound indices. On Gpu, out-of-bound indices\nresult in safe but unspecified behavior, which may include ignoring\nout-of-bound indices or outputting a tensor with a 0 stored in the first\ndimension of its shape if `num_segments` is 0.\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`."
      },
      {
        "name": "Tnumsegments",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "data",
        "typeAttr": "T"
      },
      {
        "name": "segment_ids",
        "description": "A tensor whose shape is a prefix of `data.shape`.\nThe values must be less than `num_segments`.\n\nCaution: The values are always validated to be in range on CPU, never validated\non GPU.",
        "typeAttr": "Tindices"
      },
      {
        "name": "num_segments",
        "typeAttr": "Tnumsegments"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Has same shape as data, except for the first `segment_ids.rank`\ndimensions, which are replaced with a single dimension which has size\n`num_segments`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "UnsortedSegmentSum",
    "summary": "Computes the sum along segments of a tensor.",
    "description": "Read\n[the section on segmentation](https://tensorflow.org/api_docs/python/tf/math#Segmentation)\nfor an explanation of segments.\n\nComputes a tensor such that\n\\\\(output[i] = \\sum_{j...} data[j...]\\\\) where the sum is over tuples `j...` such\nthat `segment_ids[j...] == i`.  Unlike `SegmentSum`, `segment_ids`\nneed not be sorted and need not cover all values in the full\nrange of valid values.\n\nIf the sum is empty for a given segment ID `i`, `output[i] = 0`.\nIf the given segment ID `i` is negative, the value is dropped and will not be\nadded to the sum of the segment.\n\n`num_segments` should equal the number of distinct segment IDs.\n\nCaution: On CPU, values in `segment_ids` are always validated to be less than\n`num_segments`, and an error is thrown for out-of-bound indices. On GPU, this\ndoes not throw an error for out-of-bound indices. On Gpu, out-of-bound indices\nresult in safe but unspecified behavior, which may include ignoring\nout-of-bound indices or outputting a tensor with a 0 stored in the first\ndimension of its shape if `num_segments` is 0.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/UnsortedSegmentSum.png\" alt>\n</div>\n\n>>> c = [[1,2,3,4], [5,6,7,8], [4,3,2,1]]\n>>> tf.math.unsorted_segment_sum(c, [0, 1, 0], num_segments=2).numpy()\narray([[5, 5, 5, 5],\n       [5, 6, 7, 8]], dtype=int32)\n\n",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`."
      },
      {
        "name": "Tindices",
        "type": "type",
        "description": "Must be one of the following: `int16`, `int32`, `int64`."
      },
      {
        "name": "Tnumsegments",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "data",
        "typeAttr": "T"
      },
      {
        "name": "segment_ids",
        "description": "A tensor whose shape is a prefix of `data.shape`.\nThe values must be less than `num_segments`.\n\nCaution: The values are always validated to be in range on CPU, never validated\non GPU.",
        "typeAttr": "Tindices"
      },
      {
        "name": "num_segments",
        "typeAttr": "Tnumsegments"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Has same shape as data, except for the first `segment_ids.rank`\ndimensions, which are replaced with a single dimension which has size\n`num_segments`.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Unstage",
    "summary": "Op is similar to a lightweight Dequeue.",
    "description": "The basic functionality is similar to dequeue with many fewer\ncapabilities and options.  This Op is optimized for performance.",
    "attributes": [
      {
        "name": "capacity",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "memory_limit",
        "type": "int64",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "dtypes",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "values",
        "typeListAttr": "dtypes"
      }
    ]
  },
  {
    "name": "UnwrapDatasetVariant",
    "inputs": [
      {
        "name": "input_handle",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "output_handle",
        "type": 21
      }
    ]
  },
  {
    "name": "UpperBound",
    "summary": "Applies upper_bound(sorted_search_values, values) along each row.",
    "description": "Each set of rows with the same index in (sorted_inputs, values) is treated\nindependently.  The resulting row is the equivalent of calling\n`np.searchsorted(sorted_inputs, values, side='right')`.\n\nThe result is not a global index to the entire\n`Tensor`, but rather just the index in the last dimension.\n\nA 2-D example:\n  sorted_sequence = [[0, 3, 9, 9, 10],\n                     [1, 2, 3, 4, 5]]\n  values = [[2, 4, 9],\n            [0, 2, 6]]\n\n  result = UpperBound(sorted_sequence, values)\n\n  result == [[1, 2, 4],\n             [0, 2, 5]]",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "sorted_inputs",
        "description": "2-D Tensor where each row is ordered.",
        "typeAttr": "T"
      },
      {
        "name": "values",
        "description": "2-D Tensor with the same numbers of rows as `sorted_search_values`. Contains\nthe values that will be searched for in `sorted_search_values`.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A `Tensor` with the same shape as `values`.  It contains the last scalar index\ninto the last dimension where values can be inserted without changing the\nordered property.",
        "typeAttr": "out_type"
      }
    ]
  },
  {
    "name": "VarHandleOp",
    "summary": "Creates a handle to a Variable resource.",
    "attributes": [
      {
        "name": "container",
        "type": "string",
        "description": "the container this variable is placed in.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "the name by which this variable is referred to.",
        "default": ""
      },
      {
        "name": "debug_name",
        "type": "string",
        "description": "the user-given name, which still applies in anonymous mode.",
        "default": ""
      },
      {
        "name": "dtype",
        "type": "type",
        "description": "the type of this variable. Must agree with the dtypes\nof all ops using this variable."
      },
      {
        "name": "shape",
        "type": "shape",
        "description": "The (possibly partially specified) shape of this variable."
      },
      {
        "name": "allowed_devices",
        "type": "string[]",
        "description": "DEPRECATED. The allowed devices containing the resource variable. Set when the\noutput ResourceHandle represents a per-replica/partitioned resource variable.",
        "default": []
      }
    ],
    "outputs": [
      {
        "name": "resource",
        "type": 20
      }
    ]
  },
  {
    "name": "VarIsInitializedOp",
    "summary": "Checks whether a resource handle-based variable has been initialized.",
    "inputs": [
      {
        "name": "resource",
        "description": "the input resource handle.",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "is_initialized",
        "description": "a scalar boolean which is true if the variable has been\ninitialized.",
        "type": 10
      }
    ]
  },
  {
    "name": "Variable",
    "category": "Control",
    "summary": "Use VariableV2 instead.",
    "attributes": [
      {
        "name": "shape",
        "type": "shape"
      },
      {
        "name": "dtype",
        "type": "type"
      },
      {
        "name": "container",
        "type": "string",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "ref",
        "typeAttr": "dtype",
        "isRef": true
      }
    ]
  },
  {
    "name": "VariableShape",
    "summary": "Returns the shape of the variable pointed to by `resource`.",
    "description": "This operation returns a 1-D integer tensor representing the shape of `input`.\n\nFor example:\n\n```\n# 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]\nshape(t) ==> [2, 2, 3]\n```",
    "attributes": [
      {
        "name": "out_type",
        "type": "type",
        "description": "Must be one of the following: `int32`, `int64`.",
        "default": {
          "type": "type",
          "value": 3
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "type": 20
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "out_type"
      }
    ]
  },
  {
    "name": "VariableV2",
    "category": "Control",
    "summary": "Holds state in the form of a tensor that persists across steps.",
    "description": "Outputs a ref to the tensor state so it may be read or modified.\nTODO(zhifengc/mrry): Adds a pointer to a more detail document\nabout sharing states in tensorflow.",
    "attributes": [
      {
        "name": "shape",
        "type": "shape",
        "description": "The shape of the variable tensor."
      },
      {
        "name": "dtype",
        "type": "type",
        "description": "The type of elements in the variable tensor."
      },
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this variable is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this variable is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "ref",
        "description": "A reference to the variable tensor.",
        "typeAttr": "dtype",
        "isRef": true
      }
    ]
  },
  {
    "name": "WeightedFlatMapDataset",
    "attributes": [
      {
        "name": "N",
        "type": "int64",
        "minimum": 2
      },
      {
        "name": "M",
        "type": "int64",
        "minimum": 2
      },
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_datasets",
        "numberAttr": "N",
        "type": 21
      },
      {
        "name": "weights",
        "numberAttr": "M",
        "type": 2
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "Where",
    "summary": "Returns locations of nonzero / true values in a tensor.",
    "description": "This operation returns the coordinates of true elements in `input`. The\ncoordinates are returned in a 2-D tensor where the first dimension (rows)\nrepresents the number of true elements, and the second dimension (columns)\nrepresents the coordinates of the true elements. Keep in mind, the shape of\nthe output tensor can vary depending on how many true values there are in\n`input`. Indices are output in row-major order.\n\nFor example:\n\n```\n# 'input' tensor is [[True, False]\n#                    [True, False]]\n# 'input' has two true values, so output has two coordinates.\n# 'input' has rank of 2, so coordinates have two indices.\nwhere(input) ==> [[0, 0],\n                  [1, 0]]\n\n# `input` tensor is [[[True, False]\n#                     [True, False]]\n#                    [[False, True]\n#                     [False, True]]\n#                    [[False, False]\n#                     [False, True]]]\n# 'input' has 5 true values, so output has 5 coordinates.\n# 'input' has rank of 3, so coordinates have three indices.\nwhere(input) ==> [[0, 0, 0],\n                  [0, 1, 0],\n                  [1, 0, 1],\n                  [1, 1, 1],\n                  [2, 1, 1]]\n\n# `input` tensor is [[[1.5,  0.0]\n#                     [-0.5, 0.0]]\n#                    [[0.0,  0.25]\n#                     [0.0,  0.75]]\n#                    [[0.0,  0.0]\n#                     [0.0,  0.01]]]\n# 'input' has 5 nonzero values, so output has 5 coordinates.\n# 'input' has rank of 3, so coordinates have three indices.\nwhere(input) ==> [[0, 0, 0],\n                  [0, 1, 0],\n                  [1, 0, 1],\n                  [1, 1, 1],\n                  [2, 1, 1]]\n\n# `input` tensor is [[[1.5 + 0.0j, 0.0  + 0.0j]\n#                     [0.0 + 0.5j, 0.0  + 0.0j]]\n#                    [[0.0 + 0.0j, 0.25 + 1.5j]\n#                     [0.0 + 0.0j, 0.75 + 0.0j]]\n#                    [[0.0 + 0.0j, 0.0  + 0.0j]\n#                     [0.0 + 0.0j, 0.01 + 0.0j]]]\n# 'input' has 5 nonzero magnitude values, so output has 5 coordinates.\n# 'input' has rank of 3, so coordinates have three indices.\nwhere(input) ==> [[0, 0, 0],\n                  [0, 1, 0],\n                  [1, 0, 1],\n                  [1, 1, 1],\n                  [2, 1, 1]]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `float16`, `uint32`, `uint64`, `bool`.",
        "default": {
          "type": "type",
          "value": 10
        }
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "index",
        "type": 9
      }
    ]
  },
  {
    "name": "While",
    "summary": "output = input; While (Cond(output)) { output = Body(output) }",
    "attributes": [
      {
        "name": "T",
        "type": "type[]",
        "description": "dtype in use.",
        "minimum": 0
      },
      {
        "name": "cond",
        "type": "function",
        "description": "      A function takes 'input' and returns a tensor.  If the tensor is\n      a scalar of non-boolean, the scalar is converted to a boolean\n      according to the following rule: if the scalar is a numerical\n      value, non-zero means True and zero means False; if the scalar is\n      a string, non-empty means True and empty means False. If the\n      tensor is not a scalar, non-emptiness means True and False\n      otherwise."
      },
      {
        "name": "body",
        "type": "function",
        "description": "      A function that takes a list of tensors and returns another\n      list of tensors. Both lists have the same types as specified\n      by T."
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "default": []
      },
      {
        "name": "parallel_iterations",
        "type": "int64",
        "default": 10
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "A list of input tensors whose types are T.",
        "typeListAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "A list of output tensors whose types are T.",
        "typeListAttr": "T"
      }
    ]
  },
  {
    "name": "WholeFileReader",
    "summary": "A Reader that outputs the entire contents of a file as a value.",
    "description": "To use, enqueue filenames in a Queue.  The output of ReaderRead will\nbe a filename (key) and the contents of that file (value).",
    "attributes": [
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "reader_handle",
        "description": "The handle to reference the Reader.",
        "type": 7,
        "isRef": true
      }
    ]
  },
  {
    "name": "WholeFileReaderV2",
    "summary": "A Reader that outputs the entire contents of a file as a value.",
    "description": "To use, enqueue filenames in a Queue.  The output of ReaderRead will\nbe a filename (key) and the contents of that file (value).",
    "attributes": [
      {
        "name": "container",
        "type": "string",
        "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
        "default": ""
      },
      {
        "name": "shared_name",
        "type": "string",
        "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
        "default": ""
      }
    ],
    "outputs": [
      {
        "name": "reader_handle",
        "description": "The handle to reference the Reader.",
        "type": 20
      }
    ]
  },
  {
    "name": "WindowDataset",
    "summary": "  Combines (nests of) input elements into a dataset of (nests of) windows.\n\n  A \"window\" is a finite dataset of flat elements of size `size` (or possibly\n  fewer if there are not enough input elements to fill the window and\n  `drop_remainder` evaluates to false).\n\n  The `shift` argument determines the number of input elements by which\n  the window moves on each iteration.  The first element in the `k`th window\n  will be element\n\n  ```\n  1 + (k-1) * shift\n  ```\n\n  of the input dataset. In particular, the first element of the first window\n  will always be the first element of the input dataset.  \n\n  If the `stride` parameter is greater than 1, then each window will skip\n  `(stride - 1)` input elements between each element that appears in the\n  window. Output windows will still contain `size` elements regardless of\n  the value of `stride`.\n\n  The `stride` argument determines the stride of the input elements, and the\n  `shift` argument determines the shift of the window.\n\n  For example, letting `{...}` to represent a Dataset:\n\n  - `tf.data.Dataset.range(7).window(2)` produces\n    `{{0, 1}, {2, 3}, {4, 5}, {6}}`\n  - `tf.data.Dataset.range(7).window(3, 2, 1, True)` produces\n    `{{0, 1, 2}, {2, 3, 4}, {4, 5, 6}}`\n  - `tf.data.Dataset.range(7).window(3, 1, 2, True)` produces\n    `{{0, 2, 4}, {1, 3, 5}, {2, 4, 6}}`\n\n  Note that when the `window` transformation is applied to a dataset of\n  nested elements, it produces a dataset of nested windows.\n\n  For example:\n\n  - `tf.data.Dataset.from_tensor_slices((range(4), range(4))).window(2)`\n    produces `{({0, 1}, {0, 1}), ({2, 3}, {2, 3})}`\n  - `tf.data.Dataset.from_tensor_slices({\"a\": range(4)}).window(2)`\n    produces `{{\"a\": {0, 1}}, {\"a\": {2, 3}}}`",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_dataset",
        "type": 21
      },
      {
        "name": "size",
        "description": "An integer scalar, representing the number of elements\nof the input dataset to combine into a window. Must be positive.",
        "type": 9
      },
      {
        "name": "shift",
        "description": "An integer scalar, representing the number of input elements\nby which the window moves in each iteration.  Defaults to `size`.\nMust be positive.",
        "type": 9
      },
      {
        "name": "stride",
        "description": "An integer scalar, representing the stride of the input elements\nin the sliding window. Must be positive. The default value of 1 means\n\"retain every input element\".",
        "type": 9
      },
      {
        "name": "drop_remainder",
        "description": "A Boolean scalar, representing whether the last window should be\ndropped if its size is smaller than `window_size`.",
        "type": 10
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "WindowOp",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "Tinputs",
        "type": "type[]",
        "minimum": 1
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "typeListAttr": "Tinputs"
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  },
  {
    "name": "WorkerHeartbeat",
    "summary": "Worker heartbeat op.",
    "description": "Heartbeats may be sent periodically to indicate the coordinator is still active,\nto retrieve the current worker status and to expedite shutdown when necessary.",
    "inputs": [
      {
        "name": "request",
        "description": "A string tensor containing a serialized WorkerHeartbeatRequest",
        "type": 7
      }
    ],
    "outputs": [
      {
        "name": "response",
        "description": "A string tensor containing a serialized WorkerHeartbeatResponse",
        "type": 7
      }
    ]
  },
  {
    "name": "WrapDatasetVariant",
    "inputs": [
      {
        "name": "input_handle",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "output_handle",
        "type": 21
      }
    ]
  },
  {
    "name": "WriteAudioSummary",
    "summary": "Writes an audio summary.",
    "description": "Writes encoded audio summary `tensor` at `step` with `tag` using summary `writer`.\n`sample_rate` is the audio sample rate is Hz.",
    "attributes": [
      {
        "name": "max_outputs",
        "type": "int64",
        "minimum": 1,
        "default": 3
      }
    ],
    "inputs": [
      {
        "name": "writer",
        "type": 20
      },
      {
        "name": "step",
        "type": 9
      },
      {
        "name": "tag",
        "type": 7
      },
      {
        "name": "tensor",
        "type": 1
      },
      {
        "name": "sample_rate",
        "type": 1
      }
    ]
  },
  {
    "name": "WriteFile",
    "summary": "Writes `contents` to the file at input `filename`.",
    "description": "Creates the file and recursively creates directory if it does not exist.",
    "inputs": [
      {
        "name": "filename",
        "description": "scalar. The name of the file to which we write the contents.",
        "type": 7
      },
      {
        "name": "contents",
        "description": "scalar. The content to be written to the output file.",
        "type": 7
      }
    ]
  },
  {
    "name": "WriteGraphSummary",
    "summary": "Writes a graph summary.",
    "description": "Writes TensorFlow graph `tensor` at `step` using summary `writer`.",
    "inputs": [
      {
        "name": "writer",
        "type": 20
      },
      {
        "name": "step",
        "type": 9
      },
      {
        "name": "tensor",
        "type": 7
      }
    ]
  },
  {
    "name": "WriteHistogramSummary",
    "summary": "Writes a histogram summary.",
    "description": "Writes histogram `values` at `step` with `tag` using summary `writer`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`, `bool`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "writer",
        "type": 20
      },
      {
        "name": "step",
        "type": 9
      },
      {
        "name": "tag",
        "type": 7
      },
      {
        "name": "values",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "WriteImageSummary",
    "summary": "Writes an image summary.",
    "description": "Writes image `tensor` at `step` with `tag` using summary `writer`.\n`tensor` is image with shape [height, width, channels].",
    "attributes": [
      {
        "name": "max_images",
        "type": "int64",
        "minimum": 1,
        "default": 3
      },
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `uint8`, `float64`, `float32`, `float16`.",
        "default": {
          "type": "type",
          "value": 1
        }
      }
    ],
    "inputs": [
      {
        "name": "writer",
        "type": 20
      },
      {
        "name": "step",
        "type": 9
      },
      {
        "name": "tag",
        "type": 7
      },
      {
        "name": "tensor",
        "typeAttr": "T"
      },
      {
        "name": "bad_color",
        "type": 4
      }
    ]
  },
  {
    "name": "WriteRawProtoSummary",
    "summary": "Writes a serialized proto summary.",
    "description": "Writes `tensor`, a serialized proto at `step` using summary `writer`.",
    "inputs": [
      {
        "name": "writer",
        "type": 20
      },
      {
        "name": "step",
        "type": 9
      },
      {
        "name": "tensor",
        "type": 7
      }
    ]
  },
  {
    "name": "WriteScalarSummary",
    "summary": "Writes a scalar summary.",
    "description": "Writes scalar `value` at `step` with `tag` using summary `writer`.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `float16`, `uint32`, `uint64`."
      }
    ],
    "inputs": [
      {
        "name": "writer",
        "type": 20
      },
      {
        "name": "step",
        "type": 9
      },
      {
        "name": "tag",
        "type": 7
      },
      {
        "name": "value",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "WriteSummary",
    "summary": "Writes a tensor summary.",
    "description": "Writes `tensor` at `step` with `tag` using summary `writer`.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "writer",
        "type": 20
      },
      {
        "name": "step",
        "type": 9
      },
      {
        "name": "tensor",
        "typeAttr": "T"
      },
      {
        "name": "tag",
        "type": 7
      },
      {
        "name": "summary_metadata",
        "type": 7
      }
    ]
  },
  {
    "name": "Xdivy",
    "summary": "Returns 0 if x == 0, and x / y otherwise, elementwise.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "XlaConcatND",
    "summary": "Concats input tensor across all dimensions.",
    "description": "An op which merges slices the input tensor based on the given num_splits\nattribute, strips paddings optionally, and returns the merged tensor without\npaddings.\n\nThis op may be generated via the TPU bridge.\n\nFor example, with `input` tensor:\n```\n[[0, 1],\n [4, 5]]\n[[2, 3],\n [6, 7]]\n[[8, 9],\n [12, 13]]\n[[10, 11],\n [14, 15]]\n```\n`num_splits`:\n```\n[2, 2]\n```\nand `paddings`:\n```\n[1, 1]\n```\nthe expected `outputs` is:\n```\n[[0, 1, 2],\n [4, 5, 6],\n [8, 9, 10]]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "num_concats",
        "type": "int64[]",
        "description": "Number of ways to merge per dimension."
      },
      {
        "name": "paddings",
        "type": "int64[]",
        "description": "Optional list of right paddings per dimension to strip from the final merged\ntensor. These paddings must not exceed the dimension size of the merged result\nprior to stripping paddings.",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "description": "Input tensor slices in row-major order to merge across all dimensions. All\ninputs must have the same shape.",
        "numberAttr": "N",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Output tensor formed from merging input slices based on num_concats defined.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "XlaHostCompute",
    "summary": "A pseudo-op to represent host-side computation in an XLA program.",
    "attributes": [
      {
        "name": "Tinputs",
        "type": "type[]",
        "description": "The element types of each element in `inputs`.",
        "minimum": 0
      },
      {
        "name": "Toutputs",
        "type": "type[]",
        "description": "The element types of each element in `outputs`.",
        "minimum": 0
      },
      {
        "name": "ancestors",
        "type": "string[]",
        "description": "A list of names of HostCompute computations that must be\nsequenced before this computation.",
        "minimum": 0
      },
      {
        "name": "shapes",
        "type": "shape[]",
        "description": "If shape_inference_graph is empty, a list of the shapes of `outputs`.",
        "minimum": 0
      },
      {
        "name": "shape_inference_graph",
        "type": "function",
        "description": "If non-empty, a serialized GraphDef representing a graph\nthat must be analyzed at compile time to determine the shapes of the outputs."
      },
      {
        "name": "key",
        "type": "string",
        "description": "A unique identifier for this region used to match up host transfers."
      },
      {
        "name": "send_key",
        "type": "string",
        "default": ""
      },
      {
        "name": "recv_key",
        "type": "string",
        "default": ""
      },
      {
        "name": "cost_estimate_ns",
        "type": "int64",
        "description": "Estimated duration of the host computation in nanoseconds.",
        "default": 1000000
      },
      {
        "name": "tpu_core",
        "type": "int64",
        "description": "Default core to use for host to device transfers.",
        "default": 0
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "description": "A list of tensors that will be sent to the host.",
        "typeListAttr": "Tinputs"
      }
    ],
    "outputs": [
      {
        "name": "outputs",
        "description": "A list of tensors that will be returned to the device.",
        "typeListAttr": "Toutputs"
      }
    ]
  },
  {
    "name": "XlaRecvFromHost",
    "summary": "An op to receive a tensor from the host.",
    "description": "output: the tensor that will be received from the host.\nToutput: element type for output.\nshape: shape for output.\nkey: A unique identifier for this region used to match up host transfers.",
    "attributes": [
      {
        "name": "Toutput",
        "type": "type"
      },
      {
        "name": "shape",
        "type": "shape"
      },
      {
        "name": "key",
        "type": "string"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "typeAttr": "Toutput"
      }
    ]
  },
  {
    "name": "XlaRecvTPUEmbeddingActivations",
    "summary": "An op that receives embedding activations on the TPU.",
    "description": "The TPU system performs the embedding lookups and aggregations. The results of\nthese aggregations are visible to the Tensorflow Graph as the outputs of a\nXlaRecvTPUEmbeddingActivations Op. This op returns a list containing one\nTensor of activations per table specified in the model.",
    "attributes": [
      {
        "name": "num_tables",
        "type": "int64",
        "description": "The number of output activation tensors. If feature descriptor is\npresent in the tpu embedding config, it is equal to the number of features\notherwise equal to number of embedding tables in the model.",
        "minimum": 1
      },
      {
        "name": "config",
        "type": "string",
        "description": "Serialized TPUEmbeddingConfiguration proto."
      }
    ],
    "inputs": [
      {
        "name": "deduplication_data",
        "description": "A Tensor with type=DT_VARIANT containing the deduplication\ndata. The tensor is an XLA nested tuple containing N elements (where N is\nthe ratio of the number of embedding to tensor cores per TPU chip). Each\nelement of the nested tuple is a tuple of rank 1 tensors. Each tensor either\ncontains indices (DT_UINT32) for embedding lookup on the TensorCore or\nweights (DT_FLOAT) to apply to the output of the embedding lookup operation.",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "outputs",
        "description": "A TensorList of embedding activations containing one Tensor per\nembedding table in the model.",
        "numberAttr": "num_tables",
        "type": 1
      }
    ]
  },
  {
    "name": "XlaRecvTPUEmbeddingActivationsV2",
    "summary": "An op that receives embedding activations on the TPU.",
    "description": "The TPU system performs the embedding lookups and aggregations. The results of\nthese aggregations are visible to the Tensorflow Graph as the outputs of a\nXlaRecvTPUEmbeddingActivations Op. This op returns a list containing one\nTensor of activations per table specified in the model.",
    "attributes": [
      {
        "name": "num_tables",
        "type": "int64",
        "description": "The number of output activation tensors. If feature descriptor is\npresent in the tpu embedding config, it is equal to the number of features\notherwise equal to number of embedding tables in the model.",
        "minimum": 1
      },
      {
        "name": "config",
        "type": "string",
        "description": "Serialized TPUEmbeddingConfiguration proto."
      },
      {
        "name": "embedding_partitions",
        "type": "string",
        "description": "Serialized EmbeddingPartitionsProto proto."
      },
      {
        "name": "hbm_buffers_config",
        "type": "string",
        "description": "Serialized HbmBuffersConfig proto."
      },
      {
        "name": "tpu_topology",
        "type": "string",
        "description": "Serialized TpuTopologyArgsProto proto."
      }
    ],
    "inputs": [
      {
        "name": "deduplication_data",
        "description": "A Tensor with type=DT_VARIANT containing the deduplication\ndata. The tensor is an XLA nested tuple containing N elements (where N is\nthe ratio of the number of embedding to tensor cores per TPU chip). Each\nelement of the nested tuple is a tuple of rank 1 tensors. Each tensor either\ncontains indices (DT_UINT32) for embedding lookup on the TensorCore or\nweights (DT_FLOAT) to apply to the output of the embedding lookup operation.",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "outputs",
        "description": "A TensorList of embedding activations containing one Tensor per\nembedding table in the model.",
        "numberAttr": "num_tables",
        "type": 1
      }
    ]
  },
  {
    "name": "XlaRecvTPUEmbeddingDeduplicationData",
    "summary": "Receives deduplication data (indices and weights) from the embedding core.",
    "description": "The deduplication data is a Tensor with type=DT_VARIANT. The tensor itself is an\nXLA nested tuple containing N elements (where N is the ratio of the number of\nembedding to tensor cores per TPU chip). Each element of the nested tuple is a\ntuple of rank 1 tensors. Each tensor either contains indices (DT_UINT32) for\nembedding lookup on the TensorCore or weights (DT_FLOAT) to apply to the output\nof the embedding lookup operation.",
    "attributes": [
      {
        "name": "config",
        "type": "string",
        "description": "Serialized TPUEmbeddingConfiguration proto."
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 21
      }
    ]
  },
  {
    "name": "XlaRecvTPUEmbeddingDeduplicationDataV2",
    "summary": "Receives deduplication data (indices and weights) from the embedding core.",
    "description": "The deduplication data is a Tensor with type=DT_VARIANT. The tensor itself is an\nXLA nested tuple containing N elements (where N is the ratio of the number of\nembedding to tensor cores per TPU chip). Each element of the nested tuple is a\ntuple of rank 1 tensors. Each tensor either contains indices (DT_UINT32) for\nembedding lookup on the TensorCore or weights (DT_FLOAT) to apply to the output\nof the embedding lookup operation.",
    "attributes": [
      {
        "name": "config",
        "type": "string",
        "description": "Serialized TPUEmbeddingConfiguration proto."
      },
      {
        "name": "embedding_partitions",
        "type": "string",
        "description": "Serialized EmbeddingPartitionsProto proto."
      },
      {
        "name": "hbm_buffers_config",
        "type": "string",
        "description": "Serialized HbmBuffersConfig proto."
      },
      {
        "name": "tpu_topology",
        "type": "string",
        "description": "Serialized TpuTopologyArgsProto proto."
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": 21
      }
    ]
  },
  {
    "name": "XlaSendTPUEmbeddingGradients",
    "summary": "An op that performs gradient updates of embedding tables.",
    "description": "The gradients argument is a TensorList having the same length and shapes as the\nreturn value of XlaRecvTPUEmbeddingActivations, but contains gradients of the\nmodel's loss with respect to the embedding activations. The embedding tables are\nupdated from these gradients via the optimizer specified in the\nTPUEmbeddingConfiguration proto given to tpu.initialize_system.",
    "attributes": [
      {
        "name": "NumTables",
        "type": "int64",
        "description": "number of tables",
        "minimum": 1
      },
      {
        "name": "NumLearningRateTags",
        "type": "int64",
        "description": "number of learning rate tags",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "config",
        "type": "string",
        "description": "Serialized TPUEmbeddingConfiguration proto."
      }
    ],
    "inputs": [
      {
        "name": "gradients",
        "description": "A TensorList of gradients with which to update embedding tables.",
        "numberAttr": "NumTables",
        "type": 1
      },
      {
        "name": "learning_rates",
        "description": "A TensorList of learning rates used for updating the embedding\ntables via the optimizer. The length of the TensorList must be equal to the\nnumber of dynamic learning rate tags specified in the\nTPUEmbeddingConfiguration proto.",
        "numberAttr": "NumLearningRateTags",
        "type": 1
      },
      {
        "name": "deduplication_data",
        "description": "A Tensor with type=DT_VARIANT containing the deduplication\ndata. The tensor is an XLA nested tuple containing N elements (where N is\nthe ratio of the number of embedding to tensor cores per TPU chip). Each\nelement of the nested tuple is a tuple of rank 1 tensors. Each tensor either\ncontains indices (DT_UINT32) for embedding lookup on the TensorCore or\nweights (DT_FLOAT) to apply to the output of the embedding lookup operation.",
        "type": 21
      }
    ]
  },
  {
    "name": "XlaSendTPUEmbeddingGradientsV2",
    "summary": "An op that performs gradient updates of embedding tables.",
    "description": "The gradients argument is a TensorList having the same length and shapes as the\nreturn value of XlaRecvTPUEmbeddingActivations, but contains gradients of the\nmodel's loss with respect to the embedding activations. The embedding tables are\nupdated from these gradients via the optimizer specified in the\nTPUEmbeddingConfiguration proto given to tpu.initialize_system.",
    "attributes": [
      {
        "name": "NumTables",
        "type": "int64",
        "description": "number of tables",
        "minimum": 1
      },
      {
        "name": "NumLearningRateTags",
        "type": "int64",
        "description": "number of learning rate tags",
        "minimum": 0,
        "default": 0
      },
      {
        "name": "config",
        "type": "string",
        "description": "Serialized TPUEmbeddingConfiguration proto."
      },
      {
        "name": "embedding_partitions",
        "type": "string",
        "description": "Serialized EmbeddingPartitionsProto proto."
      },
      {
        "name": "hbm_buffers_config",
        "type": "string",
        "description": "Serialized HbmBuffersConfig proto."
      },
      {
        "name": "tpu_topology",
        "type": "string",
        "description": "Serialized TpuTopologyArgsProto proto."
      }
    ],
    "inputs": [
      {
        "name": "gradients",
        "description": "A TensorList of gradients with which to update embedding tables.",
        "numberAttr": "NumTables",
        "type": 1
      },
      {
        "name": "learning_rates",
        "description": "A TensorList of learning rates used for updating the embedding\ntables via the optimizer. The length of the TensorList must be equal to the\nnumber of dynamic learning rate tags specified in the\nTPUEmbeddingConfiguration proto.",
        "numberAttr": "NumLearningRateTags",
        "type": 1
      },
      {
        "name": "deduplication_data",
        "description": "A Tensor with type=DT_VARIANT containing the deduplication\ndata. The tensor is an XLA nested tuple containing N elements (where N is\nthe ratio of the number of embedding to tensor cores per TPU chip). Each\nelement of the nested tuple is a tuple of rank 1 tensors. Each tensor either\ncontains indices (DT_UINT32) for embedding lookup on the TensorCore or\nweights (DT_FLOAT) to apply to the output of the embedding lookup operation.",
        "type": 21
      }
    ]
  },
  {
    "name": "XlaSendToHost",
    "summary": "An op to send a tensor to the host.",
    "description": "input: the tensor that will be sent to the host.\nTinput: element type for input.\nkey: A unique identifier for this region used to match up host transfers.",
    "attributes": [
      {
        "name": "Tinput",
        "type": "type"
      },
      {
        "name": "key",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "name": "input",
        "typeAttr": "Tinput"
      }
    ]
  },
  {
    "name": "XlaSparseCoreAdagrad",
    "attributes": [
      {
        "name": "feature_width",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "name": "indices",
        "type": 3
      },
      {
        "name": "gradient",
        "type": 1
      },
      {
        "name": "learning_rate",
        "type": 1
      },
      {
        "name": "accumulator",
        "type": 1
      },
      {
        "name": "embedding_table",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "updated_embedding_table",
        "type": 1
      },
      {
        "name": "updated_accumulator",
        "type": 1
      }
    ]
  },
  {
    "name": "XlaSparseCoreAdagradMomentum",
    "attributes": [
      {
        "name": "feature_width",
        "type": "int64"
      },
      {
        "name": "use_nesterov",
        "type": "boolean"
      },
      {
        "name": "beta_2",
        "type": "float32"
      },
      {
        "name": "exponent",
        "type": "float32"
      }
    ],
    "inputs": [
      {
        "name": "indices",
        "type": 3
      },
      {
        "name": "gradient",
        "type": 1
      },
      {
        "name": "learning_rate",
        "type": 1
      },
      {
        "name": "beta_1",
        "type": 1
      },
      {
        "name": "epsilon",
        "type": 1
      },
      {
        "name": "accumulator",
        "type": 1
      },
      {
        "name": "momentum",
        "type": 1
      },
      {
        "name": "embedding_table",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "updated_embedding_table",
        "type": 1
      },
      {
        "name": "updated_accumulator",
        "type": 1
      },
      {
        "name": "updated_momentum",
        "type": 1
      }
    ]
  },
  {
    "name": "XlaSparseCoreAdam",
    "attributes": [
      {
        "name": "feature_width",
        "type": "int64"
      },
      {
        "name": "use_sum_inside_sqrt",
        "type": "boolean"
      }
    ],
    "inputs": [
      {
        "name": "embedding_table",
        "type": 1
      },
      {
        "name": "indices",
        "type": 3
      },
      {
        "name": "gradient",
        "type": 1
      },
      {
        "name": "learning_rate",
        "type": 1
      },
      {
        "name": "momentum",
        "type": 1
      },
      {
        "name": "velocity",
        "type": 1
      },
      {
        "name": "beta_1",
        "type": 1
      },
      {
        "name": "beta_2",
        "type": 1
      },
      {
        "name": "epsilon",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "updated_embedding_table",
        "type": 1
      },
      {
        "name": "updated_velocity",
        "type": 1
      },
      {
        "name": "updated_momentum",
        "type": 1
      }
    ]
  },
  {
    "name": "XlaSparseCoreFtrl",
    "attributes": [
      {
        "name": "feature_width",
        "type": "int64"
      },
      {
        "name": "multiply_linear_by_learning_rate",
        "type": "boolean"
      },
      {
        "name": "l1_regularization_strength",
        "type": "float32"
      }
    ],
    "inputs": [
      {
        "name": "embedding_table",
        "type": 1
      },
      {
        "name": "accumulator",
        "type": 1
      },
      {
        "name": "linear",
        "type": 1
      },
      {
        "name": "learning_rate",
        "type": 1
      },
      {
        "name": "indices",
        "type": 3
      },
      {
        "name": "gradient",
        "type": 1
      },
      {
        "name": "beta",
        "type": 1
      },
      {
        "name": "learning_rate_power",
        "type": 1
      },
      {
        "name": "l2_regularization_strength",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "updated_embedding_table",
        "type": 1
      },
      {
        "name": "updated_accumulator",
        "type": 1
      },
      {
        "name": "updated_linear",
        "type": 1
      }
    ]
  },
  {
    "name": "XlaSparseCoreSgd",
    "attributes": [
      {
        "name": "feature_width",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "name": "indices",
        "type": 3
      },
      {
        "name": "gradient",
        "type": 1
      },
      {
        "name": "learning_rate",
        "type": 1
      },
      {
        "name": "embedding_table",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "updated_embedding_table",
        "type": 1
      }
    ]
  },
  {
    "name": "XlaSparseDenseMatmul",
    "attributes": [
      {
        "name": "max_ids_per_partition",
        "type": "int64",
        "minimum": 0
      },
      {
        "name": "max_unique_ids_per_partition",
        "type": "int64",
        "minimum": 0
      },
      {
        "name": "input_size",
        "type": "int64",
        "minimum": 0
      }
    ],
    "inputs": [
      {
        "name": "row_ids",
        "type": 3
      },
      {
        "name": "col_ids",
        "type": 22
      },
      {
        "name": "values",
        "type": 1
      },
      {
        "name": "offsets",
        "type": 22
      },
      {
        "name": "embedding_table",
        "type": 1
      }
    ],
    "outputs": [
      {
        "name": "activations",
        "type": 1
      },
      {
        "name": "row_pointers",
        "type": 3
      },
      {
        "name": "sorted_embedding_ids",
        "type": 3
      },
      {
        "name": "sorted_sample_ids",
        "type": 3
      },
      {
        "name": "sorted_gains",
        "type": 1
      }
    ]
  },
  {
    "name": "XlaSparseDenseMatmulGradWithAdagradAndCsrInput",
    "attributes": [
      {
        "name": "clip_weight_min",
        "type": "float32",
        "default": "-NaN"
      },
      {
        "name": "clip_weight_max",
        "type": "float32",
        "default": "NaN"
      },
      {
        "name": "table_name",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "name": "row_pointers",
        "type": 3
      },
      {
        "name": "sorted_sample_ids",
        "type": 3
      },
      {
        "name": "sorted_token_ids",
        "type": 3
      },
      {
        "name": "sorted_gains",
        "type": 1
      },
      {
        "name": "activation_gradients",
        "type": 1
      },
      {
        "name": "learning_rate",
        "type": 1
      },
      {
        "name": "embedding_table",
        "type": 1
      },
      {
        "name": "accumulator",
        "type": 1
      },
      {
        "name": "num_minibatches_per_physical_sparse_core",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "updated_embedding_table",
        "type": 1
      },
      {
        "name": "updated_accumulator",
        "type": 1
      }
    ]
  },
  {
    "name": "XlaSparseDenseMatmulGradWithAdagradAndStaticBufferSize",
    "attributes": [
      {
        "name": "clip_weight_min",
        "type": "float32",
        "default": "-NaN"
      },
      {
        "name": "clip_weight_max",
        "type": "float32",
        "default": "NaN"
      },
      {
        "name": "max_ids_per_sparse_core",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "max_unique_ids_per_sparse_core",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "table_name",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "name": "row_pointers",
        "type": 3
      },
      {
        "name": "sorted_sample_ids",
        "type": 3
      },
      {
        "name": "sorted_token_ids",
        "type": 3
      },
      {
        "name": "sorted_gains",
        "type": 1
      },
      {
        "name": "activation_gradients",
        "type": 1
      },
      {
        "name": "learning_rate",
        "type": 1
      },
      {
        "name": "embedding_table",
        "type": 1
      },
      {
        "name": "accumulator",
        "type": 1
      },
      {
        "name": "num_minibatches_per_physical_sparse_core",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "updated_embedding_table",
        "type": 1
      },
      {
        "name": "updated_accumulator",
        "type": 1
      }
    ]
  },
  {
    "name": "XlaSparseDenseMatmulGradWithAdagradMomentumAndCsrInput",
    "attributes": [
      {
        "name": "use_nesterov",
        "type": "boolean"
      },
      {
        "name": "exponent",
        "type": "float32"
      },
      {
        "name": "beta1",
        "type": "float32"
      },
      {
        "name": "beta2",
        "type": "float32"
      },
      {
        "name": "epsilon",
        "type": "float32"
      },
      {
        "name": "clip_weight_min",
        "type": "float32",
        "default": "-NaN"
      },
      {
        "name": "clip_weight_max",
        "type": "float32",
        "default": "NaN"
      },
      {
        "name": "table_name",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "name": "row_pointers",
        "type": 3
      },
      {
        "name": "sorted_sample_ids",
        "type": 3
      },
      {
        "name": "sorted_token_ids",
        "type": 3
      },
      {
        "name": "sorted_gains",
        "type": 1
      },
      {
        "name": "activation_gradients",
        "type": 1
      },
      {
        "name": "learning_rate",
        "type": 1
      },
      {
        "name": "embedding_table",
        "type": 1
      },
      {
        "name": "accumulator",
        "type": 1
      },
      {
        "name": "momenta",
        "type": 1
      },
      {
        "name": "num_minibatches_per_physical_sparse_core",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "updated_embedding_table",
        "type": 1
      },
      {
        "name": "updated_accumulator",
        "type": 1
      },
      {
        "name": "updated_momenta",
        "type": 1
      }
    ]
  },
  {
    "name": "XlaSparseDenseMatmulGradWithAdagradMomentumAndStaticBufferSize",
    "attributes": [
      {
        "name": "use_nesterov",
        "type": "boolean"
      },
      {
        "name": "exponent",
        "type": "float32"
      },
      {
        "name": "beta1",
        "type": "float32"
      },
      {
        "name": "beta2",
        "type": "float32"
      },
      {
        "name": "epsilon",
        "type": "float32"
      },
      {
        "name": "clip_weight_min",
        "type": "float32",
        "default": "-NaN"
      },
      {
        "name": "clip_weight_max",
        "type": "float32",
        "default": "NaN"
      },
      {
        "name": "max_ids_per_sparse_core",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "max_unique_ids_per_sparse_core",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "table_name",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "name": "row_pointers",
        "type": 3
      },
      {
        "name": "sorted_sample_ids",
        "type": 3
      },
      {
        "name": "sorted_token_ids",
        "type": 3
      },
      {
        "name": "sorted_gains",
        "type": 1
      },
      {
        "name": "activation_gradients",
        "type": 1
      },
      {
        "name": "learning_rate",
        "type": 1
      },
      {
        "name": "embedding_table",
        "type": 1
      },
      {
        "name": "accumulator",
        "type": 1
      },
      {
        "name": "momenta",
        "type": 1
      },
      {
        "name": "num_minibatches_per_physical_sparse_core",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "updated_embedding_table",
        "type": 1
      },
      {
        "name": "updated_accumulator",
        "type": 1
      },
      {
        "name": "updated_momenta",
        "type": 1
      }
    ]
  },
  {
    "name": "XlaSparseDenseMatmulGradWithAdamAndCsrInput",
    "attributes": [
      {
        "name": "use_sum_inside_sqrt",
        "type": "boolean"
      },
      {
        "name": "beta1",
        "type": "float32"
      },
      {
        "name": "beta2",
        "type": "float32"
      },
      {
        "name": "epsilon",
        "type": "float32"
      },
      {
        "name": "clip_weight_min",
        "type": "float32",
        "default": "-NaN"
      },
      {
        "name": "clip_weight_max",
        "type": "float32",
        "default": "NaN"
      },
      {
        "name": "table_name",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "name": "row_pointers",
        "type": 3
      },
      {
        "name": "sorted_sample_ids",
        "type": 3
      },
      {
        "name": "sorted_token_ids",
        "type": 3
      },
      {
        "name": "sorted_gains",
        "type": 1
      },
      {
        "name": "activation_gradients",
        "type": 1
      },
      {
        "name": "learning_rate",
        "type": 1
      },
      {
        "name": "embedding_table",
        "type": 1
      },
      {
        "name": "momenta",
        "type": 1
      },
      {
        "name": "velocity",
        "type": 1
      },
      {
        "name": "num_minibatches_per_physical_sparse_core",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "updated_embedding_table",
        "type": 1
      },
      {
        "name": "updated_momenta",
        "type": 1
      },
      {
        "name": "updated_velocity",
        "type": 1
      }
    ]
  },
  {
    "name": "XlaSparseDenseMatmulGradWithAdamAndStaticBufferSize",
    "attributes": [
      {
        "name": "use_sum_inside_sqrt",
        "type": "boolean"
      },
      {
        "name": "beta1",
        "type": "float32"
      },
      {
        "name": "beta2",
        "type": "float32"
      },
      {
        "name": "epsilon",
        "type": "float32"
      },
      {
        "name": "clip_weight_min",
        "type": "float32",
        "default": "-NaN"
      },
      {
        "name": "clip_weight_max",
        "type": "float32",
        "default": "NaN"
      },
      {
        "name": "max_ids_per_sparse_core",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "max_unique_ids_per_sparse_core",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "table_name",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "name": "row_pointers",
        "type": 3
      },
      {
        "name": "sorted_sample_ids",
        "type": 3
      },
      {
        "name": "sorted_token_ids",
        "type": 3
      },
      {
        "name": "sorted_gains",
        "type": 1
      },
      {
        "name": "activation_gradients",
        "type": 1
      },
      {
        "name": "learning_rate",
        "type": 1
      },
      {
        "name": "embedding_table",
        "type": 1
      },
      {
        "name": "momenta",
        "type": 1
      },
      {
        "name": "velocity",
        "type": 1
      },
      {
        "name": "num_minibatches_per_physical_sparse_core",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "updated_embedding_table",
        "type": 1
      },
      {
        "name": "updated_momenta",
        "type": 1
      },
      {
        "name": "updated_velocity",
        "type": 1
      }
    ]
  },
  {
    "name": "XlaSparseDenseMatmulGradWithFtrlAndCsrInput",
    "attributes": [
      {
        "name": "multiply_linear_by_learning_rate",
        "type": "boolean"
      },
      {
        "name": "beta",
        "type": "float32"
      },
      {
        "name": "learning_rate_power",
        "type": "float32"
      },
      {
        "name": "l1_regularization_strength",
        "type": "float32"
      },
      {
        "name": "l2_regularization_strength",
        "type": "float32"
      },
      {
        "name": "clip_weight_min",
        "type": "float32",
        "default": "-NaN"
      },
      {
        "name": "clip_weight_max",
        "type": "float32",
        "default": "NaN"
      },
      {
        "name": "table_name",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "name": "row_pointers",
        "type": 3
      },
      {
        "name": "sorted_sample_ids",
        "type": 3
      },
      {
        "name": "sorted_token_ids",
        "type": 3
      },
      {
        "name": "sorted_gains",
        "type": 1
      },
      {
        "name": "activation_gradients",
        "type": 1
      },
      {
        "name": "learning_rate",
        "type": 1
      },
      {
        "name": "embedding_table",
        "type": 1
      },
      {
        "name": "accumulator",
        "type": 1
      },
      {
        "name": "linear",
        "type": 1
      },
      {
        "name": "num_minibatches_per_physical_sparse_core",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "updated_embedding_table",
        "type": 1
      },
      {
        "name": "updated_accumulator",
        "type": 1
      },
      {
        "name": "updated_linear",
        "type": 1
      }
    ]
  },
  {
    "name": "XlaSparseDenseMatmulGradWithFtrlAndStaticBufferSize",
    "attributes": [
      {
        "name": "multiply_linear_by_learning_rate",
        "type": "boolean"
      },
      {
        "name": "beta",
        "type": "float32"
      },
      {
        "name": "learning_rate_power",
        "type": "float32"
      },
      {
        "name": "l1_regularization_strength",
        "type": "float32"
      },
      {
        "name": "l2_regularization_strength",
        "type": "float32"
      },
      {
        "name": "clip_weight_min",
        "type": "float32",
        "default": "-NaN"
      },
      {
        "name": "clip_weight_max",
        "type": "float32",
        "default": "NaN"
      },
      {
        "name": "max_ids_per_sparse_core",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "max_unique_ids_per_sparse_core",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "table_name",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "name": "row_pointers",
        "type": 3
      },
      {
        "name": "sorted_sample_ids",
        "type": 3
      },
      {
        "name": "sorted_token_ids",
        "type": 3
      },
      {
        "name": "sorted_gains",
        "type": 1
      },
      {
        "name": "activation_gradients",
        "type": 1
      },
      {
        "name": "learning_rate",
        "type": 1
      },
      {
        "name": "embedding_table",
        "type": 1
      },
      {
        "name": "accumulator",
        "type": 1
      },
      {
        "name": "linear",
        "type": 1
      },
      {
        "name": "num_minibatches_per_physical_sparse_core",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "updated_embedding_table",
        "type": 1
      },
      {
        "name": "updated_accumulator",
        "type": 1
      },
      {
        "name": "updated_linear",
        "type": 1
      }
    ]
  },
  {
    "name": "XlaSparseDenseMatmulGradWithSgdAndCsrInput",
    "attributes": [
      {
        "name": "clip_weight_min",
        "type": "float32",
        "default": "-NaN"
      },
      {
        "name": "clip_weight_max",
        "type": "float32",
        "default": "NaN"
      },
      {
        "name": "table_name",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "name": "row_pointers",
        "type": 3
      },
      {
        "name": "sorted_sample_ids",
        "type": 3
      },
      {
        "name": "sorted_token_ids",
        "type": 3
      },
      {
        "name": "sorted_gains",
        "type": 1
      },
      {
        "name": "activation_gradients",
        "type": 1
      },
      {
        "name": "learning_rate",
        "type": 1
      },
      {
        "name": "embedding_table",
        "type": 1
      },
      {
        "name": "num_minibatches_per_physical_sparse_core",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "updated_embedding_table",
        "type": 1
      }
    ]
  },
  {
    "name": "XlaSparseDenseMatmulGradWithSgdAndStaticBufferSize",
    "attributes": [
      {
        "name": "clip_weight_min",
        "type": "float32",
        "default": "-NaN"
      },
      {
        "name": "clip_weight_max",
        "type": "float32",
        "default": "NaN"
      },
      {
        "name": "max_ids_per_sparse_core",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "max_unique_ids_per_sparse_core",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "table_name",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "name": "row_pointers",
        "type": 3
      },
      {
        "name": "sorted_sample_ids",
        "type": 3
      },
      {
        "name": "sorted_token_ids",
        "type": 3
      },
      {
        "name": "sorted_gains",
        "type": 1
      },
      {
        "name": "activation_gradients",
        "type": 1
      },
      {
        "name": "learning_rate",
        "type": 1
      },
      {
        "name": "embedding_table",
        "type": 1
      },
      {
        "name": "num_minibatches_per_physical_sparse_core",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "updated_embedding_table",
        "type": 1
      }
    ]
  },
  {
    "name": "XlaSparseDenseMatmulWithCsrInput",
    "attributes": [
      {
        "name": "input_size",
        "type": "int64",
        "minimum": 0
      },
      {
        "name": "quantization_config_low",
        "type": "float32"
      },
      {
        "name": "quantization_config_high",
        "type": "float32"
      },
      {
        "name": "quantization_config_num_buckets",
        "type": "int64",
        "minimum": 0
      },
      {
        "name": "table_name",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "name": "row_pointers",
        "type": 3
      },
      {
        "name": "sorted_sample_ids",
        "type": 3
      },
      {
        "name": "sorted_token_ids",
        "type": 3
      },
      {
        "name": "sorted_gains",
        "type": 1
      },
      {
        "name": "embedding_table",
        "type": 1
      },
      {
        "name": "num_minibatches_per_physical_sparse_core",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "activations",
        "type": 1
      }
    ]
  },
  {
    "name": "XlaSparseDenseMatmulWithStaticBufferSize",
    "attributes": [
      {
        "name": "input_size",
        "type": "int64",
        "minimum": 0
      },
      {
        "name": "quantization_config_low",
        "type": "float32"
      },
      {
        "name": "quantization_config_high",
        "type": "float32"
      },
      {
        "name": "quantization_config_num_buckets",
        "type": "int64",
        "minimum": 0
      },
      {
        "name": "max_ids_per_sparse_core",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "max_unique_ids_per_sparse_core",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "table_name",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "name": "row_pointers",
        "type": 3
      },
      {
        "name": "sorted_sample_ids",
        "type": 3
      },
      {
        "name": "sorted_token_ids",
        "type": 3
      },
      {
        "name": "sorted_gains",
        "type": 1
      },
      {
        "name": "embedding_table",
        "type": 1
      },
      {
        "name": "num_minibatches_per_physical_sparse_core",
        "type": 3
      }
    ],
    "outputs": [
      {
        "name": "activations",
        "type": 1
      }
    ]
  },
  {
    "name": "XlaSplitND",
    "summary": "Splits input tensor across all dimensions.",
    "description": "An op which slices the input tensor based on the given num_splits attribute,\npads slices optionally, and returned the slices. Slices are returned in\nrow-major order.\n\nThis op may be generated via the TPU bridge.\n\nFor example, with `input` tensor:\n```\n[[0, 1, 2],\n [3, 4, 5],\n [6, 7, 8]]\n```\n`num_splits`:\n```\n[2, 2]\n```\nand `paddings`:\n```\n[1, 1]\n```\nthe expected `outputs` is:\n```\n[[0, 1],\n [3, 4]]\n[[2, 0],\n [5, 0]]\n[[6, 7],\n [0, 0]]\n[[8, 0],\n [0, 0]]\n```",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      },
      {
        "name": "N",
        "type": "int64",
        "minimum": 1
      },
      {
        "name": "num_splits",
        "type": "int64[]",
        "description": "Number of ways to split per dimension. Shape dimensions must be evenly\ndivisible."
      },
      {
        "name": "paddings",
        "type": "int64[]",
        "description": "Optional list of right paddings per dimension of input tensor to apply before\nsplitting. This can be used to make a dimension evenly divisible.",
        "default": []
      }
    ],
    "inputs": [
      {
        "name": "input",
        "description": "Input tensor to split across all dimensions.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "outputs",
        "description": "Output slices based on input and num_splits defined, in row-major order.",
        "numberAttr": "N",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Xlog1py",
    "summary": "Returns 0 if x == 0, and x * log1p(y) otherwise, elementwise.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Xlogy",
    "summary": "Returns 0 if x == 0, and x * log(y) otherwise, elementwise.",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float16`, `bfloat16`, `float32`, `float64`, `complex64`, `complex128`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "y",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ZerosLike",
    "summary": "Returns a tensor of zeros with the same shape and type as x.",
    "attributes": [
      {
        "name": "T",
        "type": "type"
      }
    ],
    "inputs": [
      {
        "name": "x",
        "description": "a tensor of type T.",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "y",
        "description": "a tensor of the same shape and type as x but filled with zeros.",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "Zeta",
    "summary": "Compute the Hurwitz zeta function \\\\(\\zeta(x, q)\\\\).",
    "description": "The Hurwitz zeta function is defined as:\n\n\n\\\\(\\zeta(x, q) = \\sum_{n=0}^{\\infty} (q + n)^{-x}\\\\)",
    "attributes": [
      {
        "name": "T",
        "type": "type",
        "description": "Must be one of the following: `float32`, `float64`."
      }
    ],
    "inputs": [
      {
        "name": "x",
        "typeAttr": "T"
      },
      {
        "name": "q",
        "typeAttr": "T"
      }
    ],
    "outputs": [
      {
        "name": "z",
        "typeAttr": "T"
      }
    ]
  },
  {
    "name": "ZipDataset",
    "summary": "Creates a dataset that zips together `input_datasets`.",
    "description": "The elements of the resulting dataset are created by zipping corresponding\nelements from each of the input datasets.\n\nThe size of the resulting dataset will match the size of the smallest input\ndataset, and no error will be raised if input datasets have different sizes.",
    "attributes": [
      {
        "name": "output_types",
        "type": "type[]",
        "minimum": 1
      },
      {
        "name": "output_shapes",
        "type": "shape[]",
        "minimum": 1
      },
      {
        "name": "N",
        "type": "int64",
        "description": "The length of `input_datasets`",
        "minimum": 1
      },
      {
        "name": "metadata",
        "type": "string",
        "default": ""
      }
    ],
    "inputs": [
      {
        "name": "input_datasets",
        "description": "List of `N` variant Tensors representing datasets to be zipped together.",
        "numberAttr": "N",
        "type": 21
      }
    ],
    "outputs": [
      {
        "name": "handle",
        "type": 21
      }
    ]
  }
]