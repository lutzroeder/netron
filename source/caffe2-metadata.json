[
  {
    "name": "Abs",
    "description": "\nCalculates the absolute value of the given input tensor, element-wise.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/abs_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Abs\",\n    [\"X\"],\n    [\"Y\"]\n)\n\nworkspace.FeedBlob(\"X\", np.random.randn(5).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX: [ 0.3005476   1.551666   -1.3591481   0.39191285 -0.21866608]\nY: [0.3005476  1.551666   1.3591481  0.39191285 0.21866608]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor<float>)* Input tensor.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Absolute value of input element-wise.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "AbsGradient",
    "support_level": "default"
  },
  {
    "name": "Accumulate",
    "description": "\nAccumulate operator accumulates the input tensor to the output tensor. If the\noutput tensor already has the right size, we add to it; otherwise, we first\ninitialize the output tensor to all zeros, and then do accumulation. Any\nfurther calls to the operator, given that no one else fiddles with the output\nin the interim, will do simple accumulations.\nAccumulation is done using Axpby operation as shown:\n  Y = 1*X + gamma*Y\nwhere X is the input tensor, Y is the output tensor and gamma is the multiplier\nargument.\n",
    "attributes": [
      {
        "description": "(float, default 1.0) Accumulation multiplier",
        "name": "gamma",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "The input tensor that has to be accumulated to the output tensor. If the output size is not the same as input size, the output tensor is first reshaped and initialized to zero, and only then, accumulation is done.",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Accumulated output tensor",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "AccumulateHistogram",
    "description": "\nThis operator calculate thes histogram of values in input tensor.\nThere're 2 outputs, one for histogram of current input tensor, and another\nfor histogram of the all input tensors accumulated through history.\nThe output would contain num_buckets + 2 values. index[1 ... num_buckets]\nfor values in [lower_bound, upper_bound) interval. And the rest 2 for values\nsmaller than lower_bound or greater than upper_bound respectively.\n",
    "attributes": [
      {
        "description": "the lower bound value",
        "name": "lower_bound",
        "option": "optional"
      },
      {
        "description": "the upper bound value",
        "name": "upper_bound",
        "option": "optional"
      },
      {
        "description": "number of buckets to use in [lower_bound, upper_bound)",
        "name": "num_buckets",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "Output histogram of the current tensor.",
        "name": "CurHist"
      },
      {
        "description": "Accumulated histogram of the history tensor.",
        "name": "AccHist"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Accuracy",
    "description": "\nAccuracy takes two inputs- predictions and labels, and returns a float\naccuracy value for the batch. Predictions are expected in the form of 2-D tensor\ncontaining a batch of scores for various classes, and labels are expected in the\n form of 1-D tensor containing true label indices of samples in the batch. If\nthe score for the label index in the predictions is the highest among all\nclasses, it is considered a correct prediction.\n",
    "attributes": [
      {
        "description": "Count as correct by comparing the true label to the top k scoring classes (default 1: only compare to the top scoring class i.e. argmax)",
        "name": "top_k",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "2-D tensor (Tensor<float>) of size (num_batches x num_classes) containing scores",
        "name": "predictions"
      },
      {
        "description": "1-D tensor (Tensor<float>) of size (num_batches) having the indices of true labels",
        "name": "labels"
      }
    ],
    "outputs": [
      {
        "description": "1-D tensor (Tensor<float>) of size 1 containing accuracy",
        "name": "accuracy"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Acos",
    "description": "\nCalculates the arccosine of the given input tensor, element-wise.\n",
    "inputs": [
      {
        "description": "Input tensor",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "The arccosine of the input tensor computed element-wise",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "AcosGradient",
    "support_level": "default"
  },
  {
    "name": "Adadelta",
    "description": "\n\nComputes the AdaDelta update (https://arxiv.org/abs/1212.5701) for an input\ngradient and accumulated history of squared gradients. Concretely, given\ninputs (param, moment, moment_delta, grad, learning_rate), computes:\n\n    new_moment = moment * decay + square(grad) * (1 - decay)\n    new_grad = sqrt(moment_delta + epsilon) / sqrt(new_moment + epsilon) * grad\n    new_param = param + learning_rate * new_grad\n    new_moment_delta = moment_delta * decay + square(new_grad) * (1 - decay)\n\nand returns (new_param, new_moment, new_moment_delta).\n\n",
    "attributes": [
      {
        "description": "Default 1e-5",
        "name": "epsilon",
        "option": "optional"
      },
      {
        "description": "Default 0.95, the squared gradient sum is decayed by this factor.",
        "name": "decay",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated",
        "name": "param"
      },
      {
        "description": "Average of squared gradients",
        "name": "moment"
      },
      {
        "description": "Average of squared parameter updates",
        "name": "moment_delta"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "Learning rate",
        "name": "lr"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters",
        "name": "output_param"
      },
      {
        "description": "Updated average squared gradient",
        "name": "output_moment"
      },
      {
        "description": "Updated average of squared parameter updates",
        "name": "output_moment_delta"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Adagrad",
    "description": "\n\nComputes the AdaGrad update for an input gradient and accumulated\nhistory. Concretely, given inputs (param, grad, moment, learning_rate),\ncomputes\n\n    new_moment = moment + square(grad)\n    effective_lr = learning_rate / (sqrt(new_moment) + epsilon)\n    update = learning_rate * grad / (sqrt(new_moment) + epsilon)\n    new_param = param + update\nand returns (new_param, new_moment).\n\nOptionally returns effective_lr and update as well.\n\n",
    "attributes": [
      {
        "description": "Default 1e-5",
        "name": "epsilon",
        "option": "optional"
      },
      {
        "description": "Default 1. If it is in (0, 1), the gradient square sum is decayed by this factor.",
        "name": "decay",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated",
        "name": "param"
      },
      {
        "description": "Moment history",
        "name": "moment"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "learning rate",
        "name": "lr"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters",
        "name": "output_param"
      },
      {
        "description": "Updated moment",
        "name": "output_moment"
      },
      {
        "description": "(optional) Effective learning rate",
        "name": "output_effective_lr"
      },
      {
        "description": "(optional) Actual update that is applied.",
        "name": "output_update"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Adam",
    "description": "\n\nComputes the Adam update (https://arxiv.org/abs/1412.6980) for an\ninput gradient and momentum parameters. Concretely, given inputs\n(param, m1, m2, grad, lr, iters),\n\n    t = iters + 1\n    correction_multiplier = sqrt(1 - power(beta2, t)) /\n      (1 - power(beta1, t))\n    m1_o = (beta1 * m1) + (1 - beta1) * grad\n    m2_o = (beta2 * m2) + (1 - beta2) * np.square(grad)\n    grad_o = correction_multiplier * m1_o / \\\n        (sqrt(m2_o) + epsilon)\n    param_o = param + lr * grad_o\n\nand returns (param_o, m1_o, m2_o, grad_o), in which grad_o is an optional output\n\n",
    "attributes": [
      {
        "description": "Default 0.9",
        "name": "beta1",
        "option": "optional"
      },
      {
        "description": "Default 0.999",
        "name": "beta2",
        "option": "optional"
      },
      {
        "description": "Default 1e-5",
        "name": "epsilon",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated",
        "name": "param"
      },
      {
        "description": "First moment history",
        "name": "moment_1"
      },
      {
        "description": "Second moment history",
        "name": "moment_2"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "learning rate",
        "name": "lr"
      },
      {
        "description": "iteration number",
        "name": "iter"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters",
        "name": "output_param"
      },
      {
        "description": "Updated first moment",
        "name": "output_moment_1"
      },
      {
        "description": "Updated second moment",
        "name": "output_moment_2"
      },
      {
        "description": "Optional Effective gradient",
        "name": "output_grad"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Add",
    "description": "\nPerforms element-wise binary addition (with limited broadcast support).\n\nIf necessary the right-hand-side argument will be broadcasted to match the\nshape of left-hand-side argument. When broadcasting is specified, the second\ntensor can either be of size 1 (a scalar value), or having its shape as a\ncontiguous subset of the first tensor's shape. The starting of the mutually\nequal shape is specified by the argument \"axis\", and if it is not set, suffix\nmatching is assumed. 1-dim expansion doesn't work yet.\n\nFor example, the following tensor shapes are supported (with broadcast=1):\n```\n  shape(A) = (2, 3, 4, 5), shape(B) = (,), i.e. B is a scalar\n  shape(A) = (2, 3, 4, 5), shape(B) = (5,)\n  shape(A) = (2, 3, 4, 5), shape(B) = (4, 5)\n  shape(A) = (2, 3, 4, 5), shape(B) = (3, 4), with axis=1\n  shape(A) = (2, 3, 4, 5), shape(B) = (2), with axis=0\n```\nArgument `broadcast=1` needs to be passed to enable broadcasting.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/elementwise_ops_schema.cc\n\n\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Add\",\n    [\"A\",  \"B\"],\n    [\"C\"],\n)\n\nworkspace.FeedBlob(\"A\", np.array([[1,2],[3,4]]))\nworkspace.FeedBlob(\"B\", np.array([[5,6],[7,8]]))\nprint(\"A:\", workspace.FetchBlob(\"A\"))\nprint(\"B:\", workspace.FetchBlob(\"B\"))\nworkspace.RunOperatorOnce(op)\nprint(\"C:\", workspace.FetchBlob(\"C\"))\n\n```\n\n**Result**\n\n```\n\nA:\n[[1 2]\n [3 4]]\nB:\n[[5 6]\n [7 8]]\nC:\n[[ 6  8]\n [10 12]]\n\n```\n\n</details>\n\n\n",
    "attributes": [
      {
        "default": 0,
        "description": "Pass 1 to enable broadcasting",
        "name": "broadcast",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": -1,
        "description": "Axis to concatenate on.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* First operand, should share the type with the second operand.",
        "name": "A"
      },
      {
        "description": "*(type: Tensor`<float>`)* Second operand. With broadcasting can be of smaller size than A. If broadcasting is disabled it should be of the same size as A.",
        "name": "B"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output tensor with same dimensions and type as A.",
        "name": "C"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "AddGradient",
    "support_level": "default"
  },
  {
    "name": "AddPadding",
    "description": "\nGiven a partitioned tensor $T<N, D_1, ..., D_n>$, where the partitions are\ndefined as ranges on its outer-most (slowest varying) dimension $N$,\nreturn a tensor $T<(N + 2 * padding\\_width), D_1, ..., D_n>$ with paddings\nadded to the start and end of each range.\n\nOptionally, different paddings can be provided for beginning and end.\nPaddings provided must be a tensor $T<D_1, ..., D_n>$. If no padding is\nprovided, add zero padding. If no lengths vector is provided, add padding\nonly once, at the start and end of data.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/sequence_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"AddPadding\",\n    [\"X\", \"lengths\"],\n    [\"Y\", \"lengths_out\"],\n    padding_width=1\n\n)\n\nworkspace.FeedBlob(\"X\", (np.random.rand(3,2,2).astype(np.float32)))\nworkspace.FeedBlob(\"lengths\", np.array([3]).astype(np.int32))\n\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\nprint(\"lengths_out:\", workspace.FetchBlob(\"lengths_out\"))\n```\n\n**Result**\n\n```\nX: [[[0.2531572  0.4588472 ]\n  [0.45140603 0.61161053]]\n\n [[0.92500854 0.8045306 ]\n  [0.03356671 0.30233648]]\n\n [[0.4660227  0.6287745 ]\n  [0.79372746 0.08609265]]]\nY: [[[0.         0.        ]\n  [0.         0.        ]]\n\n [[0.2531572  0.4588472 ]\n  [0.45140603 0.61161053]]\n\n [[0.92500854 0.8045306 ]\n  [0.03356671 0.30233648]]\n\n [[0.4660227  0.6287745 ]\n  [0.79372746 0.08609265]]\n\n [[0.         0.        ]\n  [0.         0.        ]]]\nlengths_out: [5]\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "Number of copies of padding to add around each range.",
        "name": "padding_width",
        "option": "optional",
        "type": "int64"
      },
      {
        "description": "[OPTIONAL] Specifies a different end-padding width. If this is not set, will use same as `padding_width`.",
        "name": "end_padding_width",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor)* Input data ($T<N, D_1, ..., D_n>$).",
        "name": "data_in"
      },
      {
        "description": "*(type: Tensor`<int>`)* Number of elements in each range. sum(lengths) = N.",
        "name": "lengths"
      },
      {
        "description": "*(type: Tensor`<int>`)* [OPTIONAL] Padding data for range start ($T<D_1, ..., D_n>$).",
        "name": "start_padding"
      },
      {
        "description": "*(type: Tensor`<int>`)* [OPTIONAL] Padding for range end. If not provided, `start_padding` is used ($T<D_1, ..., D_n>$).",
        "name": "end_padding"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor)* Padded data tensor ($T<N + 2*padding_width, D_1, ..., D_n>$).",
        "name": "data_out"
      },
      {
        "description": "*(type: Tensor`<int>`)* [OPTIONAL] Lengths for each padded range.",
        "name": "lengths_out"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "AffineChannel",
    "category": "Normalization",
    "description": "\nApplies a separate affine transformation to each channel of the input. Useful\nfor replacing spatial batch norm with its equivalent fixed transformation.\n",
    "inputs": [
      {
        "description": "Feature map input with order NCHW or NHWC.",
        "name": "X"
      },
      {
        "description": "1D input of shape (C); the c-th element is the scale factor of the affine transformation for the c-th channel of the input.",
        "name": "scale"
      },
      {
        "description": "1D input of shape (C); the c-th element is the bias of the affine transformation for the c-th channel of the input.",
        "name": "bias"
      }
    ],
    "outputs": [
      {
        "description": "Output with the same order of Input.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "AffineChannelGradient",
    "support_level": "default"
  },
  {
    "name": "Alias",
    "description": "\nMakes the output and the input share the same underlying storage.\n\nWARNING: in general, in caffe2's operator interface different tensors should\nhave different underlying storage, which is the assumption made by\ncomponents such as the dependency engine and memory optimization. Thus, in\nnormal situations you should not use the AliasOp, especially in a normal\nforward-backward pass.\n\nThe Alias op is provided so one can achieve true asynchrony, such as\nHogwild, in a graph. But make sure you understand all the implications\nsimilar to multi-thread computation before you use it explicitly.\n",
    "inputs": [
      {
        "description": "Input tensor whose storage will be shared.",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Tensor of same shape as input, sharing its storage.",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "AliasWithName",
    "description": "\nSimilar with AliasOp, storing the alias name as operator argument.\n",
    "attributes": [
      {
        "description": "name of the aliasing",
        "name": "name",
        "option": "optional"
      },
      {
        "description": "weather or not to alias forward or backward",
        "name": "is_backward",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor whose storage will be shared.",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Tensor of same shape as input, sharing its storage.",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Allgather",
    "description": "\nDoes an allgather operation among the nodes.\n",
    "inputs": [
      {
        "description": "The common world.",
        "name": "comm_world"
      },
      {
        "description": "A tensor to be allgathered.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "The allgathered tensor, same on all nodes.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Allreduce",
    "description": "\nDoes an allreduce operation among the nodes. Currently only Sum is supported.\n",
    "inputs": [
      {
        "description": "The common world.",
        "name": "comm_world"
      },
      {
        "description": "A tensor to be allreduced.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "The allreduced tensor, same on all nodes.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "And",
    "description": "\nPerforms element-wise logical operation **and** (with limited broadcast support).\nBoth input operands should be of type `bool`.\n\n\nIf necessary the right-hand-side argument will be broadcasted to match the\nshape of left-hand-side argument. When broadcasting is specified, the second\ntensor can either be of size 1 (a scalar value), or having its shape as a\ncontiguous subset of the first tensor's shape. The starting of the mutually\nequal shape is specified by the argument \"axis\", and if it is not set, suffix\nmatching is assumed. 1-dim expansion doesn't work yet.\n\nFor example, the following tensor shapes are supported (with broadcast=1):\n```\n  shape(A) = (2, 3, 4, 5), shape(B) = (,), i.e. B is a scalar\n  shape(A) = (2, 3, 4, 5), shape(B) = (5,)\n  shape(A) = (2, 3, 4, 5), shape(B) = (4, 5)\n  shape(A) = (2, 3, 4, 5), shape(B) = (3, 4), with axis=1\n  shape(A) = (2, 3, 4, 5), shape(B) = (2), with axis=0\n```\nArgument `broadcast=1` needs to be passed to enable broadcasting.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/elementwise_ops_schema.cc\n\n\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"And\",\n    [\"A\",  \"B\"],\n    [\"C\"],\n)\n\nworkspace.FeedBlob(\"A\", (np.random.rand(3, 3) > 0.5))\nworkspace.FeedBlob(\"B\", (np.random.rand(3, 3) > 0.5))\nprint(\"A:\", workspace.FetchBlob(\"A\"))\nprint(\"B:\", workspace.FetchBlob(\"B\"))\nworkspace.RunOperatorOnce(op)\nprint(\"C:\", workspace.FetchBlob(\"C\"))\n\n```\n\n**Result**\n\n```\n\nA:\n [[ True False False]\n [False  True False]\n [False False  True]]\nB:\n [[ True False  True]\n [False False False]\n [False False False]]\nC:\n [[ True False False]\n [False False False]\n [False False False]]\n\n```\n\n</details>\n\n    ",
    "attributes": [
      {
        "default": 0,
        "description": "Pass 1 to enable broadcasting.",
        "name": "broadcast",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": -1,
        "description": "Axis to concatenate on. If set, defines the broadcast dimensions.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<bool>`)* First operand.",
        "name": "A"
      },
      {
        "description": "*(type: Tensor`<bool>`)* Second operand. With broadcasting can be of smaller size than `A`. If broadcasting is disabled it should be of the same size.",
        "name": "B"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<bool>`)* Output tensor of booleans. Has same dimensions as input `A`.",
        "name": "C"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "APMeter",
    "description": "\nAPMeter computes Average Precision for binary or multi-class classification.\nIt takes two inputs: prediction scores P of size (n_samples x n_classes), and\ntrue labels Y of size (n_samples x n_classes). It returns a single float number\nper class for the average precision of that class.\n",
    "attributes": [
      {
        "description": "(int32_t) indicates how many predictions should the op buffer. defaults to 1000",
        "name": "buffer_size",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "2-D tensor (Tensor<float>) of size (num_samples xnum_classes) containing prediction scores",
        "name": "predictions"
      },
      {
        "description": "2-D tensor (Tensor<float>) of size (num_samples) containing true labels for each sample",
        "name": "labels"
      }
    ],
    "outputs": [
      {
        "description": "1-D tensor (Tensor<float>) of size num_classes containing average precision for each class",
        "name": "AP"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Append",
    "description": "\nAppend input `B` to the end of input `A`.\n\n- It is required that this operation run in-place, meaning that the input `A` blob must match the output blob.\n- All except the outer-most dimension must be the same between `A` and `B`.\n- Input `A` may have to be re-allocated in order for accommodate to the new size. Currently, an exponential growth ratio is used in order to ensure amortized constant time complexity.\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/dataset_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Append\",\n    [\"A\", \"B\"],\n    [\"A\"],\n)\n\nworkspace.FeedBlob(\"A\", np.random.randint(10, size=(1,3,3)))\nworkspace.FeedBlob(\"B\", np.random.randint(10, size=(2,3,3)))\nprint(\"A:\", workspace.FetchBlob(\"A\"))\nprint(\"B:\", workspace.FetchBlob(\"B\"))\nworkspace.RunOperatorOnce(op)\nprint(\"A:\", workspace.FetchBlob(\"A\"))\n\n```\n\n**Result**\n\n```\n\nA:\n[[[3 8 7]\n  [1 6 6]\n  [5 0 6]]]\nB:\n[[[4 3 1]\n  [7 9 6]\n  [9 4 5]]\n\n [[7 7 4]\n  [9 8 7]\n  [1 6 6]]]\nA:\n[[[3 8 7]\n  [1 6 6]\n  [5 0 6]]\n\n [[4 3 1]\n  [7 9 6]\n  [9 4 5]]\n\n [[7 7 4]\n  [9 8 7]\n  [1 6 6]]]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "(*Tensor*): base input tensor of shape $(N, d_1, d_2, ..., d_n)$",
        "name": "A"
      },
      {
        "description": "(*Tensor*): second input tensor of shape $(M, d_1, d_2, ..., d_n)$ to be appended to the base",
        "name": "B"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor*): output tensor of shape $(N+M, d_1, d_2, ..., d_n)$",
        "name": "A"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ArgMax",
    "description": "\nRetrieve the argmax of an axis dimension specified by the `axis`\nargument. Given an input tensor and two arguments (`axis` and\n`keepdims`), returns a tensor containing the indices of the largest\nelement along the given axis. If the `keepdims` arg is *True* (default),\nthe shape of the output tensor matches the input tensor except the\n`axis` dimension equals 1. Else, the `axis` dimension of the output\ntensor is removed.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/arg_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"ArgMax\",\n    [\"X\"],\n    [\"Indices\"],\n    axis=2,\n    keepdims=False\n)\n\nworkspace.FeedBlob(\"X\", (np.random.randint(10, size=(3,3,3))).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Indices:\", workspace.FetchBlob(\"Indices\"))\n\n```\n\n**Result**\n\n```\nX: [[[4. 9. 6.]\n  [6. 6. 1.]\n  [9. 5. 4.]]\n\n [[6. 7. 4.]\n  [7. 9. 1.]\n  [3. 2. 8.]]\n\n [[3. 4. 6.]\n  [5. 2. 7.]\n  [1. 5. 7.]]]\nIndices: [[1 0 0]\n [1 1 2]\n [2 2 2]]\n\n```\n\n</details>\n\n    ",
    "attributes": [
      {
        "default": -1,
        "description": "The axis to get argmax.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": true,
        "description": "If True (default), the output tensor shape will match the input tensor shape except the `axis` dimension equals 1. Else, the `axis` dimension of the output tensor is removed.",
        "name": "keepdims",
        "option": "optional",
        "type": "boolean"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input tensor.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Tensor of indices for the largest values.",
        "name": "Indices"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ArgMin",
    "description": "\nRetrieve the argmin of an axis dimension specified by the `axis`\nargument. Given an input tensor and two arguments (`axis` and\n`keepdims`), returns a tensor containing the indices of the smallest\nelement along the given axis. If the `keepdims` arg is *True* (default),\nthe shape of the output tensor matches the input tensor except the\n`axis` dimension equals 1. Else, the `axis` dimension of the output\ntensor is removed.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/arg_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"ArgMin\",\n    [\"X\"],\n    [\"Indices\"],\n    axis=1\n)\n\nworkspace.FeedBlob(\"X\", (np.random.randint(10, size=(5,5))).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Indices:\", workspace.FetchBlob(\"Indices\"))\n\n```\n\n**Result**\n\n```\n\nX: [[9. 4. 6. 4. 1.]\n  [5. 9. 8. 3. 4.]\n  [6. 1. 0. 2. 9.]\n  [7. 8. 2. 4. 9.]\n  [3. 9. 4. 9. 4.]]\nIndices: [[4]\n  [3]\n  [2]\n  [2]\n  [0]]\n\n```\n\n</details>\n\n    ",
    "attributes": [
      {
        "default": -1,
        "description": "The axis to get argmin.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": true,
        "description": "If True (default), the output tensor shape will match the input tensor shape except the `axis` dimension equals 1. Else, the `axis` dimension of the output tensor is removed.",
        "name": "keepdims",
        "option": "optional",
        "type": "boolean"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input tensor.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Tensor of indices for the smallest values.",
        "name": "Indices"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Asin",
    "description": "\nCalculates the arcsine of the given input tensor, element-wise.\n",
    "inputs": [
      {
        "description": "Input tensor",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "The arcsine of the input tensor computed element-wise",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "AsinGradient",
    "support_level": "default"
  },
  {
    "name": "Assert",
    "description": "\nTakes in a tensor of type *bool*, *int*, *long*, or *long long* and checks if all values are True when coerced into a boolean. In other words, for non-bool types this asserts that all values in the tensor are non-zero. If a value is False after coerced into a boolean, the operator throws an error. Else, if all values are True, nothing is returned. For tracability, a custom error message can be set using the `error_msg` argument.\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/assert_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Assert\",\n    [\"A\"],\n    [],\n    error_msg=\"Failed assertion from Assert operator\"\n)\n\nworkspace.FeedBlob(\"A\", np.random.randint(10, size=(3,3)).astype(np.int32))\nprint(\"A:\", workspace.FetchBlob(\"A\"))\ntry:\n    workspace.RunOperatorOnce(op)\nexcept RuntimeError:\n    print(\"Assertion Failed!\")\nelse:\n    print(\"Assertion Passed!\")\n\n```\n\n**Result**\n\n```\n\nA:\n[[7 5 6]\n [1 2 4]\n [5 3 7]]\nAssertion Passed!\n\n```\n\n</details>\n\n        ",
    "attributes": [
      {
        "description": "(*string*): custom error message to be thrown when the input does not pass assertion",
        "name": "error_msg",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "(*Tensor*): input tensor",
        "name": "X"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "AsyncNetBarrier",
    "description": "\nThis is a pretty much no-op operator, since it's only purposes is make sure that\nasync_scheduling will schedule certian operations earlier than others.\n\nExaple where this operator can work well - mixture of data-parallel and model-\nparallel training, where one wants to force that all copies are started before\ndata-parallel part starts.\n",
    "attributes": [
      {
        "description": "Specifies either inputs should be across different devices in dev inference options",
        "name": "cross_device",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Atan",
    "description": "\nCalculates the arctangent of the given input tensor, element-wise.\n",
    "inputs": [
      {
        "description": "Input tensor",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "The arctangent of the input tensor computed element-wise",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "AtanGradient",
    "support_level": "default"
  },
  {
    "name": "ATen",
    "support_level": "contribution"
  },
  {
    "name": "AtomicAppend",
    "support_level": "default"
  },
  {
    "name": "AtomicFetchAdd",
    "description": "\nGiven a mutex and two int32 scalar tensors, performs an atomic fetch add\nby mutating the first argument and adding it to the second input\nargument. Returns the updated integer and the value prior to the update.\n",
    "inputs": [
      {
        "description": "Blob containing to a unique_ptr<mutex>",
        "name": "mutex_ptr"
      },
      {
        "description": "Value to be mutated after the sum.",
        "name": "mut_value"
      },
      {
        "description": "Value to add to the first operand.",
        "name": "increment"
      }
    ],
    "outputs": [
      {
        "description": "Mutated value after sum. Usually same as input 1.",
        "name": "mut_value"
      },
      {
        "description": "Value of the first operand before sum.",
        "name": "fetched_value"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "AtomicFetchAdd64",
    "description": "\nLike, AtomicFetchAdd but with int64_t scalar tensors,\nperforms an atomic fetch add\nby mutating the first argument and adding it to the second input\nargument. Returns the updated integer and the value prior to the update.\n",
    "inputs": [
      {
        "description": "Blob containing to a unique_ptr<mutex>",
        "name": "mutex_ptr"
      },
      {
        "description": "Value to be mutated after the sum.",
        "name": "mut_value"
      },
      {
        "description": "Value to add to the first operand.",
        "name": "increment"
      }
    ],
    "outputs": [
      {
        "description": "Mutated value after sum. Usually same as input 1.",
        "name": "mut_value"
      },
      {
        "description": "Value of the first operand before sum.",
        "name": "fetched_value"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "AtomicIter",
    "description": "\nSimilar to Iter, but takes a mutex as the first input to make sure that\nupdates are carried out atomically. This can be used in e.g. Hogwild sgd\nalgorithms.\n",
    "inputs": [
      {
        "description": "The mutex used to do atomic increment.",
        "name": "mutex"
      },
      {
        "description": "The iter counter as an int64_t TensorCPU.",
        "name": "iter"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "AveragedLoss",
    "description": "\nThe *AveragedLoss* op takes a single 1-D input tensor *input* and returns a single output float value *output*. The output represents the average of the values in *input*. This op is commonly used for averaging losses, hence the name, however it does not exclusively operate on losses.\n\nGithub Links:\n\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/loss_op.h\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/loss_op.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"AveragedLoss\",\n    [\"input\"],\n    [\"output\"],\n)\n\nworkspace.FeedBlob(\"input\", np.array([8, 10, 12]).astype(np.float32))\nprint(\"input:\\n\", workspace.FetchBlob(\"input\"))\n\nworkspace.RunOperatorOnce(op)\nprint(\"output: \\n\", workspace.FetchBlob(\"output\"))\n\n```\n\n**Result**\n\n```\n\ninput:\n [ 8. 10. 12.]\noutput:\n 10.0\n\n```\n\n</details>\n\n\n",
    "inputs": [
      {
        "description": "The input data as Tensor",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "The output tensor of size 1 containing the averaged value.",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "AveragedLossGradient",
    "support_level": "default"
  },
  {
    "name": "AveragePool",
    "category": "Pool",
    "description": "AveragePool \nconsumes an input blob and applies average pooling across the the blob according\nto kernel sizes, stride sizes, pad lengths and dilation. Average pooling consists\nof taking the average value of a subset of the input tensor according to the kernel\nsize and downsampling the data into the output blob for further processing. The\n`brew` module has a wrapper for this operator for use in a `ModelHelper` object.\n\nPooling layers reduce the spatial dimensionality of the input blob. Each of the\noutput blob's dimensions will reduce according to:\n\n$$dim_{out}=\\frac{dim_{in}-kernel+2*pad}{stride}+1$$\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/pool_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/pool_op.cc\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/conv_pool_op_base.h\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"AveragePool\",\n    [\"X\"],\n    [\"Y\"],\n    kernel=2,\n    stride=2,\n)\n\nworkspace.FeedBlob(\"X\", np.random.randn(1, 1, 6, 6).astype(np.float32)) // NCHW\nprint(\"X:\\n\", workspace.FetchBlob(\"X\"), \"\\n\")\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n```\n\n**Result**\n\n```\nX:\n [[[[-0.2883434   0.43498734  0.05417408  1.912558    0.09390241\n    -0.33173105]\n   [ 1.633709    1.2047161   0.36964908  0.99961185  0.4184147\n     0.9989975 ]\n   [ 1.7644193   0.1789665   1.5812988  -0.6038542  -0.36090398\n     0.33195344]\n   [ 0.9457722  -0.95174325 -0.78124577  1.2062047   1.1903144\n     0.2586746 ]\n   [ 1.252104    0.32645547  1.8073524  -0.78397465  0.9978303\n    -0.97614396]\n   [ 0.5440196   1.5778259  -0.76750124  0.5051756   0.8838398\n    -0.37085298]]]]\n\nY:\n [[[[0.7462672  0.83399826 0.2948959 ]\n   [0.4843537  0.3506009  0.35500962]\n   [0.9251013  0.19026303 0.13366827]]]]\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input data tensor of shape NCHW or NHWC.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output data tensor.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "AveragePool1D",
    "description": "AveragePool1D \nconsumes an input blob and applies average pooling across the the blob according\nto kernel sizes, stride sizes, pad lengths and dilation. Average pooling consists\nof taking the average value of a subset of the input tensor according to the kernel\nsize and downsampling the data into the output blob for further processing. The\n`brew` module has a wrapper for this operator for use in a `ModelHelper` object.\n\nPooling layers reduce the spatial dimensionality of the input blob. Each of the\noutput blob's dimensions will reduce according to:\n\n$$dim_{out}=\\frac{dim_{in}-kernel+2*pad}{stride}+1$$\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/pool_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/pool_op.cc\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/conv_pool_op_base.h\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"AveragePool\",\n    [\"X\"],\n    [\"Y\"],\n    kernel=2,\n    stride=2,\n)\n\nworkspace.FeedBlob(\"X\", np.random.randn(1, 1, 6, 6).astype(np.float32)) // NCHW\nprint(\"X:\\n\", workspace.FetchBlob(\"X\"), \"\\n\")\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n```\n\n**Result**\n\n```\nX:\n [[[[-0.2883434   0.43498734  0.05417408  1.912558    0.09390241\n    -0.33173105]\n   [ 1.633709    1.2047161   0.36964908  0.99961185  0.4184147\n     0.9989975 ]\n   [ 1.7644193   0.1789665   1.5812988  -0.6038542  -0.36090398\n     0.33195344]\n   [ 0.9457722  -0.95174325 -0.78124577  1.2062047   1.1903144\n     0.2586746 ]\n   [ 1.252104    0.32645547  1.8073524  -0.78397465  0.9978303\n    -0.97614396]\n   [ 0.5440196   1.5778259  -0.76750124  0.5051756   0.8838398\n    -0.37085298]]]]\n\nY:\n [[[[0.7462672  0.83399826 0.2948959 ]\n   [0.4843537  0.3506009  0.35500962]\n   [0.9251013  0.19026303 0.13366827]]]]\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input data tensor of shape NCHW or NHWC.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output data tensor.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "AveragePool1DGradient",
    "support_level": "default"
  },
  {
    "name": "AveragePool2D",
    "description": "AveragePool2D \nconsumes an input blob and applies average pooling across the the blob according\nto kernel sizes, stride sizes, pad lengths and dilation. Average pooling consists\nof taking the average value of a subset of the input tensor according to the kernel\nsize and downsampling the data into the output blob for further processing. The\n`brew` module has a wrapper for this operator for use in a `ModelHelper` object.\n\nPooling layers reduce the spatial dimensionality of the input blob. Each of the\noutput blob's dimensions will reduce according to:\n\n$$dim_{out}=\\frac{dim_{in}-kernel+2*pad}{stride}+1$$\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/pool_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/pool_op.cc\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/conv_pool_op_base.h\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"AveragePool\",\n    [\"X\"],\n    [\"Y\"],\n    kernel=2,\n    stride=2,\n)\n\nworkspace.FeedBlob(\"X\", np.random.randn(1, 1, 6, 6).astype(np.float32)) // NCHW\nprint(\"X:\\n\", workspace.FetchBlob(\"X\"), \"\\n\")\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n```\n\n**Result**\n\n```\nX:\n [[[[-0.2883434   0.43498734  0.05417408  1.912558    0.09390241\n    -0.33173105]\n   [ 1.633709    1.2047161   0.36964908  0.99961185  0.4184147\n     0.9989975 ]\n   [ 1.7644193   0.1789665   1.5812988  -0.6038542  -0.36090398\n     0.33195344]\n   [ 0.9457722  -0.95174325 -0.78124577  1.2062047   1.1903144\n     0.2586746 ]\n   [ 1.252104    0.32645547  1.8073524  -0.78397465  0.9978303\n    -0.97614396]\n   [ 0.5440196   1.5778259  -0.76750124  0.5051756   0.8838398\n    -0.37085298]]]]\n\nY:\n [[[[0.7462672  0.83399826 0.2948959 ]\n   [0.4843537  0.3506009  0.35500962]\n   [0.9251013  0.19026303 0.13366827]]]]\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input data tensor of shape NCHW or NHWC.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output data tensor.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "AveragePool2DGradient",
    "support_level": "default"
  },
  {
    "name": "AveragePool3D",
    "description": "AveragePool3D \nconsumes an input blob and applies average pooling across the the blob according\nto kernel sizes, stride sizes, pad lengths and dilation. Average pooling consists\nof taking the average value of a subset of the input tensor according to the kernel\nsize and downsampling the data into the output blob for further processing. The\n`brew` module has a wrapper for this operator for use in a `ModelHelper` object.\n\nPooling layers reduce the spatial dimensionality of the input blob. Each of the\noutput blob's dimensions will reduce according to:\n\n$$dim_{out}=\\frac{dim_{in}-kernel+2*pad}{stride}+1$$\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/pool_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/pool_op.cc\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/conv_pool_op_base.h\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"AveragePool\",\n    [\"X\"],\n    [\"Y\"],\n    kernel=2,\n    stride=2,\n)\n\nworkspace.FeedBlob(\"X\", np.random.randn(1, 1, 6, 6).astype(np.float32)) // NCHW\nprint(\"X:\\n\", workspace.FetchBlob(\"X\"), \"\\n\")\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n```\n\n**Result**\n\n```\nX:\n [[[[-0.2883434   0.43498734  0.05417408  1.912558    0.09390241\n    -0.33173105]\n   [ 1.633709    1.2047161   0.36964908  0.99961185  0.4184147\n     0.9989975 ]\n   [ 1.7644193   0.1789665   1.5812988  -0.6038542  -0.36090398\n     0.33195344]\n   [ 0.9457722  -0.95174325 -0.78124577  1.2062047   1.1903144\n     0.2586746 ]\n   [ 1.252104    0.32645547  1.8073524  -0.78397465  0.9978303\n    -0.97614396]\n   [ 0.5440196   1.5778259  -0.76750124  0.5051756   0.8838398\n    -0.37085298]]]]\n\nY:\n [[[[0.7462672  0.83399826 0.2948959 ]\n   [0.4843537  0.3506009  0.35500962]\n   [0.9251013  0.19026303 0.13366827]]]]\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input data tensor of shape NCHW or NHWC.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output data tensor.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "AveragePool3DGradient",
    "support_level": "default"
  },
  {
    "name": "AveragePoolGradient",
    "support_level": "default"
  },
  {
    "name": "AveragePut",
    "description": "\n    Consume a value and pushes it to the global stat registry as an average.\n\n    Github Links:\n    - https://github.com/pytorch/pytorch/blob/master/caffe2/operators/stats_put_ops.cc\n\n        ",
    "attributes": [
      {
        "description": "(*str*): name of the stat. If not present, then uses name of input blob",
        "name": "name",
        "option": "optional"
      },
      {
        "description": "(*int64_t*): number to multiply input values by (used when inputting floats, as stats can only receive integers",
        "name": "magnitude_expand",
        "option": "optional"
      },
      {
        "description": "(*boolean*): whether or not to clamp inputs to the max inputs allowed",
        "name": "bound",
        "option": "optional"
      },
      {
        "description": "(*float*): Optionally provide a default value for receiving empty tensors",
        "name": "default_value",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "(*Tensor`<number>`*): A scalar tensor, representing any numeric value",
        "name": "value"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Barrier",
    "description": "\nDoes a barrier operation among the nodes.\n",
    "inputs": [
      {
        "description": "The common world.",
        "name": "comm_world"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "BatchBoxCox",
    "description": "\nInput `data` is a N * D matrix. Apply box-cox transform for each column.\n`lambda1` and `lambda2` is of size D that defines the hyper-parameters for\nthe transform of each column `x` of the input `data`:\n\n    ln(x + lambda2), if lambda1 == 0\n    ((x + lambda2)^lambda1 - 1)/lambda1, if lambda1 != 0\n\n",
    "inputs": [
      {
        "description": "input float or double N * D matrix",
        "name": "data"
      },
      {
        "description": "tensor of size D with the same type as data",
        "name": "lambda1"
      },
      {
        "description": "tensor of size D with the same type as data",
        "name": "lambda2"
      }
    ],
    "outputs": [
      {
        "description": "output matrix that applied box-cox transform",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "BatchBucketize",
    "description": "\nBucketize the float_features into sparse features.\nThe float_features is a N * D tensor where N is the batch_size, and D is the feature_dim.\nThe indices is a 1D tensor containing the indices of the features that need to be bucketized.\nThe lengths is a 1D tensor that splits the following 'boundaries' argument.\nThe boundaries is a 1D tensor containing the border list for each feature.\n\nWith in each batch, `indices` should not have duplicate number,\nand the number of elements in `indices` should be less than or equal to `D`.\nEach element in `lengths` vector (lengths[`i`]) represents\nthe number of boundaries in the sub border list.\nThe sum of all elements in `lengths` must be equal to the size of  `boundaries`.\nIf lengths[0] = 2, the first sub border list is [0.5, 1.0], which separate the\nvalue to (-inf, 0.5], (0,5, 1.0], (1.0, inf). The bucketized feature will have\nthree possible values (i.e. 0, 1, 2).\n\n\nFor example, with input:\n\n  float_features = [[1.42, 2.07, 3.19, 0.55, 4.32],\n                    [4.57, 2.30, 0.84, 4.48, 3.09],\n                    [0.89, 0.26, 2.41, 0.47, 1.05],\n                    [0.03, 2.97, 2.43, 4.36, 3.11],\n                    [2.74, 5.77, 0.90, 2.63, 0.38]]\n  indices = [0, 1, 4]\n  lengths = [2, 3, 1]\n  boundaries =  [0.5, 1.0, 1.5, 2.5, 3.5, 2.5]\n\nThe output is:\n\n  output =[[2, 1, 1],\n           [2, 1, 1],\n           [1, 0, 0],\n           [0, 2, 1],\n           [2, 3, 0]]\n\nafter running this operator.\n",
    "inputs": [
      {
        "description": "2-D dense tensor, the second dimension must be greater or equal to the indices dimension",
        "name": "float_features"
      },
      {
        "description": "Flatten tensor, containing the indices of `float_features` to be bucketized. The datatype must be int32.",
        "name": "indices"
      },
      {
        "description": "Flatten tensor, the size must be equal to that of `indices`. The datatype must be int32.",
        "name": "lengths"
      },
      {
        "description": "Flatten tensor, dimension has to match the sum of lengths",
        "name": "boundaries"
      }
    ],
    "outputs": [
      {
        "description": "2-D dense tensor, with 1st dim = float_features.dim(0), 2nd dim = size(indices)in the arg list, the tensor is of the same data type as `feature`.",
        "name": "bucktized_feat"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "BatchBucketOneHot",
    "description": "\nInput is a matrix tensor. Its first dimension is the batch\nsize. For each column, bucketize it based on the boundary values and then do\none hot encoding. The `lengths` specifies the number of boundary values for each\ncolumn. The final number of buckets is this number plus 1. This would also be\nthe expanded feature size. `boundaries` specifies all the boundary values.\nNote that each bucket is right-inclusive. That is, given boundary values\n[b1, b2, b3], the buckets are defined as (-int, b1], (b1, b2], (b2, b3], (b3, inf).\nFor example\n\n  data = [[2, 3], [4, 1], [2, 5]], lengths = [2, 3],\n  If boundaries = [0.1, 2.5, 1, 3.1, 4.5], then\n  output = [[0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1]]\n\n  If boundaries = [0.1, 2.5, 1, 1, 3.1], then\n  output = [[0, 1, 0, 0, 0, 1, 0], [0, 0, 1, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 1]]\n\n",
    "inputs": [
      {
        "description": "input tensor matrix",
        "name": "data"
      },
      {
        "description": "the size is the same as the width of the `data`",
        "name": "lengths"
      },
      {
        "description": "bucket boundaries",
        "name": "boundaries"
      }
    ],
    "outputs": [
      {
        "description": "output matrix that expands each input column with one hot encodingbased on the bucketization",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "BatchDenseToSparse",
    "description": "\nThis Op is a inverse of BatchSparseToDenseOp.\nBasically, given a `lengths` vector, a `indices` vector,\nand a dense matrix `dense`, output `value` vector so that, along with\n`lengths` vector and `indices` vector, forms a sparse representation\nof the dense matrix.\n\nA sparse matrix is represented by `lengths` vector, `indices` vector,\nand `values` vector. Each element in `lengths` vector (lengths[`i`]) represents\nthe number of indices in this batch (batch `i`).\nWith in each batch, `indices` should not have duplicate number.\n\nFor example, with input:\n\n  lengths = [2, 3, 1]\n  indices = [0, 1, 2, 3, 4, 5]\n  output = [[6, 7, 0, 0, 0,  0],\n            [0, 0, 8, 9, 10, 0],\n            [0, 0, 0, 0, 0, 11]]\n\nThe output is:\n\n  values = [6, 7, 8, 9, 10, 11]\n\nafter running this operator.\n",
    "inputs": [
      {
        "description": "Flatten lengths, Used to break down indices into per batch indices",
        "name": "lengths"
      },
      {
        "description": "Flatten indices, tensor of total size = \\sum lengths, containing the indices ",
        "name": "indices"
      },
      {
        "description": "dense 2-D tensor, first dim = len(lengths), last dim > Any(indices)",
        "name": "dense"
      }
    ],
    "outputs": [
      {
        "description": "Values, tensor of the same size as `indices` and same data type as dense tensor.",
        "name": "values"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "BatchGather",
    "description": "\nBatch gather operation, first dimension in DATA is the batch size.\nGiven DATA tensor of rank r >= 2, and INDICES tensor of rank q >= 1, gather\nentries of the second outer dimension (axis == 1) of DATA indexed by INDICES,\nand concatenate them in an output tensor of rank q + (r - 1).\n\nExample:\n  DATA  = [\n      [1.0, 1.2, 2.4, 4.5],\n      [2.3, 3.4, 3.6, 2.3],\n      [4.5, 5.7, 1.2, 4.5],\n  ]\n  INDICES = [0, 2]\n\n  OUTPUT = [\n      [1.0, 2.4],\n      [2.3, 3.6],\n      [4.5, 1.2],\n  ]\n",
    "inputs": [
      {
        "description": "Tensor of rank r >= 2.",
        "name": "DATA"
      },
      {
        "description": "Tensor of int32/int64 indices, of any rank q.",
        "name": "INDICES"
      }
    ],
    "outputs": [
      {
        "description": "Tensor of rank q + (r - 1).",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "BatchGatherGradient",
    "support_level": "default"
  },
  {
    "name": "BatchMatMul",
    "description": "\nBatch Matrix multiplication Yi = Ai * Bi, where A has shape (dim0, dim1, ... M, K),\nB has shape (dim0, dim1, ... K, N), Y has shape (dim0, dim1, ... M, N) and i ranges\nfrom 0 to (dim0 * dim1 ...) - 1. rank(A) == rank(B) >= 2. In case of A and B being\ntwo dimensional, it behaves like normal matrix multiplication.\n",
    "attributes": [
      {
        "description": "Pass 1 to transpose the last two dimensions of A before doing multiplication",
        "name": "trans_a",
        "option": "optional"
      },
      {
        "description": "Pass 1 to transpose the last two dimensions of B before doing multiplication",
        "name": "trans_b",
        "option": "optional"
      },
      {
        "description": "Pass 1 to allow broadcasting of dimensions. Behavior is the same as numpy.matmul. Gradient is currently not supported when running in broadcast mode.",
        "name": "broadcast",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "tensor of shape (dim0, dim1 ... M, K)",
        "name": "A"
      },
      {
        "description": "tensor of shape (dim0, dim1 ... K, N)",
        "name": "B"
      }
    ],
    "outputs": [
      {
        "description": "tensor of shape (dim0, dim1 ... M, N)",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "BatchMoments",
    "support_level": "default"
  },
  {
    "name": "BatchMomentsGradient",
    "support_level": "default"
  },
  {
    "name": "BatchOneHot",
    "description": "\nInput is a matrix tensor. Its first dimension is the batch\nsize. Expand each column of it using one hot encoding. The `lengths` specifies\nthe size of each column after encoding, and the `values` is the dictionary value\nof one-hot encoding for each column. For example\n\n  If data = [[2, 3], [4, 1], [2, 5]], lengths = [2, 3],\n  and values = [2, 4, 1, 3, 5], then\n\n  output = [[1, 0, 0, 1, 0], [0, 1, 1, 0, 0], [1, 0, 0, 0, 1]]\n",
    "inputs": [
      {
        "description": "input tensor matrix",
        "name": "data"
      },
      {
        "description": "the size is the same as the width of the `data`",
        "name": "lengths"
      },
      {
        "description": "one hot encoding dictionary values",
        "name": "values"
      }
    ],
    "outputs": [
      {
        "description": "output matrix that expands each input column with one hot encoding",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "BatchPermutation",
    "description": "\nBatch permutation of an input tensor X given input indices. First dimension of\nX equals batch size N. The indices stores a be permutation of N.\nThe output Y is a tensor of same shape as X, with data re-ordered according to\nthe indices within the batch size.\n\nExample of batch permutation on a 2-D tensor with batch size 4:\n  X = [\n    [1, 5, 2, 3, 4, 6, 0],\n    [4, 3, 3, 5, 2, 3, 1],\n    [2, 2, 3, 6, 0, 0, 1],\n    [0, 0, 1, 1, 2, 2, 3]\n  ]\n  indices = [2, 0, 1, 3]\n  Y = [\n    [2, 2, 3, 6, 0, 0, 1],\n    [1, 5, 2, 3, 4, 6, 0],\n    [4, 3, 3, 5, 2, 3, 1],\n    [0, 0, 1, 1, 2, 2, 3]\n  ]\n\nExample of batch permutation on a 3-D tensor with batch size 4:\n  X = [\n    [[1, 5, 2], [3, 4, 6, 0]],\n    [[4, 3, 3], [5, 2, 3, 1]],\n    [[2, 2, 3], [6, 0, 0, 1]],\n    [[0, 0, 1], [1, 2, 2, 3]]\n  ]\n  indices = [2, 0, 1, 3]\n  Y = [\n    [[2, 2, 3], [6, 0, 0, 1]],\n    [[1, 5, 2], [3, 4, 6, 0]],\n    [[4, 3, 3], [5, 2, 3, 1]],\n    [[0, 0, 1], [1, 2, 2, 3]]\n  ]\n",
    "inputs": [
      {
        "description": "Input tensor, where 1st dimension equals batch size",
        "name": "X"
      },
      {
        "description": "Input indices of batch to permute",
        "name": "indices"
      }
    ],
    "outputs": [
      {
        "description": "Output permuted tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "BatchPermutationGradient",
    "support_level": "default"
  },
  {
    "name": "BatchSparseToDense",
    "description": "\nConvert sparse matrix representation into dense matrix.\n\nA sparse matrix is represented by `lengths` vector, `indices` vector,\nand `values` vector. Each element in `lengths` vector (lengths[`i`]) represents\nthe number of indices in this batch (batch `i`).\nWith in each batch, `indices` should not have duplicate number.\n\nFor example, with input:\n\n  lengths = [2, 3, 1]\n  indices = [0, 1, 2, 3, 4, 5]\n  values =  [6, 7, 8, 9, 10, 11]\n  dense_dim = 6\n  default_value = 0\n\nThe output is:\n\n  output = [[6, 7, 0, 0, 0,  0],\n            [0, 0, 8, 9, 10, 0],\n            [0, 0, 0, 0, 0, 11]]\n\nafter running this operator.\n",
    "attributes": [
      {
        "description": "Optional, output dense last dimension. If both this argument and output_shape_inference are set, it should be consistent with output_shape_inference's last dim",
        "name": "dense_last_dim",
        "option": "optional"
      },
      {
        "description": "Optional, missing values are filled with this value.default_value = 0 when not set",
        "name": "default_value",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Flatten tensor, used to break down indices and values into per batch indices and values.",
        "name": "lengths"
      },
      {
        "description": "Flatten tensor of total size = \\sum lengths, containing the indices ",
        "name": "indices"
      },
      {
        "description": "Data tensor, dimension has to match `indices`",
        "name": "values"
      },
      {
        "description": "Optional, a dense tensor whose shape define the output shape",
        "name": "output_shape_inference"
      }
    ],
    "outputs": [
      {
        "description": "2-D dense tensor, with 1st dim = len(lengths), 2nd dim = dense_last_dimin the arg list, the tensor is of the same data type as `values`.Missing values are filled with default_value",
        "name": "dense"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "BatchToSpace",
    "description": "\nRearranges (permutes) data from batch into blocks of spatial data, followed by cropping. This is the reverse transformation of `SpaceToBatch`. More specifically, this op outputs a copy of the input tensor where values from the batch dimension are moved in spatial blocks to the height and width dimensions, followed by cropping along the height and width dimensions. Only \"NCHW\" order is currently supported.\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/space_batch_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"BatchToSpace\",\n    [\"X\"],\n    [\"Y\"],\n    pad=3\n)\n\nworkspace.FeedBlob(\"X\", np.random.rand(10,3,32,32).astype(np.float32))\nprint(\"X.shape:\", workspace.FetchBlob(\"X\").shape)\nworkspace.RunOperatorOnce(op)\nprint(\"Y.shape:\", workspace.FetchBlob(\"Y\").shape)\n\n```\n\n**Result**\n\n```\n\nX.shape: (10, 3, 32, 32)\nY.shape: (2, 3, 58, 58)\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "(*int*): exclusive axis that divides the first and second dimension of matrix `A` (default=0)",
        "name": "pad",
        "option": "optional"
      },
      {
        "description": "(*int*): height/width of spatial blocks to be moved (default=2)",
        "name": "block_size",
        "option": "optional"
      },
      {
        "description": "(*string*): order of dimensions of input and output blobs; only \"NCHW\" order is currently supported (default=\"NCHW\")",
        "name": "order",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "(*Tensor`<float>`*): input tensor (NCHW order)",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor`<float>`*): output tensor (NCHW order)",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "BBoxTransform",
    "description": "\nTransform proposal bounding boxes to target bounding box using bounding box\n    regression deltas.\n",
    "attributes": [
      {
        "description": "vector<float> weights [wx, wy, ww, wh] for the deltas",
        "name": "weights",
        "option": "optional"
      },
      {
        "description": "bool (default true), transform the boxes to the scaled image space after applying the bbox deltas.Set to false to match the detectron code, set to true for keypoint models and for backward compatibility",
        "name": "apply_scale",
        "option": "optional"
      },
      {
        "description": "bool (default false), Correct bounding box transform coordates, see bbox_transform() in boxes.py Set to true to match the detectron code, set to false for backward compatibility",
        "name": "correct_transform_coords",
        "option": "optional"
      },
      {
        "description": "bool (default false). If true, then boxes (rois and deltas) include angle info to handle rotation. The format will be [ctr_x, ctr_y, width, height, angle (in degrees)].",
        "name": "rotated",
        "option": "optional"
      },
      {
        "description": "bool (default true). If set, for rotated boxes, angle is normalized to be within [angle_bound_lo, angle_bound_hi].",
        "name": "angle_bound_on",
        "option": "optional"
      },
      {
        "description": "int (default -90 degrees). If set, for rotated boxes, angle is normalized to be within [angle_bound_lo, angle_bound_hi].",
        "name": "angle_bound_lo",
        "option": "optional"
      },
      {
        "description": "int (default 90 degrees). If set, for rotated boxes, angle is normalized to be within [angle_bound_lo, angle_bound_hi].",
        "name": "angle_bound_hi",
        "option": "optional"
      },
      {
        "description": "float (default 1.0 degrees). For RRPN, clip almost horizontal boxes within this threshold of tolerance for backward compatibility. Set to negative value for no clipping.",
        "name": "clip_angle_thresh",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Bounding box proposals in pixel coordinates, Size (M, 4), format [x1, y1, x2, y2], orSize (M, 5), format [batch_index, x1, y1, x2, y2]. If proposals from multiple images in a batch are present, they should be grouped sequentially and in incremental order.For rotated boxes, this would have an additional angle (in degrees) in the format [<optionaal_batch_id>, ctr_x, ctr_y, w, h, angle].",
        "name": "rois"
      },
      {
        "description": "bounding box translations and scales,size (M, 4*K), format [dx, dy, dw, dh], K = # classes. For rotated boxes, size (M, 5*K, format [dx, dy, dw, dh, da].",
        "name": "deltas"
      },
      {
        "description": "Image dimensions, size (batch_size, 3), format [img_height, img_width, img_scale]",
        "name": "im_info"
      }
    ],
    "outputs": [
      {
        "description": "Pixel coordinates of the transformed bounding boxes,Size (M, 4*K), format [x1, y1, x2, y2]. For rotated boxes, size (M, 5*K), format [ctr_x, ctr_y, w, h, angle].",
        "name": "box_out"
      },
      {
        "description": "Tensor of shape (batch_size) with each element denoting the number of RoIs belonging to the corresponding image in batch",
        "name": "roi_batch_splits"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "BernoulliJSD",
    "description": "\nComputes the Jensen-Shannon divergence (JSD) between two Bernoulli distributions\nwhere each is parametrized by a single probability.\n",
    "inputs": [
      {
        "description": "array of probabilities for target",
        "name": "T"
      }
    ],
    "outputs": [
      {
        "description": "array of JSD losses",
        "name": "L"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "BernoulliJSDGradient",
    "support_level": "default"
  },
  {
    "name": "BisectPercentile",
    "description": "\n    This operator is to map raw feature values into the percentile\n    representations based on Bisection for more than one feature.\n\n    The input is the bath of input feature values, with the size of (batch_size,\n    num_feature), where num_feature = F (F >= 1).\n\n    For each feature, we also need additional information regarding the feature\n    value distribution.\n    There are several vectors to keep data to percentile mappping information\n    as arguments (context):\n    1. feature raw values (R)\n    2. feature percentile mapping (P)\n    3. feature percentile lower bound (L)\n    4. feature percentile upper bound (U)\n\n    A toy example:\n    Suppose the sampled data distribution is as follows:\n    1, 1, 2, 2, 2, 2, 2, 2, 3, 4\n    We have the mapping vectors as follows:\n    R = [1, 2, 3, 4]\n    P = [0.15, 0.55, 0.9, 1.0]\n    L = [0.1, 0.3, 0.9, 1.0]\n    U = [0.2, 0.8, 0.9, 1.0]\n    Where P is computed as (L + U) / 2.\n\n    For a given list of feature values, X = [x_0, x_1, ..., x_i, ...], for each\n    feature value (x_i) we first apply bisection to find the right index (t),\n    such that R[t] <= x_i < R[t+1].\n    If x_i = R[t], P[t] is returned;\n    otherwise, the interpolation is apply by (R[t], R[t+1]) and (U[t] and L[t]).\n\n    As there are F features (F >= 1), we concate all the R_f, P_f, L_f, and\n    U_f for each feature f and use an additional input length to keep track of\n    the number of points for each set of raw feature value to percentile mapping.\n    For example, there are two features:\n    R_1 =[0.1, 0.4, 0.5];\n    R_2 = [0.3, 1.2];\n    We will build R = [0.1, 0.4, 0.5, 0.3, 1.2]; besides, we have\n    lengths = [3, 2]\n    to indicate the boundaries of the percentile information.\n\n",
    "attributes": [
      {
        "description": "1D tensor, which is the concatenation of all sorted raw feature values for all features.",
        "name": "percentile_raw",
        "option": "optional"
      },
      {
        "description": "1D tensor. There is one-one mapping between percentile_mapping and percentile_raw such that each element in percentile_mapping corresponds to the percentile value of the corresponding raw feature value.",
        "name": "percentile_mapping",
        "option": "optional"
      },
      {
        "description": "1D tensor. There is one-one mapping between percentile_upper and percentile_raw such that each element in percentile_mapping corresponds to the percentile lower bound of the corresponding raw feature value.",
        "name": "percentile_lower",
        "option": "optional"
      },
      {
        "description": "1D tensor. There is one-one mapping between percentile_upper and percentile_raw such that each element in percentile_mapping corresponds to the percentile upper bound of the corresponding raw feature value.",
        "name": "percentile_upper",
        "option": "optional"
      },
      {
        "description": "1D tensor. There is one-one mapping between percentile_upper and percentile_raw such that each element in percentile_mapping corresponds to the percentile upper bound of the corresponding raw feature value.",
        "name": "lengths",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input 2D tensor of floats of size (N, D), where N is the batch size and D is the feature dimension.",
        "name": "raw_values"
      }
    ],
    "outputs": [
      {
        "description": "2D tensor of output with the same dimensions as the input raw_values.",
        "name": "percentile"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "BitwiseAnd",
    "description": "\nPerforms element-wise bitwise operation `bitwise_and` (with limited broadcast support).\nBoth input operands should be of type `bool`.\n\nIf necessary the right-hand-side argument will be broadcasted to match the\nshape of left-hand-side argument. When broadcasting is specified, the second\ntensor can either be of size 1 (a scalar value), or having its shape as a\ncontiguous subset of the first tensor's shape. The starting of the mutually\nequal shape is specified by the argument \"axis\", and if it is not set, suffix\nmatching is assumed. 1-dim expansion doesn't work yet.\n\nFor example, the following tensor shapes are supported (with broadcast=1):\n```\n  shape(A) = (2, 3, 4, 5), shape(B) = (,), i.e. B is a scalar\n  shape(A) = (2, 3, 4, 5), shape(B) = (5,)\n  shape(A) = (2, 3, 4, 5), shape(B) = (4, 5)\n  shape(A) = (2, 3, 4, 5), shape(B) = (3, 4), with axis=1\n  shape(A) = (2, 3, 4, 5), shape(B) = (2), with axis=0\n```\nArgument `broadcast=1` needs to be passed to enable broadcasting.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/elementwise_ops_schema.cc\n\n",
    "attributes": [
      {
        "default": 0,
        "description": "Pass 1 to enable broadcasting.",
        "name": "broadcast",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": -1,
        "description": "Axis to concatenate on. If set, defines the broadcast dimensions.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor)* First operand.",
        "name": "A"
      },
      {
        "description": "*(type: Tensor)* Second operand. With broadcasting can be of smaller size than `A`. If broadcasting is disabled it should be of the same size.",
        "name": "B"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor)* Output tensor. Has same dimensions as input `A`.",
        "name": "C"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "BitwiseOr",
    "description": "\nPerforms element-wise bitwise operation `bitwise_or` (with limited broadcast support).\nBoth input operands should be of type `bool`.\n\nIf necessary the right-hand-side argument will be broadcasted to match the\nshape of left-hand-side argument. When broadcasting is specified, the second\ntensor can either be of size 1 (a scalar value), or having its shape as a\ncontiguous subset of the first tensor's shape. The starting of the mutually\nequal shape is specified by the argument \"axis\", and if it is not set, suffix\nmatching is assumed. 1-dim expansion doesn't work yet.\n\nFor example, the following tensor shapes are supported (with broadcast=1):\n```\n  shape(A) = (2, 3, 4, 5), shape(B) = (,), i.e. B is a scalar\n  shape(A) = (2, 3, 4, 5), shape(B) = (5,)\n  shape(A) = (2, 3, 4, 5), shape(B) = (4, 5)\n  shape(A) = (2, 3, 4, 5), shape(B) = (3, 4), with axis=1\n  shape(A) = (2, 3, 4, 5), shape(B) = (2), with axis=0\n```\nArgument `broadcast=1` needs to be passed to enable broadcasting.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/elementwise_ops_schema.cc\n\n",
    "attributes": [
      {
        "default": 0,
        "description": "Pass 1 to enable broadcasting.",
        "name": "broadcast",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": -1,
        "description": "Axis to concatenate on. If set, defines the broadcast dimensions.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor)* First operand.",
        "name": "A"
      },
      {
        "description": "*(type: Tensor)* Second operand. With broadcasting can be of smaller size than `A`. If broadcasting is disabled it should be of the same size.",
        "name": "B"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor)* Output tensor. Has same dimensions as input `A`.",
        "name": "C"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "BitwiseXor",
    "description": "\nPerforms element-wise bitwise operation `bitwise_xor` (with limited broadcast support).\nBoth input operands should be of type `bool`.\n\nIf necessary the right-hand-side argument will be broadcasted to match the\nshape of left-hand-side argument. When broadcasting is specified, the second\ntensor can either be of size 1 (a scalar value), or having its shape as a\ncontiguous subset of the first tensor's shape. The starting of the mutually\nequal shape is specified by the argument \"axis\", and if it is not set, suffix\nmatching is assumed. 1-dim expansion doesn't work yet.\n\nFor example, the following tensor shapes are supported (with broadcast=1):\n```\n  shape(A) = (2, 3, 4, 5), shape(B) = (,), i.e. B is a scalar\n  shape(A) = (2, 3, 4, 5), shape(B) = (5,)\n  shape(A) = (2, 3, 4, 5), shape(B) = (4, 5)\n  shape(A) = (2, 3, 4, 5), shape(B) = (3, 4), with axis=1\n  shape(A) = (2, 3, 4, 5), shape(B) = (2), with axis=0\n```\nArgument `broadcast=1` needs to be passed to enable broadcasting.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/elementwise_ops_schema.cc\n\n",
    "attributes": [
      {
        "default": 0,
        "description": "Pass 1 to enable broadcasting.",
        "name": "broadcast",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": -1,
        "description": "Axis to concatenate on. If set, defines the broadcast dimensions.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor)* First operand.",
        "name": "A"
      },
      {
        "description": "*(type: Tensor)* Second operand. With broadcasting can be of smaller size than `A`. If broadcasting is disabled it should be of the same size.",
        "name": "B"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor)* Output tensor. Has same dimensions as input `A`.",
        "name": "C"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "BooleanMask",
    "description": "\nGiven a 1D `data` tensor and a boolean `mask` tensor of the same shape, returns a `masked_data` tensor containing only the elements corresponding to positions where the `mask` is True, and a `masked_indices` tensor containing the indices of the True elements.\n\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/boolean_mask_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"BooleanMask\",\n    [\"data\", \"mask\"],\n    [\"masked_data\", \"masked_indices\"]\n)\n\nworkspace.FeedBlob(\"data\", np.array([1,2,3,4,5,6]))\nworkspace.FeedBlob(\"mask\", np.array([True,False,False,True,True,False]))\nprint(\"data:\", workspace.FetchBlob(\"data\"))\nprint(\"mask:\", workspace.FetchBlob(\"mask\"))\nworkspace.RunOperatorOnce(op)\nprint(\"masked_data:\", workspace.FetchBlob(\"masked_data\"))\nprint(\"masked_indices:\", workspace.FetchBlob(\"masked_indices\"))\n\n```\n\n**Result**\n\n```\n\ndata: [1 2 3 4 5 6]\nmask: [ True False False  True  True False]\nmasked_data: [1 4 5]\nmasked_indices: [0 3 4]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "(*Tensor*): 1D input tensor",
        "name": "data"
      },
      {
        "description": "(*Tensor`<bool>`*): tensor of bools which determines the input elements that will be left in the `masked_data` output tensor; same shape as `data`",
        "name": "mask"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor*): 1D tensor of same type as `data` input that contains the masked input tensor",
        "name": "masked_data"
      },
      {
        "description": "(*Tensor`<int>`*): 1D tensor of indices of the True elements in the `mask` tensor",
        "name": "masked_indices"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "BooleanMaskGradient",
    "support_level": "default"
  },
  {
    "name": "BooleanMaskLengths",
    "description": "\nGiven a tensor of int32 `lengths` tensor representing segment lengths and a `mask` (boolean) tensor, return the segment lengths of the corresponding segmented tensor after **BooleanMask** is applied.\n\nIf `lengths` tensor is $[a_1, a_2, ..., a_n]$, then length of `mask` tensor must be $a_1 + a_2 + ... + a_n$.\n\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/boolean_mask_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"BooleanMaskLengths\",\n    [\"lengths\", \"mask\"],\n    [\"masked_lengths\"]\n)\n\nworkspace.FeedBlob(\"lengths\", np.array([1,3,2], dtype=np.int32))\nworkspace.FeedBlob(\"mask\", np.array([False,True,True,False,True,True]))\nprint(\"lengths:\", workspace.FetchBlob(\"lengths\"))\nprint(\"mask:\", workspace.FetchBlob(\"mask\"))\nworkspace.RunOperatorOnce(op)\nprint(\"masked_lengths:\", workspace.FetchBlob(\"masked_lengths\"))\n\n```\n\n**Result**\n\n```\n\nlengths: [1 3 2]\nmask: [False  True  True False  True  True]\nmasked_lengths: [0 2 2]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "(*Tensor`<int>`*): input tensor containing segment lengths",
        "name": "lengths"
      },
      {
        "description": "(*Tensor`<bool>`*): A 1D bool tensor of values to keep.",
        "name": "mask"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor`<int>`*): 1D tensor of same type as inputs that contains the sequence",
        "name": "masked_lengths"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "BooleanUnmask",
    "description": "\nGiven a series of masks and values, reconstruct values together according to masks. A comprehensive example:\n```\nmask1   = True, False, True, False, False\nvalues1 = 1.0, 3.0\nmask2   = False, True, False, False, False\nvalues2 = 2.0\nmask3   = False, False, False, True, True\nvalues3 = 4.0, 5.0\n```\n\nReconstruct by:\n\n```\noutput = net.BooleanUnmask([mask1, values1, mask2, values2, mask3, values3], [\"output\"])\noutput = 1.0, 2.0, 3.0, 4.0, 5.0\n```\n\nNote that for all mask positions, there must be at least one True. This is not allowed:\n\n```\nmask1   = True, False\nvalues1 = 1.0\nmask2   = False, False\nvalues2 =\n\noutput = net.BooleanUnmask([mask1, values1, mask2, values2], [\"output\"])\n```\n\nIf there are multiple True values for a field, we accept the first value, and no longer expect a value for that location:\n\n```\nmask1   = True, False\nvalues1 = 1.0\nmask2   = True, True\nvalues2 = 2.0\n\noutput = net.BooleanUnmask([mask1, values1, mask2, values2], [\"output\"])\noutput = 1.0, 2.0\n```\n\n*** Note that we alternate `data` and `mask` inputs\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/boolean_unmask_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"BooleanUnmask\",\n    [\"mask1\", \"data1\", \"mask2\", \"data2\"],\n    [\"unmasked_data\"]\n)\n\nworkspace.FeedBlob(\"mask1\", np.array([True,False,False,True,True,False]))\nworkspace.FeedBlob(\"data1\", np.array([1,4,5]))\nworkspace.FeedBlob(\"mask2\", np.array([False,True,True,False,False,True]))\nworkspace.FeedBlob(\"data2\", np.array([2,3,6]))\n\nprint(\"data1:\", workspace.FetchBlob(\"data1\"))\nprint(\"mask1:\", workspace.FetchBlob(\"mask1\"))\nprint(\"data2:\", workspace.FetchBlob(\"data2\"))\nprint(\"mask2:\", workspace.FetchBlob(\"mask2\"))\nworkspace.RunOperatorOnce(op)\nprint(\"unmasked_data:\", workspace.FetchBlob(\"unmasked_data\"))\n\n```\n\n**Result**\n\n```\n\ndata1: [1 4 5]\nmask1: [ True False False  True  True False]\ndata2: [2 3 6]\nmask2: [False  True  True False False  True]\nunmasked_data: [1 2 3 4 5 6]\n\n```\n\n</details>\n",
    "inputs": [
      {
        "description": "(*Tensor*): 1D input tensor(s)",
        "name": "data"
      },
      {
        "description": "(*Tensor`<bool>`*): 1D boolean mask tensor(s)",
        "name": "mask"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor*): 1D tensor of same type as `data` input that contains the unmasked input tensor",
        "name": "unmasked_data"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "BoxWithNMSLimit",
    "description": "\nApply NMS to each class (except background) and limit the number of\nreturned boxes.\n",
    "attributes": [
      {
        "description": "(float) TEST.SCORE_THRESH",
        "name": "score_thresh",
        "option": "optional"
      },
      {
        "description": "(float) TEST.NMS",
        "name": "nms",
        "option": "optional"
      },
      {
        "description": "(int) TEST.DEECTIONS_PER_IM",
        "name": "detections_per_im",
        "option": "optional"
      },
      {
        "description": "(bool) TEST.SOFT_NMS.ENABLED",
        "name": "soft_nms_enabled",
        "option": "optional"
      },
      {
        "description": "(string) TEST.SOFT_NMS.METHOD",
        "name": "soft_nms_method",
        "option": "optional"
      },
      {
        "description": "(float) TEST.SOFT_NMS.SIGMA",
        "name": "soft_nms_sigma",
        "option": "optional"
      },
      {
        "description": "(float) Lower bound on updated scores to discard boxes",
        "name": "soft_nms_min_score_thres",
        "option": "optional"
      },
      {
        "description": "bool (default false). If true, then boxes (rois and deltas) include angle info to handle rotation. The format will be [ctr_x, ctr_y, width, height, angle (in degrees)].",
        "name": "rotated",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Scores, size (count, num_classes)",
        "name": "scores"
      },
      {
        "description": "Bounding box for each class, size (count, num_classes * 4). For rotated boxes, this would have an additional angle (in degrees) in the format [<optionaal_batch_id>, ctr_x, ctr_y, w, h, angle]. Size: (count, num_classes * 5).",
        "name": "boxes"
      },
      {
        "description": "Tensor of shape (batch_size) with each element denoting the number of RoIs/boxes belonging to the corresponding image in batch. Sum should add up to total count of scores/boxes.",
        "name": "batch_splits"
      }
    ],
    "outputs": [
      {
        "description": "Filtered scores, size (n)",
        "name": "scores"
      },
      {
        "description": "Filtered boxes, size (n, 4). For rotated boxes, size (n, 5), format [ctr_x, ctr_y, w, h, angle].",
        "name": "boxes"
      },
      {
        "description": "Class id for each filtered score/box, size (n)",
        "name": "classes"
      },
      {
        "description": "Output batch splits for scores/boxes after applying NMS",
        "name": "batch_splits"
      },
      {
        "description": "Optional filtered indices, size (n)",
        "name": "keeps"
      },
      {
        "description": "Optional number of filtered indices per class, size (num_classes)",
        "name": "keeps_size"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "BRGNCHWCToPackedInt8BGRAStylizerDeprocess",
    "support_level": "default"
  },
  {
    "name": "Broadcast",
    "description": "\nDoes a broadcast operation from the root node to every other node. The tensor\non each node should have been pre-created with the same shape and data type.\n",
    "attributes": [
      {
        "description": "(int, default 0) the root to run broadcast from.",
        "name": "root",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "The common world.",
        "name": "comm_world"
      },
      {
        "description": "A tensor to be broadcasted.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "In-place as input 1.",
        "name": "X"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Bucketize",
    "description": "\nThis operator works as bucketize in tensorflow and digitize\nin numpy. It bucketizes the input 'X' based on argument 'boundaries'.\nFor each value x in input 'data', the operator returns index i given\nboundaries[i-1] < x <= boundaries[i].\nIf values in 'data' are beyond the bounds of boundaries, 0 or\nlen(boundaries) is returned as appropriate.\nThe boundaries need to be monotonically increasing.\nFor example\n\nIf data = [2, 4, 1] and boundaries = [0.1, 2.5], then\n\noutput = [1, 2, 1]\n\nIf data = [[2, 3], [4, 1], [2, 5]] and boundaries = [0.1, 2.5], then\n\noutput = [[1, 2], [2, 1], [1, 2]]\n\n",
    "attributes": [
      {
        "description": "bucketization boundaries",
        "name": "boundaries",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "input tensor",
        "name": "data"
      }
    ],
    "outputs": [
      {
        "description": "indices of bins given by boundaries to which each valuein data belongs",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ByteWeightDequant",
    "support_level": "default"
  },
  {
    "name": "Cast",
    "description": "\nCasts the elements of a given input tensor to a data type specified by the `to`\nargument and returns an output tensor of the same size in the converted type.\nThe `to` argument must be one of the data types specified in the *DataType*\nenum field in the TensorProto message (see below). If the `to` argument is not\nprovided or is not one of the enumerated types in *DataType*, Caffe2 throws an\nEnforce error.\n\nNOTE: Casting from strings is not supported, and casting to strings is only\nsupported on CPU.\n\nTensorProto *DataType* field:\n```\nmessage TensorProto {\n  ...\n  enum DataType {\n    UNDEFINED = 0;\n    FLOAT = 1;  // float\n    INT32 = 2;  // int\n    BYTE = 3;  // BYTE, when deserialized, is going to be restored as uint8.\n    STRING = 4;  // string\n    BOOL = 5;  // bool\n    UINT8 = 6;  // uint8_t\n    INT8 = 7;  // int8_t\n    UINT16 = 8;  // uint16_t\n    INT16 = 9;  // int16_t\n    INT64 = 10;  // int64_t\n    FLOAT16 = 12;  // at::Half\n    DOUBLE = 13;  // double\n  }\n```\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/cast_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Cast\",\n    [\"X\"],\n    [\"Y\"],\n    to=2\n)\n\nworkspace.FeedBlob(\"X\", (np.random.rand(3,3)).astype(np.float32)*10)\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n```\n\n**Result**\n\n```\nX: [[9.436466   5.8529844  0.54932857]\n [1.1583444  2.9936118  0.22950427]\n [3.9143739  3.4040766  8.905341  ]]\nY: [[9 5 0]\n [1 2 0]\n [3 3 8]]\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "Data type to which the elements of the input tensor are cast. Strictly must be one of the types from *DataType* enum in TensorProto.",
        "name": "to",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor)* Input tensor to be cast.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<'to' type>`)* Output tensor with the same shape as input with type specified by the `to` argument.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Cbrt",
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input tensor.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output tensor calculated as the cbrt of the input tensor, element-wise.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CbrtGradient",
    "support_level": "default"
  },
  {
    "name": "Ceil",
    "description": "\nElement-wise application of the ceil function ($y=ceil(x)$) to the input tensor\n`X`. Output tensor shape is the same as the input tensor.\n\nGithub Link:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/ceil_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Ceil\",\n    [\"X\"],\n    [\"X\"],\n)\n\nworkspace.FeedBlob(\"X\", (np.random.uniform(-10, 10, (5,5))).astype(np.float32))\nprint(\"X before running op:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"X after running op:\", workspace.FetchBlob(\"X\"))\n\n```\n\n**Result**\n\n```\n\nX before running op:\n[[ 8.44598    -6.5098248  -2.2993476  -7.6859694   0.58566964]\n [-7.846551   -0.03689406  6.9362907  -4.0521703   4.4969673 ]\n [ 0.33355865 -7.895527   -8.393201    9.374202   -2.3930092 ]\n [-6.3061996   3.1403487   3.782099   -8.516556   -2.8387244 ]\n [-2.0164998   4.7663913  -3.422966    0.3636999   8.75713   ]]\nX after running op:\n[[ 9. -6. -2. -7.  1.]\n [-7. -0.  7. -4.  5.]\n [ 1. -7. -8. 10. -2.]\n [-6.  4.  4. -8. -2.]\n [-2.  5. -3.  1.  9.]]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input tensor.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output tensor.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ChannelBackpropStats",
    "description": "\nGiven an input tensor in NCHW format, the gradient for the output of SpatialBN\nand the per-channel mean and inverse std var vectors for the input, computes the\nper-channel bias and scale gradient to be used during the backward pass for\nsubsequent spatial batch normalization gradient calculation. Typically, the\nresults of this op are subsequently reduced over multiple devices to obtain\nstatistics over a larger batch size in cases where the batch size for a single\nmodel copy is too low to yield the full benefit of batch normalization. The\nresulting bias and scale can then be plugged back into SpatialBNGradient to get\nresults over the larger batch size ",
    "inputs": [
      {
        "description": "The input 4-dimensional tensor of shape NCHW",
        "name": "X"
      },
      {
        "description": "The mean saved from the forward pass as a 1-dimensional tensor of size C.",
        "name": "mean"
      },
      {
        "description": "The saved inverse standard deviation as a 1-dimensional tensor of size C.",
        "name": "inv_std"
      },
      {
        "description": "Gradient for the output layer of SpatialBN, here used as input because we are on the backward pass",
        "name": "output_grad"
      }
    ],
    "outputs": [
      {
        "description": "Gradient for the scale vector",
        "name": "scale_grad"
      },
      {
        "description": "Gradient for the bias vector",
        "name": "bias_grad"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ChannelShuffle",
    "support_level": "default"
  },
  {
    "name": "ChannelShuffleGradient",
    "support_level": "default"
  },
  {
    "name": "ChannelStats",
    "description": "\nGiven an input tensor in NCHW format, computes the sum of all elements per\nchannel and the sum of all elements squared per channel. These values can be\nreduced across multiple batches and used to obtain the mean and variance across\nthe full set of batches. Using the new mean and variance as input to SpatialBN\nhas the effect of changing the batch size over which SpatialBN is applied.\n",
    "inputs": [
      {
        "description": "The input 4-dimensional tensor of shape NCHW",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "The output 1-dimensional tensor of size C containing the sum of elements of X per channel.",
        "name": "sum"
      },
      {
        "description": "The output 1-dimensional tensor of size C containing the sum of elements squared per channel.",
        "name": "sumsq"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CheckAtomicBool",
    "description": "Copy the value of an atomic<bool> to a bool",
    "inputs": [
      {
        "description": "Blob containing a unique_ptr<atomic<bool>>",
        "name": "atomic_bool"
      }
    ],
    "outputs": [
      {
        "description": "Copy of the value for the atomic<bool>",
        "name": "value"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CheckCounterDone",
    "description": "\nIf the internal count value <= 0, outputs true, otherwise outputs false.\n\n  Github Links:\n  - https://github.com/pytorch/pytorch/blob/master/caffe2/operators/counter_ops.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\ncreatecounter_op = core.CreateOperator(\n    \"CreateCounter\",\n    [],\n    [\"counter\"],\n    init_count=5\n)\n\nretrievecount_op = core.CreateOperator(\n    \"RetrieveCount\",\n    [\"counter\"],\n    [\"count\"]\n)\n\ncheckcounterdone_op = core.CreateOperator(\n    \"CheckCounterDone\",\n    [\"counter\"],\n    [\"done\"]\n)\n\ncountup_op = core.CreateOperator(\n    \"CountUp\",\n    [\"counter\"],\n    [\"previous_count\"],\n)\n\ncountdown_op = core.CreateOperator(\n    \"CountDown\",\n    [\"counter\"],\n    [\"done\"],\n)\n\nresetcounter_op = core.CreateOperator(\n    \"ResetCounter\",\n    [\"counter\"],\n    [\"previous_count\"],\n    init_count=3\n)\n\n\n// Create counter\nworkspace.RunOperatorOnce(createcounter_op)\nprint(\"'counter' pointer:\", workspace.FetchBlob(\"counter\"))\n\n\n// Retrieve initial counter value\nworkspace.RunOperatorOnce(retrievecount_op)\nprint(\"Initial 'count':\", workspace.FetchBlob(\"count\"))\n\n\n// Check if counter is done\nworkspace.RunOperatorOnce(checkcounterdone_op)\nprint(\"Initial 'done' value:\", workspace.FetchBlob(\"done\"))\n\n\n// Test CountUp operator\nprint(\"\\nTesting CountUp operator...\")\nfor i in range(5):\n    workspace.RunOperatorOnce(countup_op)\n    print(\"'previous_count' after CountUp:\", workspace.FetchBlob(\"previous_count\"))\n\nworkspace.RunOperatorOnce(retrievecount_op)\nprint(\"'count' value after CountUp test:\", workspace.FetchBlob(\"count\"))\n\n\n// Test CountDown operator\nprint(\"\\nTesting CountDown operator...\")\nfor i in range(11):\n    workspace.RunOperatorOnce(countdown_op)\n    workspace.RunOperatorOnce(retrievecount_op)\n    print(\"'count' value after CountDown: {}\\t'done' value: {}\".format(workspace.FetchBlob(\"count\"), workspace.FetchBlob(\"done\")))\n```\n\n**Result**\n\n```\n'counter' pointer: counter, a C++ native class of type std::__1::unique_ptr<caffe2::Counter<long long>, std::__1::default_delete<caffe2::Counter<long long> > >.\nInitial 'count': 5\nInitial 'done' value: False\n\nTesting CountUp operator...\n'previous_count' after CountUp: 5\n'previous_count' after CountUp: 6\n'previous_count' after CountUp: 7\n'previous_count' after CountUp: 8\n'previous_count' after CountUp: 9\n'count' value after CountUp test: 10\n\nTesting CountDown operator...\n'count' value after CountDown: 9        'done' value: False\n'count' value after CountDown: 8        'done' value: False\n'count' value after CountDown: 7        'done' value: False\n'count' value after CountDown: 6        'done' value: False\n'count' value after CountDown: 5        'done' value: False\n'count' value after CountDown: 4        'done' value: False\n'count' value after CountDown: 3        'done' value: False\n'count' value after CountDown: 2        'done' value: False\n'count' value after CountDown: 1        'done' value: False\n'count' value after CountDown: 0        'done' value: False\n'count' value after CountDown: -1        'done' value: True\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<ptr>`)* A blob pointing to an instance of a counter.",
        "name": "counter"
      }
    ],
    "outputs": [
      {
        "description": "*(type: bool)* True if the internal count is zero or negative, otherwise False.",
        "name": "done"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CheckDatasetConsistency",
    "description": "\nChecks that the given data fields represents a consistent dataset under\nthe schema specified by the `fields` argument. Operator fails if the fields\nare not consistent. If data is consistent, each field's data can be safely\nappended to an existing dataset, keeping it consistent.\n",
    "attributes": [
      {
        "description": "List of strings representing the string names in the formatspecified in the doc for CreateTreeCursor.",
        "name": "fields",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Data for field 0.",
        "name": "field_0"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Checkpoint",
    "description": "\nThe Checkpoint operator is similar to the Save operator, but allows one to save\nto db every few iterations, with a db name that is appended with the iteration\ncount. It takes [1, infinity) number of inputs and has no output. The first\ninput has to be a TensorCPU of type int and has size 1 (i.e. the iteration\ncounter). This is determined whether we need to do checkpointing.\n",
    "attributes": [
      {
        "description": "(int, default 0) if set, use the db path directly and do not prepend the current root folder of the workspace.",
        "name": "absolute_path",
        "option": "optional"
      },
      {
        "description": "(string) a template string that one can combine with the iteration to create the final db name. For example, \"/home/lonestarr/checkpoint_%08d.db\"",
        "name": "db",
        "option": "optional"
      },
      {
        "description": "(string) the type of the db.",
        "name": "db_type",
        "option": "optional"
      },
      {
        "description": "(int, default 1) the checkpointing is carried out when (iter mod every) is zero.",
        "name": "every",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Clip",
    "description": "\nThis operator limits the given input within an interval. The interval is\nspecified by the `min` and `max` arguments. They default to\n*numeric_limits::lowest()* and *numeric_limits::max()* respectively. The\nclipping operation can be done in an in-place fashion by using the same output\nblob as the input blob.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/clip_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Clip\",\n    [\"X\"],\n    [\"Y\"],\n    min=20.0,\n    max=60.0\n\n)\n\nworkspace.FeedBlob(\"X\", (np.random.randint(100, size=(5,5))).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\nX: [[45. 16. 59. 99. 48.]\n [12. 44. 46. 82. 28.]\n [ 1. 91. 18.  9. 71.]\n [24. 37. 61. 12. 81.]\n [36. 38. 30. 84. 40.]]\nY: [[45. 20. 59. 60. 48.]\n [20. 44. 46. 60. 28.]\n [20. 60. 20. 20. 60.]\n [24. 37. 60. 20. 60.]\n [36. 38. 30. 60. 40.]]\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "Minimum value, under which element is replaced by min (default=*numeric_limits::lowest()*).",
        "name": "min",
        "option": "optional",
        "type": "float32"
      },
      {
        "description": "Maximum value, under which element is replaced by max (default=*numeric_limits::max()*).",
        "name": "max",
        "option": "optional",
        "type": "float32"
      }
    ],
    "inputs": [
      {
        "description": "*(Tensor`<float>`)* Input tensor within range [*numeric_limits::lowest()*, *numeric_limits::max()*].",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(Tensor`<float>`)* Output tensor clipped within range [`min`, `max`].",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ClipGradient",
    "support_level": "default"
  },
  {
    "name": "ClipTensorByScaling",
    "description": "\n    Clips the input tensor by scaling based on the input value and the threshold.\n    The value is usually the (pre-computed) norm of the tensor. If the value is\n    larger than the threshold, scaling would be performed in this way:\n\n          tensor *= (threshold / value).\n\n    An optional input called additional_threshold can be provided which\n    will scale the original threshold before it is used. That is,\n    the final threshold will become threshold * additional_threshold.\n    This op could be used for gradient clipping.\n",
    "attributes": [
      {
        "description": "Threshold to determine whether to scale down the tensor",
        "name": "threshold",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Tensor of floats to be clipped.",
        "name": "input_tensor"
      },
      {
        "description": "Value to be compared against the threshold",
        "name": "val"
      },
      {
        "description": "An optional additional threshold to scale the original threshold",
        "name": "additional_threshold"
      }
    ],
    "outputs": [
      {
        "description": "Tensor of floats, which is the same size as the input tensor, representing the clipped tensor.",
        "name": "clipped"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CloneCommonWorld",
    "description": "\nClones existing common world.\n",
    "inputs": [
      {
        "description": "Existing common world to clone.",
        "name": "existing_comm_world"
      }
    ],
    "outputs": [
      {
        "description": "A common world for collective operations.",
        "name": "comm_world"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CloseBlobsQueue",
    "support_level": "default"
  },
  {
    "name": "CloseRebatchingQueue",
    "description": "\nCloses the Queue.\n",
    "inputs": [
      {
        "description": "object representing the queue",
        "name": "queue"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Col2Im",
    "support_level": "default"
  },
  {
    "name": "CollectAndDistributeFpnRpnProposals",
    "description": "\nMerge RPN proposals generated at multiple FPN levels and then\ndistribute those proposals to their appropriate FPN levels for Faster RCNN.\nAn anchor at one FPN level may predict an RoI that will map to another level,\nhence the need to redistribute the proposals.\n\nOnly inference is supported. To train, please use the original Python\noperator in Detectron.\n\nInputs and outputs are examples only; if min/max levels change,\nthe number of inputs and outputs, as well as their level numbering,\nwill change.\n",
    "attributes": [
      {
        "description": "(int) ROI_CANONICAL_SCALE",
        "name": "roi_canonical_scale",
        "option": "optional"
      },
      {
        "description": "(int) ROI_CANONICAL_LEVEL",
        "name": "roi_canonical_level",
        "option": "optional"
      },
      {
        "description": "(int) ROI_MAX_LEVEL",
        "name": "roi_max_level",
        "option": "optional"
      },
      {
        "description": "(int) ROI_MIN_LEVEL",
        "name": "roi_min_level",
        "option": "optional"
      },
      {
        "description": "(int) RPN_MAX_LEVEL",
        "name": "rpn_max_level",
        "option": "optional"
      },
      {
        "description": "(int) RPN_MIN_LEVEL",
        "name": "rpn_min_level",
        "option": "optional"
      },
      {
        "description": "(int) RPN_POST_NMS_TOP_N",
        "name": "rpn_post_nms_topN",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "RPN proposals for FPN level 2, format (image_index, x1, y1, x2, y2). See rpn_rois documentation from GenerateProposals.",
        "name": "rpn_rois_fpn2"
      },
      {
        "description": "RPN proposals for FPN level 3, format (image_index, x1, y1, x2, y2). See rpn_rois documentation from GenerateProposals.",
        "name": "rpn_rois_fpn3"
      },
      {
        "description": "RPN proposals for FPN level 4, format (image_index, x1, y1, x2, y2). See rpn_rois documentation from GenerateProposals.",
        "name": "rpn_rois_fpn4"
      },
      {
        "description": "RPN proposals for FPN level 5, format (image_index, x1, y1, x2, y2). See rpn_rois documentation from GenerateProposals.",
        "name": "rpn_rois_fpn5"
      },
      {
        "description": "RPN proposals for FPN level 6, format (image_index, x1, y1, x2, y2). See rpn_rois documentation from GenerateProposals.",
        "name": "rpn_rois_fpn6"
      },
      {
        "description": "RPN objectness probabilities for FPN level 2. See rpn_roi_probs documentation from GenerateProposals.",
        "name": "rpn_roi_probs_fpn2"
      },
      {
        "description": "RPN objectness probabilities for FPN level 3. See rpn_roi_probs documentation from GenerateProposals.",
        "name": "rpn_roi_probs_fpn3"
      },
      {
        "description": "RPN objectness probabilities for FPN level 4. See rpn_roi_probs documentation from GenerateProposals.",
        "name": "rpn_roi_probs_fpn4"
      },
      {
        "description": "RPN objectness probabilities for FPN level 5. See rpn_roi_probs documentation from GenerateProposals.",
        "name": "rpn_roi_probs_fpn5"
      },
      {
        "description": "RPN objectness probabilities for FPN level 6. See rpn_roi_probs documentation from GenerateProposals.",
        "name": "rpn_roi_probs_fpn6"
      }
    ],
    "outputs": [
      {
        "description": "Top proposals limited to rpn_post_nms_topN total, format (image_index, x1, y1, x2, y2)",
        "name": "rois"
      },
      {
        "description": "RPN proposals for ROI level 2, format (image_index, x1, y1, x2, y2)",
        "name": "rois_fpn2"
      },
      {
        "description": "RPN proposals for ROI level 3, format (image_index, x1, y1, x2, y2)",
        "name": "rois_fpn3"
      },
      {
        "description": "RPN proposals for ROI level 4, format (image_index, x1, y1, x2, y2)",
        "name": "rois_fpn4"
      },
      {
        "description": "RPN proposals for ROI level 5, format (image_index, x1, y1, x2, y2)",
        "name": "rois_fpn5"
      },
      {
        "description": "Permutation on the concatenation of all rois_fpni, i=min...max, such that when applied the RPN RoIs are restored to their original order in the input blobs.",
        "name": "rois_idx_restore"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CollectRpnProposals",
    "description": "\n...\n",
    "attributes": [
      {
        "description": "(int) RPN_MAX_LEVEL",
        "name": "rpn_max_level",
        "option": "optional"
      },
      {
        "description": "(int) RPN_MIN_LEVEL",
        "name": "rpn_min_level",
        "option": "optional"
      },
      {
        "description": "(int) RPN_POST_NMS_TOP_N",
        "name": "rpn_post_nms_topN",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "RPN proposals for FPN level 2, format (image_index, x1, y1, x2, y2). See rpn_rois documentation from GenerateProposals.",
        "name": "rpn_rois_fpn2"
      },
      {
        "description": "RPN proposals for FPN level 3, format (image_index, x1, y1, x2, y2). See rpn_rois documentation from GenerateProposals.",
        "name": "rpn_rois_fpn3"
      },
      {
        "description": "RPN proposals for FPN level 4, format (image_index, x1, y1, x2, y2). See rpn_rois documentation from GenerateProposals.",
        "name": "rpn_rois_fpn4"
      },
      {
        "description": "RPN proposals for FPN level 5, format (image_index, x1, y1, x2, y2). See rpn_rois documentation from GenerateProposals.",
        "name": "rpn_rois_fpn5"
      },
      {
        "description": "RPN proposals for FPN level 6, format (image_index, x1, y1, x2, y2). See rpn_rois documentation from GenerateProposals.",
        "name": "rpn_rois_fpn6"
      },
      {
        "description": "RPN objectness probabilities for FPN level 2. See rpn_roi_probs documentation from GenerateProposals.",
        "name": "rpn_roi_probs_fpn2"
      },
      {
        "description": "RPN objectness probabilities for FPN level 3. See rpn_roi_probs documentation from GenerateProposals.",
        "name": "rpn_roi_probs_fpn3"
      },
      {
        "description": "RPN objectness probabilities for FPN level 4. See rpn_roi_probs documentation from GenerateProposals.",
        "name": "rpn_roi_probs_fpn4"
      },
      {
        "description": "RPN objectness probabilities for FPN level 5. See rpn_roi_probs documentation from GenerateProposals.",
        "name": "rpn_roi_probs_fpn5"
      },
      {
        "description": "RPN objectness probabilities for FPN level 6. See rpn_roi_probs documentation from GenerateProposals.",
        "name": "rpn_roi_probs_fpn6"
      }
    ],
    "outputs": [
      {
        "description": "Top proposals limited to rpn_post_nms_topN total, format (image_index, x1, y1, x2, y2)",
        "name": "rois"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CollectTensor",
    "description": "\nCollect tensor into tensor vector by reservoir sampling,\nargument num_to_collect indicates the max number of tensors that will be\ncollected. The first half of the inputs are tensor vectors, which are also the\noutputs. The second half of the inputs are the tensors to be collected into each\nvector (in the same order). The input tensors are collected in all-or-none\nmanner. If they are collected, they will be placed at the same index in the\noutput vectors.\n",
    "attributes": [
      {
        "description": "The max number of tensors to collect",
        "name": "num_to_collect",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ColwiseMax",
    "description": "\nCompute column-wise max reduction of the input tensor. This op takes one input, $X$, of shape $BxMxN$, where $B$ is the batch size, $M$ is number of rows, and $N$ is number of columns. The output of this op, $Y$, is a matrix of shape $BxN$, with one row for each element of the batch, and the same number of columns as the input tensor.\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/reduction_ops.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/reduction_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"ColwiseMax\",\n    [\"X\"],\n    [\"Y\"]\n)\n\n// Create X, simulating a batch of 2, 4x4 matricies\nX = np.random.randint(0,high=20,size=(2,4,4))\nprint(\"X:\\n\",X)\n\n// Feed X into workspace\nworkspace.FeedBlob(\"X\", X.astype(np.float32))\n\n// Run op\nworkspace.RunOperatorOnce(op)\n\n// Collect Output\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n [[[17 15  2  6]\n  [ 8 12  6  0]\n  [ 6  9  7  3]\n  [ 4 13 16 13]]\n\n [[ 0  3  4 12]\n  [18  1 17 12]\n  [ 7 17 13 14]\n  [12 17  2  1]]]\nY:\n [[17. 15. 16. 13.]\n [18. 17. 17. 14.]]\n\n```\n\n</details>\n\n    ",
    "inputs": [
      {
        "description": "A tensor of dimensions $B x M x N$ to compute columnwise-max. Here, $B$ is batch size, and $M$ and $N$ are the number of rows and columns of each element of the batch, respectively.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "The output tensor of shape $B x N$, where each row represents the column-wise maximums for that element of the input batch.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ColwiseMaxGradient",
    "support_level": "default"
  },
  {
    "name": "ComputeOffset",
    "description": "\nCompute the offsets matrix given cursor and data blobs. Need to be ran at\nbeginning or after reseting cursor\n\nInput(0) is a blob pointing to a TreeCursor, and\n[Input(1),... Input(num_fields)] a list of tensors containing the data for\neach field of the dataset.\n\nComputeOffset is thread safe.\n",
    "inputs": [
      {
        "description": "A blob containing a pointer to the cursor.",
        "name": "cursor"
      },
      {
        "description": "First dataset field",
        "name": "dataset_field_0"
      }
    ],
    "outputs": [
      {
        "description": "Tensor containing offset info for this chunk.",
        "name": "field_0"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Concat",
    "category": "Tensor",
    "description": "\nConcatenate a list of tensors into a single tensor. Similar functionality to\nNumpy's [concatenate](https://docs.scipy.org/doc/numpy/reference/generated/numpy.concatenate.html)\nfunction. The `axis` argument specifies what axis along which the arrays will be concatenated.\nWhen set to non-zero (default=0), the `add_axis` argument adds the axis specified in `axis` to\nall input tensors.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/concat_split_op.cc\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/concat_split_op.h\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Concat\",\n    [\"X1\",  \"X2\"],\n    [\"Y\", \"split_info\"],\n    axis=0\n)\n\nworkspace.FeedBlob(\"X1\", np.array([[1,2],[3,4]]))\nworkspace.FeedBlob(\"X2\", np.array([[5,6]]))\nprint(\"X1:\", workspace.FetchBlob(\"X1\"))\nprint(\"X2:\", workspace.FetchBlob(\"X2\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\nprint(\"split_info:\", workspace.FetchBlob(\"split_info\"))\n\n```\n\n**Result**\n\n```\n\nX1: [[1 2]\n [3 4]]\nX2: [[5 6]]\nY: [[1 2]\n [3 4]\n [5 6]]\nsplit_info: [2 1]\n\n```\n\n</details>\n\n<details>\n\n<summary> <b>Example 2</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Concat\",\n    [\"X1\",  \"X2\"],\n    [\"Y\", \"split_info\"],\n    add_axis=1,\n    axis=3\n)\n\nworkspace.FeedBlob(\"X1\", np.random.randint(10, size=(1, 1, 5, 5))) // NCHW\nworkspace.FeedBlob(\"X2\", np.random.randint(10, size=(1, 1, 5, 5))) // NCHW\nprint(\"X1:\", workspace.FetchBlob(\"X1\"))\nprint(\"X2:\", workspace.FetchBlob(\"X2\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\nprint(\"split_info:\", workspace.FetchBlob(\"split_info\"))\n\n```\n\n**Result**\n\n```\n\nX1: [[[[1 8 3 9 0]\n   [6 4 6 5 6]\n   [3 9 1 9 9]\n   [5 1 0 7 7]\n   [9 4 0 0 9]]]]\nX2: [[[[7 0 2 6 1]\n   [3 9 4 0 3]\n   [5 3 8 9 4]\n   [3 4 2 1 0]\n   [0 8 8 8 1]]]]\nY: [[[[[1 8 3 9 0]\n    [7 0 2 6 1]]\n\n   [[6 4 6 5 6]\n    [3 9 4 0 3]]\n\n   [[3 9 1 9 9]\n    [5 3 8 9 4]]\n\n   [[5 1 0 7 7]\n    [3 4 2 1 0]]\n\n   [[9 4 0 0 9]\n    [0 8 8 8 1]]]]]\nsplit_info: [1 1]\n\n```\n\n</details>\n\n    ",
    "attributes": [
      {
        "default": -1,
        "description": "Axis to concatenate on.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      },
      {
        "description": "Order of blob dimensions. Concats on the C dimension.",
        "name": "order",
        "option": "optional",
        "type": "string"
      },
      {
        "description": "Pass non-zero integer to add the axis specified in `axis` to all input tensors.",
        "name": "add_axis",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "name": "inputs",
        "option": "variadic"
      },
      {
        "description": "*(type: Tensor`<float>`)* List of input tensors.",
        "name": "X1, X2, ..."
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Concatenated tensor.",
        "name": "concat_result"
      },
      {
        "description": "*(type: Tensor`<int>`)* The dimensions of the inputs.",
        "name": "split_info"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ConcatBatchMatMulBatchGatherOp",
    "support_level": "default"
  },
  {
    "name": "ConcatTensorVector",
    "description": "\nConcat Tensors in the std::unique_ptr<std::vector<Tensor> >\nalong the first dimension.\n    ",
    "inputs": [
      {
        "description": "std::unique_ptr<std::vector<Tensor> >",
        "name": "vector of Tensor"
      }
    ],
    "outputs": [
      {
        "description": "tensor after concatenating",
        "name": "tensor"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Conditional",
    "description": "\nGiven a 1-D tensor of boolean values, apply conditional operator along the first\ndimension of DataT and DataF and return DataO. Note, DataT and DataF must\nhave the exact same shape and type.\n",
    "inputs": [
      {
        "description": "Boolean tensor to select DataT or DataF",
        "name": "Condition"
      },
      {
        "description": "Data to use when True",
        "name": "DataT"
      },
      {
        "description": "Data to use when False",
        "name": "DataF"
      }
    ],
    "outputs": [
      {
        "description": "Output data after applying ConditionalOp",
        "name": "DataO"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ConditionalSetAtomicBool",
    "description": "\nSet an atomic<bool> to true if the given condition bool variable is true\n    ",
    "inputs": [
      {
        "description": "Blob containing a unique_ptr<atomic<bool>>",
        "name": "atomic_bool"
      },
      {
        "description": "Blob containing a bool",
        "name": "condition"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ConstantFill",
    "description": "\nThis operator fills the elements of the output tensor with a constant value\nspecified by the `value` argument.\n\n- The data type is specified by the `dtype` argument\n\n- Currently, the data types supported are *float*, *int32*, *int64*, and *bool*\n\n- If the `dtype` argument is not provided, the data type of `value` is used\n\n- The output tensor shape is either specified by the `shape` argument or will\nmatch the shape of the input tensor if one is provided (if an input tensor is\nprovided, a shape argument should not be set)\n\n- Optional additional dimensions can be appended at the end as specified by\n`extra_shape` argument\n\n- If `input_as_shape` is set to True, the input should be a 1D tensor\ncontaining the desired output shape (the dimensions specified in `extra_shape`\nwill also be appended)\n\n- If a second input V is passed, fill the output with the first element of V\n\nWhen specifying `dtype` argument, use the integer keys from the *DataType* enum\nin TensorProto:\n\n```\nmessage TensorProto {\n  ...\n  enum DataType {\n    UNDEFINED = 0;\n    FLOAT = 1;  // float\n    INT32 = 2;  // int\n    BYTE = 3;  // BYTE, when deserialized, is going to be restored as uint8.\n    STRING = 4;  // string\n    BOOL = 5;  // bool\n    UINT8 = 6;  // uint8_t\n    INT8 = 7;  // int8_t\n    UINT16 = 8;  // uint16_t\n    INT16 = 9;  // int16_t\n    INT64 = 10;  // int64_t\n    FLOAT16 = 12;  // at::Half\n    DOUBLE = 13;  // double\n  }\n```\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/filler_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"ConstantFill\",\n    [],\n    [\"Y\"],\n    shape=(1,5,5)\n)\n\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n```\n\n**Result**\n\n```\nY: [[[0. 0. 0. 0. 0.]\n  [0. 0. 0. 0. 0.]\n  [0. 0. 0. 0. 0.]\n  [0. 0. 0. 0. 0.]\n  [0. 0. 0. 0. 0.]]]\n```\n</details>\n\n<details>\n<summary> <b>Example 2</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"ConstantFill\",\n    [\"X\"],\n    [\"Y\"],\n    value=4.0,\n    dtype=1,\n    extra_shape=(1,2)\n)\n\nworkspace.FeedBlob(\"X\", (np.random.randint(100, size=(3,3))).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n```\n\n**Result**\n\n```\nX: [[86. 30. 84.]\n [34. 51.  9.]\n [29. 86. 59.]]\nY: [[[[4. 4.]]\n\n  [[4. 4.]]\n\n  [[4. 4.]]]\n\n\n [[[4. 4.]]\n\n  [[4. 4.]]\n\n  [[4. 4.]]]\n\n\n [[[4. 4.]]\n\n  [[4. 4.]]\n\n  [[4. 4.]]]]\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "value to populate output tensor with.",
        "name": "value",
        "option": "optional"
      },
      {
        "description": "The data type for the elements of the output tensor. Strictly must be one of the types from *DataType* enum in TensorProto.",
        "name": "dtype",
        "option": "optional",
        "type": "int64"
      },
      {
        "description": "Shape of the output tensor. Cannot pass an input blob and this arg at the same time.",
        "name": "shape",
        "option": "optional"
      },
      {
        "description": "Additional dimensions appended at the end of the shape indicated by the input blob. Cannot set thisargument when there is no input blob.",
        "name": "extra_shape",
        "option": "optional"
      },
      {
        "description": "1D tensor containing the desired output shape. First input must be in CPU context.",
        "name": "input_as_shape",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor)* [OPTIONAL] Input tensor to provide shape information.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor)* Output tensor of constant values.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Conv",
    "category": "Layer",
    "description": "\nThe convolution operator consumes an input vector, a filter blob\nand a bias blob and computes the output. \nThe Conv2D operator computes a 2D convolution operation over an input blob $(X)$, with a filter blob $(filter)$ and a bias blob $(bias)$, and outputs a single output blob $(Y)$. Although there are several options for order, the convention is that the input $(X)$ is a blob of shape $(N,C_{in},H_{in},W_{in})$ and the output $(Y)$ is a blob of shape $(N,C_{out},H_{out},W_{out})$. Here, $N$ is the batch size, $C$ is the number of channels, $H$ is the spatial height, and $W$ is the spatial width. For example, if your input data was a batch of five, 100x120pixel RGB images, $X$ would have shape $(5,3,120,100)$.\n\nThe $filter$ input blob may contain multiple filters and has shape $(M, C_{in}, K_H, K_W)$. Here, $M$ is the number of individual filters contained in the blob, $C_{in}$ is the number of channels of each filter (by convention in 2D convolution it is the same as the number of channels in the input), $K_H$ is the spatial height of the kernel, and $K_W$ is the spatial width of the kernel. The $bias$ blob is a vector of length $M$, where there is one bias for each filter in the $filter$ blob.\n\nGiven the shape of the input blob and the filter blob, we can calculate the shape of the output blob as follows. The number of items in the batch $N$ will stay the same. The number of channels in the output will equal the number of kernels in the filter blob, so $C_{out} = M.$ With stride and pad defined below, the spatial height and width of the output ($H_{out}$ and $W_{out}$) are calculated as\n\n$$H_{out} = \\left \\lfloor{\\frac{H_{in} - K_H + 2*pad}{stride}+1}\\right \\rfloor$$\n\n\n$$W_{out} = \\left \\lfloor{\\frac{W_{in} - K_W + 2*pad}{stride}+1}\\right \\rfloor$$\n\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/conv_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/conv_op.cc\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/conv_pool_op_base.h\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Conv\",\n    [\"X\", \"filter\", \"bias\"],\n    [\"Y\"],\n    kernel=5,\n    pad=1,\n    stride=2\n)\n\n// Create X: (N,C,H,W)\ndata = np.random.randn(1,1,8,8).astype(np.float32)\nprint(\"Data shape: \",data.shape)\n\n// Create W: (M,C,Kh,Kw)\nfilters = np.random.randn(3,1,5,5).astype(np.float32)\nprint(\"Filter shape: \",filters.shape)\n\n// Create b: M\nbias = np.array([1.,1.,1.]).astype(np.float32)\nprint(\"Bias shape: \",bias.shape)\n\n// Put the inputs into the workspace\nworkspace.FeedBlob(\"X\", data)\nworkspace.FeedBlob(\"filter\", filters)\nworkspace.FeedBlob(\"bias\", bias)\n\n// Run the operator\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nData shape:  (1, 1, 8, 8)\nFilter shape:  (3, 1, 5, 5)\nBias shape:  (3,)\nY:\n [[[[  0.6406407    0.8620521    0.56461596]\n   [ -1.5042953   -0.79549205 -10.683343  ]\n   [ -0.5240259    3.4538248   -3.9564204 ]]\n\n  [[  0.6876496    4.8328524   -1.9525816 ]\n   [  1.2995434   -2.3895378    7.2670045 ]\n   [  3.9929862    1.8126237    5.4699917 ]]\n\n  [[  3.55949      4.7934155    0.76086235]\n   [  3.9588015   -1.3251319    4.413117  ]\n   [ -1.5296054   -1.4924102   -3.2552304 ]]]]\n\n```\n\n</details>\n\n\n",
    "attributes": [
      {
        "default": 0,
        "name": "pad"
      },
      {
        "default": 1,
        "name": "stride"
      },
      {
        "name": "exhaustive_search",
        "type": "boolean",
        "visible": false
      }
    ],
    "inputs": [
      {
        "description": "Input data blob, of shape $(N, C_{in}, H_{in}, W_{in})$, to be convolved with the kernels in the filter blob.",
        "name": "X"
      },
      {
        "description": "The filter blob, of shape $(M, C_{in}, K_H, K_W)$, containing the filters to be convolved with the data.",
        "name": "filter"
      },
      {
        "description": "The bias blob, of length $M$, containing the biases for the convolution, one bias per filter.",
        "name": "bias"
      }
    ],
    "outputs": [
      {
        "description": "Output data blob, of shape $(N, C_{out}, H_{out}, W_{out})$, that contains the result of the convolution.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Conv1D",
    "description": "\nThe convolution operator consumes an input vector, a 1D filter blob\nand a bias blob and computes the output. \nThe Conv2D operator computes a 2D convolution operation over an input blob $(X)$, with a filter blob $(filter)$ and a bias blob $(bias)$, and outputs a single output blob $(Y)$. Although there are several options for order, the convention is that the input $(X)$ is a blob of shape $(N,C_{in},H_{in},W_{in})$ and the output $(Y)$ is a blob of shape $(N,C_{out},H_{out},W_{out})$. Here, $N$ is the batch size, $C$ is the number of channels, $H$ is the spatial height, and $W$ is the spatial width. For example, if your input data was a batch of five, 100x120pixel RGB images, $X$ would have shape $(5,3,120,100)$.\n\nThe $filter$ input blob may contain multiple filters and has shape $(M, C_{in}, K_H, K_W)$. Here, $M$ is the number of individual filters contained in the blob, $C_{in}$ is the number of channels of each filter (by convention in 2D convolution it is the same as the number of channels in the input), $K_H$ is the spatial height of the kernel, and $K_W$ is the spatial width of the kernel. The $bias$ blob is a vector of length $M$, where there is one bias for each filter in the $filter$ blob.\n\nGiven the shape of the input blob and the filter blob, we can calculate the shape of the output blob as follows. The number of items in the batch $N$ will stay the same. The number of channels in the output will equal the number of kernels in the filter blob, so $C_{out} = M.$ With stride and pad defined below, the spatial height and width of the output ($H_{out}$ and $W_{out}$) are calculated as\n\n$$H_{out} = \\left \\lfloor{\\frac{H_{in} - K_H + 2*pad}{stride}+1}\\right \\rfloor$$\n\n\n$$W_{out} = \\left \\lfloor{\\frac{W_{in} - K_W + 2*pad}{stride}+1}\\right \\rfloor$$\n\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/conv_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/conv_op.cc\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/conv_pool_op_base.h\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Conv\",\n    [\"X\", \"filter\", \"bias\"],\n    [\"Y\"],\n    kernel=5,\n    pad=1,\n    stride=2\n)\n\n// Create X: (N,C,H,W)\ndata = np.random.randn(1,1,8,8).astype(np.float32)\nprint(\"Data shape: \",data.shape)\n\n// Create W: (M,C,Kh,Kw)\nfilters = np.random.randn(3,1,5,5).astype(np.float32)\nprint(\"Filter shape: \",filters.shape)\n\n// Create b: M\nbias = np.array([1.,1.,1.]).astype(np.float32)\nprint(\"Bias shape: \",bias.shape)\n\n// Put the inputs into the workspace\nworkspace.FeedBlob(\"X\", data)\nworkspace.FeedBlob(\"filter\", filters)\nworkspace.FeedBlob(\"bias\", bias)\n\n// Run the operator\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nData shape:  (1, 1, 8, 8)\nFilter shape:  (3, 1, 5, 5)\nBias shape:  (3,)\nY:\n [[[[  0.6406407    0.8620521    0.56461596]\n   [ -1.5042953   -0.79549205 -10.683343  ]\n   [ -0.5240259    3.4538248   -3.9564204 ]]\n\n  [[  0.6876496    4.8328524   -1.9525816 ]\n   [  1.2995434   -2.3895378    7.2670045 ]\n   [  3.9929862    1.8126237    5.4699917 ]]\n\n  [[  3.55949      4.7934155    0.76086235]\n   [  3.9588015   -1.3251319    4.413117  ]\n   [ -1.5296054   -1.4924102   -3.2552304 ]]]]\n\n```\n\n</details>\n\n\n",
    "inputs": [
      {
        "description": "Input data blob, of shape $(N, C_{in}, H_{in}, W_{in})$, to be convolved with the kernels in the filter blob.",
        "name": "X"
      },
      {
        "description": "The filter blob, of shape $(M, C_{in}, K_H, K_W)$, containing the filters to be convolved with the data.",
        "name": "filter"
      },
      {
        "description": "The bias blob, of length $M$, containing the biases for the convolution, one bias per filter.",
        "name": "bias"
      }
    ],
    "outputs": [
      {
        "description": "Output data blob, of shape $(N, C_{out}, H_{out}, W_{out})$, that contains the result of the convolution.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Conv1DGradient",
    "support_level": "default"
  },
  {
    "name": "Conv2D",
    "description": "\nThe convolution operator consumes an input vector, a 2D filter blob\nand a bias blob and computes the output. \nThe Conv2D operator computes a 2D convolution operation over an input blob $(X)$, with a filter blob $(filter)$ and a bias blob $(bias)$, and outputs a single output blob $(Y)$. Although there are several options for order, the convention is that the input $(X)$ is a blob of shape $(N,C_{in},H_{in},W_{in})$ and the output $(Y)$ is a blob of shape $(N,C_{out},H_{out},W_{out})$. Here, $N$ is the batch size, $C$ is the number of channels, $H$ is the spatial height, and $W$ is the spatial width. For example, if your input data was a batch of five, 100x120pixel RGB images, $X$ would have shape $(5,3,120,100)$.\n\nThe $filter$ input blob may contain multiple filters and has shape $(M, C_{in}, K_H, K_W)$. Here, $M$ is the number of individual filters contained in the blob, $C_{in}$ is the number of channels of each filter (by convention in 2D convolution it is the same as the number of channels in the input), $K_H$ is the spatial height of the kernel, and $K_W$ is the spatial width of the kernel. The $bias$ blob is a vector of length $M$, where there is one bias for each filter in the $filter$ blob.\n\nGiven the shape of the input blob and the filter blob, we can calculate the shape of the output blob as follows. The number of items in the batch $N$ will stay the same. The number of channels in the output will equal the number of kernels in the filter blob, so $C_{out} = M.$ With stride and pad defined below, the spatial height and width of the output ($H_{out}$ and $W_{out}$) are calculated as\n\n$$H_{out} = \\left \\lfloor{\\frac{H_{in} - K_H + 2*pad}{stride}+1}\\right \\rfloor$$\n\n\n$$W_{out} = \\left \\lfloor{\\frac{W_{in} - K_W + 2*pad}{stride}+1}\\right \\rfloor$$\n\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/conv_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/conv_op.cc\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/conv_pool_op_base.h\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Conv\",\n    [\"X\", \"filter\", \"bias\"],\n    [\"Y\"],\n    kernel=5,\n    pad=1,\n    stride=2\n)\n\n// Create X: (N,C,H,W)\ndata = np.random.randn(1,1,8,8).astype(np.float32)\nprint(\"Data shape: \",data.shape)\n\n// Create W: (M,C,Kh,Kw)\nfilters = np.random.randn(3,1,5,5).astype(np.float32)\nprint(\"Filter shape: \",filters.shape)\n\n// Create b: M\nbias = np.array([1.,1.,1.]).astype(np.float32)\nprint(\"Bias shape: \",bias.shape)\n\n// Put the inputs into the workspace\nworkspace.FeedBlob(\"X\", data)\nworkspace.FeedBlob(\"filter\", filters)\nworkspace.FeedBlob(\"bias\", bias)\n\n// Run the operator\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nData shape:  (1, 1, 8, 8)\nFilter shape:  (3, 1, 5, 5)\nBias shape:  (3,)\nY:\n [[[[  0.6406407    0.8620521    0.56461596]\n   [ -1.5042953   -0.79549205 -10.683343  ]\n   [ -0.5240259    3.4538248   -3.9564204 ]]\n\n  [[  0.6876496    4.8328524   -1.9525816 ]\n   [  1.2995434   -2.3895378    7.2670045 ]\n   [  3.9929862    1.8126237    5.4699917 ]]\n\n  [[  3.55949      4.7934155    0.76086235]\n   [  3.9588015   -1.3251319    4.413117  ]\n   [ -1.5296054   -1.4924102   -3.2552304 ]]]]\n\n```\n\n</details>\n\n\n",
    "inputs": [
      {
        "description": "Input data blob, of shape $(N, C_{in}, H_{in}, W_{in})$, to be convolved with the kernels in the filter blob.",
        "name": "X"
      },
      {
        "description": "The filter blob, of shape $(M, C_{in}, K_H, K_W)$, containing the filters to be convolved with the data.",
        "name": "filter"
      },
      {
        "description": "The bias blob, of length $M$, containing the biases for the convolution, one bias per filter.",
        "name": "bias"
      }
    ],
    "outputs": [
      {
        "description": "Output data blob, of shape $(N, C_{out}, H_{out}, W_{out})$, that contains the result of the convolution.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Conv2DGradient",
    "support_level": "default"
  },
  {
    "name": "Conv3D",
    "description": "\nThe convolution operator consumes an input vector, a 3D filter blob\nand a bias blob and computes the output. \nThe Conv2D operator computes a 2D convolution operation over an input blob $(X)$, with a filter blob $(filter)$ and a bias blob $(bias)$, and outputs a single output blob $(Y)$. Although there are several options for order, the convention is that the input $(X)$ is a blob of shape $(N,C_{in},H_{in},W_{in})$ and the output $(Y)$ is a blob of shape $(N,C_{out},H_{out},W_{out})$. Here, $N$ is the batch size, $C$ is the number of channels, $H$ is the spatial height, and $W$ is the spatial width. For example, if your input data was a batch of five, 100x120pixel RGB images, $X$ would have shape $(5,3,120,100)$.\n\nThe $filter$ input blob may contain multiple filters and has shape $(M, C_{in}, K_H, K_W)$. Here, $M$ is the number of individual filters contained in the blob, $C_{in}$ is the number of channels of each filter (by convention in 2D convolution it is the same as the number of channels in the input), $K_H$ is the spatial height of the kernel, and $K_W$ is the spatial width of the kernel. The $bias$ blob is a vector of length $M$, where there is one bias for each filter in the $filter$ blob.\n\nGiven the shape of the input blob and the filter blob, we can calculate the shape of the output blob as follows. The number of items in the batch $N$ will stay the same. The number of channels in the output will equal the number of kernels in the filter blob, so $C_{out} = M.$ With stride and pad defined below, the spatial height and width of the output ($H_{out}$ and $W_{out}$) are calculated as\n\n$$H_{out} = \\left \\lfloor{\\frac{H_{in} - K_H + 2*pad}{stride}+1}\\right \\rfloor$$\n\n\n$$W_{out} = \\left \\lfloor{\\frac{W_{in} - K_W + 2*pad}{stride}+1}\\right \\rfloor$$\n\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/conv_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/conv_op.cc\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/conv_pool_op_base.h\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Conv\",\n    [\"X\", \"filter\", \"bias\"],\n    [\"Y\"],\n    kernel=5,\n    pad=1,\n    stride=2\n)\n\n// Create X: (N,C,H,W)\ndata = np.random.randn(1,1,8,8).astype(np.float32)\nprint(\"Data shape: \",data.shape)\n\n// Create W: (M,C,Kh,Kw)\nfilters = np.random.randn(3,1,5,5).astype(np.float32)\nprint(\"Filter shape: \",filters.shape)\n\n// Create b: M\nbias = np.array([1.,1.,1.]).astype(np.float32)\nprint(\"Bias shape: \",bias.shape)\n\n// Put the inputs into the workspace\nworkspace.FeedBlob(\"X\", data)\nworkspace.FeedBlob(\"filter\", filters)\nworkspace.FeedBlob(\"bias\", bias)\n\n// Run the operator\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nData shape:  (1, 1, 8, 8)\nFilter shape:  (3, 1, 5, 5)\nBias shape:  (3,)\nY:\n [[[[  0.6406407    0.8620521    0.56461596]\n   [ -1.5042953   -0.79549205 -10.683343  ]\n   [ -0.5240259    3.4538248   -3.9564204 ]]\n\n  [[  0.6876496    4.8328524   -1.9525816 ]\n   [  1.2995434   -2.3895378    7.2670045 ]\n   [  3.9929862    1.8126237    5.4699917 ]]\n\n  [[  3.55949      4.7934155    0.76086235]\n   [  3.9588015   -1.3251319    4.413117  ]\n   [ -1.5296054   -1.4924102   -3.2552304 ]]]]\n\n```\n\n</details>\n\n\n",
    "inputs": [
      {
        "description": "Input data blob, of shape $(N, C_{in}, H_{in}, W_{in})$, to be convolved with the kernels in the filter blob.",
        "name": "X"
      },
      {
        "description": "The filter blob, of shape $(M, C_{in}, K_H, K_W)$, containing the filters to be convolved with the data.",
        "name": "filter"
      },
      {
        "description": "The bias blob, of length $M$, containing the biases for the convolution, one bias per filter.",
        "name": "bias"
      }
    ],
    "outputs": [
      {
        "description": "Output data blob, of shape $(N, C_{out}, H_{out}, W_{out})$, that contains the result of the convolution.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Conv3DGradient",
    "support_level": "default"
  },
  {
    "name": "ConvGradient",
    "support_level": "default"
  },
  {
    "name": "ConvRelu",
    "support_level": "default"
  },
  {
    "name": "ConvTranspose",
    "category": "Layer",
    "description": "\nThe ConvTranspose op takes an input data tensor $X$, an input weight tensor $filter$, and optionally an input bias tensor $bias$. It then computes the transposed convolution, sometimes referred to as deconvolution, and produces a single output tensor $Y$. The hyperparameters of the op such as kernel size, stride, and padding are specified as args. At each stride, the filter is deconvolved with a subset of $X$ and the $bias$ is added. This is done throughout the input data until the output computation is complete.\n\nThe output shapes are computed as follows. The number of channels in the output feature map is the number of kernels specified in the filter blob. The spatial height and width are computed as:\n\n$$H_{out} = (H_{in}-1)*strides[0] - 2*pads[0] + kernels[0]$$\n\n\n$$W_{out} = (W_{in}-1)*strides[1] - 2*pads[1] + kernels[1]$$\n\nNote on the implementation layout: conv_transpose_op_impl.h is the templated implementation of the conv_transpose_op.h file, which is why they are separate files. Also, in the implementation this operator inherits from the *ConvTransposeUnpoolOpBase* operator.\n\nGithub Links:\n- https://github.com/pytorch/pytorch/tree/master/caffe2/operators/conv_transpose_op.h\n- https://github.com/pytorch/pytorch/tree/master/caffe2/operators/conv_transpose_op.cc\n- https://github.com/pytorch/pytorch/tree/master/caffe2/operators/conv_transpose_unpool_op_base.h\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"ConvTranspose\",\n    [\"X\", \"filter\", \"bias\"],\n    [\"Y\"],\n    kernels=[2,2],\n    pads=[4,4,4,4],\n    strides=[2,2]\n)\n\n// Create X: (N,C,H,W)\ndata = np.random.randn(2,3,5,5).astype(np.float32)\nprint(\"Data shape: \",data.shape)\n\n// Create filter: (M,C,Kh,Kw)\nfilters = np.random.randn(3,1,2,2).astype(np.float32)\nprint(\"Filter shape: \",filters.shape)\n\n// Create b: M\nbias = np.array([1.]).astype(np.float32)\nprint(\"Bias shape: \",bias.shape)\n\n// Put the inputs into the workspace\nworkspace.FeedBlob(\"X\", data)\nworkspace.FeedBlob(\"filter\", filters)\nworkspace.FeedBlob(\"bias\", bias)\n\n// Run the operator\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nData shape:  (2, 3, 5, 5)\nFilter shape:  (3, 1, 2, 2)\nBias shape:  (1,)\nY:\n [[[[0.53606427 0.5775447 ]\n   [0.40148795 1.5188271 ]]]\n\n\n [[[1.9903406  3.2794335 ]\n   [0.09960175 0.31917763]]]]\n\n```\n\n</details>\n\n  ",
    "attributes": [
      {
        "description": "Should the legacy padding be VALID or SAME. When used, pads should not be used.",
        "name": "legacy_pad",
        "option": "optional",
        "type": "int64"
      },
      {
        "description": "Desired kernel size. If left at default the kernel size will be inferred from the input $filter$ blob.",
        "name": "kernels",
        "option": "optional",
        "type": "int64[]"
      },
      {
        "description": "Controls the stride of the kernel as it traverses the input blob.",
        "name": "strides",
        "option": "optional",
        "type": "int64[]"
      },
      {
        "description": "Controls the amount of padding applied to the input feature map before computation.",
        "name": "pads",
        "option": "optional",
        "type": "int64[]"
      },
      {
        "description": "",
        "name": "adjs",
        "option": "optional",
        "type": "int64[]"
      },
      {
        "default": "NCHW",
        "description": "Specifies the order of the input data blob, where $N$ is batch size, $C$ is number of channels, $H$ is spatial height, and $W$ is spatial width. The only other valid option is \"NHWC\".",
        "name": "order",
        "option": "optional",
        "type": "string"
      },
      {
        "default": 0,
        "description": "",
        "name": "shared_buffer",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": false,
        "description": "",
        "name": "no_bias",
        "option": "optional",
        "type": "boolean"
      }
    ],
    "inputs": [
      {
        "description": "Input data blob, of shape $(N, C_{in}, H_{in}, W_{in})$, to be operated on.",
        "name": "X"
      },
      {
        "description": "The filter blob, of shape $(M, C_{out}, K_H, K_W)$, containing the filters to be used in the transposed convolution.",
        "name": "filter"
      },
      {
        "description": "The bias blob, of length $C_{out}$, containing the biases for the operation, one bias per output channel. If not passed, biases assumed to be zeros.",
        "name": "bias"
      }
    ],
    "outputs": [
      {
        "description": "Output data blob, of shape $(N, C_{out}, H_{out}, W_{out})$, that contains the result of the operation.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ConvTransposeGradient",
    "support_level": "default"
  },
  {
    "name": "Copy",
    "description": "\nCopy input tensor into output, potentially across devices.\n\nGithub Links:\n\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/copy_op.cc\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/copy_op.h\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Copy\",\n    [\"input\"],\n    [\"output\"]\n)\n\nworkspace.FeedBlob(\"input\", np.random.rand(3,3))\nprint(\"input:\", workspace.FetchBlob(\"input\"))\nworkspace.RunOperatorOnce(op)\nprint(\"output:\", workspace.FetchBlob(\"output\"))\n\n```\n\n**Result**\n\n```\n\ninput:\n[[0.16826761 0.68168217 0.55196001]\n [0.19735483 0.34837823 0.69015595]\n [0.09448514 0.57390828 0.37097193]]\noutput:\n[[0.16826761 0.68168217 0.55196001]\n [0.19735483 0.34837823 0.69015595]\n [0.09448514 0.57390828 0.37097193]]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "(*Tensor*): input tensor to copy",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor*): copy of input tensor",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CopyFromCPUInput",
    "description": "\nTake a CPU input tensor and copy it to an output in the current\nContext (GPU or CPU). This may involves cross-device MemCpy.\n",
    "inputs": [
      {
        "description": "The input CPU tensor.",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "either a TensorCUDA or a TensorCPU",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CopyOnDeviceLike",
    "description": "Copy input tensor into output to the specific device.",
    "inputs": [
      {
        "description": "The input tensor.",
        "name": "input"
      },
      {
        "description": "Tensor, on which device the copy will be performed.",
        "name": "dst"
      }
    ],
    "outputs": [
      {
        "description": "Tensor that will contain a copy of the input.",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CopyRowsToTensor",
    "description": "\n      This operator takes in a 2d tensor, a list of indices, and a 1d tensor\n      with the same width of the 2d tensor. It will replace the rows in 2d\n      tensor specified in indices with the 2d tensor. The operator does an\n      in-place change to the input tensor.\n      Example:\n        INPUT_TENSOR = [[1, 2], [3, 4], [5, 6]]\n        INDICES = [1]\n        ROW = [9, 0]\n        OUTPUT_TENSOR = [[1, 2], [9, 0], [5, 6]]\n      ",
    "inputs": [
      {
        "description": "Input tensor needs to be modified.",
        "name": "input_tensor"
      },
      {
        "description": "Indices of rows need to be copied",
        "name": "indices"
      },
      {
        "description": "1-d tensor that is going to replace the rows",
        "name": "row"
      }
    ],
    "outputs": [
      {
        "description": "updated tensor",
        "name": "output_tensor"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CopyRowsToTensorGradient",
    "support_level": "default"
  },
  {
    "name": "Cos",
    "description": "\nCalculates the cosine of the given input tensor, element-wise.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/cos_op.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Cos\",\n    [\"X\"],\n    [\"Y\"]\n)\n\nworkspace.FeedBlob(\"X\", np.random.rand(5).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX: [0.6816719  0.76771533 0.933932   0.01404487 0.11862425]\nY: [0.7765203  0.71949923 0.5946774  0.99990135 0.9929724 ]\n\n```\n\n</details>\n\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input tensor.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output tensor calculated as the cosine of the input tensor, element-wise.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CosGradient",
    "support_level": "default"
  },
  {
    "name": "Cosh",
    "description": "\nCalculates the hyperbolic cosine of the given input tensor, element-wise.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/cosh_op.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Cosh\",\n    [\"X\"],\n    [\"Y\"]\n)\n\nworkspace.FeedBlob(\"X\", np.random.rand(5).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX: [0.66423494 0.32074615 0.81523746 0.90423071 0.39275789]\nY: [1.22883528 1.05188156 1.35112322 1.43744212 1.07812598]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "Input tensor",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "The hyperbolic cosine values of the input tensor, computed element-wise",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CoshGradient",
    "support_level": "default"
  },
  {
    "name": "CosineEmbeddingCriterion",
    "description": "\nCosineEmbeddingCriterion takes two inputs: the similarity value and\nthe label, and computes the elementwise criterion output as\n\n  output = 1 - s,               if y == 1\n           max(0, s - margin),  if y == -1\n",
    "inputs": [
      {
        "description": "The cosine similarity as a 1-dim TensorCPU.",
        "name": "S"
      },
      {
        "description": "The label as a 1-dim TensorCPU with int value of 1 or -1.",
        "name": "Y"
      }
    ],
    "outputs": [
      {
        "description": "The output loss with the same dimensionality as S.",
        "name": "loss"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CosineEmbeddingCriterionGradient",
    "support_level": "default"
  },
  {
    "name": "CosineSimilarity",
    "description": "\nThis op takes two input float tensors of the same size, $X$ and $Y$, and produces one output float tensor , $Z$, calculated as the cosine similarity between $X$ and $Y$. Recall, the cosine similarity between two tensors $X$ and $Y$ is defined as:\n\n$$\\mathbf{Z}=CosineSimilarity(\\mathbf{X},\\mathbf{Y}) = \\frac{\\mathbf{X}\\cdot\\mathbf{Y}}{\\|\\mathbf{X}\\|\\|\\mathbf{Y}\\|} = \\frac{\\sum_n^{i=1}X_iY_i}{\\sqrt{\\sum_n^{i=1}X_i^2}\\sqrt{\\sum_n^{i=1}Y_i^2}}$$\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/distance_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/distance_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"CosineSimilarity\",\n    [\"X\", \"Y\"],\n    [\"Z\"]\n)\n\n// Create X\nX = np.random.randn(3, 3)\nprint(\"X:\\n\",X)\n\n// Create Y\nY = np.random.randn(3, 3)\nprint(\"Y:\\n\",Y)\n\n// Feed X & Y into workspace\nworkspace.FeedBlob(\"X\", X.astype(np.float32))\nworkspace.FeedBlob(\"Y\", Y.astype(np.float32))\n\n// Run op\nworkspace.RunOperatorOnce(op)\n\n// Collect Output\nprint(\"Z:\\n\", workspace.FetchBlob(\"Z\"))\n\n```\n\n**Result**\n\n```\n\nX:\n [[-0.42635564 -0.23831588 -0.25515547]\n [ 1.43914719 -1.05613228  1.01717373]\n [ 0.06883105  0.33386519 -1.46648334]]\nY:\n [[-0.90648691 -0.14241514 -1.1070837 ]\n [ 0.92152729 -0.28115511 -0.17756722]\n [-0.88394254  1.34654037 -0.80080998]]\nZ:\n [-1.7849885e-23  1.7849885e-23 -1.0842022e-07]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "1D or 2D input tensor",
        "name": "X"
      },
      {
        "description": "1D or 2D input tensor (must have the same shape as X)",
        "name": "Y"
      }
    ],
    "outputs": [
      {
        "description": "1D output tensor",
        "name": "Z"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CosineSimilarityGradient",
    "support_level": "default"
  },
  {
    "name": "CountDown",
    "description": "\nIf the internal count value > 0, decreases count value by 1 and outputs False,\notherwise outputs True.\n\n  Github Links:\n  - https://github.com/pytorch/pytorch/blob/master/caffe2/operators/counter_ops.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\ncreatecounter_op = core.CreateOperator(\n    \"CreateCounter\",\n    [],\n    [\"counter\"],\n    init_count=5\n)\n\nretrievecount_op = core.CreateOperator(\n    \"RetrieveCount\",\n    [\"counter\"],\n    [\"count\"]\n)\n\ncheckcounterdone_op = core.CreateOperator(\n    \"CheckCounterDone\",\n    [\"counter\"],\n    [\"done\"]\n)\n\ncountup_op = core.CreateOperator(\n    \"CountUp\",\n    [\"counter\"],\n    [\"previous_count\"],\n)\n\ncountdown_op = core.CreateOperator(\n    \"CountDown\",\n    [\"counter\"],\n    [\"done\"],\n)\n\nresetcounter_op = core.CreateOperator(\n    \"ResetCounter\",\n    [\"counter\"],\n    [\"previous_count\"],\n    init_count=3\n)\n\n\n// Create counter\nworkspace.RunOperatorOnce(createcounter_op)\nprint(\"'counter' pointer:\", workspace.FetchBlob(\"counter\"))\n\n\n// Retrieve initial counter value\nworkspace.RunOperatorOnce(retrievecount_op)\nprint(\"Initial 'count':\", workspace.FetchBlob(\"count\"))\n\n\n// Check if counter is done\nworkspace.RunOperatorOnce(checkcounterdone_op)\nprint(\"Initial 'done' value:\", workspace.FetchBlob(\"done\"))\n\n\n// Test CountUp operator\nprint(\"\\nTesting CountUp operator...\")\nfor i in range(5):\n    workspace.RunOperatorOnce(countup_op)\n    print(\"'previous_count' after CountUp:\", workspace.FetchBlob(\"previous_count\"))\n\nworkspace.RunOperatorOnce(retrievecount_op)\nprint(\"'count' value after CountUp test:\", workspace.FetchBlob(\"count\"))\n\n\n// Test CountDown operator\nprint(\"\\nTesting CountDown operator...\")\nfor i in range(11):\n    workspace.RunOperatorOnce(countdown_op)\n    workspace.RunOperatorOnce(retrievecount_op)\n    print(\"'count' value after CountDown: {}\\t'done' value: {}\".format(workspace.FetchBlob(\"count\"), workspace.FetchBlob(\"done\")))\n```\n\n**Result**\n\n```\n'counter' pointer: counter, a C++ native class of type std::__1::unique_ptr<caffe2::Counter<long long>, std::__1::default_delete<caffe2::Counter<long long> > >.\nInitial 'count': 5\nInitial 'done' value: False\n\nTesting CountUp operator...\n'previous_count' after CountUp: 5\n'previous_count' after CountUp: 6\n'previous_count' after CountUp: 7\n'previous_count' after CountUp: 8\n'previous_count' after CountUp: 9\n'count' value after CountUp test: 10\n\nTesting CountDown operator...\n'count' value after CountDown: 9        'done' value: False\n'count' value after CountDown: 8        'done' value: False\n'count' value after CountDown: 7        'done' value: False\n'count' value after CountDown: 6        'done' value: False\n'count' value after CountDown: 5        'done' value: False\n'count' value after CountDown: 4        'done' value: False\n'count' value after CountDown: 3        'done' value: False\n'count' value after CountDown: 2        'done' value: False\n'count' value after CountDown: 1        'done' value: False\n'count' value after CountDown: 0        'done' value: False\n'count' value after CountDown: -1        'done' value: True\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<ptr>`)* A blob pointing to an instance of a counter.",
        "name": "counter"
      }
    ],
    "outputs": [
      {
        "description": "*(type: bool)* False unless the internal count is zero.",
        "name": "done"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CountUp",
    "description": "\nIncreases count value by 1 and outputs the previous value atomically.\n\n  Github Links:\n  - https://github.com/pytorch/pytorch/blob/master/caffe2/operators/counter_ops.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\ncreatecounter_op = core.CreateOperator(\n    \"CreateCounter\",\n    [],\n    [\"counter\"],\n    init_count=5\n)\n\nretrievecount_op = core.CreateOperator(\n    \"RetrieveCount\",\n    [\"counter\"],\n    [\"count\"]\n)\n\ncheckcounterdone_op = core.CreateOperator(\n    \"CheckCounterDone\",\n    [\"counter\"],\n    [\"done\"]\n)\n\ncountup_op = core.CreateOperator(\n    \"CountUp\",\n    [\"counter\"],\n    [\"previous_count\"],\n)\n\ncountdown_op = core.CreateOperator(\n    \"CountDown\",\n    [\"counter\"],\n    [\"done\"],\n)\n\nresetcounter_op = core.CreateOperator(\n    \"ResetCounter\",\n    [\"counter\"],\n    [\"previous_count\"],\n    init_count=3\n)\n\n\n// Create counter\nworkspace.RunOperatorOnce(createcounter_op)\nprint(\"'counter' pointer:\", workspace.FetchBlob(\"counter\"))\n\n\n// Retrieve initial counter value\nworkspace.RunOperatorOnce(retrievecount_op)\nprint(\"Initial 'count':\", workspace.FetchBlob(\"count\"))\n\n\n// Check if counter is done\nworkspace.RunOperatorOnce(checkcounterdone_op)\nprint(\"Initial 'done' value:\", workspace.FetchBlob(\"done\"))\n\n\n// Test CountUp operator\nprint(\"\\nTesting CountUp operator...\")\nfor i in range(5):\n    workspace.RunOperatorOnce(countup_op)\n    print(\"'previous_count' after CountUp:\", workspace.FetchBlob(\"previous_count\"))\n\nworkspace.RunOperatorOnce(retrievecount_op)\nprint(\"'count' value after CountUp test:\", workspace.FetchBlob(\"count\"))\n\n\n// Test CountDown operator\nprint(\"\\nTesting CountDown operator...\")\nfor i in range(11):\n    workspace.RunOperatorOnce(countdown_op)\n    workspace.RunOperatorOnce(retrievecount_op)\n    print(\"'count' value after CountDown: {}\\t'done' value: {}\".format(workspace.FetchBlob(\"count\"), workspace.FetchBlob(\"done\")))\n```\n\n**Result**\n\n```\n'counter' pointer: counter, a C++ native class of type std::__1::unique_ptr<caffe2::Counter<long long>, std::__1::default_delete<caffe2::Counter<long long> > >.\nInitial 'count': 5\nInitial 'done' value: False\n\nTesting CountUp operator...\n'previous_count' after CountUp: 5\n'previous_count' after CountUp: 6\n'previous_count' after CountUp: 7\n'previous_count' after CountUp: 8\n'previous_count' after CountUp: 9\n'count' value after CountUp test: 10\n\nTesting CountDown operator...\n'count' value after CountDown: 9        'done' value: False\n'count' value after CountDown: 8        'done' value: False\n'count' value after CountDown: 7        'done' value: False\n'count' value after CountDown: 6        'done' value: False\n'count' value after CountDown: 5        'done' value: False\n'count' value after CountDown: 4        'done' value: False\n'count' value after CountDown: 3        'done' value: False\n'count' value after CountDown: 2        'done' value: False\n'count' value after CountDown: 1        'done' value: False\n'count' value after CountDown: 0        'done' value: False\n'count' value after CountDown: -1        'done' value: True\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<ptr>`)* A blob pointing to an instance of a counter.",
        "name": "counter"
      }
    ],
    "outputs": [
      {
        "description": "*(type: int)* Count value BEFORE this operation.",
        "name": "previous_count"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CreateAtomicBool",
    "description": "Create an unique_ptr blob to hold an atomic<bool>",
    "outputs": [
      {
        "description": "Blob containing a unique_ptr<atomic<bool>>",
        "name": "atomic_bool"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CreateBlobsQueue",
    "support_level": "default"
  },
  {
    "name": "CreateBlobsQueueDB",
    "description": "Create a DBReader from a BlobsQueue",
    "attributes": [
      {
        "description": "(default: -1 (no key)) index of blob for DB key in the BlobsQueue.",
        "name": "key_blob_index",
        "option": "optional"
      },
      {
        "description": "(default: 0) index of blob for DB value in the BlobsQueue.",
        "name": "value_blob_index",
        "option": "optional"
      },
      {
        "description": "(default: 0.0 (no timeout)) Timeout in seconds for reading from the BlobsQueue.",
        "name": "timeout_secs",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "The shared pointer to a queue containing Blobs.",
        "name": "queue"
      }
    ],
    "outputs": [
      {
        "description": "The DBReader for the given BlobsQueue",
        "name": "reader"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CreateCommonWorld",
    "description": "\nCreates a common world for communication operators.\n",
    "attributes": [
      {
        "description": "(int) size of the common world.",
        "name": "size",
        "option": "optional"
      },
      {
        "description": "(int) rank of this node in the common world.",
        "name": "rank",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Key/value handler for rendezvous (optional).",
        "name": "kv_handler"
      }
    ],
    "outputs": [
      {
        "description": "A common world for collective operations.",
        "name": "comm_world"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CreateCounter",
    "description": "\nCreates a count-down counter with initial value specified by the `init_count`\nargument.\n\n\n  Github Links:\n  - https://github.com/pytorch/pytorch/blob/master/caffe2/operators/counter_ops.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\ncreatecounter_op = core.CreateOperator(\n    \"CreateCounter\",\n    [],\n    [\"counter\"],\n    init_count=5\n)\n\nretrievecount_op = core.CreateOperator(\n    \"RetrieveCount\",\n    [\"counter\"],\n    [\"count\"]\n)\n\ncheckcounterdone_op = core.CreateOperator(\n    \"CheckCounterDone\",\n    [\"counter\"],\n    [\"done\"]\n)\n\ncountup_op = core.CreateOperator(\n    \"CountUp\",\n    [\"counter\"],\n    [\"previous_count\"],\n)\n\ncountdown_op = core.CreateOperator(\n    \"CountDown\",\n    [\"counter\"],\n    [\"done\"],\n)\n\nresetcounter_op = core.CreateOperator(\n    \"ResetCounter\",\n    [\"counter\"],\n    [\"previous_count\"],\n    init_count=3\n)\n\n\n// Create counter\nworkspace.RunOperatorOnce(createcounter_op)\nprint(\"'counter' pointer:\", workspace.FetchBlob(\"counter\"))\n\n\n// Retrieve initial counter value\nworkspace.RunOperatorOnce(retrievecount_op)\nprint(\"Initial 'count':\", workspace.FetchBlob(\"count\"))\n\n\n// Check if counter is done\nworkspace.RunOperatorOnce(checkcounterdone_op)\nprint(\"Initial 'done' value:\", workspace.FetchBlob(\"done\"))\n\n\n// Test CountUp operator\nprint(\"\\nTesting CountUp operator...\")\nfor i in range(5):\n    workspace.RunOperatorOnce(countup_op)\n    print(\"'previous_count' after CountUp:\", workspace.FetchBlob(\"previous_count\"))\n\nworkspace.RunOperatorOnce(retrievecount_op)\nprint(\"'count' value after CountUp test:\", workspace.FetchBlob(\"count\"))\n\n\n// Test CountDown operator\nprint(\"\\nTesting CountDown operator...\")\nfor i in range(11):\n    workspace.RunOperatorOnce(countdown_op)\n    workspace.RunOperatorOnce(retrievecount_op)\n    print(\"'count' value after CountDown: {}\\t'done' value: {}\".format(workspace.FetchBlob(\"count\"), workspace.FetchBlob(\"done\")))\n```\n\n**Result**\n\n```\n'counter' pointer: counter, a C++ native class of type std::__1::unique_ptr<caffe2::Counter<long long>, std::__1::default_delete<caffe2::Counter<long long> > >.\nInitial 'count': 5\nInitial 'done' value: False\n\nTesting CountUp operator...\n'previous_count' after CountUp: 5\n'previous_count' after CountUp: 6\n'previous_count' after CountUp: 7\n'previous_count' after CountUp: 8\n'previous_count' after CountUp: 9\n'count' value after CountUp test: 10\n\nTesting CountDown operator...\n'count' value after CountDown: 9        'done' value: False\n'count' value after CountDown: 8        'done' value: False\n'count' value after CountDown: 7        'done' value: False\n'count' value after CountDown: 6        'done' value: False\n'count' value after CountDown: 5        'done' value: False\n'count' value after CountDown: 4        'done' value: False\n'count' value after CountDown: 3        'done' value: False\n'count' value after CountDown: 2        'done' value: False\n'count' value after CountDown: 1        'done' value: False\n'count' value after CountDown: 0        'done' value: False\n'count' value after CountDown: -1        'done' value: True\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 0,
        "description": "Initial count for the counter, must be >= 0.",
        "name": "init_count",
        "option": "optional",
        "type": "int64"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<ptr>`)* A blob pointing to an instance of a new counter.",
        "name": "counter"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CreateDB",
    "support_level": "default"
  },
  {
    "name": "CreateMap",
    "description": "Create an empty map blob",
    "attributes": [
      {
        "description": "Key's TensorProto::DataType (default INT32)",
        "name": "key_dtype",
        "option": "optional"
      },
      {
        "description": "Value's TensorProto::DataType (default INT32)",
        "name": "value_dtype",
        "option": "optional"
      }
    ],
    "outputs": [
      {
        "description": "Blob reference to the map",
        "name": "map blob"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CreateMutex",
    "description": "Creates an unlocked mutex and returns it in a unique_ptr blob.",
    "outputs": [
      {
        "description": "Blob containing a std::unique_ptr<mutex>.",
        "name": "mutex_ptr"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CreateRebatchingQueue",
    "description": "\nCreates the Queue.\n",
    "attributes": [
      {
        "description": "Number of input tensors the queue will support",
        "name": "num_blobs",
        "option": "optional"
      },
      {
        "description": "Maximal number of elements the queue can hold at any given point",
        "name": "capacity",
        "option": "optional"
      }
    ],
    "outputs": [
      {
        "description": "object representing the queue",
        "name": "queue"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CreateScope",
    "description": "\n'CreateScope' operator initializes and outputs empty scope that is used\nby Do operator to store local blobs\n    ",
    "support_level": "default"
  },
  {
    "name": "CreateTensorVector",
    "description": "Create a std::unique_ptr<std::vector<Tensor> >",
    "support_level": "default"
  },
  {
    "name": "CreateTextFileReader",
    "description": "Create a text file reader. Fields are delimited by <TAB>.",
    "attributes": [
      {
        "description": "Path to the file.",
        "name": "filename",
        "option": "optional"
      },
      {
        "description": "Number of passes over the file.",
        "name": "num_passes",
        "option": "optional"
      },
      {
        "description": "List with type of each field. Type enum is found at core.DataType.",
        "name": "field_types",
        "option": "optional"
      }
    ],
    "outputs": [
      {
        "description": "Pointer to the created TextFileReaderInstance.",
        "name": "handler"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CreateTreeCursor",
    "description": "\nCreates a cursor to iterate through a list of tensors, where some of those\ntensors contain the lengths in a nested schema. The schema is determined by\nthe `fields` arguments.\n\nFor example, to represent the following schema:\n\n  Struct(\n      a=Int(),\n      b=List(List(Int)),\n      c=List(\n          Struct(\n             c1=String,\n             c2=List(Int),\n          ),\n      ),\n  )\n\nthe field list will be:\n  [\n      \"a\",\n      \"b:lengths\",\n      \"b:values:lengths\",\n      \"b:values:values\",\n      \"c:lengths\",\n      \"c:c1\",\n      \"c:c2:lengths\",\n      \"c:c2:values\",\n  ]\n\nAnd for the following instance of the struct:\n\n  Struct(\n      a=3,\n      b=[[4, 5], [6, 7, 8], [], [9]],\n      c=[\n          Struct(c1='alex', c2=[10, 11]),\n          Struct(c1='bob', c2=[12]),\n      ],\n  )\n\nThe values of the fields will be:\n  {\n      \"a\": [3],\n      \"b:lengths\": [4],\n      \"b:values:lengths\": [2, 3, 0, 1],\n      \"b:values:values\": [4, 5, 6, 7, 8, 9],\n      \"c:lengths\": [2],\n      \"c:c1\": [\"alex\", \"bob\"],\n      \"c:c2:lengths\": [2, 1],\n      \"c:c2:values\", [10, 11, 12],\n  }\n\nIn general, every field name in the format \"{prefix}:lengths\" defines a domain\n\"{prefix}\", and every subsequent field in the format \"{prefix}:{field}\" will\nbe in that domain, and the length of the domain is provided for each entry of\nthe parent domain. In the example, \"b:lengths\" defines a domain of length 4, so\nevery field under domain \"b\" will have 4 entries.\nThe \"lengths\" field for a given domain must appear before any reference to\nthat domain.\n\nReturns a pointer to an instance of the Cursor, which keeps the current offset\non each of the domains defined by `fields`. Cursor also ensures thread-safety\nsuch that ReadNextBatch and ResetCursor can be used safely in parallel.\n\nA cursor does not contain data per se, so calls to ReadNextBatch actually need\nto pass a list of blobs containing the data to read for each one of the fields.\n",
    "attributes": [
      {
        "description": "A list of strings each one representing a field of the dataset.",
        "name": "fields",
        "option": "optional"
      }
    ],
    "outputs": [
      {
        "description": "A blob pointing to an instance of a new TreeCursor.",
        "name": "cursor"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CrossEntropy",
    "description": "\nThis operator computes the cross entropy between a $NxD$ dimensional input data tensor $X$  and a $NxD$ dimensional input label tensor $label$. The op produces a single length $N$ output tensor $Y$. Here, $N$ is considered the batch size and $D$ is the size of each element in the batch. In practice, it is most commonly used at the end of models as a part of the loss computation, after the SoftMax operator and before the AveragedLoss operator. The cross entropy operation is defined as follows\n\n$$Y_i = \\sum_j (label_{ij} * log(X_{ij}))$$\n\nwhere ($i$, $j$) is the classifier's prediction of the $j$th class (the correct one), and $i$ is the batch size. Each log has a lower limit for numerical stability.\n\nGithub Links:\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/cross_entropy_op.h\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/cross_entropy_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"CrossEntropy\",\n    [\"X\", \"label\"],\n    [\"Y\"]\n)\n\n// Create X: Sample softmax output for 5-class model\nX = np.array([[.01, .05, .02, .02, .9],[.03, .1, .42, .05, .4]])\nprint(\"X:\\n\",X)\n\n// Create label: Sample 1-hot ground truth label vectors\nlabel = np.array([[0.,0.,0.,0.,1.],[0.,0.,1.,0.,0.]])\nprint(\"label:\\n\",label)\n\n// Feed X & label into workspace\nworkspace.FeedBlob(\"X\", X.astype(np.float32))\nworkspace.FeedBlob(\"label\", label.astype(np.float32))\n\n// Run op\nworkspace.RunOperatorOnce(op)\n\n// Collect Output\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n [[0.01 0.05 0.02 0.02 0.9 ]\n [0.03 0.1  0.42 0.05 0.4 ]]\nlabel:\n [[0. 0. 0. 0. 1.]\n [0. 0. 1. 0. 0.]]\nY:\n [0.10536055 0.8675006 ]\n\n```\n\n</details>\n\n\n",
    "inputs": [
      {
        "description": "Input tensor which is almost always the result of a softmax operation. $X$ is a 2D array of size $NxD$, where $N$ is the batch size and $D$ is the number of classes.",
        "name": "X"
      },
      {
        "description": "Blob containing the labels used to compare the input. $label$ is the same shape as $X$.",
        "name": "label"
      }
    ],
    "outputs": [
      {
        "description": "Output blob from the cross entropy computation. $Y$ is 1D length $N$ tensor.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CrossEntropyGradient",
    "support_level": "default"
  },
  {
    "name": "CTCBeamSearchDecoder",
    "description": "Prefix beam search decoder for connectionist temporal classification.",
    "attributes": [
      {
        "description": "Maximum number of candidates to carry over to next activation step.",
        "name": "beam_width",
        "option": "optional"
      },
      {
        "description": "Probability threshold below which outputs are ignored.",
        "name": "prune_threshold",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "3D float Tensor sized [max_activation_length, batch_size, alphabet_size] of network logits (before softmax application).",
        "name": "INPUTS"
      },
      {
        "description": "(optional) 1D int vector containing sequence lengths, having size [batch_size] seq_len will be set to max_time if not provided.",
        "name": "SEQ_LEN"
      }
    ],
    "outputs": [
      {
        "description": "Output_len matrix size (batch_size * num_candidates). Each index stores lengths of candidates for its corresponding batch item.",
        "name": "OUTPUT_LEN"
      },
      {
        "description": "Values vector, size (total_decoded_outputs). The flattened vector of final output sequences, in batch order.",
        "name": "VALUES"
      },
      {
        "description": "Probability vector, size (total_decoded_outputs). Each index stores final output probability of its corresponding batch item.",
        "name": "OUTPUT_PROB"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CTCGreedyDecoder",
    "description": "Greedy decoder for connectionist temporal classification.",
    "attributes": [
      {
        "description": "When merge_repeated is true, merge repeated classes in output.",
        "name": "merge_repeated",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "3D float Tensor sized [max_time, batch_size, num_classes]",
        "name": "INPUTS"
      },
      {
        "description": "(optional) 1D int vector containing sequence lengths, having size [batch_size]seq_len will be set to max_time if not provided",
        "name": "SEQ_LEN"
      }
    ],
    "outputs": [
      {
        "description": "Output_len matrix size (batch). The row store: [decoded_length]",
        "name": "OUTPUT_LEN"
      },
      {
        "description": "Values vector, size (total_decoded_outputs). The vector stores the decoded classes",
        "name": "VALUES"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Cube",
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input tensor.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output tensor calculated as the cube of the input tensor, element-wise.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "CubeGradient",
    "support_level": "default"
  },
  {
    "name": "DataCouple",
    "description": "\n\nA one to one operator that takes an arbitrary number of input and output blobs\nsuch that each input blob is inplace with it's matching output blob. It then proceedes\nto do nothing with each of these operators. This serves two purposes. It can make it\nappear as if a blob has been written to, as well as can tie together different blobs\nin a data dependency\n\n",
    "support_level": "default"
  },
  {
    "name": "DBExists",
    "description": "\nChecks if the db described by the arguments exists.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/load_save_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"DBExists\",\n    [],\n    [\"exists\"],\n    db_name=\"test_db\",\n    db_type=\"leveldb\",\n)\n\nworkspace.RunOperatorOnce(op)\nprint(\"exists:\", workspace.FetchBlob(\"exists\"))\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 0,
        "description": "If set to non-zero, save the db directly to the path specified by the `db` arg. If not set (default), prepend the path of the current root folder of the workspace to the path specified by the `db` arg.",
        "name": "absolute_path",
        "option": "optional",
        "type": "int64"
      },
      {
        "description": "Path to the db in question; see the `absolute_path` arg details for options regarding the current root folder of the workspace.",
        "name": "db_name",
        "option": "optional",
        "type": "string"
      },
      {
        "description": "Type of db to save (options: \"lmdb\", \"leveldb\", \"minidb\").",
        "name": "db_type",
        "option": "optional",
        "type": "string"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<bool>`)* Scalar boolean output tensor. True if the db exists, else false.",
        "name": "exists"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "DenseVectorToIdList",
    "description": "\nDenseVectorToIdList: Convert a blob with dense feature into a ID_LIST.\n\nAn ID_LIST is a list of IDs (may be ints, often longs) that represents a single\nfeature. As described in https://caffe2.ai/docs/sparse-operations.html, a batch\nof ID_LIST examples is represented as a pair of lengths and values where the\n`lengths` (int32) segment the `values` or ids (int32/int64) into examples.\n\nInput is a single blob where the first dimension is the batch size and the\nsecond dimension is the length of dense vectors. This operator produces a\nID_LIST where out_values are the indices of non-zero entries\nand out_lengths are the number of non-zeros entries in each row.\n\n",
    "inputs": [
      {
        "description": "A data blob of dense vectors",
        "name": "values"
      }
    ],
    "outputs": [
      {
        "description": "Lengths of the sparse feature",
        "name": "out_lengths"
      },
      {
        "description": "Values of the sparse feature",
        "name": "out_values"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "DepthConcat",
    "description": "Backward compatible operator name for Concat.",
    "support_level": "default"
  },
  {
    "name": "DepthSplit",
    "description": "Backward compatible operator name for Split.",
    "support_level": "default"
  },
  {
    "name": "DequeueBlobs",
    "description": "\n  Dequeue the blobs from queue.\n  ",
    "attributes": [
      {
        "description": "Timeout in secs, default: no timeout",
        "name": "timeout_secs",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "The shared pointer for the BlobsQueue",
        "name": "queue"
      }
    ],
    "outputs": [
      {
        "description": "The blob to store the dequeued data",
        "name": "blob"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "DequeueRebatchingQueue",
    "description": "\nDequeue Tensors from the Queue.\nIf the Queue is closed this might return less elements than asked.\nIf num_elements > 1 the returned elements will be concatenated into one\ntensor per component.\n",
    "attributes": [
      {
        "description": "Number of elements to dequeue. By default we dequeue one element.",
        "name": "num_elements",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "object representing the queue",
        "name": "rebatching_queue"
      },
      {
        "description": "First tensor to enqueue",
        "name": "tensor"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "DestroyCommonWorld",
    "description": "Closes all connections managed by a common world.",
    "inputs": [
      {
        "description": "The common world to be destroyed.",
        "name": "common_world"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "DiagonalFill",
    "description": "\nThe operator fills the diagonal elements of the output tensor (>= 2D)\nwith a constant value specified by the 'value' argument, and others 0. If\nnumber of dimensions of the output tensor is greater than 2, all dimensions\nmust be equal.\n\nThe data type is specified by the 'dtype' argument. The 'dtype' argument must\nbe one of the data types specified in the 'DataType' enum field in the\nTensorProto message. If the 'dtype' argument is not provided, the data type of\n'value' is used.\n\nThe output tensor shape is specified by the 'shape' argument. If the number of\ninput is 1, the shape will be identical to that of the input at run time with\noptional additional dimensions appended at the end as specified by 'extra_shape'\nargument. In that case the 'shape' argument should not be set.\n\nIf input_as_shape is set to true, then the input should be a 1D tensor\ncontaining the desired output shape (the dimensions specified in extra_shape\nwill also be appended)\n\nNOTE: Currently, it supports data type of float, int32, int64, and bool.\n",
    "attributes": [
      {
        "description": "The value for the elements of the output tensor.",
        "name": "value",
        "option": "optional"
      },
      {
        "description": "The data type for the elements of the output tensor.Strictly must be one of the types from DataType enum in TensorProto.",
        "name": "dtype",
        "option": "optional"
      },
      {
        "description": "The shape of the output tensor.Cannot set the shape argument and pass in an input at the same time.",
        "name": "shape",
        "option": "optional"
      },
      {
        "description": "The additional dimensions appended at the end of the shape indicatedby the input blob.Cannot set the extra_shape argument when there is no input blob.",
        "name": "extra_shape",
        "option": "optional"
      },
      {
        "description": "1D tensor containing the desired output shape",
        "name": "input_as_shape",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor (optional) to provide shape information.",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Output tensorargument and its type is specified by the 'dtype' argument",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "DistributeFpnProposals",
    "description": "\n...\n",
    "attributes": [
      {
        "description": "(int) ROI_CANONICAL_SCALE",
        "name": "roi_canonical_scale",
        "option": "optional"
      },
      {
        "description": "(int) ROI_CANONICAL_LEVEL",
        "name": "roi_canonical_level",
        "option": "optional"
      },
      {
        "description": "(int) ROI_MAX_LEVEL",
        "name": "roi_max_level",
        "option": "optional"
      },
      {
        "description": "(int) ROI_MIN_LEVEL",
        "name": "roi_min_level",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Top proposals limited to rpn_post_nms_topN total, format (image_index, x1, y1, x2, y2)",
        "name": "rois"
      }
    ],
    "outputs": [
      {
        "description": "RPN proposals for ROI level 2, format (image_index, x1, y1, x2, y2)",
        "name": "rois_fpn2"
      },
      {
        "description": "RPN proposals for ROI level 3, format (image_index, x1, y1, x2, y2)",
        "name": "rois_fpn3"
      },
      {
        "description": "RPN proposals for ROI level 4, format (image_index, x1, y1, x2, y2)",
        "name": "rois_fpn4"
      },
      {
        "description": "RPN proposals for ROI level 5, format (image_index, x1, y1, x2, y2)",
        "name": "rois_fpn5"
      },
      {
        "description": "Permutation on the concatenation of all rois_fpni, i=min...max, such that when applied the RPN RoIs are restored to their original order in the input blobs.",
        "name": "rois_idx_restore"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Div",
    "description": "\nPerforms element-wise binary division (with limited broadcast support).\n\nIf necessary the right-hand-side argument will be broadcasted to match the\nshape of left-hand-side argument. When broadcasting is specified, the second\ntensor can either be of size 1 (a scalar value), or having its shape as a\ncontiguous subset of the first tensor's shape. The starting of the mutually\nequal shape is specified by the argument \"axis\", and if it is not set, suffix\nmatching is assumed. 1-dim expansion doesn't work yet.\n\nFor example, the following tensor shapes are supported (with broadcast=1):\n```\n  shape(A) = (2, 3, 4, 5), shape(B) = (,), i.e. B is a scalar\n  shape(A) = (2, 3, 4, 5), shape(B) = (5,)\n  shape(A) = (2, 3, 4, 5), shape(B) = (4, 5)\n  shape(A) = (2, 3, 4, 5), shape(B) = (3, 4), with axis=1\n  shape(A) = (2, 3, 4, 5), shape(B) = (2), with axis=0\n```\nArgument `broadcast=1` needs to be passed to enable broadcasting.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/elementwise_ops_schema.cc\n\n\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Div\",\n    [\"A\",  \"B\"],\n    [\"C\"],\n)\n\nworkspace.FeedBlob(\"A\", np.array([[18,8],[2,9]]))\nworkspace.FeedBlob(\"B\", np.array([[9,2],[3,2]]))\nprint(\"A:\", workspace.FetchBlob(\"A\"))\nprint(\"B:\", workspace.FetchBlob(\"B\"))\nworkspace.RunOperatorOnce(op)\nprint(\"C:\", workspace.FetchBlob(\"C\"))\n\n```\n\n**Result**\n\n```\n\nA:\n[[18  8]\n [ 2  9]]\nB:\n[[9 2]\n [3 2]]\nC:\n[[2 4]\n [0 4]]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 0,
        "description": "Pass 1 to enable broadcasting",
        "name": "broadcast",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": -1,
        "description": "Axis to concatenate on.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* First operand, should share the type with the second operand.",
        "name": "A"
      },
      {
        "description": "*(type: Tensor`<float>`)* Second operand. With broadcasting can be of smaller size than A. If broadcasting is disabled it should be of the same size as A.",
        "name": "B"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output tensor with same dimensions and type as A.",
        "name": "C"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "DivGradient",
    "support_level": "default"
  },
  {
    "name": "Do",
    "description": "\n'Do' control operator, executes a subnet in a separate workspace.\nLast blobs in the input and output lists should be the same blob created with\nCreateScope op. Arguments 'inner_blobs' and 'outer_blobs_idx' provide a mapping\nbetween selected inner blob names and corresponding outer blob indices.\n    ",
    "attributes": [
      {
        "description": "Subnet with blob bindings",
        "name": "net",
        "option": "optional"
      },
      {
        "description": "List of inner net blob names to bind to outer workspace",
        "name": "inner_blobs",
        "option": "optional"
      },
      {
        "description": "Indices of corresponding outer workspace blobs, in order: operator inputs, operator outputs (skipping workspace blobs)",
        "name": "outer_blobs_idx",
        "option": "optional"
      },
      {
        "description": "List of blobs from the forward Do operator workspace needed in backward pass, used in gradient Do operator",
        "name": "saved_fwd_blobs",
        "option": "optional"
      },
      {
        "description": "Whether to reuse workspace or create a new one in a given scope",
        "name": "reuse_workspace",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "DotProduct",
    "description": "\nComputes and outputs the dot product of the two input float tensors `X` and `Y`.\nNote that `X` and `Y` must be either 1D or 2D, and they must be the same shape.\nThe output tensor is 1D, which represents either the product of each element in\na respective dimension if the inputs are 1D, or the sum of the products in a\ngiven dimension if the inputs are 2D matrices. Note that the actual dot product\nis a scalar value, which is effectively the sum of the elements in the 1D\noutput tensor.\n\nFor 1D inputs:\nGiven two vectors $X = [x_0, x_1, x_2]$ and $Y = [y_0, y_1, y_2]$; $Z = [x_0 * y_0, x_1 * y_1, x_2 * y_2]$\n\nFor 2D inputs:\nGiven two matrices:\n$$X = [[x_0^0, x_1^0, x_2^0], \\\\ [x_0^1, x_1^1, x_2^1], \\\\ [x_0^2, x_1^2, x_2^2], \\\\ ..., \\\\ [x_0^n, x_1^n, x_2^n]]$$\n\nand\n\n$$Y = [[y_0^0, y_1^0, y_2^0], \\\\ [y_0^1, y_1^1, y_2^1], \\\\ [y_0^2, y_1^2, y_2^2], \\\\ ..., \\\\ [y_0^n, y_1^n, y_2^n]]$$\n\nthen\n\n$$Z =  \\biggl[\\Big((x_0^0 * y_0^0) + (x_1^0 * y_1^0) + (x_2^0 * y_2^0)\\Big), \\\\ \\Big((x_0^1 * y_0^1) + (x_1^1 * y_1^1) + (x_2^1 * y_2^1)\\Big), \\\\ \\Big((x_0^2 * y_0^2) + (x_1^2 * y_1^2) + (x_2^2 * y_2^2)\\Big), \\\\ ..., \\\\ \\Big((x_0^n * y_0^n) + (x_1^n * y_1^n) + (x_2^n * y_2^n)\\Big)\\biggr]$$\n\nGithub Link:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/distance_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"DotProduct\",\n    [\"X\",  \"Y\"],\n    [\"Z\"]\n)\n\nworkspace.FeedBlob(\"X\", np.random.randint(20, size=(5)).astype(np.float32))\nworkspace.FeedBlob(\"Y\", np.random.randint(20, size=(5)).astype(np.float32))\nprint(\"X:\\n\", workspace.FetchBlob(\"X\"))\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Z:\\n\", workspace.FetchBlob(\"X\"))\n\n\nworkspace.ResetWorkspace()\nworkspace.FeedBlob(\"X\", np.random.randint(10, size=(3,3)).astype(np.float32))\nworkspace.FeedBlob(\"Y\", np.random.randint(10, size=(3,3)).astype(np.float32))\nprint(\"X:\\n\", workspace.FetchBlob(\"X\"))\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Z:\\n\", workspace.FetchBlob(\"Z\"))\n\n```\n\n**Result**\n\n```\n\nX:\n [ 2. 15.  2.  7. 12.]\nY:\n [ 3. 12.  9.  3. 18.]\nZ:\n [ 2. 15.  2.  7. 12.]\nX:\n [[2. 0. 4.]\n [7. 7. 4.]\n [7. 9. 9.]]\nY:\n [[2. 0. 8.]\n [9. 6. 1.]\n [7. 8. 0.]]\nZ:\n [ 36. 109. 121.]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* 1D or 2D input tensor.",
        "name": "X"
      },
      {
        "description": "*(type: Tensor`<float>`)* 1D or 2D input tensor (must have the same shape as X).",
        "name": "Y"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* 1D output tensor.",
        "name": "Z"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "DotProductGradient",
    "support_level": "default"
  },
  {
    "name": "DotProductWithPadding",
    "description": "\nGiven two input float tensors X, Y with different shapes and produces one\noutput float tensor of the dot product between X and Y. We currently support\ntwo kinds of strategies to achieve this. Before doing normal dot_product 1)\npad the smaller tensor (using pad_value) to the same shape as the other one.\n2) replicate the smaller tensor to the same shape as the other one. Note the\nfirst dimension of X, Y must be equal. Only the second dimension of X or Y\ncan be padded.\n",
    "attributes": [
      {
        "description": "the padding value for tensors with smaller dimension",
        "name": "pad_value",
        "option": "optional"
      },
      {
        "description": "whether to replicate the smaller tensor or not",
        "name": "replicate",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "1D or 2D input tensor",
        "name": "X"
      },
      {
        "description": "1D or 2D input tensor",
        "name": "Y"
      }
    ],
    "outputs": [
      {
        "description": "1D output tensor",
        "name": "Z"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "DotProductWithPaddingGradient",
    "support_level": "default"
  },
  {
    "name": "Dropout",
    "category": "Dropout",
    "description": "\n\n`Dropout` takes one input data tensor (`X`) and produces two tensor outputs, `Y` and\n`mask`. If the `is_test` argument is zero (default=0), the output `Y` will be the input\nwith random elements zeroed. The probability that a given element is zeroed is\ndetermined by the `ratio` argument.\n\nIf the `is_test` argument is set to non-zero, the output `Y` is exactly the same as the\ninput `X`. Note that outputs are scaled by a factor of $\\frac{1}{1-ratio}$ during\ntraining, so that during test time, we can simply compute an identity function. This\nscaling is important because we want the output at test time to equal the expected value\nat training time. Dropout has been proven to be an effective regularization technique to\nprevent overfitting during training.\n\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/dropout_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/dropout_op.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Dropout\",\n    [\"X\"],\n    [\"Y\"] + [\"mask\"],\n    ratio=0.5,\n    is_test=0\n)\n\nworkspace.FeedBlob(\"X\", np.random.randint(10, size=(5, 5)).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\nprint(\"mask:\", workspace.FetchBlob(\"mask\"))\n```\n\n**Result**\n\n```\nX: [[5. 4. 3. 6. 9.]\n [2. 1. 8. 0. 9.]\n [7. 3. 0. 6. 3.]\n [1. 8. 2. 6. 4.]\n [6. 2. 6. 4. 0.]]\nY: [[ 0.  0.  0. 12. 18.]\n [ 0.  0. 16.  0.  0.]\n [ 0.  0.  0. 12.  6.]\n [ 0.  0.  4.  0.  0.]\n [12.  0.  0.  0.  0.]]\nmask: [[False False False  True  True]\n [False False  True  True False]\n [False False  True  True  True]\n [False False  True False False]\n [ True False False False False]]\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 0.5,
        "description": "Probability of an element to be zeroed.",
        "name": "ratio",
        "option": "optional",
        "type": "float32"
      },
      {
        "default": 0,
        "description": "If zero (train mode), perform dropout. If non-zero(test mode), Y = X.",
        "name": "is_test",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "The input data as Tensor.",
        "name": "data"
      },
      {
        "description": "*(type: Tensor`<float>`)* Input data tensor.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "The output.",
        "name": "output"
      },
      {
        "description": "*(type: Tensor`<bool>`)* The output mask containing boolean values foreach element, signifying which elements are dropped out. If `is_test` isnonzero, this output is not filled.",
        "name": "mask"
      },
      {
        "description": "*(type: Tensor`<float>`)* Output tensor.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "DropoutGrad",
    "support_level": "default"
  },
  {
    "name": "ElementwiseLinear",
    "description": "\nThis op computes the elementwise linear combination of a batch of input vectors with a weight vector and bias vector. As input, the op takes an input tensor $X$ of shape $NxD$, a weight vector $w$ of length $D$, and a bias vector $b$ of length $D$. Here, $N$ represents the batch size and $D$ represents the length of the feature vectors. The output, $Y$, is a tensor of shape $NxD$ and is calculated as\n\n$$Y_{ij} = X_{ij}w_j + b_j \\ for \\ i\\in{N}, j\\in{D}$$\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/elementwise_linear_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/elementwise_linear_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"ElementwiseLinear\",\n    [\"X\", \"w\", \"b\"],\n    [\"Y\"]\n)\n\n// Create X\nX = np.array([[1,2,3,4,5],[6,8,9,16,10]])\nprint(\"X:\\n\",X)\n\n// Create w\nw = np.array([1,1/2.,1/3.,1/4.,1/5.])\nprint(\"w:\\n\",w)\n\n// Create b\nb = np.array([1.,1.,1.,1.,1.])\nprint(\"b:\\n\",b)\n\n\n// Feed X & w & b into workspace\nworkspace.FeedBlob(\"X\", X.astype(np.float32))\nworkspace.FeedBlob(\"w\", w.astype(np.float32))\nworkspace.FeedBlob(\"b\", b.astype(np.float32))\n\n// Run op\nworkspace.RunOperatorOnce(op)\n\n// Collect Output\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n [[ 1  2  3  4  5]\n [ 6  8  9 16 10]]\nw:\n [1.  0.5  0.33333333 0.25  0.2]\nb:\n [1. 1. 1. 1. 1.]\nY:\n [[2. 2. 2. 2. 2.]\n [7. 5. 4. 5. 3.]]\n\n```\n\n</details>\n\n  ",
    "attributes": [
      {
        "default": 1,
        "description": "Describes the axis of the inputs; defaults to one because the 0th axis most likely describes the batch size.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "2D input tensor of size $NxD$. This input represents the input data to be operated on.",
        "name": "X"
      },
      {
        "description": "1D scaling factors, or weights, of size $D$. This input contains the weights that will be multiplied by the data.",
        "name": "w"
      },
      {
        "description": "1D biases of size $D$. This input contains the biases that will be added to the products of the weights and data.",
        "name": "b"
      }
    ],
    "outputs": [
      {
        "description": "2D output tensor of size $NxD$. Calculated as described above.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ElementwiseLinearGradient",
    "support_level": "default"
  },
  {
    "name": "Elu",
    "description": "\n\nThis op implements the exponential linear unit (ELU) activation function as described in [Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs)](https://arxiv.org/abs/1511.07289). The op takes an input tensor $X$ of arbitrary shape, computes the elementwise elu operation, and returns a vector $Y$ of the same shape as output. The alpha parameter may be passed as an argument, but defaults to 1. The elu operation is defined as\n\n$$y=f(x) =\\begin{cases}\\alpha(e^x-1) & x < 0 \\\\ x & otherwise\\end{cases}$$\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/elu_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/elu_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Elu\",\n    [\"X\"],\n    [\"Y\"],\n    alpha=1.1\n)\n\nworkspace.FeedBlob(\"X\", np.random.randn(3, 3).astype(np.float32))\nprint(\"X:\\n\", workspace.FetchBlob(\"X\"), \"\\n\")\n\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n [[ 0.35339102  1.1860217  -0.10710736]\n [-3.1173866  -0.1889988  -0.20330353]\n [ 1.8525308  -0.368949    0.506277  ]]\n\nY:\n [[ 0.35339102  1.1860217  -0.11172786]\n [-1.0513     -0.18943374 -0.20236646]\n [ 1.8525308  -0.33939326  0.506277  ]]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 1.0,
        "description": "Defines alpha parameter used in calculation.",
        "name": "alpha",
        "option": "optional",
        "type": "float32"
      }
    ],
    "inputs": [
      {
        "description": "1D input tensor of data to be operated on.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "1D input tensor, calculated as described above.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "EluGradient",
    "description": "\nEluGradient takes both Y and dY and uses this to update dX according to the\nchain rule and derivatives of the rectified linear function.\n",
    "support_level": "default"
  },
  {
    "name": "EnforceFinite",
    "description": "\nRaise if there is NaN or Inf values in the input tensor.\n",
    "inputs": [
      {
        "description": "Input tensor",
        "name": "input"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "EnqueueBlobs",
    "support_level": "default"
  },
  {
    "name": "EnqueueRebatchingQueue",
    "description": "\nEnqueues Tensors into the queue.\nNumber of input tensors should be equal to the number of components passed\nduring creation of the queue.\nIf the Queue is closed this operation will fail.\nIf enqueue_batch argument is set. We will split the input tensors by the\nfirst dimension to produce single queue elements.\n",
    "attributes": [
      {
        "description": "Are we enqueuing a batch or just a single element.         By default we enqueue single element.",
        "name": "enqueue_batch",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "object representing the queue",
        "name": "queue"
      },
      {
        "description": "First tensor to enque. ",
        "name": "tensor"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "EnsureClipped",
    "description": "\nGiven a tensor, apply clip after gradient is applied; when the param is sparse as\nindicated by valid indices and grad, in-place is required\n",
    "inputs": [
      {
        "description": "Parameters to be normalized",
        "name": "param"
      },
      {
        "description": "Sparse indices, only needed for sparse param",
        "name": "indices"
      },
      {
        "description": "Gradient computed, only needed for sparse param",
        "name": "grad"
      }
    ],
    "outputs": [
      {
        "description": "param ensured to be clipped within range",
        "name": "output_param"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "EnsureCPUOutput",
    "description": "\nThis Op always create TensorCPU output, and may involves cross-device MemCpy.\nUnder CPU Context, this Op takes TensorCPU as input. Under the CUDA Context,\nthis Op accepts either CUDA or CPU Tensor input.\n",
    "inputs": [
      {
        "description": "The input CUDA or CPU tensor.",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "TensorCPU that is a copy of the input.",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "EnsureDense",
    "description": "\nThis operator converts dense or sparse gradients to dense ones.\nTherefore, sparse gradient can be back propagated to Operators that consume\ndense gradients only (e.g., FCGradient).\n\nThe operator's behaviors:\n\n- In forward, simply pass in place or copy input to the output.\n- In backward, if the gradient passed-in is sparse gradient, change it to dense gradient in linear time; otherwise, simply pass the dense gradient.\n",
    "inputs": [
      {
        "description": "Input tensors.",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Output tensor. Same dimension as inputs.",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "EQ",
    "description": "\nPerforms element-wise equal to comparison **==** (with limited broadcast support).\n\n\nIf necessary the right-hand-side argument will be broadcasted to match the\nshape of left-hand-side argument. When broadcasting is specified, the second\ntensor can either be of size 1 (a scalar value), or having its shape as a\ncontiguous subset of the first tensor's shape. The starting of the mutually\nequal shape is specified by the argument \"axis\", and if it is not set, suffix\nmatching is assumed. 1-dim expansion doesn't work yet.\n\nFor example, the following tensor shapes are supported (with broadcast=1):\n```\n  shape(A) = (2, 3, 4, 5), shape(B) = (,), i.e. B is a scalar\n  shape(A) = (2, 3, 4, 5), shape(B) = (5,)\n  shape(A) = (2, 3, 4, 5), shape(B) = (4, 5)\n  shape(A) = (2, 3, 4, 5), shape(B) = (3, 4), with axis=1\n  shape(A) = (2, 3, 4, 5), shape(B) = (2), with axis=0\n```\nArgument `broadcast=1` needs to be passed to enable broadcasting.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/elementwise_ops_schema.cc\n\n\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"EQ\",\n    [\"A\",  \"B\"],\n    [\"C\"],\n)\n\nworkspace.FeedBlob(\"A\", np.array([1, 5, 2, 9, 12, 3]))\nworkspace.FeedBlob(\"B\", np.array([1, 3, 4, 9, 12, 8]))\nprint(\"A:\", workspace.FetchBlob(\"A\"))\nprint(\"B:\", workspace.FetchBlob(\"B\"))\nworkspace.RunOperatorOnce(op)\nprint(\"C:\", workspace.FetchBlob(\"C\"))\n\n```\n\n**Result**\n\n```\nA: [ 1  5  2  9 12  3]\nB: [ 1  3  4  9 12  8]\nC: [ True False False  True  True False]\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 0,
        "description": "Pass 1 to enable broadcasting.",
        "name": "broadcast",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": -1,
        "description": "Axis to concatenate on. If set, defines the broadcast dimensions.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<bool>`)* First operand, should share the type with the second operand.",
        "name": "A"
      },
      {
        "description": "*(type: Tensor`<bool>`)* Second operand. With broadcasting can be of smaller size than `A`. If broadcasting is disabled it should be of the same size.",
        "name": "B"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<bool>`)* Output tensor with same dimensions as `A`.",
        "name": "C"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Erf",
    "description": "\nCalculates the arcsine of the given input tensor, element-wise.\n",
    "inputs": [
      {
        "description": "Input tensor",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "The arcsine of the input tensor computed element-wise",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ErfGradient",
    "support_level": "default"
  },
  {
    "name": "Exp",
    "description": "\nCalculates the exponential of the given input tensor ($exp(x)$), element-wise. This\noperation can be done in an in-place fashion too, by providing the same input\nand output blobs.\n\nGithub Link:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/exp_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Exp\",\n    [\"X\"],\n    [\"X\"],\n)\n\nworkspace.FeedBlob(\"X\", (np.random.rand(3,3)).astype(np.float32))\nprint(\"X before running op:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"X after running op:\", workspace.FetchBlob(\"X\"))\n\n```\n\n**Result**\n\n```\n\nX before running op:\n[[0.5821691  0.07719802 0.50159824]\n [0.40952456 0.36788362 0.84887683]\n [0.02472685 0.65730894 0.9066397 ]]\nX after running op:\n[[1.7899168 1.080256  1.6513585]\n [1.5061016 1.4446739 2.3370204]\n [1.0250351 1.9295927 2.4759884]]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input tensor.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* The exponential of the input tensor computed element-wise.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Expand",
    "description": "\n        Broadcast the input tensor to a materialized new tensor using given shape.\n        Broadcast rule is similar to \"numpy.array(input) * numpy.ones(shape)\":\n        Dimensions are right alignment;\n        Two corresponding dimensions must have the same value, or one of them\n        equals to 1.\n        In order to align with PyTorch's `expand`, `shape` is allowed to have entries\n        equal to -1, which means to preserve the size of the corresponding dimension\n        in `X` (so it's actually equivalent to equal to 1).\n",
    "inputs": [
      {
        "description": "(*Tensor`<NumericType>`*): input tensor",
        "name": "X"
      },
      {
        "description": "(*Tensor`<int>`*): expand shape",
        "name": "shape"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor`<NumericType>`*): expanded tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ExpandDims",
    "description": "\nThe *ExpandDims* op inserts single-dimensional entries into the shape of the input tensor *data,* and produces a single output tensor *expanded*. The op also takes an argument *dims* with a list of dimensions for where to add the single dimensional entries. If the same blob is provided as input and output, the operation is copy-free. This is the exact inverse operation of *Squeeze*.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/expand_squeeze_dims_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/expand_squeeze_dims_op.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"ExpandDims\",\n    [\"data\"],\n    [\"expanded\"],\n    dims=[0,1],\n)\n\nworkspace.FeedBlob(\"data\", np.zeros((100,100)).astype(np.float32))\nprint(\"data.shape:\", workspace.FetchBlob(\"data\").shape)\n\nworkspace.RunOperatorOnce(op)\nprint(\"expanded.shape:\", workspace.FetchBlob(\"expanded\").shape)\n\n```\n\n**Result**\n\n```\n\ndata.shape: (100, 100)\nexpanded.shape: (1, 1, 100, 100)\n\n```\n\n</details>\n\n\n\n",
    "attributes": [
      {
        "description": "List of dimensions of *data* to add single dimensional entry.",
        "name": "dims",
        "option": "optional",
        "type": "int64[]"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor of data to be operated on.",
        "name": "data"
      }
    ],
    "outputs": [
      {
        "description": "Reshaped tensor with same data as input.",
        "name": "expanded"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ExpandGradient",
    "support_level": "default"
  },
  {
    "name": "Fail",
    "support_level": "default"
  },
  {
    "name": "FbFCPacked",
    "description": "Same as FC,\n      but the weight is prepacked as a fbgemm::PackedGemmMatrixFP16",
    "support_level": "default"
  },
  {
    "name": "FbGemmPack",
    "description": "Prepack weight for fbgemm",
    "inputs": [
      {
        "description": "row major format weight matrix",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "Block row major packed format weight matrix",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "FbGemmPackTranspose",
    "description": "Prepack weight for fbgemm",
    "inputs": [
      {
        "description": "col major format weight matrix",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "Block col major packed format weight matrix",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "FC",
    "category": "Layer",
    "description": "\nThe FC operator computes an output $(Y)$ as a linear combination of the input data blob $(X)$ with a weight blob $(W)$ and bias blob $(b)$. More formally,\n\n$$Y = XW^T+b$$\n\nHere, $X$ is a matrix of shape $(M,K)$, $W$ is a matrix of shape $(N,K)$, $b$ is a vector of length $N$, and $Y$ is a matrix of shape $(M,N)$. $N$ can be thought of as the number of nodes in the layer, $M$ is the batch size, and $K$ is the number of features in an input observation.\n\n*NOTE: $X$ does not need to explicitly be a 2-dimensional matrix, however, if it is not it will be coerced into one. For an arbitrary $n$-dimensional tensor $X$, e.g. $[a_0, a_1, \\ldots ,a_{k-1}, a_k, \\ldots , a_{n-1}]$, where $a_i$ in $N$, and $k$ is the $axis$ arg provided, then $X$ will be coerced into a 2-dimensional tensor with dimensions $[a_0 * \\ldots * a_{k-1}, a_k * \\ldots * a_{n-1}]$. For the default case where axis=1, this means the $X$ tensor will be coerced into a 2D tensor of dimensions $[a_0, a_1 * \\ldots * a_{n-1}]$, where $a_0$ is often the batch size. In this situation, we must have $a_0 = M$ and $a_1 * \\ldots * a_{n-1} = K$. Lastly, even though $b$ is a vector of length $N$, it is copied and resized to shape $(M x N)$ implicitly, then added to each vector in the batch.*\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/fully_connected_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/fully_connected_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\n// In this example, our batch size is 1 (M=1), the input observation will have\n//   6 features (K=6), and the layer will have one hidden node (N=1). The\n//   expected output is Y=7.\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"FC\",\n    [\"X\", \"W\", \"b\"],\n    [\"Y\"]\n)\n\n// Create X: MxK\ndata = np.array([1,2,3,4,5,6]).astype(np.float32)\ndata = data[np.newaxis,:]\n\n// Create W: NxK\nweights = np.array(np.array([1,1/2.,1/3.,1/4.,1/5.,1/6.])).astype(np.float32)\nweights = weights[np.newaxis,:]\n\n// Create b: N\nbias = np.array([1.]).astype(np.float32)\n\n// Put the inputs into the workspace\nworkspace.FeedBlob(\"X\", data)\nworkspace.FeedBlob(\"W\", weights)\nworkspace.FeedBlob(\"b\", bias)\n\n// Run the operator\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nY:\n [[7.]]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 1,
        "description": "Describes the axis of the input data $X$. Defaults to one because in the common case when the input $X$ has shape $(M,K)$, the first axis encodes the batch size.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": 1,
        "description": "Describes the axis of the input weight matrix $W$. Defaults to one because the first axis most likely describes the batch_size.",
        "name": "axis_w",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": false,
        "description": "Whether to use float-16 compute kernel.",
        "name": "float16_compute",
        "option": "optional",
        "type": "boolean"
      }
    ],
    "inputs": [
      {
        "description": "Input blob to be coerced into a 2D matrix of shape $(M,K)$, where $M$ is the batch size and $K$ is the number of features in a single observation.",
        "name": "X"
      },
      {
        "description": "Input blob to be coerced into a 2D matrix of shape $(N,K)$ describing a fully connected weight matrix. Here, $K$ is the number of features in a single observation and $N$ is the number of nodes in the FC layer.",
        "name": "W"
      },
      {
        "description": "Input blob containing vector of length $N$ which describes one bias for each node in the layer.",
        "name": "b"
      }
    ],
    "outputs": [
      {
        "description": "Output blob containing a 2D output matrix of shape $(M,N)$, where $M$ is the batch size and $N$ is the number of nodes in the layer. The output is calculated as $Y=XW^T+b$.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "FCGradient",
    "support_level": "default"
  },
  {
    "name": "FCTransposed",
    "description": "\nSame as FC, but weight matrix is supposed to be already pretransposed.\nFCTransposed stands for calling blass with no noTrans, noTrans\n",
    "support_level": "default"
  },
  {
    "name": "FCTransposedGradient",
    "support_level": "default"
  },
  {
    "name": "FeedBlob",
    "description": "\nFeedBlobs the content of the blobs. The input and output blobs should be\none-to-one inplace.",
    "attributes": [
      {
        "description": "(string) if provided then we will use this string as the value for theprovided output tensor",
        "name": "value",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "FileStoreHandlerCreate",
    "description": "\nCreates a unique_ptr<StoreHandler> that uses the filesystem as backing\nstore (typically a filesystem shared between many nodes, such as NFS).\nThis store handler is not built to be fast. Its recommended use is for\nintegration tests and prototypes where extra dependencies are\ncumbersome. Use an ephemeral path to ensure multiple processes or runs\ndon't interfere.\n",
    "attributes": [
      {
        "description": "base path used by the FileStoreHandler",
        "name": "path",
        "option": "optional"
      },
      {
        "description": "prefix for all keys used by this store",
        "name": "prefix",
        "option": "optional"
      }
    ],
    "outputs": [
      {
        "description": "unique_ptr<StoreHandler>",
        "name": "handler"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Find",
    "description": "\nFinds elements of second input from first input,\noutputting the last (max) index for each query.\nIf query not find, inserts missing_value.\nSee IndexGet() for a version that modifies the index when\nvalues are not found.\n",
    "attributes": [
      {
        "description": "Placeholder for items that are not found",
        "name": "missing_value",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Index (integers)",
        "name": "index"
      },
      {
        "description": "Needles / query",
        "name": "query"
      }
    ],
    "outputs": [
      {
        "description": "Indices of the needles in index or 'missing value'",
        "name": "query_indices"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "FindDuplicateElements",
    "description": "\nThe *FindDuplicateElements* op takes a single 1-D tensor *data* as input and returns a single 1-D output tensor *indices*. The output tensor contains the indices of the duplicate elements of the input, excluding the first occurrences. If all elements of *data* are unique, *indices* will be empty.\n\nGithub Links:\n\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/find_duplicate_elements_op.h\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/find_duplicate_elements_op.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"FindDuplicateElements\",\n    [\"data\"],\n    [\"indices\"],\n)\n\nworkspace.FeedBlob(\"data\", np.array([8,2,1,1,7,8,1]).astype(np.float32))\nprint(\"data:\\n\", workspace.FetchBlob(\"data\"))\n\nworkspace.RunOperatorOnce(op)\nprint(\"indices: \\n\", workspace.FetchBlob(\"indices\"))\n\n```\n\n**Result**\n\n```\n\ndata:\n [8. 2. 1. 1. 7. 8. 1.]\nindices:\n [3 5 6]\n\n```\n\n</details>\n\n\n  ",
    "inputs": [
      {
        "description": "a 1-D tensor.",
        "name": "data"
      }
    ],
    "outputs": [
      {
        "description": "Indices of duplicate elements in data, excluding first occurrences.",
        "name": "indices"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Flatten",
    "description": "\nFlattens the input tensor into a 2D matrix. If input tensor has shape\n$(d_0, d_1, ..., d_n)$ then the output will have shape\n$\\bigl((d_0 * d_1 * ... * d_{(axis-1)}), (d_{axis} * d_{(axis+1)} * ... * d_n)\\bigr)$.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/flatten_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Flatten\",\n    [\"X\"],\n    [\"Y\"],\n    axis=1\n)\n\nworkspace.FeedBlob(\"X\", np.random.rand(1,3,2,2))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n```\n\n**Result**\n\n```\nX: [[[[0.53432311 0.23734561]\n   [0.56481598 0.52152617]]\n\n  [[0.33662627 0.32472711]\n   [0.17939016 0.97175851]]\n\n  [[0.87226421 0.49045439]\n   [0.92470531 0.30935077]]]]\nY: [[0.53432311 0.23734561 0.56481598 0.52152617 0.33662627 0.32472711\n  0.17939016 0.97175851 0.87226421 0.49045439 0.92470531 0.30935077]]\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 1,
        "description": "Indicates up to which input dimensions (exclusive) should be flattened to the outer dimension of the output.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor)* Input Tensor of rank >= axis.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor)* A 2D tensor with the contents of the input tensor, with input dimensions up to `axis` flattened to the outer dimension of the output and the remaining input dimensions flattened into the inner dimension of the output.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "FlattenToVec",
    "description": "\n\nThe *FlattenToVec* op flattens the input tensor into a 1-D vector. The op accepts a single input tensor and returns a single output tensor.\n\nGithub Links:\n\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/utility_ops.cc\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/utility_ops.h\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"FlattenToVec\",\n    [\"input\"],\n    [\"output\"],\n)\n\nworkspace.FeedBlob(\"input\", np.array([[1,2,3],[4,5,6],[7,8,9],[10,11,12]]).astype(np.float32))\nprint(\"input:\\n\", workspace.FetchBlob(\"input\"))\n\nworkspace.RunOperatorOnce(op)\nprint(\"output: \\n\", workspace.FetchBlob(\"output\"))\n\n```\n\n**Result**\n\n```\n\ninput:\n [[ 1.  2.  3.]\n [ 4.  5.  6.]\n [ 7.  8.  9.]\n [10. 11. 12.]]\noutput:\n [ 1.  2.  3.  4.  5.  6.  7.  8.  9. 10. 11. 12.]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "A tensor of rank >= 1.",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "A tensor of rank 1 (vector) with the contents of the input tensor.",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "FlexibleTopK",
    "description": "\nGiven two tensors: X and K,\nretrieve the top K[..., 1] elements from X on the last dimension.\nX is an input tensor of shape [a_1, a_2, ..., a_n, r].\nK is an input tensor of shape [a_1, a_2, ..., a_n, 1],\nwhere for each element, r >= K[..., 1] > 0\nOutput two outputs:\n-Flatten values tensor of shape [ \\sum_i K[i, 1] ] which contains the values of\n the top K[..., 1]  elements along the last dimension\n-Flatten indices tensor of shape [ \\sum_i K[i, 1] ] which contains the indices\n of the top K[..., 1]  elements, flatten indices from the input tensor).\nThese two outputs should be used with the input K, so that we know which indices\nin X are picked.\n\nGiven two equivalent values, this operator uses the indices along the last dim-\nension as a tiebreaker. That is, the element with the lower index will appear\nfirst.\n    ",
    "inputs": [
      {
        "description": "Tensor of shape [a_1, a_2, ..., a_n, r]",
        "name": "X"
      },
      {
        "description": "Tensor of shape [a_1, a_2, ..., a_n, 1]",
        "name": "K"
      }
    ],
    "outputs": [
      {
        "description": "Tensor of shape [ \\sum_i K[i, 1] ] containing top K[..., 1] values from the input tensor",
        "name": "Flatten values"
      },
      {
        "description": "Tensor of shape [ \\sum_i K[i, 1] ] containing the indices into the flatten input",
        "name": "Flatten indices"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "FlexibleTopKGradient",
    "support_level": "default"
  },
  {
    "name": "Float16ConstantFill",
    "attributes": [
      {
        "description": "The value for the elements of the output tensor.",
        "name": "value",
        "option": "optional"
      },
      {
        "description": "The shape of the output tensor.",
        "name": "shape",
        "option": "optional"
      }
    ],
    "outputs": [
      {
        "description": "Output tensor of constant values specified by 'value'",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Float16SparseNormalize",
    "description": "\nGiven a sparse matrix, apply max_norm or constant_norm sparse regularization.\n",
    "attributes": [
      {
        "description": "A bool variable to control whether to use max norm     or constant norm. When use_max_norm = false, constant norm is used so that     all the embedding vectors are scaled to have a L2 norm equals to A     (see blow argument norm=A). If use_max_norm = true,     max norm is used so that embedding is scaled so that its l2 norm is no larger     than A. If an embedding's norm is less than A originally,     the embedding is left unchanged.    The default is True.",
        "name": "use_max_norm",
        "option": "optional"
      },
      {
        "description": "L2 norm of the embedding. The default is 1.0.",
        "name": "norm",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be normalized",
        "name": "param"
      },
      {
        "description": "Sparse indices",
        "name": "indices"
      },
      {
        "description": "Gradient computed (optional - not used, this argument is for backwards compatibility)",
        "name": "grad"
      }
    ],
    "outputs": [
      {
        "description": "Normalized parameters",
        "name": "output_param"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Float16UniformFill",
    "description": "Fills a half float tensor of a specified shape with values from a uniform distribution[min,max]",
    "attributes": [
      {
        "description": "Shape of the tensor",
        "name": "shape",
        "option": "optional"
      },
      {
        "description": "Minimim value to generate",
        "name": "min",
        "option": "optional"
      },
      {
        "description": "Maximum value to generate",
        "name": "max",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "FloatToFused2BitFakeRowwiseQuantized",
    "description": "\nApplies 2-bit row-wise fake quantization to a tensor of floats.\nThe output looks like an int8 rowwise quantized blob with\nscale and biases in half float.\n",
    "inputs": [
      {
        "description": "Float32 input data",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Fused scale, bias and quantized data",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "FloatToFused2BitRowwiseQuantized",
    "description": "\nApplies 2-bit row-wise quantization by determining the range\n(maximum - minimum) and offset (minimum value) of each row in the input\nmatrix, and then scaling each element to an 2-bit number between 0 and\n3. To later de-quantize values, the scale (range / 3) and zero_point\nare stored alongside the data. More precisely, each row first has quantized\nvalues, and then 2-byte fp16 scale and 2-byte zero_offset.)\n",
    "inputs": [
      {
        "description": "Float32 input data",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Fused scale, bias and quantized data",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "FloatToFused4BitFakeRowwiseQuantized",
    "description": "\nApplies 4-bit row-wise fake quantization to a tensor of floats.\nThe output looks like an int8 rowwise quantized blob with\nscale and biases in half float.\n",
    "inputs": [
      {
        "description": "Float32 input data",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Fused scale, bias and quantized data",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "FloatToFused4BitRowwiseQuantized",
    "description": "\nApplies 4-bit row-wise quantization by determining the range\n(maximum - minimum) and offset (minimum value) of each row in the input\nmatrix, and then scaling each element to an 4-bit number between 0 and\n15. To later de-quantize values, the scale (range / 15) and zero_point\nare stored alongside the data. More precisely, each row first has quantized\nvalues, and then 2-byte fp16 scale and 2-byte zero_offset.)\n",
    "inputs": [
      {
        "description": "Float32 input data",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Fused scale, bias and quantized data",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "FloatToFused8BitRowwiseQuantized",
    "description": "\nApplies 8-bit row-wise quantization by determining the range\n(maximum - minimum) and offset (minimum value) of each row in the input\nmatrix, and then scaling each element to an 8-bit number between 0 and\n255. To later de-quantize values, the scale (range / 255) and offset\n(bias) are stored alongside the data. More precisely, each row contains\nint8 elements for each quantized element, and the last 8 bytes\nof each row in the output matrix are a float storing the scale\nfollowed by another float containing the scale.\nFor N-dimensional input tensor, the first N-1 dimensions are interpreted as\nrows and the last dimension is interpreted as a column. For example, an\ninput tensor with dimension 5x2x4 is interpreted as 10 rows and 4 columns.\n)\n",
    "inputs": [
      {
        "description": "Float32 input data",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Fused scale, bias and quantized data",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "FloatToFused8BitRowwiseQuantizedHalfScaleBias",
    "description": "\nApplies 8-bit row-wise quantization by determining the range\n(maximum - minimum) and offset (minimum value) of each row in the input\nmatrix, and then scaling each element to an 8-bit number between 0 and\n255. To later de-quantize values, the scale (range / 255) and offset\n(bias) are stored alongside the data. More precisely, each row contains\nint8 elements for each quantized element, and the last 4 bytes\nof each row in the output matrix are a half float storing the scale\nfollowed by another half float containing the scale.)\n",
    "inputs": [
      {
        "description": "Float32 input data",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Fused scale, bias and quantized data",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "FloatToFusedRandRowwiseQuantized",
    "description": "\nApplies row-wise stochastic/random quantization by determining the range of\neach row in the input matrix, and then quantize each element to one of two\nclosest discrete levels by randomly drawing Bernoulli distribution.\nThe method is extended from TernGrad [1],\nwhich randomly quantizes gradients to three levels to reduce communication in distributed training.\nThe format of each row (x) in the output matrix is [bitwidth][tail][min][max][data]:\nbitwidth[1 Byte]: bitwidth per data [1, 2, 4 or 8];\ntail[1 Byte]: the number of unused buckets [1-8] (One byte is split to 8/bitwidth buckets and each bucket stores one low-precision data in bitwidth bits);\nmin[4 Bytes]: the minimum floating value min(x);\nmax[4 Bytes]: the maximum floating value max(x);\ndata: quantized data.\nThe quantization is uniform with levels q = min + (max-min)/(2^bitwidth - 1)*[0:1:2^bitwidth].\nDuring stochastic/random quantization x'=Quantize(x), for q_j < x_i <= q_{j+1}, we draw quantization x'_i from Bernoulli distributions with\nP(x'_i = q_{j+1}) = (x_i - q_j)/(q_{j+1} - q_j), and\nP(x'_i = q_j) = (q_{j+1} - x_i)/(q_{j+1} - q_j) where x'_i is the quantized value of x_i.\n[1] proved E{x'_i}=x_i, which is an unbiased approximation. More details are in the paper.\nFor example, suppose targeted bitwidth = 2 and x = [0.3, -1.4, -0.6, 0.9, 1.0],\nthen tail = 3, min = -1.4, max = 1.0 and q = [-1.4, -0.6, 0.2, 1.0].\nx_1 = 0.3 will be quantized to x'_1 = 0.2 with probability 7/8 and to x'_1 = 1.0 with probability 1/8.\nThe storage format of quantized data is: [x'_1|x'_3|x'_5|xxx]-[x'_2|x'_4|xxx|xxx].\nIn general, a input row is split to multiple segments. One segment is a continuous subarray of the row,\nand its length is the number of bytes storing quantized data in the output matrix.\nThe b-th bucket of the i-th byte stores the i-th data of the b-th segment of input row.\n\n[1] Wen, Wei, Cong Xu, Feng Yan, Chunpeng Wu, Yandan Wang, Yiran Chen, and Hai Li.\n\"Terngrad: Ternary gradients to reduce communication in distributed deep learning.\"\nIn Advances in Neural Information Processing Systems, pp. 1508-1518. 2017.\n\n",
    "attributes": [
      {
        "description": "How many bits to quantize per data (defaults to 8).",
        "name": "bitwidth",
        "option": "optional"
      },
      {
        "description": "random or not (True). False is set up for unittest.",
        "name": "random",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Float32 input data",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Fused bitwidth, tail, min, max and quantized data",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "FloatToHalf",
    "support_level": "default"
  },
  {
    "name": "FloatToRowwiseQuantized8Bits",
    "description": "\nThis operator applies 8Bit row-wise quantization to\ninput tensor and returns quantized tensor. Row wise quantization of\ninput tensor is the following process. We take tensor of size\n(m_1, m_2,...,m_n), n >= 2, reshape it into matrix of size\n(m_1, m_2 x... x m_n) and apply row-wise quantization. After this,\nwe compute scale_i= (min_i - max_i) / 255 and  bias_i = min_i for\ni-th row r_i of reshaped matrix, where min_i and max_i --  minimum\nand maximum elements of i-th row, and quantize each element r_{ij} as\n0 <= round(r_ij - bias_i) / scale_i) < 256. Instead of input tensor\nwe obtain uint8 tensor and auxiliary information as scale and bias to\nrestore input tensor (with losses).\n",
    "inputs": [
      {
        "description": "input",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "quantized_input",
        "name": "quantized_input"
      },
      {
        "description": "Matrix of floats, each row r_i of which stores a pair s_i, b_i",
        "name": "scale_bias"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Floor",
    "description": "\nElement-wise application of the floor function ($y=floor(x)$) to the input\ntensor `X`. Output tensor shape is the same as the input tensor. This\noperator can be used in an in-place fashion by using the same input blob as the\noutput blob.\n\nGithub Link:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/floor_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Floor\",\n    [\"X\"],\n    [\"X\"],\n)\n\nworkspace.FeedBlob(\"X\", (np.random.uniform(-10, 10, (5,5))).astype(np.float32))\nprint(\"X before running op:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"X after running op:\", workspace.FetchBlob(\"X\"))\n\n```\n\n**Result**\n\n```\n\nX before running op:\n[[ 3.813361   -1.319647    5.2089314  -4.931328    0.6218652 ]\n [ 7.2757645   5.5552588   5.785643   -2.4790506  -0.41400087]\n [ 1.1541046  -6.933266    3.3754056   1.6569928  -1.7670316 ]\n [-3.4932013   4.891472    1.5530115  -3.2443287  -4.605099  ]\n [-4.574543   -7.360948    5.91305    -8.196495   -5.357458  ]]\nX after running op:\n[[ 3. -2.  5. -5.  0.]\n [ 7.  5.  5. -3. -1.]\n [ 1. -7.  3.  1. -2.]\n [-4.  4.  1. -4. -5.]\n [-5. -8.  5. -9. -6.]]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input tensor.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output tensor.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Free",
    "description": "\nFrees the content of the blobs. The input and output blobs should be\none-to-one inplace.",
    "support_level": "default"
  },
  {
    "name": "Ftrl",
    "support_level": "default"
  },
  {
    "name": "Fused2BitRowwiseQuantizedToFloat",
    "description": "\nDe-quantizes the result of the\nFloatToFused2BitRowwiseQuantized operator. The input is expected to first have\nquantized values, then 2-byte fp16 scale and 1-byte zero_offset. The output is a\nmatrix containing only the values, but de-quantized. De-quantization is\nperformed by multiplying each value by its row's scale and zero_point\nparameters. The de-quantized values will thus not be exactly equal to\nthe original, un-quantized floating point values.\n",
    "inputs": [
      {
        "description": "Fused scale, bias and quantized data",
        "name": "scale_bias_quantized_input"
      }
    ],
    "outputs": [
      {
        "description": "Float32 data",
        "name": "float_output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Fused2BitRowwiseQuantizedToHalf",
    "description": "\nDe-quantizes the result of the\nFloatToFused2BitRowwiseQuantized operator. The input is expected to first have\nquantized values, then 2-byte fp16 scale and 1-byte zero_offset. The output is a\nmatrix containing only the values, but de-quantized. De-quantization is\nperformed by multiplying each value by its row's scale and zero_point\nparameters. The de-quantized values will thus not be exactly equal to\nthe original, un-quantized floating point values.\n",
    "inputs": [
      {
        "description": "Fused scale, bias and quantized data",
        "name": "scale_bias_quantized_input"
      }
    ],
    "outputs": [
      {
        "description": "Float16 data",
        "name": "float16_output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Fused4BitRowwiseQuantizedToFloat",
    "description": "\nDe-quantizes the result of the\nFloatToFused4BitRowwiseQuantized operator. The input is expected to first have\nquantized values, then 2-byte fp16 scale and 1-byte zero_offset. The output is a\nmatrix containing only the values, but de-quantized. De-quantization is\nperformed by multiplying each value by its row's scale and zero_point\nparameters. The de-quantized values will thus not be exactly equal to\nthe original, un-quantized floating point values.\n",
    "inputs": [
      {
        "description": "Fused scale, bias and quantized data",
        "name": "scale_bias_quantized_input"
      }
    ],
    "outputs": [
      {
        "description": "Float32 data",
        "name": "float_output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Fused4BitRowwiseQuantizedToHalf",
    "description": "\nDe-quantizes the result of the\nFloatToFused4BitRowwiseQuantized operator. The input is expected to first have\nquantized values, then 2-byte fp16 scale and 1-byte zero_offset. The output is a\nmatrix containing only the values, but de-quantized. De-quantization is\nperformed by multiplying each value by its row's scale and zero_point\nparameters. The de-quantized values will thus not be exactly equal to\nthe original, un-quantized floating point values.\n",
    "inputs": [
      {
        "description": "Fused scale, bias and quantized data",
        "name": "scale_bias_quantized_input"
      }
    ],
    "outputs": [
      {
        "description": "Float16 data",
        "name": "float16_output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Fused8BitRowwiseQuantizedHalfScaleBiasToFloat",
    "description": "\nDe-quantizes the result of the\nFloatToFused8BitRowwiseQuantized operator. The input is expected to\nencode the scale as a 16-bit float in the second to the last 2 bytes of each\nrow, followed by the bias as a 16-bit float in the next 2 bytes, and the\nquantized values in the preceding bytes of the row. The output is a\nmatrix containing only the values, but de-quantized. De-quantization is\nperformed by multiplying each value by its row's scale and bias\nparameters. The de-quantized values will thus not be exactly equal to\nthe original, un-quantized floating point values.\n",
    "inputs": [
      {
        "description": "Fused scale, bias and quantized data",
        "name": "scale_bias_quantized_input"
      }
    ],
    "outputs": [
      {
        "description": "Float32 data",
        "name": "float_output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Fused8BitRowwiseQuantizedHalfScaleBiasToHalfFloat",
    "description": "\nDe-quantizes the result of the\nFloatToFused8BitRowwiseQuantized operator. The input is expected to\nencode the scale as a 16-bit float in the second to the last 2 bytes of each\nrow, followed by the bias as a 16-bit float in the next 2 bytes, and the\nquantized values in the preceding bytes of the row. The output is a\nmatrix containing only the values, but de-quantized. De-quantization is\nperformed by multiplying each value by its row's scale and bias\nparameters. The de-quantized values will thus not be exactly equal to\nthe original, un-quantized floating point values.\n",
    "inputs": [
      {
        "description": "Fused scale, bias and quantized data",
        "name": "scale_bias_quantized_input"
      }
    ],
    "outputs": [
      {
        "description": "Float32 data",
        "name": "float_output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Fused8BitRowwiseQuantizedToFloat",
    "description": "\nDe-quantizes the result of the\nFloatToFused8BitRowwiseQuantized operator. The input is expected to\nencode the scale as a 32-bit float in the second to the last 4 bytes of each\nrow, followed by the bias as a 32-bit float in the next 4 bytes, and the\nquantized values in the preceding bytes of the row. The output is a\nmatrix containing only the values, but de-quantized. De-quantization is\nperformed by multiplying each value by its row's scale and bias\nparameters. The de-quantized values will thus not be exactly equal to\nthe original, un-quantized floating point values.\n",
    "inputs": [
      {
        "description": "Fused scale, bias and quantized data",
        "name": "scale_bias_quantized_input"
      }
    ],
    "outputs": [
      {
        "description": "Float32 data",
        "name": "float_output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Fused8BitRowwiseQuantizedToHalfFloat",
    "description": "\nDe-quantizes the result of the\nHalfFloatToFused8BitRowwiseQuantized operator. The input is expected to\nencode the scale as a 32-bit float in the second to the last 4 bytes of each\nrow, followed by the bias as a 32-bit float in the next 4 bytes, and the\nquantized values in the preceding bytes of the row. The output is a\nmatrix containing only the values, but de-quantized. De-quantization is\nperformed by multiplying each value by its row's scale and bias\nparameters. The de-quantized values will thus not be exactly equal to\nthe original, un-quantized floating point values.\n",
    "inputs": [
      {
        "description": "Fused scale, bias and quantized data",
        "name": "scale_bias_quantized_input"
      }
    ],
    "outputs": [
      {
        "description": "Float16 data",
        "name": "float16_output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "FusedRandRowwiseQuantizedToFloat",
    "description": "\nDe-quantizes the result of the FloatToFusedRandRowwiseQuantized operator.\nRefer FloatToFusedRandRowwiseQuantized operator for details.\n",
    "inputs": [
      {
        "description": "Fused bitwidth, tail, min, max and quantized data",
        "name": "quantized_input"
      }
    ],
    "outputs": [
      {
        "description": "Float32 data",
        "name": "float_input"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Gather",
    "category": "Transform",
    "description": "\n\nThe *Gather* op accepts a *DATA* tensor of rank $r >= 1$ and *INDICES* tensor of rank $q$ as inputs. It then gathers entries of the outer-most dimension of *DATA*, indexed by *INDICES*, and concatenate them in an output tensor of rank $q + (r - 1)$.\n\nGithub Links:\n\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/gather_op.cc\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/gather_op.h\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Gather\",\n    [\"DATA\", \"INDICES\"],\n    [\"OUTPUT\"]\n)\ndata = np.array([[1., 1.2],[2.3, 3.4],[4.5, 5.7]])\nprint(\"DATA:\\n\",data)\n\ninds = np.array([[0, 1],[1, 2]])\nprint(\"INDICES:\\n\",inds)\n\n// Feed X into workspace\nworkspace.FeedBlob(\"DATA\", data.astype(np.float32))\nworkspace.FeedBlob(\"INDICES\", inds.astype(np.int32))\n\nworkspace.RunOperatorOnce(op)\nprint(\"OUTPUT:\\n\", workspace.FetchBlob(\"OUTPUT\"))\n\n```\n\n**Result**\n\n```\n\nDATA:\n [[1.  1.2]\n [2.3 3.4]\n [4.5 5.7]]\nINDICES:\n [[0 1]\n [1 2]]\nOUTPUT:\n [[[1.  1.2]\n  [2.3 3.4]]\n\n [[2.3 3.4]\n  [4.5 5.7]]]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "Input data tensor of rank $r>=1$",
        "name": "DATA"
      },
      {
        "description": "Input indices tensor of rank $q$. This tensor must contain integers.",
        "name": "INDICES"
      }
    ],
    "outputs": [
      {
        "description": "Output tensor of rank $q+(r-1)$",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "GatherByKey",
    "description": "\nInverse operation of Partition.\n\nTakes the original, full 'keys' tensor followed by sharded value tensors,\nand returns the full value tensor, combined using the same hash used in\nPartition.\n",
    "inputs": [
      {
        "description": "The first input is the full keys tensor (same as the first input of Partition).",
        "name": "keys"
      },
      {
        "description": "Subsequented inputs are sharded values tensors.",
        "name": "sharded_values"
      }
    ],
    "outputs": [
      {
        "description": "Reconstructed values tensor.",
        "name": "values"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "GatherFused8BitRowwise",
    "description": "\nPerform the same operation as Gather, but operating on 8-bit rowwise quantized\nmatrices with fused storage (where each row stores quantized values, and then\nthe scale and offset).\nDATA needs to have rank 2 and INDICES needs to have rank 1.\n",
    "inputs": [
      {
        "description": "uint8 tensor with rank 2 obtained with operator FloatToFused8BitRowwiseQuantized",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA forthe rows that are being gathered",
        "name": "INDICES"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "GatherPadding",
    "description": "\nGather the sum of start and end paddings in a padded input sequence. Used in\norder to compute the gradients of AddPadding w.r.t the padding tensors.\n",
    "attributes": [
      {
        "description": "Outer-size of padding present around each range.",
        "name": "padding_width",
        "option": "optional"
      },
      {
        "description": "(Optional) Specifies a different end-padding width.",
        "name": "end_padding_width",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "T<N, D1..., Dn> Padded input data",
        "name": "data_in"
      },
      {
        "description": "(i64) Num of elements in each range. sum(lengths) = N. If not provided, considers all data as a single segment.",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "Sum of all start paddings, or of all paddings if end_padding_sum is not provided.",
        "name": "padding_sum"
      },
      {
        "description": "T<D1..., Dn> Sum of all end paddings, if provided.",
        "name": "end_padding_sum"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "GatherRanges",
    "description": "\nGiven DATA tensor of rank 1, and RANGES tensor of rank 3, gather\ncorresponding ranges into a 1-D tensor OUTPUT.\n\nRANGES dimentions description:\n1: represents list of examples within a batch\n2: represents list features\n3: two values which are start and length or a range (to be applied on DATA)\n\nAnother output LENGTHS represents each example length within OUTPUT\n\nExample:\n  DATA  = [1, 2, 3, 4, 5, 6]\n  RANGES = [\n    [\n      [0, 1],\n      [2, 2],\n    ],\n    [\n      [4, 1],\n      [5, 1],\n    ]\n  ]\n  OUTPUT = [1, 3, 4, 5, 6]\n  LENGTHS = [3, 2]\n",
    "inputs": [
      {
        "description": "Tensor of rank 1.",
        "name": "DATA"
      },
      {
        "description": "Tensor of int32/int64 ranges, of dims (N, M, 2). Where N is number of examples and M is a size of each example. Last dimension represents a range in the format (start, lengths)",
        "name": "RANGES"
      }
    ],
    "outputs": [
      {
        "description": "1-D tensor of size sum of range lengths",
        "name": "OUTPUT"
      },
      {
        "description": "1-D tensor of size N with lengths over gathered data for each row in a batch. sum(LENGTHS) == OUTPUT.size()",
        "name": "LENGTHS"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "GatherRangesToDense",
    "description": "\nGiven DATA tensor of rank 1, and RANGES tensor of rank 3, gather values\ncorresponding to each range into a separate output tensor. If the optional input\nKEY tensor is also given, the output will be sorted by KEY for each example.\n\nRANGES dimensions description:\n1: represents list of examples within a batch\n2: represents list features\n3: two values which are start and length or a range (to be applied on DATA)\n\nEach feature has fixed lengths which are passed as lengths argument and a\nseparate tensor will be produced for each feature.\ni.e. DATA.dim(1) = len(lengths) = NumOuptuts.\n\nMissing features (represented by empty ranges) filled with default_value.\n\nExample 1:\n  DATA  = [1, 2, 3, 4, 5, 6, 7, 8]\n  RANGES = [\n    [\n      [2, 4],\n      [0, 2],\n    ],\n    [\n      [0, 0],\n      [6, 2],\n    ]\n  ]\n  lengths = [4, 2]\n  OUTPUT[0] = [[3, 4, 5, 6], [0, 0, 0, 0]]\n  OUTPUT[1] = [[1, 2], [7, 8]]\n\nExample 2 (with KEY):\nDATA  = [1, 2, 3, 4, 5, 6, 7, 8]\nKEY   = [0, 1, 3, 2, 1, 0, 1, 0]\nRANGES = [\n  [\n    [2, 4],\n    [0, 2],\n  ],\n  [\n    [0, 0],\n    [6, 2],\n  ]\n]\nlengths = [4, 2]\nOUTPUT[0] = [[6, 5, 4, 3], [0, 0, 0, 0]]\nOUTPUT[1] = [[1, 2], [8, 7]]\n\nContrast Example 2 with Example 1. For each data point per feature, the values\nare sorted by the corresponding KEY.\n",
    "attributes": [
      {
        "description": "Expected lengths for ranges",
        "name": "lengths",
        "option": "optional"
      },
      {
        "description": "The number of observations needed before deciding that the ratio of mismatched ranges is alarming, also determines whether an info sumarizing the empty and mismatch ratio will be printed at the end.",
        "name": "min_observation",
        "option": "optional"
      },
      {
        "description": "An error is raised when ratio of empty ranges exceeds this (default is 1, which means by default no error will be triggered).",
        "name": "max_empty_ratio",
        "option": "optional"
      },
      {
        "description": "An error is raised when ratio of mismatched ranges exceeds this.",
        "name": "max_mismatched_ratio",
        "option": "optional"
      },
      {
        "description": "A log is recorded only after an error is triggered every n times.",
        "name": "log_every_n",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Tensor of rank 1.",
        "name": "DATA"
      },
      {
        "description": "Tensor of int32/int64 ranges, of dims (N, M, 2). Where N is number of examples and M is a size of each example. Last dimension represents a range in the format (start, lengths)",
        "name": "RANGES"
      },
      {
        "description": "Tensor of rank 1 and type int64.",
        "name": "KEY"
      }
    ],
    "outputs": [
      {
        "description": "1-D tensor of size sum of range lengths",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "GaussianFill",
    "description": "\nThis op fills an output tensor with samples drawn from a normal distribution specified by the mean and standard deviation arguments. The output tensor shape is specified by the *shape* argument. However, if *input_as_shape* is set to *true*, then the *input* should be a 1D tensor containing the desired output shape (the dimensions specified in *extra_shape* will also be appended). In this case, the *shape* argument should **not** be set.\n\n*Note: cannot set the shape argument and pass in an input at the same time.*\n\nGithub Links:\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/filler_op.h\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/filler_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"GaussianFill\",\n    [],\n    [\"out\"],\n    shape=[3,3],\n    mean=2.0,\n    std=1.1\n)\n\nworkspace.RunOperatorOnce(op)\nprint(\"Out:\\n\", workspace.FetchBlob(\"out\"))\n\n```\n\n**Result**\n\n```\n\nOut:\n [[1.2084167  2.3336504  2.827349  ]\n [2.7108908  0.9374752  1.7173369 ]\n [0.03320992 2.1775863  1.0894578 ]]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 0.0,
        "description": "Mean of the distribution to draw from.",
        "name": "mean",
        "option": "optional",
        "type": "float32"
      },
      {
        "default": 1.0,
        "description": "Standard deviation of the distribution to draw from.",
        "name": "std",
        "option": "optional",
        "type": "float32"
      },
      {
        "description": "Desired shape of the *output* tensor.",
        "name": "shape",
        "option": "optional",
        "type": "int64[]"
      },
      {
        "description": "The additional dimensions appended at the end of the *shape* indicated by the input blob. Cannot set the *extra_shape* argument when there is no input blob.",
        "name": "extra_shape",
        "option": "optional",
        "type": "int64[]"
      },
      {
        "default": false,
        "description": "set to *True* to use the *input* as shape. First, input must be in CPU context.",
        "name": "input_as_shape",
        "option": "optional",
        "type": "boolean"
      }
    ],
    "inputs": [
      {
        "description": "(Optional) 1D tensor specifying the shape of the output. Must be used with *input_as_shape=True*",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Output tensor of random values drawn from a normal distribution. If the shape argument is set, this is the shape specified, and if the *input* exists and *input_as_shape=True*, it is the shape specified by the *input* tensor.",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "GE",
    "description": "\nPerforms element-wise greater or equal than comparison **>=** (with limited broadcast support).\n\n\nIf necessary the right-hand-side argument will be broadcasted to match the\nshape of left-hand-side argument. When broadcasting is specified, the second\ntensor can either be of size 1 (a scalar value), or having its shape as a\ncontiguous subset of the first tensor's shape. The starting of the mutually\nequal shape is specified by the argument \"axis\", and if it is not set, suffix\nmatching is assumed. 1-dim expansion doesn't work yet.\n\nFor example, the following tensor shapes are supported (with broadcast=1):\n```\n  shape(A) = (2, 3, 4, 5), shape(B) = (,), i.e. B is a scalar\n  shape(A) = (2, 3, 4, 5), shape(B) = (5,)\n  shape(A) = (2, 3, 4, 5), shape(B) = (4, 5)\n  shape(A) = (2, 3, 4, 5), shape(B) = (3, 4), with axis=1\n  shape(A) = (2, 3, 4, 5), shape(B) = (2), with axis=0\n```\nArgument `broadcast=1` needs to be passed to enable broadcasting.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/elementwise_ops_schema.cc\n\n\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"GE\",\n    [\"A\",  \"B\"],\n    [\"C\"],\n)\n\nworkspace.FeedBlob(\"A\", np.array([1, 5, 2, 9, 12, 3]))\nworkspace.FeedBlob(\"B\", np.array([1, 3, 4, 9, 12, 8]))\nprint(\"A:\", workspace.FetchBlob(\"A\"))\nprint(\"B:\", workspace.FetchBlob(\"B\"))\nworkspace.RunOperatorOnce(op)\nprint(\"C:\", workspace.FetchBlob(\"C\"))\n\n```\n\n**Result**\n\n```\n\nA: [ 1  5  2  9 12  3]\nB: [ 1  3  4  9 12  8]\nC: [ True  True False  True  True False]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 0,
        "description": "Pass 1 to enable broadcasting.",
        "name": "broadcast",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": -1,
        "description": "Axis to concatenate on. If set, defines the broadcast dimensions.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<bool>`)* First operand, should share the type with the second operand.",
        "name": "A"
      },
      {
        "description": "*(type: Tensor`<bool>`)* Second operand. With broadcasting can be of smaller size than `A`. If broadcasting is disabled it should be of the same size.",
        "name": "B"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<bool>`)* Output tensor with same dimensions as `A`.",
        "name": "C"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Gelu",
    "description": "\nRelu takes one input data (Tensor) and produces one output data\n(Tensor) where the rectified linear function, y = xP(X <= x) where X ~ N(0, 1),\nis applied to the tensor elementwise.\n",
    "attributes": [
      {
        "description": "If true, use y = 0.5x * (1 + tanh(sqrt(2/Pi) * (x + 0.044715x^3))).",
        "name": "fast_gelu",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "1D input tensor",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "1D input tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "GeluGradient",
    "support_level": "default"
  },
  {
    "name": "GenerateProposals",
    "description": "\nGenerate bounding box proposals for Faster RCNN. The propoasls are generated for\na list of images based on image score 'score', bounding box regression result\n'deltas' as well as predefined bounding box shapes 'anchors'. Greedy\nnon-maximum suppression is applied to generate the final bounding boxes.\n",
    "attributes": [
      {
        "description": "(float) spatial scale",
        "name": "spatial_scale",
        "option": "optional"
      },
      {
        "description": "(int) RPN_PRE_NMS_TOP_N",
        "name": "pre_nms_topN",
        "option": "optional"
      },
      {
        "description": "(int) RPN_POST_NMS_TOP_N",
        "name": "post_nms_topN",
        "option": "optional"
      },
      {
        "description": "(float) RPN_NMS_THRESH",
        "name": "nms_thresh",
        "option": "optional"
      },
      {
        "description": "(float) RPN_MIN_SIZE",
        "name": "min_size",
        "option": "optional"
      },
      {
        "description": "bool (default false), Correct bounding box transform coordates, see bbox_transform() in boxes.py Set to true to match the detectron code, set to false for backward compatibility",
        "name": "correct_transform_coords",
        "option": "optional"
      },
      {
        "description": "bool (default true). If set, for rotated boxes, angle is normalized to be within [angle_bound_lo, angle_bound_hi].",
        "name": "angle_bound_on",
        "option": "optional"
      },
      {
        "description": "int (default -90 degrees). If set, for rotated boxes, angle is normalized to be within [angle_bound_lo, angle_bound_hi].",
        "name": "angle_bound_lo",
        "option": "optional"
      },
      {
        "description": "int (default 90 degrees). If set, for rotated boxes, angle is normalized to be within [angle_bound_lo, angle_bound_hi].",
        "name": "angle_bound_hi",
        "option": "optional"
      },
      {
        "description": "float (default 1.0 degrees). For RRPN, clip almost horizontal boxes within this threshold of tolerance for backward compatibility. Set to negative value for no clipping.",
        "name": "clip_angle_thresh",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Scores from conv layer, size (img_count, A, H, W)",
        "name": "scores"
      },
      {
        "description": "Bounding box deltas from conv layer, size (img_count, 4 * A, H, W)",
        "name": "bbox_deltas"
      },
      {
        "description": "Image info, size (img_count, 3), format (height, width, scale)",
        "name": "im_info"
      },
      {
        "description": "Bounding box anchors, size (A, 4)",
        "name": "anchors"
      }
    ],
    "outputs": [
      {
        "description": "Proposals, size (n x 5), format (image_index, x1, y1, x2, y2)",
        "name": "rois"
      },
      {
        "description": "scores of proposals, size (n)",
        "name": "rois_probs"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "GenerateProposalsCPP",
    "support_level": "default"
  },
  {
    "name": "GetAllBlobNames",
    "description": "\nReturn a 1D tensor of strings containing the names\nof each blob in the active workspace.\n",
    "attributes": [
      {
        "description": "(bool, default true) Whether to include blobs inherited from parent workspaces.",
        "name": "include_shared",
        "option": "optional"
      }
    ],
    "outputs": [
      {
        "description": "1D tensor of strings containing blob names.",
        "name": "blob_names"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "GetCursorOffset",
    "description": "Get the current offset in the cursor.",
    "inputs": [
      {
        "description": "A blob containing a pointer to the cursor.",
        "name": "cursor"
      }
    ],
    "outputs": [
      {
        "description": "Tensor containing the offsets for the cursor.",
        "name": "offsets"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "GFtrl",
    "support_level": "default"
  },
  {
    "name": "GivenTensorBoolFill",
    "attributes": [
      {
        "description": "The value for the elements of the output tensor.",
        "name": "values"
      },
      {
        "description": "The shape of the output tensor.Cannot set the shape argument and pass in an input at the same time.",
        "name": "shape",
        "option": "optional"
      },
      {
        "description": "The additional dimensions appended at the end of the shape indicatedby the input blob.Cannot set the extra_shape argument when there is no input blob.",
        "name": "extra_shape",
        "option": "optional"
      },
      {
        "description": "1D tensor containing the desired output shape. First input must be in CPU context.",
        "name": "input_as_shape",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "GivenTensorByteStringToUInt8Fill",
    "description": "\nThis op fills a uint8 output tensor with the data specified by the *value* argument. The data must previously be serialized as a byte string. The output tensor shape is specified by the *shape* argument. Beware, when using this argument *value* should have a value for every element of the *output*, as missing values will not be initialized automatically. If *input_as_shape* is set to *true*, then the *input* should be a 1D tensor containing the desired output shape (the dimensions specified in *extra_shape* will also be appended). In this case, the *shape* argument should **not** be set.\n\nThis op allows us to write uint8 tensors to Protobuf as byte strings and read them back as uint8 tensors in order to avoid the Protobuf uint32_t varint encoding size penalty.\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nval = np.array([1, 2, 3], dtype=np.uint8)\nop = core.CreateOperator(\n    \"GivenTensorByteStringToUInt8Fill\",\n    [],\n    [\"out\"],\n    values=[val.tobytes()],\n    shape=val.shape,\n)\n\nworkspace.RunOperatorOnce(op)\nprint(\"Out:\\n\", workspace.FetchBlob(\"out\"))\n\n```\n\n**Result**\n\n```\n\nOut:\n [1 2 3]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "The value for the elements of the output tensor.",
        "name": "values"
      },
      {
        "description": "The shape of the output tensor.Cannot set the shape argument and pass in an input at the same time.",
        "name": "shape",
        "option": "optional"
      },
      {
        "description": "The additional dimensions appended at the end of the shape indicatedby the input blob.Cannot set the extra_shape argument when there is no input blob.",
        "name": "extra_shape",
        "option": "optional"
      },
      {
        "description": "1D tensor containing the desired output shape. First input must be in CPU context.",
        "name": "input_as_shape",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "GivenTensorDoubleFill",
    "attributes": [
      {
        "description": "The value for the elements of the output tensor.",
        "name": "values"
      },
      {
        "description": "The shape of the output tensor.Cannot set the shape argument and pass in an input at the same time.",
        "name": "shape",
        "option": "optional"
      },
      {
        "description": "The additional dimensions appended at the end of the shape indicatedby the input blob.Cannot set the extra_shape argument when there is no input blob.",
        "name": "extra_shape",
        "option": "optional"
      },
      {
        "description": "1D tensor containing the desired output shape. First input must be in CPU context.",
        "name": "input_as_shape",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "GivenTensorFill",
    "description": "\nThis op fills an output tensor with the data specified by the *value* and *dtype* arguments.  The output tensor shape is specified by the *shape* argument. Beware, when using this argument *value* should have a value for every element of the *output*, as missing values will not be initialized automatically. If *input_as_shape* is set to *true*, then the *input* should be a 1D tensor containing the desired output shape (the dimensions specified in *extra_shape* will also be appended). In this case, the *shape* argument should **not** be set.\n\n*Note: Do not set the shape argument and pass in an input at the same time.*\n\nGithub Links:\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/given_tensor_fill_op.h\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/given_tensor_fill_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"GivenTensorFill\",\n    [],\n    [\"out\"],\n    values=[1., 2., 3.],\n    shape=[3],\n)\n\nworkspace.RunOperatorOnce(op)\nprint(\"Out:\\n\", workspace.FetchBlob(\"out\"))\n\n```\n\n**Result**\n\n```\n\nOut:\n [1. 2. 3.]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "The value of the elements to go in the *output* tensor.",
        "name": "values"
      },
      {
        "description": "The data type for the elements of the output tensor. Strictly must be one of the types from DataType enum in TensorProto.",
        "name": "dtype",
        "option": "optional"
      },
      {
        "description": "Desired shape of the *output* tensor.",
        "name": "shape",
        "option": "optional",
        "type": "int64[]"
      },
      {
        "description": "The additional dimensions appended at the end of the *shape* indicated by the input blob. Cannot set the *extra_shape* argument when there is no input blob.",
        "name": "extra_shape",
        "option": "optional",
        "type": "int64[]"
      },
      {
        "default": false,
        "description": "set to *True* to use the *input* as shape. First, input must be in CPU context.",
        "name": "input_as_shape",
        "option": "optional",
        "type": "boolean"
      }
    ],
    "inputs": [
      {
        "description": "(Optional) 1D tensor specifying the shape of the output. Must be used with *input_as_shape=True*",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Output tensor with desired dimension filled with specified data. If the shape argument is set, this is the shape specified, and if the *input* exists and *input_as_shape=True*, it is the shape specified by the *input* tensor.",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "GivenTensorInt16Fill",
    "attributes": [
      {
        "description": "The value for the elements of the output tensor.",
        "name": "values"
      },
      {
        "description": "The shape of the output tensor.Cannot set the shape argument and pass in an input at the same time.",
        "name": "shape",
        "option": "optional"
      },
      {
        "description": "The additional dimensions appended at the end of the shape indicatedby the input blob.Cannot set the extra_shape argument when there is no input blob.",
        "name": "extra_shape",
        "option": "optional"
      },
      {
        "description": "1D tensor containing the desired output shape. First input must be in CPU context.",
        "name": "input_as_shape",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "GivenTensorInt64Fill",
    "attributes": [
      {
        "description": "The value for the elements of the output tensor.",
        "name": "values"
      },
      {
        "description": "The shape of the output tensor.Cannot set the shape argument and pass in an input at the same time.",
        "name": "shape",
        "option": "optional"
      },
      {
        "description": "The additional dimensions appended at the end of the shape indicatedby the input blob.Cannot set the extra_shape argument when there is no input blob.",
        "name": "extra_shape",
        "option": "optional"
      },
      {
        "description": "1D tensor containing the desired output shape. First input must be in CPU context.",
        "name": "input_as_shape",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "GivenTensorIntFill",
    "attributes": [
      {
        "description": "The value for the elements of the output tensor.",
        "name": "values"
      },
      {
        "description": "The shape of the output tensor.Cannot set the shape argument and pass in an input at the same time.",
        "name": "shape",
        "option": "optional"
      },
      {
        "description": "The additional dimensions appended at the end of the shape indicatedby the input blob.Cannot set the extra_shape argument when there is no input blob.",
        "name": "extra_shape",
        "option": "optional"
      },
      {
        "description": "1D tensor containing the desired output shape. First input must be in CPU context.",
        "name": "input_as_shape",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "GivenTensorStringFill",
    "attributes": [
      {
        "description": "The value for the elements of the output tensor.",
        "name": "values"
      },
      {
        "description": "The shape of the output tensor.Cannot set the shape argument and pass in an input at the same time.",
        "name": "shape",
        "option": "optional"
      },
      {
        "description": "The additional dimensions appended at the end of the shape indicatedby the input blob.Cannot set the extra_shape argument when there is no input blob.",
        "name": "extra_shape",
        "option": "optional"
      },
      {
        "description": "1D tensor containing the desired output shape. First input must be in CPU context.",
        "name": "input_as_shape",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Glu",
    "description": "\nApplies gated linear unit to the input Tensor X. The output Y is half the size\nof the input X, so if the shape of X is [d1, d2, ..., N] shape of Y will be\n[d1, d2, ..., dn/2] and Y(:dn-1, i) = GLU(X(:dn-1, i), X(:dn-1, i+N/2)) =\nX(dn-1, i) * sigmoid(X(dn-1, i+N/2))\n",
    "inputs": [
      {
        "description": "1D input tensor",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "1D output tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "GroupNorm",
    "description": "\nGroup Normalization (GN) operation: https://arxiv.org/abs/1803.08494\n",
    "attributes": [
      {
        "description": "(int) default 32; number of groups used by GN.",
        "name": "num_groups",
        "option": "optional"
      },
      {
        "description": "(float) default 1e-5; small constant added to var.",
        "name": "epsilon",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": ">=4D feature map input of shape (N, C, H, W) or (N, C, T, H, W)",
        "name": "X"
      },
      {
        "description": "The scale as a 1-dimensional tensor of size C to be applied to the output.",
        "name": "gamma"
      },
      {
        "description": "The bias as a 1-dimensional tensor of size C to be applied to the output.",
        "name": "beta"
      }
    ],
    "outputs": [
      {
        "description": "The output >=4-dimensional tensor of the same shape as X.",
        "name": "Y"
      },
      {
        "description": "The mean of shape (N, G). For backward usage or reference. Cannot be used as activations.",
        "name": "mean"
      },
      {
        "description": "The std of shape (N, G). For backward usage or reference. Cannot be used as activations.",
        "name": "std"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "GroupNormGradient",
    "support_level": "default"
  },
  {
    "name": "GRUUnit",
    "description": "\nGRUUnit computes the activations of a standard GRU,\nin a sequence-length aware fashion.\n\nConcretely, given the (fused) inputs X (TxNxD), the previous hidden\nstate (NxD), and the sequence lengths (N), computes the GRU\nactivations, avoiding computation if the input is invalid (as in, the\nvalue at X[t][n] >= seqLengths[n].\n\n",
    "attributes": [
      {
        "description": "Bool to determine if hidden state is zeroes or passed along for timesteps past the given sequence_length.",
        "name": "drop_states",
        "option": "optional"
      },
      {
        "description": "When false, the sequence lengths input is left out, and all following inputs are shifted left by one.",
        "name": "sequence_lengths",
        "option": "optional"
      }
    ],
    "outputs": [
      {
        "description": "The new GRU hidden state calculated by this op.",
        "name": "hidden"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "GRUUnitGradient",
    "attributes": [
      {
        "description": "When false, the sequence lengths input is left out, and all following inputs are shifted left by one.",
        "name": "sequence_lengths",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "GT",
    "description": "\nPerforms element-wise greater than comparison **>** (with limited broadcast support).\n\n\nIf necessary the right-hand-side argument will be broadcasted to match the\nshape of left-hand-side argument. When broadcasting is specified, the second\ntensor can either be of size 1 (a scalar value), or having its shape as a\ncontiguous subset of the first tensor's shape. The starting of the mutually\nequal shape is specified by the argument \"axis\", and if it is not set, suffix\nmatching is assumed. 1-dim expansion doesn't work yet.\n\nFor example, the following tensor shapes are supported (with broadcast=1):\n```\n  shape(A) = (2, 3, 4, 5), shape(B) = (,), i.e. B is a scalar\n  shape(A) = (2, 3, 4, 5), shape(B) = (5,)\n  shape(A) = (2, 3, 4, 5), shape(B) = (4, 5)\n  shape(A) = (2, 3, 4, 5), shape(B) = (3, 4), with axis=1\n  shape(A) = (2, 3, 4, 5), shape(B) = (2), with axis=0\n```\nArgument `broadcast=1` needs to be passed to enable broadcasting.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/elementwise_ops_schema.cc\n\n\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"GT\",\n    [\"A\",  \"B\"],\n    [\"C\"],\n)\n\nworkspace.FeedBlob(\"A\", np.array([1, 5, 2, 9, 12, 3]))\nworkspace.FeedBlob(\"B\", np.array([1, 3, 4, 9, 12, 8]))\nprint(\"A:\", workspace.FetchBlob(\"A\"))\nprint(\"B:\", workspace.FetchBlob(\"B\"))\nworkspace.RunOperatorOnce(op)\nprint(\"C:\", workspace.FetchBlob(\"C\"))\n\n```\n\n**Result**\n\n```\n\nA: [ 1  5  2  9 12  3]\nB: [ 1  3  4  9 12  8]\nC: [False  True False False False False]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 0,
        "description": "Pass 1 to enable broadcasting.",
        "name": "broadcast",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": -1,
        "description": "Axis to concatenate on. If set, defines the broadcast dimensions.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<bool>`)* First operand, should share the type with the second operand.",
        "name": "A"
      },
      {
        "description": "*(type: Tensor`<bool>`)* Second operand. With broadcasting can be of smaller size than `A`. If broadcasting is disabled it should be of the same size.",
        "name": "B"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<bool>`)* Output tensor with same dimensions as `A`.",
        "name": "C"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "HalfFloatToFused8BitRowwiseQuantized",
    "description": "\nApplies 8-bit row-wise quantization by determining the range\n(maximum - minimum) and offset (minimum value) of each row in the input\nmatrix, and then scaling each element to an 8-bit number between 0 and\n255. To later de-quantize values, the scale (range / 255) and offset\n(bias) are stored alongside the data. More precisely, each row contains\nint8 elements for each quantized element, and the last 8 bytes\nof each row in the output matrix are a float storing the scale\nfollowed by another float containing the scale.)\n",
    "inputs": [
      {
        "description": "Float16 input data",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Fused scale, bias and quantized data",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "HalfFloatToFused8BitRowwiseQuantizedHalfScaleBias",
    "description": "\nApplies 8-bit row-wise quantization by determining the range\n(maximum - minimum) and offset (minimum value) of each row in the input\nmatrix, and then scaling each element to an 8-bit number between 0 and\n255. To later de-quantize values, the scale (range / 255) and offset\n(bias) are stored alongside the data. More precisely, each row contains\nint8 elements for each quantized element, and the last 4 bytes\nof each row in the output matrix are a float storing the scale\nfollowed by another float containing the scale.)\n",
    "inputs": [
      {
        "description": "Float16 input data",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Fused scale, bias and quantized data",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "HalfToFloat",
    "support_level": "default"
  },
  {
    "name": "HalfToFused2BitFakeRowwiseQuantized",
    "description": "\nApplies 2-bit row-wise fake quantization to a tensor of half floats.\nThe output looks like an int8 rowwise quantized blob with\nscale and biases in half float.\n",
    "inputs": [
      {
        "description": "Float16 input data",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Fused scale, bias and quantized data",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "HalfToFused2BitRowwiseQuantized",
    "description": "\nApplies 2-bit row-wise quantization by determining the range\n(maximum - minimum) and offset (minimum value) of each row in the input\nmatrix, and then scaling each element to an 2-bit number between 0 and\n3. To later de-quantize values, the scale (range / 3) and zero_point\nare stored alongside the data. More precisely, each row first has quantized\nvalues, and then 2-byte fp16 scale and 2-byte zero_offset.)\n",
    "inputs": [
      {
        "description": "Float16 input data",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Fused scale, bias and quantized data",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "HalfToFused4BitFakeRowwiseQuantized",
    "description": "\nApplies 4-bit row-wise fake quantization to a tensor of half floats.\nThe output looks like an int8 rowwise quantized blob with\nscale and biases in half float.\n",
    "inputs": [
      {
        "description": "Float16 input data",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Fused scale, bias and quantized data",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "HalfToFused4BitRowwiseQuantized",
    "description": "\nApplies 4-bit row-wise quantization by determining the range\n(maximum - minimum) and offset (minimum value) of each row in the input\nmatrix, and then scaling each element to an 4-bit number between 0 and\n15. To later de-quantize values, the scale (range / 15) and zero_point\nare stored alongside the data. More precisely, each row first has quantized\nvalues, and then 2-byte fp16 scale and 2-byte zero_offset.)\n",
    "inputs": [
      {
        "description": "Float16 input data",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Fused scale, bias and quantized data",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "HardSigmoid",
    "description": "\nApplies hard sigmoid operation to the input data element-wise.\nThe HardSigmoid operation takes one input $X$, produces one output $Y$, and is defined as:\n\n$$Y = max(0,min(1,x * alpha + beta))$$\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/hard_sigmoid_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/hard_sigmoid_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"HardSigmoid\",\n    [\"X\"],\n    [\"Y\"],\n    alpha = 0.2,\n    beta = 0.5,\n)\n\nworkspace.FeedBlob(\"X\", np.random.randn(5).astype(np.float32))\nprint(\"input:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"sigmoid:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\ninput: [ 1.5744036   0.31632107  1.7842269   1.4450722  -2.1726978 ]\nhard_sigmoid: [ 0.81488073,  0.56326419,  0.85684538,  0.78901446,  0.06546044]\n\n```\n\n</details>\n\n\n",
    "attributes": [
      {
        "description": "float: the slope of the function. Defaults to 0.2",
        "name": "alpha",
        "option": "optional"
      },
      {
        "description": "float: the bias value of the function. Defaults to 0.5",
        "name": "beta",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "1D input tensor",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "1D output tensor with same shape as input",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "HardSigmoidGradient",
    "description": "\nHardSigmoidGradient takes both Y and dY as well as an argument alpha and uses\nthis to update dX according to the chain rule and derivatives of the hard\nsigmoid function.\n",
    "support_level": "default"
  },
  {
    "name": "HasElements",
    "description": "\nThe *HasElements* op accepts a single or multiple input tensors, and produces a single boolean output $has\\_elements$. The output is *True* if and only if any of the input tensor has size > 0. Note, this op is the opposite of the *IsEmpty* op.\n\nGithub Links:\n\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/utility_ops.cc\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/utility_ops.h\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"HasElements\",\n    [\"tensor\"],\n    [\"has_elements\"],\n)\n\n// Use a not-empty tensor\nworkspace.FeedBlob(\"tensor\", np.random.randn(2, 2).astype(np.float32))\nprint(\"tensor:\\n\", workspace.FetchBlob(\"tensor\"))\n\nworkspace.RunOperatorOnce(op)\nprint(\"has_elements: \", workspace.FetchBlob(\"has_elements\"),\"\\n\")\n\n// Use an empty tensor\nworkspace.FeedBlob(\"tensor\", np.empty(0))\nprint(\"tensor:\\n\", workspace.FetchBlob(\"tensor\"))\n\nworkspace.RunOperatorOnce(op)\nprint(\"has_elements: \", workspace.FetchBlob(\"has_elements\"))\n\n```\n\n**Result**\n\n```\n\ntensor:\n [[ 0.6116506  -0.54433197]\n [ 0.19406661 -0.7338629 ]]\nhas_elements:  True\n\ntensor:\n []\nhas_elements:  False\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "Input data tensor to check for elements.",
        "name": "tensor"
      },
      {
        "description": "List of input data tensors to check for elements.",
        "name": "X1, X2, ..."
      }
    ],
    "outputs": [
      {
        "description": "Output scalar boolean tensor. True if input has size > 0.",
        "name": "has_elements"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "HasScope",
    "description": "\nChecks whether scope blob has any saved scopes left\n    ",
    "support_level": "default"
  },
  {
    "name": "HeatmapMaxKeypoint",
    "support_level": "default"
  },
  {
    "name": "Histogram",
    "description": "\n            Computes a histogram for values in the given list of tensors.\n            For logging activation histograms for post-hoc analyses, consider using the\n            HistogramObserver observer.\n            For iteratively computing a histogram for all input tensors encountered through\n            history, consider using the AccumulateHistogram operator.\n            ",
    "attributes": [
      {
        "description": "length-(k + 1) sequence of float values wherein the i-th element represents the inclusive left boundary of the i-th bin for i in [0, k - 1] and the exclusive right boundary of the (i-1)-th bin for i in [1, k].",
        "name": "bin_edges",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* List of input tensors.",
        "name": "X1, X2, ..."
      }
    ],
    "outputs": [
      {
        "description": "1D tensor of length k, wherein the i-th element expresses the count of tensor values that fall within range [bin_edges[i], bin_edges[i + 1])",
        "name": "histogram"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "HSoftmax",
    "description": "\nHierarchical softmax is an operator which approximates the softmax operator\nwhile giving significant training speed gains and reasonably comparable\nperformance. In this operator, instead of calculating the probabilities of all\nthe classes, we calculate the probability of each step in the path from root to\nthe target word in the hierarchy.\n\nThe operator takes a 2-D tensor (Tensor) containing a batch of layers, a\nset of parameters represented by the weight matrix and bias terms, and a 1-D\ntensor (Tensor) holding labels, or the indices of the target class. The\nhierarchy has to be specified as an argument to the operator.\n\nThe operator returns a 1-D tensor holding the computed log probability of the\ntarget class and a 2-D tensor of intermediate outputs (from the weight matrix\nand softmax from each step in the path from root to target class) which will be\nused by the gradient operator to compute gradients for all samples in the batch.\n",
    "attributes": [
      {
        "description": "Serialized HierarchyProto string containing list of vocabulary words and their paths from root of hierarchy to the leaf",
        "name": "hierarchy",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input data from previous layer",
        "name": "X"
      },
      {
        "description": "2D blob containing 'stacked' fully connected weight matrices. Each node in the hierarchy contributes one FC weight matrix if it has children nodes. Dimension is N*D, D is input dimension of data (X), N is sum of all output dimensions, or total number of nodes (excl root)",
        "name": "W"
      },
      {
        "description": "1D blob with N parameters",
        "name": "b"
      },
      {
        "description": "int word_id of the target word",
        "name": "labels"
      }
    ],
    "outputs": [
      {
        "description": "1-D of log probability outputs, one per sample",
        "name": "Y"
      },
      {
        "description": "Extra blob to store the intermediate FC and softmax outputs for each node in the hierarchical path of a word. The outputs from samples are stored in consecutive blocks in the forward pass and are used in reverse order in the backward gradientOp pass",
        "name": "intermediate_output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "HSoftmaxGradient",
    "support_level": "default"
  },
  {
    "name": "HSoftmaxSearch",
    "description": "\nHSoftmaxSearch is an operator to generate the most possible paths given a\nwell-trained model and input vector. Greedy algorithm is used for pruning the\nsearch tree.\n",
    "attributes": [
      {
        "description": "Serialized TreeProto string containing a tree including all intermidate nodes and leafs. All nodes must have names for correct outputs",
        "name": "tree",
        "option": "optional"
      },
      {
        "description": "beam used for pruning tree. The pruning algorithm is that only children, whose score is smaller than parent's score puls beam, will be propagated.",
        "name": "beam",
        "option": "optional"
      },
      {
        "description": "Number of nodes in outputs",
        "name": "topN",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input data from previous layer",
        "name": "X"
      },
      {
        "description": "The matrix trained from Softmax Ops",
        "name": "W"
      },
      {
        "description": "The bias trained from Softmax Ops",
        "name": "b"
      }
    ],
    "outputs": [
      {
        "description": "The name of selected nodes and leafs. For nodes, it will be the name defined in the tree. For leafs, it will be the index of the word in the tree.",
        "name": "Y_names"
      },
      {
        "description": "The corresponding scores of Y_names",
        "name": "Y_scores"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "HuffmanTreeHierarchy",
    "description": "\nHuffmanTreeHierarchy is an operator to generate huffman tree hierarchy given\nthe input labels. It returns the tree as serialized HierarchyProto\n",
    "attributes": [
      {
        "description": "The number of classes used to build the hierarchy.",
        "name": "num_classes",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "The labels vector",
        "name": "Labels"
      }
    ],
    "outputs": [
      {
        "description": "Huffman coding hierarchy of the labels",
        "name": "Hierarch"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "If",
    "description": "\n'If' control operator, first input is a scalar boolean blob that stores condition\nvalue. Accepts 'then_net' (required) and 'else_net' (optional) arguments for 'then' and\n'else' subnets respectively. Subnets are executed in the same workspace as 'If'.\n    ",
    "attributes": [
      {
        "description": "Net executed when condition is true",
        "name": "then_net",
        "option": "optional"
      },
      {
        "description": "Net executed when condition is false (optional)",
        "name": "else_net",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Scalar boolean condition",
        "name": "condition"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Im2Col",
    "description": "The Im2Col operator from Matlab.",
    "inputs": [
      {
        "description": "4-tensor in NCHW or NHWC.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "4-tensor. For NCHW: N x (C x kH x kW) x outH x outW.For NHWC: N x outH x outW x (kH x kW x C",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "IncrementPut",
    "description": "\n    Consume a value and pushes it to the global stat registry as an sum.\n\n    Github Links:\n    - https://github.com/pytorch/pytorch/blob/master/caffe2/operators/stats_put_ops.cc\n\n        ",
    "attributes": [
      {
        "description": "(*str*): name of the stat. If not present, then uses name of input blob",
        "name": "name",
        "option": "optional"
      },
      {
        "description": "(*int64_t*): number to multiply input values by (used when inputting floats, as stats can only receive integers",
        "name": "magnitude_expand",
        "option": "optional"
      },
      {
        "description": "(*boolean*): whether or not to clamp inputs to the max inputs allowed",
        "name": "bound",
        "option": "optional"
      },
      {
        "description": "(*float*): Optionally provide a default value for receiving empty tensors",
        "name": "default_value",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "(*Tensor`<number>`*): A scalar tensor, representing any numeric value",
        "name": "value"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "IndexFreeze",
    "description": "\nFreezes the given index, disallowing creation of new index entries.\nShould not be called concurrently with IndexGet.\n",
    "inputs": [
      {
        "description": "Pointer to an Index instance.",
        "name": "handle"
      }
    ],
    "outputs": [
      {
        "description": "The input handle.",
        "name": "handle"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "IndexGet",
    "description": "\nGiven an index handle and a tensor of keys, return an Int tensor of same shape\ncontaining the indices for each of the keys. If the index is frozen, unknown\nentries are given index 0. Otherwise, new entries are added into the index.\nIf an insert is necessary but max_elements has been reached, fail.\n",
    "inputs": [
      {
        "description": "Pointer to an Index instance.",
        "name": "handle"
      },
      {
        "description": "Tensor of keys to be looked up.",
        "name": "keys"
      }
    ],
    "outputs": [
      {
        "description": "Indices for each of the keys.",
        "name": "indices"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "IndexHash",
    "description": "\nThis operator translates a list of indices into a list of hashed indices.\nA seed can be fed as an argument to change the behavior of the hash function.\nIf a modulo is specified, all the hashed indices will be modulo the\nspecified number. All input and output indices are enforced to be positive.\n",
    "attributes": [
      {
        "description": "seed for the hash function",
        "name": "seed",
        "option": "optional"
      },
      {
        "description": "must be > 0, hashed ids will be modulo this number",
        "name": "modulo",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input feature indices.",
        "name": "Indices"
      }
    ],
    "outputs": [
      {
        "description": "Hashed feature indices.",
        "name": "HashedIndices"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "IndexLoad",
    "description": "\nLoads the index from the given 1-D tensor. Elements in the tensor will be given\nconsecutive indexes starting at 1. Fails if tensor contains repeated elements.\n",
    "attributes": [
      {
        "description": "If set, skips the first entry of the tensor. This allows to load tensors that are aligned with an embedding, where the first entry corresponds to the default 0 index entry.",
        "name": "skip_first_entry",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Pointer to an Index instance.",
        "name": "handle"
      },
      {
        "description": "1-D tensor with elements starting with index 1.",
        "name": "items"
      }
    ],
    "outputs": [
      {
        "description": "The input handle.",
        "name": "handle"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "IndexSize",
    "description": "\nReturns the number of entries currently present in the index.\n",
    "inputs": [
      {
        "description": "Pointer to an Index instance.",
        "name": "handle"
      }
    ],
    "outputs": [
      {
        "description": "Scalar int64 tensor with number of entries.",
        "name": "items"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "IndexStore",
    "description": "\nStores the keys of this index in a 1-D tensor. Since element 0 is reserved\nfor unknowns, the first element of the output tensor will be element of index 1.\n",
    "inputs": [
      {
        "description": "Pointer to an Index instance.",
        "name": "handle"
      }
    ],
    "outputs": [
      {
        "description": "1-D tensor with elements starting with index 1.",
        "name": "items"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "InferenceLSTM",
    "attributes": [
      {
        "description": "(*long*): number of layers in the lstm stack",
        "name": "num_layers",
        "option": "optional"
      },
      {
        "description": "(*bool*): whether the cells have biases or not",
        "name": "has_biases",
        "option": "optional"
      },
      {
        "description": "(*bool*): whether the batch is at dim 0",
        "name": "batch_first",
        "option": "optional"
      },
      {
        "description": "(*bool*): if bidirectional",
        "name": "bidirectional",
        "option": "optional"
      }
    ],
    "outputs": [
      {
        "description": "the output of the last layer of lstm",
        "name": "output"
      },
      {
        "description": "hidden state at t = seq_len",
        "name": "hidden"
      },
      {
        "description": "cell state at t = seq_len",
        "name": "cell"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "InstanceNorm",
    "description": "\nThe *InstanceNorm* op applies Instance Normalization over a 4D input as described in [Instance Normalization: The Missing Ingredient for Fast Stylization](https://arxiv.org/abs/1607.08022).\n\n$$output = \\frac{input-\\mu_{input}}{\\sqrt{\\sigma_{input}^2} + \\epsilon}*scale + bias$$\n\nNotice, two of the outputs are optional so there are three output cases for this op. Case 1: output; Case 2: output, saved_mean; Case 3: output, saved_mean, saved_inv_stdev.\n\nGithub Links:\n\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/instance_norm_op.h\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/instance_norm_op.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"InstanceNorm\",\n    [\"input\", \"scale\", \"bias\"],\n    [\"output\"],\n    epsilon=1e-5,\n)\n\nworkspace.FeedBlob(\"input\", np.random.randn(2, 1, 3, 3).astype(np.float32))\nprint(\"input:\\n\", workspace.FetchBlob(\"input\"), \"\\n\")\n\nworkspace.FeedBlob(\"scale\", np.array([1.5]).astype(np.float32))\nprint(\"scale: \", workspace.FetchBlob(\"scale\"))\n\nworkspace.FeedBlob(\"bias\", np.array([1.]).astype(np.float32))\nprint(\"bias: \", workspace.FetchBlob(\"bias\"))\n\nworkspace.RunOperatorOnce(op)\nprint(\"output:\\n\", workspace.FetchBlob(\"output\"))\n\n```\n\n**Result**\n\n```\n\ninput:\n [[[[ 0.97856593 -1.1832817  -0.2540021 ]\n   [-1.3315694  -0.7485018   0.3787225 ]\n   [-0.6826597  -1.4637762   0.57116514]]]\n\n\n [[[-0.44948956  0.85544354 -0.9315333 ]\n   [-0.37202677 -0.22266895 -0.27194235]\n   [ 0.4948163  -0.7296504   1.3393803 ]]]]\n\nscale:  [1.5]\nbias:  [1.]\noutput:\n [[[[ 3.5017493  -0.3791256   1.2890853 ]\n   [-0.6453266   0.40137637  2.4249308 ]\n   [ 0.5195738  -0.8826599   2.7703972 ]]]\n\n\n [[[ 0.12639964  2.856744   -0.8821926 ]\n   [ 0.28847694  0.60098207  0.49788612]\n   [ 2.1021945  -0.45978796  3.869297  ]]]]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 1e-05,
        "description": "The epsilon value to use to avoid division by zero.",
        "name": "epsilon",
        "option": "optional",
        "type": "float32"
      },
      {
        "default": "NCHW",
        "description": "Specifies the order of the input data blob, where $N$ is batch size, $C$ is number of channels, $H$ is spatial height, and $W$ is spatial width. The only other valid option is \"NHWC\".",
        "name": "order",
        "option": "optional",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "description": "The input 4-dimensional NCHW tensor to be operated on.",
        "name": "input"
      },
      {
        "description": "The input 1-dimensional scale tensor of size *C*.",
        "name": "scale"
      },
      {
        "description": "The input 1-dimensional bias tensor of size *C*.",
        "name": "bias"
      }
    ],
    "outputs": [
      {
        "description": "The output 4-dimensional tensor of the same shape as input.",
        "name": "output"
      },
      {
        "description": "(Optional) Saved mean used during training to speed up gradient computation. Should not be used for testing.",
        "name": "saved_mean"
      },
      {
        "description": "(Optional) Saved inverse stdev used during training to speed up gradient computation. Should not be used for testing.",
        "name": "saved_inv_stdev"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "InstanceNormGradient",
    "support_level": "default"
  },
  {
    "name": "Int8Add",
    "description": "\n    Performs element-wise binary Add (with no broadcast support).\n",
    "attributes": [
      {
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "First operand, should share the type with the second operand.",
        "name": "A"
      },
      {
        "description": "Second operand. It should be of the same size as A.",
        "name": "B"
      }
    ],
    "outputs": [
      {
        "description": "Result, has same dimensions and type as A",
        "name": "C"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8AddRelu",
    "description": "\n    Performs element-wise binary Add (with no broadcast support). \"\n    \"Output will go through rectified linear \"\n    \"function, where y = max(0, x).\n",
    "attributes": [
      {
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "First operand, should share the type with the second operand.",
        "name": "A"
      },
      {
        "description": "Second operand. It should be of the same size as A.",
        "name": "B"
      }
    ],
    "outputs": [
      {
        "description": "Result, has same dimensions and type as A",
        "name": "C"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8AveragePool",
    "category": "Pool",
    "description": "AveragePool \nconsumes an input blob X and applies average pooling across the\nthe blob according to kernel sizes, stride sizes, and pad lengths defined by the\nConvPoolOpBase operator. Average pooling consisting of averaging all values of a\nsubset of the input tensor according to the kernel size and downsampling the\ndata into the output blob Y for further processing.\n",
    "attributes": [
      {
        "default": 0,
        "name": "order"
      },
      {
        "default": 0,
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "default": 0,
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input data tensor from the previous operator; dimensions depend on whether the NCHW or NHWC operators are being used. For example, in the former, the input has size (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data. The corresponding permutation of dimensions is used in the latter case.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "Output data tensor from average pooling across the input tensor. Dimensions will vary based on various kernel, stride, and pad sizes.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8AveragePoolRelu",
    "description": "AveragePool \nconsumes an input blob X and applies average pooling across the\nthe blob according to kernel sizes, stride sizes, and pad lengths defined by the\nConvPoolOpBase operator. Average pooling consisting of averaging all values of a\nsubset of the input tensor according to the kernel size and downsampling the\ndata into the output blob Y for further processing.\n",
    "attributes": [
      {
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input data tensor from the previous operator; dimensions depend on whether the NCHW or NHWC operators are being used. For example, in the former, the input has size (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data. The corresponding permutation of dimensions is used in the latter case.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "Output data tensor from average pooling across the input tensor. Dimensions will vary based on various kernel, stride, and pad sizes. Output will go through rectified linear function, where y = max(0, x).",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8ChannelShuffle",
    "attributes": [
      {
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8Concat",
    "description": "Concatenate a list of tensors into a single tensor",
    "attributes": [
      {
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      },
      {
        "description": "Which axis to concat on",
        "name": "axis",
        "option": "optional"
      },
      {
        "description": "Pass 1 to add the axis specified in arg 'axis' to all input tensors",
        "name": "add_axis",
        "option": "optional"
      }
    ],
    "outputs": [
      {
        "description": "Concatenated tensor",
        "name": "concat_result"
      },
      {
        "description": "The dimensions of the inputs.",
        "name": "split_info"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8Conv",
    "category": "Layer",
    "description": "\nThe convolution operator consumes an input vector, a filter blob\nand a bias blob and computes the output. \n[Only NHWC order is supported now]Note that other parameters, such as the stride and\nkernel size, or the pads' sizes in each direction are not necessary for input\nbecause they are provided by the ConvPoolOpBase operator. Various dimension\nchecks are done implicitly, and the sizes are specified in the Input docs for\nthis operator. As is expected, the filter is convolved with a subset of the\nimage and the bias is added; this is done throughout the image data and the\noutput is computed. As a side note on the implementation layout:\nconv_op_impl.h is the templated implementation of the conv_op.h file, which is\nwhy they are separate files.\n",
    "attributes": [
      {
        "default": 0,
        "name": "order"
      },
      {
        "default": 0,
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "default": 0,
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      },
      {
        "default": 0,
        "name": "pad"
      },
      {
        "default": 1,
        "name": "stride"
      }
    ],
    "inputs": [
      {
        "description": "Input data blob from previous layer; has size (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and width. Note that this is for the NCHW usage. On the other hand, the NHWC Op has a different set of dimension constraints. ",
        "name": "X"
      },
      {
        "description": "The filter blob that will be used in the convolutions; has size (M x C x kH x kW), where C is the number of channels, and kH and kW are the height and width of the kernel.",
        "name": "filter"
      },
      {
        "description": "The 1D bias blob that is added through the convolution; has size (M).",
        "name": "bias"
      }
    ],
    "outputs": [
      {
        "description": "Output data blob that contains the result of the convolution. The output dimensions are functions of the kernel size, stride size, and pad lengths.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8ConvRelu",
    "description": "\nThe convolution operator consumes an input vector, a filter blob\nand a bias blob and computes the output. \n[Only NHWC order is supported now]Note that other parameters, such as the stride and\nkernel size, or the pads' sizes in each direction are not necessary for input\nbecause they are provided by the ConvPoolOpBase operator. Various dimension\nchecks are done implicitly, and the sizes are specified in the Input docs for\nthis operator. As is expected, the filter is convolved with a subset of the\nimage and the bias is added; this is done throughout the image data and the\noutput is computed. As a side note on the implementation layout:\nconv_op_impl.h is the templated implementation of the conv_op.h file, which is\nwhy they are separate files.\n",
    "attributes": [
      {
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input data blob from previous layer; has size (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and width. Note that this is for the NCHW usage. On the other hand, the NHWC Op has a different set of dimension constraints. ",
        "name": "X"
      },
      {
        "description": "The filter blob that will be used in the convolutions; has size (M x C x kH x kW), where C is the number of channels, and kH and kW are the height and width of the kernel.",
        "name": "filter"
      },
      {
        "description": "The 1D bias blob that is added through the convolution; has size (M).",
        "name": "bias"
      }
    ],
    "outputs": [
      {
        "description": "Output data blob that contains the result of the convolution. The output dimensions are functions of the kernel size, stride size, and pad lengths. Output will go through rectified linear function, where y = max(0, x).",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8ConvTranspose",
    "description": "\nThe transposed convolution consumes an input vector, the filter blob, and\nthe bias blob, and computes the output. Note that other parameters, such as\nthe stride and kernel size, or the pads' sizes in each direction are not\nnecessary for input because they are provided by the\nConvTransposeUnpoolOpBase operator. Various dimension checks are done\nimplicitly, and the sizes are specified in the Input docs for this operator.\nAs is expected, the filter is deconvolved with a subset of the\nimage and the bias is added; this is done throughout the image data and the\noutput is computed. As a side note on the implementation layout:\nconv_transpose_op_impl.h is the templated implementation of the\nconv_transpose_op.h file, which is why they are separate files.\n  ",
    "attributes": [
      {
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input data blob from previous layer; has size (N x H x W x C), where N is the batch size, C is the number of channels, and H and W are the height and width. Note that NHWC is supported now",
        "name": "X"
      },
      {
        "description": "The filter blob that will be used in the transposed convolution; has size (M x kH x kW x C), where C is the number of channels, and kH and kW are the height and width of the kernel.",
        "name": "filter"
      },
      {
        "description": "The 1D bias blob that is added through the convolution;has size (C). Optional, if not passed, will treat it as all 0.",
        "name": "bias"
      }
    ],
    "outputs": [
      {
        "description": "Output data blob that contains the result of the transposed convolution. The output dimensions are functions of the kernel size, stride size, and pad lengths.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8Dequantize",
    "inputs": [
      {
        "description": "Int8 Tensor qX.",
        "name": "qX"
      }
    ],
    "outputs": [
      {
        "description": "FP32 Tensor that represents mapped real value of qX.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8FC",
    "category": "Layer",
    "description": "\nComputes the result of passing an input vector X into a fully\nconnected layer with 2D weight matrix W and 1D bias vector b. That is,\nthe layer computes Y = X * W^T + b, where X has size (M x K),\nW has size (N x K), b has size (N), and Y has size (M x N),\nwhere M is often the batch size.\n\n\nNOTE: X does not need to explicitly be a 2D vector; rather, it will be\ncoerced into one. For an arbitrary n-dimensional tensor\nX \\in [a_0, a_1 * ... * a_{n-1}]. Only this case is supported!\nLastly, even though b is a 1D vector of size N, it is copied/resized to\nbe size (M x N) implicitly and added to each vector in the batch.\nEach of these dimensions must be matched correctly, or else the operator\nwill throw errors.\n",
    "attributes": [
      {
        "default": 0,
        "name": "order"
      },
      {
        "default": 0,
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "default": 0,
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "input tensor that's coerced into a 2D matrix of size (MxK) as described above",
        "name": "X"
      },
      {
        "description": "A tensor that is coerced into a 2D blob of size (KxN) containing fully connected weight matrix",
        "name": "W"
      },
      {
        "description": "1D blob containing bias vector",
        "name": "b"
      },
      {
        "description": "Optional scale quantization param computed on activation histogram dataWill overwrite Y_scale argument if specified",
        "name": "Scale qparam"
      },
      {
        "description": "Optionsl zero-point quantization param computed on activation dataWill overwrite Y_zero_point argument if specified",
        "name": "Zero-point qparam"
      },
      {
        "description": "Optional Qparam blob that contains quant param computed on activation histogram dataWill overwrite Y_scale and Y_zero_point argument if specified",
        "name": "Qparam"
      }
    ],
    "outputs": [
      {
        "description": "2D output tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8FCPackWeight",
    "description": "Prepack weight for Int8FC",
    "attributes": [
      {
        "description": "See FC operator",
        "name": "axis_w",
        "option": "optional"
      },
      {
        "description": "Default false. Per output channel quantization",
        "name": "quantize_channelwise",
        "option": "optional"
      },
      {
        "description": "Default false. Store unpacked quantized weights to W_q.original_tensor",
        "name": "save_unpacked_weights",
        "option": "optional"
      },
      {
        "description": "The scale of input activation tensor. Only meaningful when bias is provided (NOTE: this is not the scale of weight",
        "name": "in_scale",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Weight tensor in KRSC layout",
        "name": "W"
      },
      {
        "description": "Bias tensor",
        "name": "b"
      }
    ],
    "outputs": [
      {
        "description": "Weight/bias tensor in a packed format with type Int8FCDNNLowPPackedWeightBlob",
        "name": "W_q"
      },
      {
        "description": "Bias int32 quantized tensor",
        "name": "B_q"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8Flatten",
    "description": "\nFlattens the input tensor into a 2D matrix. If input tensor has shape\n(d_0, d_1, ... d_n) then the output will have shape\n(d_0 X d_1 ... d_(axis-1), d_axis X d_(axis+1) ... X dn)\n",
    "attributes": [
      {
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      },
      {
        "description": "(Default to 1) Indicate up to which input dimensions (exclusive) should be flattened to the outer dimension of the output",
        "name": "axis",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "A Int8 tensor of rank >= axis.",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "A 2D Int8 tensor with the contents of the input tensor, with input dimensions up to axis flattened to the outer dimension of the output and remaining input dimensions flattened into the inner dimension of the output.",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8GenQuantParams",
    "description": "Operator wrapper for generating int8 tensor quantization parameters given the input data and quant scheme",
    "inputs": [
      {
        "description": "The input data, or last N samples of the output activations.",
        "name": "X"
      },
      {
        "description": "Int8QuantSchemeBlob that specifies the quantization kind and preserve_sparsity options when generating the quant params.",
        "name": "quant_scheme"
      }
    ],
    "outputs": [
      {
        "description": "Int8QuantParamsBlob that contains the scale and zero_point info in TensorQuantizationParams type.",
        "name": "quant_param"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8GivenIntTensorFill",
    "description": "\n    Creates quantized tensor of type int32 with scale and zero point info.\n",
    "attributes": [
      {
        "description": "Input array of type int32",
        "name": "values",
        "option": "optional"
      },
      {
        "description": "Input tensor shape",
        "name": "shape",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      }
    ],
    "outputs": [
      {
        "description": "An Int8TensorCPU with scale and zero point info",
        "name": "Tensor"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8GivenTensorFill",
    "description": "\n    Creates quantized tensor of type char(byte) with scale and zero point info.\n",
    "attributes": [
      {
        "description": "Input array of type char(byte)",
        "name": "values",
        "option": "optional"
      },
      {
        "description": "Input tensor shape",
        "name": "shape",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      }
    ],
    "outputs": [
      {
        "description": "An Int8TensorCPU with scale and zero point info",
        "name": "Tensor"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8LeakyRelu",
    "description": "\nLeakyRelu takes input data (Tensor<T>) and an argument alpha, and produces one\noutput data (Tensor<T>) where the function `f(x) = alpha * x for x < 0`,\n`f(x) = x for x >= 0`, is applied to the data tensor elementwise.\n",
    "attributes": [
      {
        "description": "Coefficient of leakage, default value is 0.01",
        "name": "alpha",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "1D input tensor",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "1D input tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8MaxPool",
    "description": "MaxPool \nconsumes an input blob X and applies max pooling across the\nthe blob according to kernel sizes, stride sizes, and pad lengths defined by the\nConvPoolOpBase operator. Max pooling consisting of taking the maximum value of a\nsubset of the input tensor according to the kernel size and downsampling the\ndata into the output blob Y for further processing.\n",
    "attributes": [
      {
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input data tensor from the previous operator; dimensions depend on whether the NCHW or NHWC operators are being used. For example, in the former, the input has size (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data. The corresponding permutation of dimensions is used in the latter case.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "Output data tensor from max pooling across the input tensor. Dimensions will vary based on various kernel, stride, and pad sizes. Output will go through rectified linear",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8MaxPoolRelu",
    "description": "MaxPool \nconsumes an input blob X and applies max pooling across the\nthe blob according to kernel sizes, stride sizes, and pad lengths defined by the\nConvPoolOpBase operator. Max pooling consisting of taking the maximum value of a\nsubset of the input tensor according to the kernel size and downsampling the\ndata into the output blob Y for further processing.\n",
    "attributes": [
      {
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input data tensor from the previous operator; dimensions depend on whether the NCHW or NHWC operators are being used. For example, in the former, the input has size (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data. The corresponding permutation of dimensions is used in the latter case.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "Output data tensor from max pooling across the input tensor. Dimensions will vary based on various kernel, stride, and pad sizes. Output will go through rectified linearfunction, where y = max(0, x).",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8Quantize",
    "attributes": [
      {
        "default": 0,
        "name": "order"
      },
      {
        "default": 0,
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "default": 0,
        "description": "Output tensor quantization offset"
      },
      {
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "FP32 Tensor X.",
        "name": "X"
      },
      {
        "description": "Optional scale quantization param computed on activation histogram dataWill overwrite Y_scale argument if specified",
        "name": "Scale qparam"
      },
      {
        "description": "Optionsl zero-point quantization param computed on activation dataWill overwrite Y_zero_point argument if specified",
        "name": "Zero-point qparam"
      },
      {
        "description": "Optional Qparam blob that contains quant param computed on activation histogram dataWill overwrite Y_scale and Y_zero_point argument if specified",
        "name": "Qparam"
      }
    ],
    "outputs": [
      {
        "description": "Int8 Tensor qX representing X with linear quantization.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8Relu",
    "category": "Activation",
    "description": "\nRelu takes one input data (Tensor<T>) and produces one output data\n(Tensor<T>) where the rectified linear function, y = max(0, x), is applied to\nthe tensor elementwise.\n",
    "attributes": [
      {
        "default": 0,
        "name": "order"
      },
      {
        "default": 0,
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "default": 0,
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "1D input tensor",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "1D input tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8Reshape",
    "description": "\nReshape the input tensor similar to numpy.reshape.\n\nIt takes a tensor as input and an optional tensor specifying the new shape.\nWhen the second input is absent, an extra argument `shape` must be specified.\nIt outputs the reshaped tensor as well as the original shape.\n\nAt most one dimension of the new shape can be -1. In this case, the value is\ninferred from the size of the tensor and the remaining dimensions. A dimension\ncould also be 0, in which case the actual dimension value is going to be copied\nfrom the input tensor.\n",
    "attributes": [
      {
        "description": "New shape",
        "name": "shape",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "An input tensor.",
        "name": "data"
      },
      {
        "description": "New shape.",
        "name": "new_shape"
      }
    ],
    "outputs": [
      {
        "description": "Reshaped data.",
        "name": "reshaped"
      },
      {
        "description": "Original shape.",
        "name": "old_shape"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8ResizeNearest",
    "description": "\nResizes the spatial dimensions of the input using nearest neighbor\ninterpolation. The `width_scale` and `height_scale` arguments\ncontrol the size of the output, which is given by:\noutput_width = floor(input_width * width_scale)\noutput_height = floor(output_height * height_scale)\n",
    "attributes": [
      {
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      },
      {
        "description": "Scale along width dimension",
        "name": "width_scale",
        "option": "optional"
      },
      {
        "description": "Scale along height dimension",
        "name": "height_scale",
        "option": "optional"
      },
      {
        "description": "Output dimensions (HxW). If specified this takes precedence over scale values.",
        "name": "output_size",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input Int8 tensor",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "Output Int8 tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8RoIAlign",
    "description": "\nRegion of Interest (RoI) align operation as used in Mask R-CNN.\n",
    "attributes": [
      {
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      },
      {
        "description": "(float) default 1.0; Spatial scale of the input feature map X relative to the input image. E.g., 0.0625 if X has a stride of 16 w.r.t. the input image.",
        "name": "spatial_scale",
        "option": "optional"
      },
      {
        "description": "(int) default 1; Pooled output Y's height.",
        "name": "pooled_h",
        "option": "optional"
      },
      {
        "description": "(int) default 1; Pooled output Y's width.",
        "name": "pooled_w",
        "option": "optional"
      },
      {
        "description": "(int) default -1; number of sampling points in the interpolation grid used to compute the output value of each pooled output bin. If > 0, then exactly sampling_ratio x sampling_ratio grid points are used. If <= 0, then an adaptive number of grid points are used (computed as ceil(roi_width / pooled_w), and likewise for height).",
        "name": "sampling_ratio",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "4D Int8 Tensor feature map input of shape (N, C, H, W).",
        "name": "X"
      },
      {
        "description": "2D input of shape (R, 4 or 5) specifying R RoIs representing: batch index in [0, N - 1], x1, y1, x2, y2. The RoI coordinates are in the coordinate system of the input image. For inputs corresponding to a single image, batch index can be excluded to have just 4 columns.",
        "name": "RoIs"
      }
    ],
    "outputs": [
      {
        "description": "4D Int8 Tensor output of shape (R, C, pooled_h, pooled_w). The r-th batch element is a pooled feature map cooresponding to the r-th RoI.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8Sigmoid",
    "description": "\nApply the Sigmoid function element-wise to the input tensor. This is often used\nas a non-linear activation function in a neural network. The sigmoid function is\ndefined as:\n\n$$Sigmoid(x) = \\frac{1}{1+\\exp(-x)}$$\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/sigmoid_op.cc\n",
    "attributes": [
      {
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "The input tensor that's coerced into a 2D matrix of size (NxD) as described above.",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "The sigmoid normalized output values with the same shape as input tensor.",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8Slice",
    "description": "\nProduces a slice of the input Int8 tensor. Currently, only slicing in a single\ndimension is supported.\nSlices are passed as 2 1D vectors or as two keyword argument lists with starting\nand end indices for each dimension of the input `data` tensor. If a negative\nvalue is passed for any of the start or end indices, it represents the number of\nelements before the end of that dimension. End indices are non-inclusive unless\nnegative (end index -1 means up to and including the last element).\n\n\nExample:\n\n  data = [\n      [1, 2, 3, 4],\n      [5, 6, 7, 8],\n  ]\n  starts = [0, 1]\n  ends = [-1, 3]\n\n  result = [\n      [2, 3],\n      [6, 7],\n  ]\n",
    "attributes": [
      {
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      },
      {
        "description": "List of starting indices",
        "name": "starts",
        "option": "optional"
      },
      {
        "description": "List of ending indices",
        "name": "ends",
        "option": "optional"
      },
      {
        "description": "(Optional) The dimension to slice over. If specified start_idx and end_idx should also be given and it takes precedence over starts and ends",
        "name": "dim",
        "option": "optional"
      },
      {
        "description": "(Optional) The dimension to start slice from. Default is 0",
        "name": "start_idx",
        "option": "optional"
      },
      {
        "description": "(Optional) The dimension to end the slice. Default is -1",
        "name": "end_idx",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Int8 Tensor of data to extract slices from.",
        "name": "data"
      },
      {
        "description": "1D tensor: start-indices for each dimension of data.",
        "name": "starts"
      },
      {
        "description": "1D tensor: end-indices for each dimension of data.",
        "name": "ends"
      }
    ],
    "outputs": [
      {
        "description": "Sliced Int8 data tensor.",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8Softmax",
    "category": "Activation",
    "description": "\nThe operator computes the softmax normalized values for each layer in the batch\n of the given input. The input is a 2-D tensor (Tensor<float>) of size\n(batch_size x input_feature_dimensions). The output tensor has the same shape\nand contains the softmax normalized values of the corresponding input.\n\nX does not need to explicitly be a 2D vector; rather, it will be\ncoerced into one. For an arbitrary n-dimensional tensor\nX \\in [a_0, a_1, ..., a_{k-1}, a_k, ..., a_{n-1}] and k is\nthe axis provided, then X will be coerced into a 2-dimensional tensor with\ndimensions [a_0 * ... * a_{k-1}, a_k * ... * a_{n-1}]. For the default\ncase where axis=1, this means the X tensor will be coerced into a 2D tensor\nof dimensions [a_0, a_1 * ... * a_{n-1}], where a_0 is often the batch size.\nIn this situation, we must have a_0 = N and a_1 * ... * a_{n-1} = D.\nEach of these dimensions must be matched correctly, or else the operator\nwill throw errors.\n",
    "attributes": [
      {
        "default": 0,
        "name": "order"
      },
      {
        "default": 0,
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "default": 0,
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      },
      {
        "description": "(int) default to 1; describes the axis of the inputs when coerced to 2D; defaults to one because the 0th axis most likely describes the batch_size",
        "name": "axis",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "The input tensor that's coerced into a 2D matrix of size (NxD) as described above.",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "The softmax normalized output values with the same shape as input tensor.",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8Sum",
    "attributes": [
      {
        "default": 0,
        "name": "order"
      },
      {
        "default": 0,
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "default": 0,
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8SumRelu",
    "attributes": [
      {
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Int8Transpose",
    "description": "\nTranspose the input tensor by permuting the axes of the input according\nto the `axes` argument. Similar to numpy's\n[transpose](https://docs.scipy.org/doc/numpy/reference/generated/numpy.transpose.html)\nfunction.\n\nFor example, when axes=(1, 0, 2), given an input tensor of shape\n(1, 2, 3), the output shape will be (2, 1, 3).\n",
    "attributes": [
      {
        "description": "Order to permute axes of input tensor. Reverses the dimensions by default.",
        "name": "axes",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization scale",
        "name": "Y_scale",
        "option": "optional"
      },
      {
        "description": "Output tensor quantization offset",
        "name": "Y_zero_point",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "Transposed output",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "IntegralImage",
    "description": "\nComputes an integral image, which contains the sum of pixel values within\nan image vertically and horizontally. This integral image can then be used\nwith other detection and tracking techniques.\n",
    "inputs": [
      {
        "description": "Images tensor of the form (N, C, H, W)",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "Integrated image of the form (N, C, H+1, W+1)",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "IntegralImageGradient",
    "support_level": "default"
  },
  {
    "name": "IntIndexCreate",
    "description": "\nCreates a dictionary that maps int32 keys to consecutive integers\nfrom 1 to max_elements. Zero is reserved for unknown keys.\n",
    "attributes": [
      {
        "description": "Max number of elements, including the zero entry.",
        "name": "max_elements",
        "option": "optional"
      }
    ],
    "outputs": [
      {
        "description": "Pointer to an Index instance.",
        "name": "handler"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "IsEmpty",
    "description": "\nThe *IsEmpty* op accepts a single input $tensor$, and produces a single boolean output $is\\_empty$. The output is *True* if and only if $tensor$ has size == 0.\n\nGithub Links:\n\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/utility_ops.cc\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/utility_ops.h\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"IsEmpty\",\n    [\"tensor\"],\n    [\"is_empty\"],\n)\n\n// Use a not-empty tensor\nworkspace.FeedBlob(\"tensor\", np.random.randn(2, 2).astype(np.float32))\nprint(\"tensor:\\n\", workspace.FetchBlob(\"tensor\"))\n\nworkspace.RunOperatorOnce(op)\nprint(\"is_empty: \", workspace.FetchBlob(\"is_empty\"),\"\\n\")\n\n// Use an empty tensor\nworkspace.FeedBlob(\"tensor\", np.empty(0))\nprint(\"tensor:\\n\", workspace.FetchBlob(\"tensor\"))\n\nworkspace.RunOperatorOnce(op)\nprint(\"is_empty: \", workspace.FetchBlob(\"is_empty\"))\n\n```\n\n**Result**\n\n```\n\ntensor:\n [[ 0.26018378  0.6778789 ]\n [-1.3097627  -0.40083608]]\nis_empty:  False\n\ntensor:\n []\nis_empty:  True\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "Input data tensor to check if empty.",
        "name": "tensor"
      }
    ],
    "outputs": [
      {
        "description": "Output scalar boolean tensor. True if input has size == 0.",
        "name": "is_empty"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "IsMemberOf",
    "description": "\nThe *IsMemberOf* op takes an input tensor *X* and a list of values as argument, and produces one output data tensor *Y*. The output tensor is the same shape as *X* and contains booleans. The output is calculated as the function *f(x) = x in value* and is applied to *X* elementwise.\n\nGithub Links:\n\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/elementwise_logical_ops.cc\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/elementwise_logical_ops.h\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"IsMemberOf\",\n    [\"X\"],\n    [\"Y\"],\n    value=[0,2,4,6,8],\n)\n\n// Use a not-empty tensor\nworkspace.FeedBlob(\"X\", np.array([0,1,2,3,4,5,6,7,8]).astype(np.int32))\nprint(\"X:\\n\", workspace.FetchBlob(\"X\"))\n\nworkspace.RunOperatorOnce(op)\nprint(\"Y: \\n\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n// value=[0,2,4,6,8]\n\nX:\n [0 1 2 3 4 5 6 7 8]\nY:\n [ True False  True False  True False  True False  True]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "List of values to check for membership.",
        "name": "value",
        "option": "optional"
      },
      {
        "description": "The data type for the elements of the output tensor. Strictly must be one of the types from DataType enum in TensorProto.",
        "name": "dtype",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor of any shape",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "Output tensor (same size as X containing booleans)",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "IsNaN",
    "description": "Returns a new tensor with boolean elements representing if each element is NaN or not.",
    "inputs": [
      {
        "description": "Tensor to check for nan",
        "name": "tensor"
      }
    ],
    "outputs": [
      {
        "description": "Tensor containing a 1 at each location of NaN elements.",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Iter",
    "description": "\nStores a singe integer, that gets incremented on each call to Run().\nUseful for tracking the iteration count during SGD, for example.\n",
    "support_level": "default"
  },
  {
    "name": "KeySplit",
    "support_level": "default"
  },
  {
    "name": "KeyValueToMap",
    "description": "Convert key and value blob pairs into a map blob",
    "inputs": [
      {
        "description": "Blob reference to the key",
        "name": "key blob"
      },
      {
        "description": "Blob reference to the value",
        "name": "value blob"
      }
    ],
    "outputs": [
      {
        "description": "Blob reference to the map",
        "name": "map blob"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "L1Distance",
    "description": "\nComputes the row-wise L1 Distance between the two input tensors $X$ and $Y$, which is defined as\n\n$$L1Distance(\\mathbf{x},\\mathbf{y}) = \\sum_{i}\\mid x_i - y_i\\mid$$\n\nNote, both inputs must either be 1-dimensional or 2-dimensional and both must have the same shape. The output $Z$ will be 1-dimensional regardless and its length will equal the number of rows in the inputs.\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/distance_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/distance_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"L1Distance\",\n    [\"X\", \"Y\"],\n    [\"Z\"]\n)\n\n// Create X\nX = 5*np.ones((1, 4))\nprint(\"X:\\n\",X)\n\n// Create Y\nY = np.ones((1, 4))\nprint(\"Y:\\n\",Y)\n\n// Feed X & Y into workspace\nworkspace.FeedBlob(\"X\", X.astype(np.float32))\nworkspace.FeedBlob(\"Y\", Y.astype(np.float32))\n\n// Run op\nworkspace.RunOperatorOnce(op)\n\n// Collect Output\nprint(\"Z:\\n\", workspace.FetchBlob(\"Z\"))\n\n```\n\n**Result**\n\n```\n\nX:\n [[5. 5. 5. 5.]]\nY:\n [[1. 1. 1. 1.]]\nZ:\n [16.]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "First input tensor. (1D or 2D)",
        "name": "X"
      },
      {
        "description": "Second input tensor. (must have the same shape as $X$)",
        "name": "Y"
      }
    ],
    "outputs": [
      {
        "description": "1D output tensor. One value for each row of the inputs.",
        "name": "Z"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "L1DistanceGradient",
    "support_level": "default"
  },
  {
    "name": "LabelCrossEntropy",
    "description": "\nThis operator computes the cross entropy between a $NxD$ dimensional input data tensor $X$  and a one dimensional input label tensor $label$. The op produces a single length $N$ output tensor $Y$. Here, $N$ is considered the batch size and $D$ is the size of each element in the batch. In practice, it is most commonly used at the end of models as a part of the loss computation, after the SoftMax operator and before the AveragedLoss operator. The cross entropy operation is defined as follows\n\n$$Y_i = -log(X_{ij})$$\n\nwhere ($i$, $j$) is the classifier's prediction of the $j$th class (the correct one), and $i$ is the batch size. Each log has a lower limit for numerical stability.\n\nThe difference between *LabelCrossEntropy* and *CrossEntropy* is how the labels are specified. Here, the labels are a length $N$ list of integers, whereas in CrossEntropy the labels are a $NxD$ dimensional matrix of one hot label vectors. However, the results of computation should be the same, as shown in the two examples where ($i$, $j$) is the classifier's prediction of the $j$th class (the correct one), and $i$ is the batch size. Each log has a lower limit for numerical stability.\n\nGithub Links:\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/cross_entropy_op.h\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/cross_entropy_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"LabelCrossEntropy\",\n    [\"X\", \"label\"],\n    [\"Y\"]\n)\n\n// Create X: Sample softmax output for 5-class model\nX = np.array([[.01, .05, .02, .02, .9],[.03, .1, .42, .05, .4]])\nprint(\"X:\\n\",X)\n\n// Create label: Sample 1-hot ground truth label vectors\nlabel = np.array([4,2])\nprint(\"label:\\n\",label)\n\n// Feed X & label into workspace\nworkspace.FeedBlob(\"X\", X.astype(np.float32))\nworkspace.FeedBlob(\"label\", label.astype(np.int32))\n\n// Run op\nworkspace.RunOperatorOnce(op)\n\n// Collect Output\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n [[0.01 0.05 0.02 0.02 0.9 ]\n [0.03 0.1  0.42 0.05 0.4 ]]\nlabel:\n [4 2]\nY:\n [0.10536055 0.8675006 ]\n\n```\n\n</details>\n\n\n",
    "inputs": [
      {
        "description": "Input tensor which is almost always the result of a softmax operation. $X$ is a 2D array of size $NxD$, where $N$ is the batch size and $D$ is the number of classes.",
        "name": "X"
      },
      {
        "description": "Blob containing the labels used to compare the input. $label$ is a length $N$ list of integers, where each element is the integer label for the $n$th element of the batch.",
        "name": "label"
      }
    ],
    "outputs": [
      {
        "description": "Output blob from the cross entropy computation. $Y$ is 1D length $N$ tensor.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LabelCrossEntropyGradient",
    "support_level": "default"
  },
  {
    "name": "LambdaRankNdcg",
    "description": "\nIt implements the LambdaRank as appeared in Wu, Qiang, et al. \"Adapting boosting\nfor information retrieval measures.\" Information Retrieval 13.3 (2010): 254-270.\n\nThis method heuristically optimizes the NDCG.\n",
    "support_level": "default"
  },
  {
    "name": "LambdaRankNdcgGradient",
    "support_level": "default"
  },
  {
    "name": "Lars",
    "description": "\nImplement Layer-wise Adaptive Rate Scaling (LARS) with clipping. Before adding weight\ndecay, given a parameter tensor X and its gradient dX, the local learning rate\nfor X will be\n\nlocal_lr = trust * norm(X) / ( norm(dX) + wd * norm(X) + offset * norm(X) )\n\n      = trust / ( norm(dX) / norm(X) + wd + offset ),\n\nwhere offset is a preset hyper-parameter to avoid numerical issue and trust\nindicates how much we trust the layer to change its parameters during one update.\nIn this implementation, we uses l2 norm and the computed local learning rate is\nclipped based on the upper bound lr_max and the lower bound lr_min:\n\nlocal_lr = min(local_lr, lr_max) and local_lr = max(local_lr, lr_min)\n\n",
    "attributes": [
      {
        "description": "rescaling offset parameter",
        "name": "offset",
        "option": "optional"
      },
      {
        "description": "minimum learning rate for clipping",
        "name": "lr_min",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameter tensor",
        "name": "X"
      },
      {
        "description": "Gradient tensor",
        "name": "dX"
      },
      {
        "description": "Weight decay",
        "name": "wd"
      },
      {
        "description": "Trust",
        "name": "trust"
      },
      {
        "description": "Upper bound of learning rate",
        "name": "lr_max"
      }
    ],
    "outputs": [
      {
        "description": "Rescaled local learning rate",
        "name": "lr_rescaled"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LastNWindowCollector",
    "description": "\nCollect the last N rows from input data. The purpose is to keep track of data\naccross batches, so for example suppose the LastNWindowCollector is called\nsuccessively with the following input data\n\n  [1, 2, 3, 4]\n  [5, 6, 7]\n  [8, 9, 10, 11]\n\nAnd the number of items is set to 6, then the output after the 3rd call\nwill contain the following elements:\n\n  [6, 7, 8, 9, 10, 11]\n\nNo guarantee is made on the ordering of elements in input. So a valid value for\noutput could have been\n\n  [11, 10, 9, 8, 7, 6]\n\nAlso, this method works for any order tensor, treating the first dimension as\ninput rows and keeping the last N rows seen as input. So for instance:\n\n  [[1, 2], [2, 3], [3, 4], [4, 5]]\n  [[5, 6], [6, 7], [7, 8]]\n  [[8, 9], [9, 10], [10, 11], [11, 12]]\n\nA possible output would be\n\n  [[6, 7], [7, 8], [8, 9], [9, 10], [10, 11], [11, 12]]\n\nThis is not thread safe unless a mutex is given.\n",
    "attributes": [
      {
        "description": "The number of random samples to append for each positive samples",
        "name": "num_to_collect",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "The buffer for last-N record. Should be initialized to empty tensor",
        "name": "last-N buffer"
      },
      {
        "description": "The cursor pointing to the next position that should be replaced. Should be initialized to 0.",
        "name": "next cursor"
      },
      {
        "description": "tensor to collect from",
        "name": "DATA"
      },
      {
        "description": "(optional) mutex to use to make this thread-safe",
        "name": "MUTEX"
      },
      {
        "description": "",
        "name": "NUM_VISITED"
      }
    ],
    "outputs": [
      {
        "description": "Data stored in sessions",
        "name": "last-N buffer"
      },
      {
        "description": "Updated input cursor",
        "name": "next cursor"
      },
      {
        "description": "number of records seen so far",
        "name": "NUM_VISITED"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LayerNorm",
    "description": "\nComputes layer normalization as described in https://arxiv.org/pdf/1607.06450.pdf.\nGiven an input vector x \\in [a_0, a_1, ...,a_{k-1}, a_k, ..., a_{n-1}],\nthis op treats dimensions a_k through a_{n-1} as feature vectors. For each\nfeature vector, the op contains the mean and standard deviation. Then,\nit returns the normalized values (with respect to the feature vector).\n\nNote that this op does not contain the scale an bias terms described in the\npaper. Simply follow this op with an FC op to add those. Concretely, this op\nimplements:\n\nh = \\frac{1}{\\sigma}(a - \\mu)\nwhere \\mu = \\frac{1}{H}\\sum_{i=1}^{H} a_i\nand \\sigma = \\sqrt{\\frac{1}{H}\\sum_{i=1}^{H}(a_i - \\mu)^2}\nwhere H is the number of hidden units (i.e. product of dimensions from 'axis'\nto the end.)\n",
    "attributes": [
      {
        "description": "(int) default to 1; Describes axis of the inputs. Defaults to one because the 0th axis most likely describes the batch size",
        "name": "axis",
        "option": "optional"
      },
      {
        "description": "(float) default to 0.001. Small value to be added to the stdev when dividing out by that value. This prevents division by zero.",
        "name": "epsilon",
        "option": "optional"
      },
      {
        "description": "(bool) default to False; If true, this op will do affine transformation after normalization.",
        "name": "elementwise_affine",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor which layer normalization will be applied to",
        "name": "input"
      },
      {
        "description": "scale tensor for elementwise_affine, the shape should be the same as the dimensions of X begin from axis",
        "name": "gamma"
      },
      {
        "description": "bias tensor for elementwise_affine, the shape should be the same as the dimensions of X begin from axis",
        "name": "beta"
      }
    ],
    "outputs": [
      {
        "description": "Normalized values",
        "name": "output"
      },
      {
        "description": "Mean values for each feature vector",
        "name": "mean"
      },
      {
        "description": "Standard deviations for each feature vector",
        "name": "stddev"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LayerNormGradient",
    "support_level": "default"
  },
  {
    "name": "LC",
    "description": "\nThe locally connected operator consumes an input vector, a filter blob\nand a bias blob and computes the output. \nNote that other parameters, such as the stride and\nkernel size, or the pads' sizes in each direction are not necessary for input\nbecause they are provided by the ConvPoolOpBase operator. Various dimension\nchecks are done implicitly, and the sizes are specified in the Input docs for\nthis operator. As is expected, the filter is locally connected with a subset of\nthe image and the bias is added; this is done throughout the image data and the\noutput is computed. As a side note on the implementation layout:\nlocally_connected_op_impl.h is the templated implementation of the\nlocally_connected_op.h file, which is why they are separate files.\n",
    "inputs": [
      {
        "name": null
      },
      {
        "description": "The filter blob that will be used in the locally connected op; has size (YH * YW * M x C x kH x kW) if order == NCHW else (YH * YW * M  * KH * KW * C), where YH and YW are the height and width of the output image, C is the number of channels, and kH and kW are the height and width of the kernel.",
        "name": "filter"
      },
      {
        "description": "The 1D bias blob that is added through the locally connected op; has size (YH * YW * M).",
        "name": "bias"
      }
    ],
    "outputs": [
      {
        "description": "Output data blob that contains the result of the locally connected op.The output dimensions are functions of the kernel size, stride size, and pad lengths.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LC1D",
    "description": "\nThe locally connected operator consumes an input vector, a 1D filter blob\nand a bias blob and computes the output. \nNote that other parameters, such as the stride and\nkernel size, or the pads' sizes in each direction are not necessary for input\nbecause they are provided by the ConvPoolOpBase operator. Various dimension\nchecks are done implicitly, and the sizes are specified in the Input docs for\nthis operator. As is expected, the filter is locally connected with a subset of\nthe image and the bias is added; this is done throughout the image data and the\noutput is computed. As a side note on the implementation layout:\nlocally_connected_op_impl.h is the templated implementation of the\nlocally_connected_op.h file, which is why they are separate files.\n",
    "inputs": [
      {
        "name": null
      },
      {
        "description": "The filter blob that will be used in the locally connected op; has size (YH * YW * M x C x kH x kW) if order == NCHW else (YH * YW * M  * KH * KW * C), where YH and YW are the height and width of the output image, C is the number of channels, and kH and kW are the height and width of the kernel.",
        "name": "filter"
      },
      {
        "description": "The 1D bias blob that is added through the locally connected op; has size (YH * YW * M).",
        "name": "bias"
      }
    ],
    "outputs": [
      {
        "description": "Output data blob that contains the result of the locally connected op.The output dimensions are functions of the kernel size, stride size, and pad lengths.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LC1DGradient",
    "support_level": "default"
  },
  {
    "name": "LC2D",
    "description": "\nThe locally connected operator consumes an input vector, a 2D filter blob\nand a bias blob and computes the output. \nNote that other parameters, such as the stride and\nkernel size, or the pads' sizes in each direction are not necessary for input\nbecause they are provided by the ConvPoolOpBase operator. Various dimension\nchecks are done implicitly, and the sizes are specified in the Input docs for\nthis operator. As is expected, the filter is locally connected with a subset of\nthe image and the bias is added; this is done throughout the image data and the\noutput is computed. As a side note on the implementation layout:\nlocally_connected_op_impl.h is the templated implementation of the\nlocally_connected_op.h file, which is why they are separate files.\n",
    "inputs": [
      {
        "name": null
      },
      {
        "description": "The filter blob that will be used in the locally connected op; has size (YH * YW * M x C x kH x kW) if order == NCHW else (YH * YW * M  * KH * KW * C), where YH and YW are the height and width of the output image, C is the number of channels, and kH and kW are the height and width of the kernel.",
        "name": "filter"
      },
      {
        "description": "The 1D bias blob that is added through the locally connected op; has size (YH * YW * M).",
        "name": "bias"
      }
    ],
    "outputs": [
      {
        "description": "Output data blob that contains the result of the locally connected op.The output dimensions are functions of the kernel size, stride size, and pad lengths.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LC2DGradient",
    "support_level": "default"
  },
  {
    "name": "LC3D",
    "description": "\nThe locally connected operator consumes an input vector, a 3D filter blob\nand a bias blob and computes the output. \nNote that other parameters, such as the stride and\nkernel size, or the pads' sizes in each direction are not necessary for input\nbecause they are provided by the ConvPoolOpBase operator. Various dimension\nchecks are done implicitly, and the sizes are specified in the Input docs for\nthis operator. As is expected, the filter is locally connected with a subset of\nthe image and the bias is added; this is done throughout the image data and the\noutput is computed. As a side note on the implementation layout:\nlocally_connected_op_impl.h is the templated implementation of the\nlocally_connected_op.h file, which is why they are separate files.\n",
    "inputs": [
      {
        "name": null
      },
      {
        "description": "The filter blob that will be used in the locally connected op; has size (YH * YW * M x C x kH x kW) if order == NCHW else (YH * YW * M  * KH * KW * C), where YH and YW are the height and width of the output image, C is the number of channels, and kH and kW are the height and width of the kernel.",
        "name": "filter"
      },
      {
        "description": "The 1D bias blob that is added through the locally connected op; has size (YH * YW * M).",
        "name": "bias"
      }
    ],
    "outputs": [
      {
        "description": "Output data blob that contains the result of the locally connected op.The output dimensions are functions of the kernel size, stride size, and pad lengths.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LC3DGradient",
    "support_level": "default"
  },
  {
    "name": "LCGradient",
    "support_level": "default"
  },
  {
    "name": "LE",
    "description": "\nPerforms element-wise less or equal than comparison **<=** (with limited broadcast support).\n\n\nIf necessary the right-hand-side argument will be broadcasted to match the\nshape of left-hand-side argument. When broadcasting is specified, the second\ntensor can either be of size 1 (a scalar value), or having its shape as a\ncontiguous subset of the first tensor's shape. The starting of the mutually\nequal shape is specified by the argument \"axis\", and if it is not set, suffix\nmatching is assumed. 1-dim expansion doesn't work yet.\n\nFor example, the following tensor shapes are supported (with broadcast=1):\n```\n  shape(A) = (2, 3, 4, 5), shape(B) = (,), i.e. B is a scalar\n  shape(A) = (2, 3, 4, 5), shape(B) = (5,)\n  shape(A) = (2, 3, 4, 5), shape(B) = (4, 5)\n  shape(A) = (2, 3, 4, 5), shape(B) = (3, 4), with axis=1\n  shape(A) = (2, 3, 4, 5), shape(B) = (2), with axis=0\n```\nArgument `broadcast=1` needs to be passed to enable broadcasting.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/elementwise_ops_schema.cc\n\n\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"LE\",\n    [\"A\",  \"B\"],\n    [\"C\"],\n)\n\nworkspace.FeedBlob(\"A\", np.array([1, 5, 2, 9, 12, 3]))\nworkspace.FeedBlob(\"B\", np.array([1, 3, 4, 9, 12, 8]))\nprint(\"A:\", workspace.FetchBlob(\"A\"))\nprint(\"B:\", workspace.FetchBlob(\"B\"))\nworkspace.RunOperatorOnce(op)\nprint(\"C:\", workspace.FetchBlob(\"C\"))\n\n```\n\n**Result**\n\n```\n\nA: [ 1  5  2  9 12  3]\nB: [ 1  3  4  9 12  8]\nC: [ True False  True  True  True  True]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 0,
        "description": "Pass 1 to enable broadcasting.",
        "name": "broadcast",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": -1,
        "description": "Axis to concatenate on. If set, defines the broadcast dimensions.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<bool>`)* First operand, should share the type with the second operand.",
        "name": "A"
      },
      {
        "description": "*(type: Tensor`<bool>`)* Second operand. With broadcasting can be of smaller size than `A`. If broadcasting is disabled it should be of the same size.",
        "name": "B"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<bool>`)* Output tensor with same dimensions as `A`.",
        "name": "C"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LeakyRelu",
    "description": "\nThe *LeakyRelu* op takes one input tensor $X$ and an argument $alpha$, and produces one output tensor $Y$ of the same shape as $X.$ The op performs the element wise leaky relu operation, defined as\n\n$$y=LeakyRelu(x) =\\begin{cases}\\alpha x & x < 0\\\\x & otherwise\\end{cases}$$\n\nThe default value of *alpha* is 0.01.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/leaky_relu_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/leaky_relu_op.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"LeakyRelu\",\n    [\"X\"],\n    [\"Y\"],\n    alpha=0.01\n)\n\nworkspace.FeedBlob(\"X\", np.random.randn(3, 3).astype(np.float32))\nprint(\"X:\\n\", workspace.FetchBlob(\"X\"), \"\\n\")\n\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n [[-0.91060215  0.09374836  2.1429708 ]\n [-0.748983    0.19164062 -1.5130422 ]\n [-0.29539835 -0.8530696   0.7673204 ]]\n\nY:\n [[-0.00910602  0.09374836  2.1429708 ]\n [-0.00748983  0.19164062 -0.01513042]\n [-0.00295398 -0.0085307   0.7673204 ]]\n\n```\n\n</details>\n\n\n",
    "attributes": [
      {
        "default": 0.01,
        "description": "Coefficient of leakage.",
        "name": "alpha",
        "option": "optional",
        "type": "float32"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor of data to be operated on.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "Output tensor, calculated as described above.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LeakyReluGradient",
    "attributes": [
      {
        "description": "Coefficient of leakage",
        "name": "alpha",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LearningRate",
    "description": "\nLearning rate is a decreasing function of time. With low learning rates the\nimprovements will be linear. With high learning rates they will start to look\nmore exponential. Learning rate is controlled by the following arguments:\n\n\nRequired:\n `iterations`\n `base_lr`: base learning rate\n `policy`: this controls how the learning rate is applied, options are:\n   `fixed`\n   `step`: uses `stepsize`, `gamma`\n   `exp`: uses `gamma`\n   `gate`: uses 'multiplier_1', 'multiplier_2', `num_iter``\n   `inv`: uses `gamma`, `power`\n   `linearWarmup`: uses `start_multiplier`, `num_iter`\n   `constantWarmup`: uses `multiplier`, `num_iter`\n   `alter`: uses  `active_first`, `active_period`, `inactive_period`\n   `hill`: uses those in both `linearWarmup` and `inv`, plus `end_multiplier`\n   `composite`: uses `sub_policy_num_iters` and additional args with format\n   `cyclic`: uses `max_lr`, `stepsize`\n   `cosine`: uses `min_lr`, `max_lr`, `period`, `t_mult`, `lr_shrink`\n   `constantThenLinearWarmup`: uses `start_warmup_multiplier`, `constant_warmup_num_iter`, `linear_warmup_num_iter`\n   `compositeCyclical`: uses `start_warmup_multiplier`, `constant_warmup_num_iter`, `linear_warmup_num_iter`, `cyclical_max_lr`, `cyclical_step_size`, `cyclical_decay`\n   `compositeCosine`: uses `start_warmup_multiplier`, `constant_warmup_num_iter`, `linear_warmup_num_iter`, `cosine_max_lr`, `cosine_period`, `cosine_t_mult`, `cosine_lr_shrink`\n   sub_policy_{sub_policy_index}_{sub_policy_arg}, for example:\n   sub_policy_0_policy: \"exp\", sub_policy_0_gamma: 0.99,\n   sub_policy_0_lr_scale: 1.2\n   sub_policy_0_policy: \"fixed\", sub_policy_0_lr_scale: 1.0\n   sub_policy_num_iters: [1000, 1000]\n\nOptional:\n  `stepsize`: defaults to 0\n  `max_lr`: defaults to 0.005\n  `gamma`: defaults to 0\n  `power`: defaults to 0\n  `num_iter`: defaults to 0\n  `start_multiplier`: defaults to 0\n  `multiplier`: defaults to 0.5\n  `multiplier_1`: defaults to 1\n  `multiplier_2`: defaults to 1\n  `m1`: defaults to 0.5, the first piece lr of piece warmup\n  `n1`: defaults to 0, iter threshold of the first piece lr\n  `m2`: defaults to 0.5, the second piece lr of piece warmup\n  `n2`: defaults to 0, iter threshold of the second piece lr\n  `m3`: defaults to 0.5, the third piece lr of piece warmup\n  `start_warmup_multiplier`: defaults to 0.1, part of constantThenLinearWarmup\n  `constant_warmup_num_iter`: defaults to 10000000, part of constantThenLinearWarmup and constantThenLinearWarmup\n  `linear_warmup_num_iter`: defaults to 10000000, part of constantThenLinearWarmup, CompositeCyclicalLRPolicy, CompositeCosineLRPolicy\n  `cyclical_max_lr`: defaults to 0.05, part of CompositeCyclicalLRPolicy\n  `cyclical_step_size`: defaults to 1000000, part of CompositeCyclicalLRPolicy\n  `cyclical_decay`: defaults to 1.0, part of CompositeCyclicalLRPolicy\n  `cosine_min_lr`:defaults to 0.01, part of CompositeCosineLRPolicy\n  `cosine_max_lr`:defaults to 0.05, part of CompositeCosineLRPolicy\n  `cosine_period`:defaults to 50, part of CompositeCosineLRPolicy\n  `cosine_t_mult`:defaults to 1.0, part of CompositeCosineLRPolicy\n  `cosine_lr_shrink`:defaults to 0.99, part of CompositeCosineLRPolicy\n\nUsage:\n  train_net.LearningRate(*iterations*, \"*label*\", base_lr=*float*,\n                         policy=\"policy_name\", stepsize=*int*, gamma=*float*)\n\n\nExample usage:\n  train_net.LearningRate(200, \"LR\", base_lr=-0.1,\n                         policy=\"step\", stepsize=20, gamma=0.9)\n",
    "attributes": [
      {
        "description": "(float, required) base learning rate",
        "name": "base_lr",
        "option": "optional"
      },
      {
        "description": "(float, default 1.0) strategy for gamma enforcement",
        "name": "policy",
        "option": "optional"
      },
      {
        "description": "(float, default 1.0) used only for inv policy type",
        "name": "power",
        "option": "optional"
      },
      {
        "description": "(float, default 1.0) momentum of change",
        "name": "gamma",
        "option": "optional"
      },
      {
        "description": "(float, default 1.0) sampling rate on iterations",
        "name": "stepsize",
        "option": "optional"
      },
      {
        "description": "(boolean, default True) in alter policy",
        "name": "active_first",
        "option": "optional"
      },
      {
        "description": "(int64_t, required) in alter policy",
        "name": "active_period",
        "option": "optional"
      },
      {
        "description": "(int64_t, required) in alter policy",
        "name": "inactive_period",
        "option": "optional"
      },
      {
        "description": "(int, default -1) maximum iterations in this training run",
        "name": "max_iter",
        "option": "optional"
      },
      {
        "description": "(int, default 0) number of iterations over which to warmup lr",
        "name": "num_iter",
        "option": "optional"
      },
      {
        "description": "(float, default 0) starting multiplier for learning rate",
        "name": "start_multiplier",
        "option": "optional"
      },
      {
        "description": "(float, default 0) end multiplier for learning rate",
        "name": "end_multiplier",
        "option": "optional"
      },
      {
        "description": "(float, default 0.5) constant multiplier for learning rate",
        "name": "multiplier",
        "option": "optional"
      },
      {
        "description": "(float, default 1) start multiplier for learning rate",
        "name": "multiplier_1",
        "option": "optional"
      },
      {
        "description": "(float, default 1) end multiplier for learning rate",
        "name": "multiplier_2",
        "option": "optional"
      },
      {
        "description": "(int array, default empty) number of iterations for each sub learning rate policy in composite policy",
        "name": "sub_policy_num_iters",
        "option": "optional"
      },
      {
        "description": "",
        "name": "m1",
        "option": "optional"
      },
      {
        "description": "",
        "name": "n1",
        "option": "optional"
      },
      {
        "description": "",
        "name": "m2",
        "option": "optional"
      },
      {
        "description": "",
        "name": "n2",
        "option": "optional"
      },
      {
        "description": "",
        "name": "m3",
        "option": "optional"
      },
      {
        "description": "(float, default 0.005) max learning rate",
        "name": "max_lr",
        "option": "optional"
      },
      {
        "description": "defaults to 0.1",
        "name": "start_warmup_multiplier",
        "option": "optional"
      },
      {
        "description": "defaults to 10000000",
        "name": "constant_warmup_num_iter",
        "option": "optional"
      },
      {
        "description": "defaults to 10000000",
        "name": "linear_warmup_num_iter",
        "option": "optional"
      },
      {
        "description": "defaults to 0.05, part of CompositeCyclicalLRPolicy",
        "name": "cyclical_max_lr",
        "option": "optional"
      },
      {
        "description": "defaults to 1000000, part of CompositeCyclicalLRPolicy",
        "name": "cyclical_step_size",
        "option": "optional"
      },
      {
        "description": "defaults to 0.999, part of CompositeCyclicalLRPolicy",
        "name": "cyclical_decay",
        "option": "optional"
      },
      {
        "description": "defaults to 0.01, part of CompositeCosineLRPolicy",
        "name": "cosine_min_lr",
        "option": "optional"
      },
      {
        "description": "defaults to 0.05, part of CompositeCosineLRPolicy",
        "name": "cosine_max_lr",
        "option": "optional"
      },
      {
        "description": "defaults to 50, part of CompositeCosineLRPolicy",
        "name": "cosine_period",
        "option": "optional"
      },
      {
        "description": "defaults to 1,0, part of CompositeCosineLRPolicy",
        "name": "cosine_t_mult",
        "option": "optional"
      },
      {
        "description": "defaults to 0.99, part of CompositeCosineLRPolicy",
        "name": "cosine_lr_shrink",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "description needed",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "description needed",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LearningRateAdaption",
    "description": "\n      Learning Rate Adaption is an operation that perform one iteration of\n      gradient descent based on learning rate:\n        lr(k) = lr(k-1) - lr_alpha * df(k-1)/dlr,\n      where df(k-1)/dlr is the gradient of objective function f on lr, and\n      lr_alpha is a learning rate hyperparameter. It can be prove that\n      df(k-1)/dlr equals INNERPRODUCT(grad(k-1), -grad(k-2)), where grad(k-1) is\n      the grad of f(k-1) on parameters. When the argument\n      \"normalized_lr_adaption\" is false, we simply perform the\n      following update:\n      lr(k) = lr(k-1) - lr_alpha * INNERPRODUCT(grad(k-1), grad(k-2)).\n      If we set \"normalized_lr_adaption\" to be true, we do not directly apply\n      INNERPRODUCT(grad(k-1), -grad(k-2)) as the grad. Instead, we perform the\n      following update:\n      lr(k) = lr(k-1) + lr_alpha * cosineSimilarity(grad(k-1), grad(k-2)).\n",
    "attributes": [
      {
        "description": "the learning rate for performing gradient descent on learning rate lr",
        "name": "lr_alpha",
        "option": "optional"
      },
      {
        "description": "whether to apply normalized lr adaption or not",
        "name": "normalized_lr_adaption",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Learning rate",
        "name": "lr"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "The effective grad",
        "name": "effgrad"
      }
    ],
    "outputs": [
      {
        "description": "Updated learning rate",
        "name": "output_lr"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LengthsGather",
    "description": "\nGather items from sparse tensor. Sparse tensor is described by items and\nlengths. This operator gathers items corresponding to lengths at the given\nindices. This deliberately doesn't return lengths of OUTPUTS so that both lists\nand maps can be supported without special cases. If you need lengths tensor for\n OUTPUT, use `Gather`.\n\nExample:\n  ITEMS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n  LENGTHS = [0, 2, 3, 1, 4]\n  INDICES = [0, 2, 4]\n\n  OUTPUT = [2, 3, 4, 6, 7, 8, 9]\n",
    "inputs": [
      {
        "description": "items tensor",
        "name": "ITEMS"
      },
      {
        "description": "lengths tensor",
        "name": "LENGTHS"
      },
      {
        "description": "indices into LENGTHS where items should be gathered",
        "name": "INDICES"
      }
    ],
    "outputs": [
      {
        "description": "1-D tensor containing gathered items",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LengthsIndicesInGradientMeanGradient",
    "support_level": "default"
  },
  {
    "name": "LengthsIndicesInGradientSumGradient",
    "support_level": "default"
  },
  {
    "name": "LengthsMax",
    "description": "\nApplies 'Max' to each segment of the input tensor. Segments are defined\nby their *LENGTHS*. *LENGTHS* is a vector that maps each of the slices of\n*DATA* to a particular segment. Values belonging to the same segment are\naggregated together and considered for the 'Max' operation.\n\nFor example *LENGTHS = [2, 1]* stands for segments *DATA[0..1]* and *DATA[2]*\n\nThe sum of elements in *LENGTHS* must equal the number of elements in the first\ndimension of *DATA*. The length of *OUTPUT* is equal to the number of input\nsegments, i.e. len(*LENGTHS*).\n\nMax computes the element-wise max of the input slices. Operation doesn't change the shape of the individual blocks.\n\n\nThe *LengthsMax* op takes two inputs *DATA* and *LENGTHS*, and produces a single output *OUTPUT*. The op finds the maximum value in each of the segments of *DATA*, where segments are defined by their lengths.\nFor example, if $DATA = [2,4,3,1,2,10]$ and $LENGTHS = [2,3,1]$ then $OUTPUT = [max([2,4]), max([3,1,2]), max([10])] = [4,3,10]$.\n\nGithub Link:\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/segment_reduction_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"LengthsMax\",\n    [\"DATA\", \"LENGTHS\"],\n    [\"OUTPUT\"],\n)\n\nworkspace.FeedBlob(\"DATA\", np.array([2,4,3,1,2,10]).astype(np.float32))\nprint(\"DATA:\\n\", workspace.FetchBlob(\"DATA\"))\n\nworkspace.FeedBlob(\"LENGTHS\", np.array([2,3,1]).astype(np.int32))\nprint(\"LENGTHS:\\n\", workspace.FetchBlob(\"LENGTHS\"))\n\nworkspace.RunOperatorOnce(op)\nprint(\"OUTPUT: \\n\", workspace.FetchBlob(\"OUTPUT\"))\n\n```\n\n**Result**\n\n```\n\nDATA:\n [ 2.  4.  3.  1.  2. 10.]\nLENGTHS:\n [2 3 1]\nOUTPUT:\n [ 4.  3. 10.]\n\n```\n\n</details>\n\n\n  ",
    "inputs": [
      {
        "description": "Input tensor, slices of which are aggregated.",
        "name": "DATA"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated output tensor. Has the first dimension of len(LENGTHS) ",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LengthsMaxWithMainInputAndForwardOutputGradient",
    "support_level": "default"
  },
  {
    "name": "LengthsMean",
    "description": "\nApplies 'Mean' to each segment of the input tensor. Segments are defined\nby their *LENGTHS*. *LENGTHS* is a vector that maps each of the slices of\n*DATA* to a particular segment. Values belonging to the same segment are\naggregated together and considered for the 'Mean' operation.\n\nFor example *LENGTHS = [2, 1]* stands for segments *DATA[0..1]* and *DATA[2]*\n\nThe sum of elements in *LENGTHS* must equal the number of elements in the first\ndimension of *DATA*. The length of *OUTPUT* is equal to the number of input\nsegments, i.e. len(*LENGTHS*).\n\nMean computes the element-wise mean of the input slices. Operation doesn't change the shape of the individual blocks.\n\n\nThe *LengthsMean* op takes two inputs *DATA* and *LENGTHS*, and produces a single output *OUTPUT*. The op finds the mean value in each of the segments of *DATA*, where segments are defined by their lengths.\nFor example, if $DATA = [2,4,3,1,2,10]$ and $LENGTHS = [2,3,1]$ then $OUTPUT = [mean([2,4]), mean([3,1,2]), mean([10])] = [3,2,10]$.\n\nGithub Link:\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/segment_reduction_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"LengthsMean\",\n    [\"DATA\", \"LENGTHS\"],\n    [\"OUTPUT\"],\n)\n\nworkspace.FeedBlob(\"DATA\", np.array([2,4,3,1,2,10]).astype(np.float32))\nprint(\"DATA:\\n\", workspace.FetchBlob(\"DATA\"))\n\nworkspace.FeedBlob(\"LENGTHS\", np.array([2,3,1]).astype(np.int32))\nprint(\"LENGTHS:\\n\", workspace.FetchBlob(\"LENGTHS\"))\n\nworkspace.RunOperatorOnce(op)\nprint(\"OUTPUT: \\n\", workspace.FetchBlob(\"OUTPUT\"))\n\n```\n\n**Result**\n\n```\n\nDATA:\n [ 2.  4.  3.  1.  2. 10.]\nLENGTHS:\n [2 3 1]\nOUTPUT:\n [ 3.  2. 10.]\n\n```\n\n</details>\n\n\n  ",
    "inputs": [
      {
        "description": "Input tensor, slices of which are aggregated.",
        "name": "DATA"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated output tensor. Has the first dimension of len(LENGTHS) ",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LengthsMeanGradient",
    "support_level": "default"
  },
  {
    "name": "LengthsPad",
    "description": "\nGiven DATA tensor of rank r >= 1, and LENGTHS tensor of rank 1, pad each\nsegment in DATA with `value`, so that each segment's length is `target_length`.\nIf will throw, if there is segment of length larger than `target_length`.\n\nExample:\n  DATA  = [\n      [2.3, 3.4],\n      [4.5, 5.7],\n      [6.8, 7.9],\n  ]\n  LENGTHS = [0, 1, 1, 1]\n  and target_length = 2, padding value = -1.0\n  OUTPUT = [\n    [-1.0, -1.0],\n    [-1.0, -1.0],\n    [2.3, 3.4],\n    [-1.0, -1.0],\n    [4.5, 5.7],\n    [-1.0, -1.0],\n    [6.8, 7.9],\n    [-1.0, -1.0],\n  ]\n",
    "attributes": [
      {
        "description": "The value to pad the data",
        "name": "padding_value",
        "option": "optional"
      },
      {
        "description": "The target length of each segment",
        "name": "target_length",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Tensor of rank r >= 1. First dimension must be equal to the size of lengths",
        "name": "DATA"
      },
      {
        "description": "Tensor of int32 lengths of rank 1",
        "name": "LENGTHS"
      }
    ],
    "outputs": [
      {
        "description": "Padded DATA tensor",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LengthsPartition",
    "description": "\nLengthsPartition splits the input int tensor into multiple ones according to the\nsecond tensor. The first dimension is expected to be the tensor that describes\nlengths of the elements.\n\nTakes the second input and partitions it to shards according to the remainder of\nvalues modulo the number of partitions. It requires the second tensor to be\na 1D-tensor of the integral type. The first tensor should be 1D-tensor of int32\nthat would represent the lengths of the elements in the input. The number of\npartitions is derived as (num_output / num_input).\n\nIf additional inputs are present they must have the same shape as the first\ninput, optionally with extra trailing dimensions. They will be partitioned\naccordingly to the first input.\n\nOptional arg 'pack_first_input' transforms the first tensor values as\nX_ij / num_partitions.\n\nOutputs are ordered as\nX_0_part_0, X_1_part_0, ..., X_N-1_part_0, X_0_part_1, ..., X_N-1_part_K-1\n",
    "attributes": [
      {
        "description": "(int, default 0) If set, the operator transforms the first tensor values as floor(X_ij / num_partitions)",
        "name": "pack_first_input",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor containing data to be partitioned. The number of input tensors might be greater than 1 but must have the same shape as the previous tensors.",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Output Partitions. The number of output tensors has to be a multiple of the number of input tensors.",
        "name": "partitions"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LengthsRangeFill",
    "description": "\nThe *LengthsRangeFill* op takes a single input *lengths* and outputs a single tensor *range_sequence*. For each element of *lengths*, the op appends the range(0,lengths) vector to the end of *range_sequence*. For example, if input=[2,4,1], the output would be [0,1,0,1,2,3,0].\n\nGithub Links:\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/filler_op.h\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/filler_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"LengthsRangeFill\",\n    [\"lengths\"],\n    [\"range_sequence\"],\n)\n\nworkspace.FeedBlob(\"lengths\", np.array([2,4,1]).astype(np.int32))\nprint(\"lengths:\\n\", workspace.FetchBlob(\"lengths\"))\n\nworkspace.RunOperatorOnce(op)\nprint(\"range_sequence: \\n\", workspace.FetchBlob(\"range_sequence\"))\n\n```\n\n**Result**\n\n```\n\nlengths:\n [2 4 1]\nrange_sequence:\n [0 1 0 1 2 3 0]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "1D tensor of int32 or int64 segment lengths.",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "1D tensor whose size is the sum of *lengths*",
        "name": "range_sequence"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LengthsSplit",
    "description": "\nGiven input vector LENGTHS, and input n_split, LengthsSplit returns\na single output vector. It \"splits\" each length into n_split values which add\nup to the original length. It will attempt to do equal splits, and if not possible,\nit orders larger values first. If the n_split is larger than the length, zero\npadding will be applied.\n\ne.g. LENGTHS = [9 4 5]\n     n_split = 3\n     Y = [3 3 3 2 1 1 2 2 1]\n\ne.g. LENGTHS = [2, 1, 2]\n     n_split = 3\n     Y = [1 1 0 1 0 0 1 1 0]\n",
    "attributes": [
      {
        "description": "Number of splits for each element in LENGTHS",
        "name": "n_split",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Mx1 Input tensor denoting INT32 lengths",
        "name": "LENGTHS"
      },
      {
        "description": "(Optional) Number of splits for each element in LENGTHS (overrides argument)",
        "name": "n_split"
      }
    ],
    "outputs": [
      {
        "description": "(M*n_split)x1 Output vector denoting split lengths",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LengthsSum",
    "description": "\nApplies 'Sum' to each segment of the input tensor. Segments are defined\nby their *LENGTHS*. *LENGTHS* is a vector that maps each of the slices of\n*DATA* to a particular segment. Values belonging to the same segment are\naggregated together and considered for the 'Sum' operation.\n\nFor example *LENGTHS = [2, 1]* stands for segments *DATA[0..1]* and *DATA[2]*\n\nThe sum of elements in *LENGTHS* must equal the number of elements in the first\ndimension of *DATA*. The length of *OUTPUT* is equal to the number of input\nsegments, i.e. len(*LENGTHS*).\n\nSummation is done element-wise across slices of the input tensor and doesn't change the shape of the individual blocks.\n\n\nThe *LengthsSum* op takes two inputs *DATA* and *LENGTHS*, and produces a single output *OUTPUT*. The op finds the sum in each of the segments of *DATA*, where segments are defined by their lengths.\nFor example, if $DATA = [2,4,3,1,2,10]$ and $LENGTHS = [2,3,1]$ then $OUTPUT = [sum([2,4]), sum([3,1,2]), sum([10])] = [6,6,10]$.\n\nGithub Link:\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/segment_reduction_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"LengthsSum\",\n    [\"DATA\", \"LENGTHS\"],\n    [\"OUTPUT\"],\n)\n\nworkspace.FeedBlob(\"DATA\", np.array([2,4,3,1,2,10]).astype(np.float32))\nprint(\"DATA:\\n\", workspace.FetchBlob(\"DATA\"))\n\nworkspace.FeedBlob(\"LENGTHS\", np.array([2,3,1]).astype(np.int32))\nprint(\"LENGTHS:\\n\", workspace.FetchBlob(\"LENGTHS\"))\n\nworkspace.RunOperatorOnce(op)\nprint(\"OUTPUT: \\n\", workspace.FetchBlob(\"OUTPUT\"))\n\n```\n\n**Result**\n\n```\n\nDATA:\n [ 2.  4.  3.  1.  2. 10.]\nLENGTHS:\n [2 3 1]\nOUTPUT:\n [ 6.  6. 10.]\n\n```\n\n</details>\n\n\n  ",
    "inputs": [
      {
        "description": "Input tensor, slices of which are aggregated.",
        "name": "DATA"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated output tensor. Has the first dimension of len(LENGTHS) ",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LengthsSumGradient",
    "support_level": "default"
  },
  {
    "name": "LengthsTile",
    "description": "\nGiven DATA tensor of rank r >= 1, and LENGTHS tensor of rank 1, duplicate each\nentry of the outer-most dimension of DATA according to LENGTHS, and concatenate\nthem in an output tensor of rank r.\n\nExample:\n  DATA  = [\n      [1.0, 1.2],\n      [2.3, 3.4],\n      [4.5, 5.7],\n      [6.8, 7.9],\n  ]\n  LENGTHS = [0, 1, 3, 2]\n  OUTPUT = [\n      [2.3, 3.4],\n      [4.5, 5.7],\n      [4.5, 5.7],\n      [4.5, 5.7],\n      [6.8, 7.9],\n      [6.8, 7.9],\n  ]\n",
    "inputs": [
      {
        "description": "Tensor of rank r >= 1. First dimension must be equal to the size of lengths",
        "name": "DATA"
      },
      {
        "description": "Tensor of int32 lengths of rank 1",
        "name": "LENGTHS"
      }
    ],
    "outputs": [
      {
        "description": "Tensor of rank r",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LengthsToOffsets",
    "description": "\nGiven a vector of segment lengths, returns a vector of offsets from these lengths,\nwhich will have the same size as the input vector. Output is going to have\nthe same type as input. For long tensors explicit casting from int32 to int64\nmight be necessary prior to this op.\n\nFor example, `[1, 3, 0, 2]` transforms into `[0, 1, 4, 4]`.\n",
    "inputs": [
      {
        "description": "1D tensor of int32 or int64 segment lengths.",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "1D tensor of the same shape and type as `lengths`",
        "name": "offsets"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LengthsTopK",
    "description": "\nApply TopK to each segment of the input tensor, where segments are defined by\ntheir LENGTHS, and concatenate them in an output tensor of\nshape=(SIZE(LENGTHs), k). In case there's less than k values in a segment,\nthe output value will be padded by 0, and the corresponding output indices will\nbe padded by -1.\n",
    "attributes": [
      {
        "description": "the number of top values to return for each segment, if the number of values is smaller than k, the values would be padded with 0 and indices would be padded with -1.",
        "name": "k",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Tensor of rank 1. First dimension must be equal to the sum of lengths",
        "name": "DATA"
      },
      {
        "description": "Tensor of int32 lengths of rank 1",
        "name": "LENGTHS"
      }
    ],
    "outputs": [
      {
        "description": "Output top k elements for each segment, withshape=(SIZE(lengths), k)",
        "name": "TopKValue"
      },
      {
        "description": "Output indices in DATA corresponding to value in TopKValue",
        "name": "TopKIndices"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LengthsTopKGradient",
    "support_level": "default"
  },
  {
    "name": "LengthsToRanges",
    "description": "\nGiven a vector of segment lengths, calculates offsets of each segment and packs\nthem next to the lengths. For the input vector of length N the output is a Nx2\nmatrix with (offset, lengths) packaged for each segment.\n\nFor example, `[1, 3, 0, 2]` transforms into `[[0, 1], [1, 3], [4, 0], [4, 2]]`.\n",
    "inputs": [
      {
        "description": "1D tensor of int32 segment lengths.",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "2D tensor of shape len(lengths) X 2 and the same type as `lengths`",
        "name": "ranges"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LengthsToSegmentIds",
    "description": "\nGiven a vector of segment lengths (*lengths*) the *LengthsToSegmentIds* op returns a zero-based, consecutive vector of segment ids (*segment_ids*). For example, *lengths=[1, 3, 0, 2]* will produce *segment_ids=[0, 1, 1, 1, 3, 3]*. In general, the inverse operation is *SegmentIdsToLengths*. Notice though that trailing empty sequence lengths can't be properly recovered from segment ids.\n\nGithub Links:\n\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/utility_ops.cc\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/utility_ops.h\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"LengthsToSegmentIds\",\n    [\"lengths\"],\n    [\"segment_ids\"],\n)\n\nworkspace.FeedBlob(\"lengths\", np.array([1, 3, 0, 2]).astype(np.int32))\nprint(\"lengths:\\n\", workspace.FetchBlob(\"lengths\"))\n\nworkspace.RunOperatorOnce(op)\nprint(\"segment_ids: \\n\", workspace.FetchBlob(\"segment_ids\"))\n\n```\n\n**Result**\n\n```\n\nlengths:\n [1 3 0 2]\nsegment_ids:\n [0 1 1 1 3 3]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "1D tensor of int32 or int64 segment lengths.",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "1D tensor of length *sum(lengths)*",
        "name": "segment_ids"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LengthsToShape",
    "description": "\nThis operator takes a list of $N$ equal integers as input which represent the lengths of $N$ vectors. The output is the calculated shape of the matrix if the $N$ integers were combined into a single matrix.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/utility_ops.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/utility_ops.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"LengthsToShape\",\n    [\"X\"],\n    [\"Y\"]\n)\n\n// Create X: Sample softmax output for 5-class model\nX = np.array([2,2,2,2,2,2,2,2,2,2])\nprint(\"X:\\n\",X)\n\n// Feed X into workspace\nworkspace.FeedBlob(\"X\", X.astype(np.int32))\n\n// Run op\nworkspace.RunOperatorOnce(op)\n\n// Collect Output\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n [2 2 2 2 2 2 2 2 2 2]\nY:\n [10  2]\n\n```\n\n</details>\n\n    ",
    "inputs": [
      {
        "description": "List, of length $N$, of equal integers representing the lengths of several vectors.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "Vector of length 2 describing the dimensions of the data if the $N$ vectors from the input were combined to a single matrix.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LengthsToWeights",
    "description": "\nSimilar as LengthsToSegmentIds but output vector of segment\nweights derived by lengths. i.e 1/pow(length, power)\n",
    "attributes": [
      {
        "description": "n of 1/pow(length,n) for normalization",
        "name": "power",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "1-D int32_t or int64_t tensor of lengths",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "1-D float tensor of weights by length",
        "name": "a vector of weights"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LengthsWeightedSum",
    "description": "\nApplies 'WeightedSum' to each segment of the input tensor. Segments are defined\nby their *LENGTHS*. *LENGTHS* is a vector that maps each of the slices of\n*DATA* to a particular segment. Values belonging to the same segment are\naggregated together and considered for the 'WeightedSum' operation.\n\nFor example *LENGTHS = [2, 1]* stands for segments *DATA[0..1]* and *DATA[2]*\n\nThe sum of elements in *LENGTHS* must equal the number of elements in the first\ndimension of *DATA*. The length of *OUTPUT* is equal to the number of input\nsegments, i.e. len(*LENGTHS*).\n\nInput slices are first scaled by SCALARS and then summed element-wise. It doesn't change the shape of the individual blocks.\n\n\nThe *LengthsWeightedSum* op takes three inputs *DATA*, *LENGTHS*, and *SCALARS*, and produces a single output *OUTPUT*. The op finds the weighted sum in each of the segments of *DATA*, where segments are defined by their lengths. Before calculating the sums, the input *DATA* is weighted by the contents of *SCALARS*.\nFor example, if $DATA = [2,4,3,1,2,10]$, $SCALARS = [8, 2, 1, 4, 1, 0.6]$, and $LENGTHS = [2,3,1]$, then $OUTPUT = [sum([8*2,2*4]), sum([1*3,4*1,1*2]), sum([0.6*10])] = [24,9,6]$.\n\nGithub Link:\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/segment_reduction_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"LengthsWeightedSum\",\n    [\"DATA\", \"SCALARS\",\"LENGTHS\"],\n    [\"OUTPUT\"],\n)\n\nworkspace.FeedBlob(\"DATA\", np.array([2,4,3,1,2,10]).astype(np.float32))\nprint(\"DATA:\\n\", workspace.FetchBlob(\"DATA\"))\n\nworkspace.FeedBlob(\"SCALARS\", np.array([8, 2, 1, 4, 1, 0.6]).astype(np.float32))\nprint(\"SCALARS:\\n\", workspace.FetchBlob(\"SCALARS\"))\n\nworkspace.FeedBlob(\"LENGTHS\", np.array([2,3,1]).astype(np.int32))\nprint(\"LENGTHS:\\n\", workspace.FetchBlob(\"LENGTHS\"))\n\nworkspace.RunOperatorOnce(op)\nprint(\"OUTPUT: \\n\", workspace.FetchBlob(\"OUTPUT\"))\n\n```\n\n**Result**\n\n```\n\nDATA:\n [ 2.  4.  3.  1.  2. 10.]\nSCALARS:\n [8.  2.  1.  4.  1.  0.6]\nLENGTHS:\n [2 3 1]\nOUTPUT:\n [24.  9.  6.]\n\n```\n\n</details>\n\n\n  ",
    "attributes": [
      {
        "description": "Produce also gradient for `weights`. For now it's only supported in `Lengths`-based operators",
        "name": "grad_on_weights",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor for the summation",
        "name": "DATA"
      },
      {
        "description": "Scalar multipliers for the input slices. Must be a vector with the length matching the number of slices",
        "name": "SCALARS"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated output tensor. Has the first dimension of len(LENGTHS) ",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LengthsWeightedSumGradient",
    "support_level": "default"
  },
  {
    "name": "LengthsWeightedSumWithMainInputGradient",
    "support_level": "default"
  },
  {
    "name": "Load",
    "description": "\nThe Load operator loads a set of serialized blobs from a db or multiple dbs. It\ntakes $[0, \\infty)$ number of inputs and $[0, \\infty)$ number of outputs, using\nthe db keys to match the db entries with the outputs.\n\nIf at least one input is passed, then it is assumed that that input blobs are a\nset of DBReaders to load from. Otherwise the `db` or `dbs` argument is used to load\nblobs from one single db or multiple dbs respectively. `db_type` argument is used\nto specify the type of the input db/dbs.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/load_save_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Load\",\n    [],\n    [\"X\", \"Y\"],\n    db=\"test_db\",\n    db_type=\"lmdb\"\n)\n\nworkspace.RunOperatorOnce(op)\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 0,
        "description": "If set to non-zero, save the db directly to the path specified by the `db` arg. If not set (default), prepend the path of the current root folder of the workspace to the path specified by the `db` arg.",
        "name": "absolute_path",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": "",
        "description": "Blobs will be prefixed with this when loading. Useful for avoiding collisions with blobs existing in the workspace. The output blob names specified to this op should include this prefix.",
        "name": "add_prefix",
        "option": "optional",
        "type": "string"
      },
      {
        "default": "",
        "description": "Characters in the provided blob names that match `strip_prefix` will be removed prior to saving. Also, characters that precede `strip_prefix` will be removed. Useful for removing device scope from blob names.",
        "name": "strip_prefix",
        "option": "optional",
        "type": "string"
      },
      {
        "description": "The output path of the db. See the `absolute_path` arg details for options regarding the current root folder of the workspace.",
        "name": "db",
        "option": "optional",
        "type": "string"
      },
      {
        "description": "List of paths to dbs to load blobs from. See the `absolute_path` arg details for options regarding the current root folder of the workspace.",
        "name": "dbs",
        "option": "optional",
        "type": "string[]"
      },
      {
        "description": "(type: string)* Type of db to save (options: \"lmdb\", \"leveldb\", \"minidb\").",
        "name": "db_type",
        "option": "optional"
      },
      {
        "default": 0,
        "description": "If nonzero, the blobs are loaded into the device that is specified in the serialized `BlobProto`. Otherwise, the device will be set as the one that the `Load` operator is being run under.",
        "name": "keep_device",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": 0,
        "description": "If nonzero, will load all blobs pointed to by the db to the workspace overwriting/creating blobs as needed.",
        "name": "load_all",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": false,
        "description": "If True, will allow not loading all the output blobs specified in the outputs.",
        "name": "allow_incomplete",
        "option": "optional",
        "type": "boolean"
      },
      {
        "description": "If set, used instead of output blob names to specify which blobs in the db shall be loaded. Must be the same length as number of output blobs.",
        "name": "source_blob_names",
        "option": "optional",
        "type": "string[]"
      }
    ],
    "inputs": [
      {
        "description": "*(type: List(DBReader))* [OPTIONAL] List of DBReaders to load from. Can use this instead of the `db`/`dbs` args.",
        "name": "X, Y, ..."
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Log",
    "description": "\nCalculates the natural log of the given input tensor ($ln(x)$), element-wise. This\noperation can be done in an in-place fashion too, by providing the same input\nand output blobs.\n\nGithub Link:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/log_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Log\",\n    [\"X\"],\n    [\"X\"],\n)\n\nworkspace.FeedBlob(\"X\", (np.random.rand(3,3)).astype(np.float32))\nprint(\"X before running op:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"X after running op:\", workspace.FetchBlob(\"X\"))\n\n```\n\n**Result**\n\n```\n\nX before running op:\n[[0.07341351 0.15404125 0.386613  ]\n [0.34090295 0.99727786 0.24141751]\n [0.32016268 0.8724168  0.93515724]]\nX after running op:\n[[-2.6116474  -1.8705349  -0.9503311 ]\n [-1.0761575  -0.00272586 -1.4212275 ]\n [-1.138926   -0.13648799 -0.06704059]]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input tensor.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output tensor computed as the natural log of the input tensor computed, element-wise.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LogFatal",
    "support_level": "default"
  },
  {
    "name": "Logit",
    "description": "\nElementwise logit transform: logit(x) = log(x / (1 - x)), where x is the\ninput data clampped in (eps, 1-eps).\n",
    "attributes": [
      {
        "description": "small positive epsilon value, the default is 1e-6.",
        "name": "eps (optional)",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "input float tensor",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "output float tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LogitGradient",
    "attributes": [
      {
        "description": "small positive epsilon value, the default is 1e-6.",
        "name": "eps",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "input float tensor",
        "name": "X"
      },
      {
        "description": "input float tensor",
        "name": "dY"
      }
    ],
    "outputs": [
      {
        "description": "output float tensor",
        "name": "dX"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LongIndexCreate",
    "description": "\nCreates a dictionary that maps int64 keys to consecutive integers\nfrom 1 to max_elements. Zero is reserved for unknown keys.\n",
    "attributes": [
      {
        "description": "Max number of elements, including the zero entry.",
        "name": "max_elements",
        "option": "optional"
      }
    ],
    "outputs": [
      {
        "description": "Pointer to an Index instance.",
        "name": "handler"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LpNorm",
    "description": "\nThis op computes the $L_p$ norm of the one dimensional input tensor $X$, and outputs a one dimensional output tensor $Y$. Here, the $L_p$ norm is calculated as\n\n$$L_p(\\mathbf{x}) = \\sum_i x_i^p$$\n\nThis op supports $p$ values of 1 or 2. If the average argument is set, the norm is calculated as Lp_averaged_norm(x) is defined as Lp_averaged_norm(x) = LpNorm(x) / size(x).\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/lpnorm_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/lpnorm_op.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"LpNorm\",\n    [\"X\"],\n    [\"Y\"],\n    p=2\n)\nX = np.array([5., 2.])\nprint(\"X:\\n\",X)\n\n// Feed X into workspace\nworkspace.FeedBlob(\"X\", X.astype(np.float32))\n\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n [5. 2.]\nY:\n [29.]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 2,
        "description": "Order of the norm in p-norm.",
        "name": "p",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": false,
        "description": "Whether we calculate norm or averaged_norm.The Lp_averaged_norm(x) is defined as Lp_averaged_norm(x) = LpNorm(x) / size(x)",
        "name": "average",
        "option": "optional",
        "type": "boolean"
      }
    ],
    "inputs": [
      {
        "description": "1D Input tensor of data to be operated on.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "1D output tensor",
        "name": "Z"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LpNormGradient",
    "description": "\nGiven one input float tensor X, derivative dout, and produces one output\nfloat tensor dX. dX is the derivative of the Lp norm of tensor X, computed as\ndx = d(sum over |x^p|)/dx, in which p is either 1 or 2(currently only\nsupports l1 and l2 norm) determined by the argument p.\n",
    "attributes": [
      {
        "description": "Order of the norm in p-norm",
        "name": "p",
        "option": "optional"
      },
      {
        "description": "whehther we calculate norm or averaged_norm.The Lp_averaged_norm(x) is defined asLp_averaged_normgradient(x) = LpNormGradient(x) / size(x)",
        "name": "average",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "1D input tensor",
        "name": "X"
      },
      {
        "description": "1D input tensor",
        "name": "dout"
      }
    ],
    "outputs": [
      {
        "description": "1D output tensor",
        "name": "dx"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LpPool",
    "description": "\n`LpPool` consumes an input blob and applies max pooling across the the blob according to kernel sizes, stride sizes, pad lengths and dilation. $L_p$ pooling consists of taking the $L_p$ norm of a subset of the input tensor according to the kernel size and downsampling the data into the output blob for further processing.\n\nPooling layers reduce the spatial dimensionality of the input blob. Each of the output blob's dimensions will reduce according to:\n\n$$dim_{out}=\\frac{dim_{in}-kernel+2*pad}{stride}+1$$\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/lp_pool_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"LpPool\",\n    [\"X\"],\n    [\"Y\"],\n    kernel=2,\n    stride=2,\n    p=2.0\n)\n\nworkspace.FeedBlob(\"X\", np.random.randn(1, 1, 6, 6).astype(np.float32)) // NCHW\nprint(\"X:\\n\", workspace.FetchBlob(\"X\"), \"\\n\")\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n [[[[-1.1113514  -1.1173418  -0.1504435   0.1327146  -1.2221841  -0.5654315 ]\n   [-1.9209646  -0.04675794  0.8604731   1.2042469   0.28154245   0.38656202]\n   [-0.8772837  -0.03264008  0.26222762  0.28526652  0.321102    -2.5891325 ]\n   [-0.9248281   1.440776   -0.56832    -0.6017927   1.2262512   -2.1443934 ]\n   [ 0.5194415  -1.6858683   0.45221648  0.65029615 -0.8574544    0.8121054 ]\n   [ 0.25902653  0.4934758   0.49870652 -0.48134378 -0.9178449   -0.07626943]]]]\n\nY:\n [[[[2.4851248 1.49361   1.4290358]\n   [1.9240153 0.9139378 3.5928857]\n   [1.8500228 1.0525136 1.4976646]]]]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "(*float*): type of $L_p$ norm to use (default=2.0)",
        "name": "p",
        "option": "optional"
      },
      {
        "description": "(*int*): the size of the window to take a max over",
        "name": "kernel",
        "option": "optional"
      },
      {
        "description": "(*int*): the stride of the window",
        "name": "stride",
        "option": "optional"
      },
      {
        "description": "(*int*): implicit zero padding to be added on both sides",
        "name": "pad",
        "option": "optional"
      },
      {
        "description": "(*int*): parameter that controls the stride of elements in the window",
        "name": "dilation",
        "option": "optional"
      },
      {
        "description": "(*string*): order of blob dimensions (default=\"NCHW\")",
        "name": "order",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "(*Tensor`<float>`*): input tensor",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor`<float>`*): output tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LpPoolGradient",
    "support_level": "default"
  },
  {
    "name": "LRN",
    "category": "Normalization",
    "description": "\n\n`LRN` applies Local Response Normalization to an input blob. This operation performs\na kind of \"lateral inhibition\" by normalizing over local input regions, where\nnormalization is applied across channels. This operator is typically used to\nnormalize an unbounded activation (such as ReLU). The output shape is the same as\nthe input shape. The `brew` module has a wrapper for this operator for use in a\n`ModelHelper` object.\n\nThe formula for LRN is as follows:\n\n$$b_{c} = a_{c}(bias + \\frac{\\alpha}{n}\\sum_{c'=max(0,c-n/2)}^{min(N-1,c+n/2)} a_{c'}^2 )^{-\\beta}$$\n\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/local_response_normalization_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/local_response_normalization_op.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\"LRN\",\n     [\"X\"],\n     [\"Y\", \"Y_scale\"],\n     size=11,\n     alpha=0.001,\n     beta=0.5,\n     bias=2.0,\n     order=\"NHWC\"\n)\n\nworkspace.FeedBlob(\"X\", np.random.randn(1, 6, 6, 1).astype(np.float32)) // NCHW\nprint(\"X:\\n\", workspace.FetchBlob(\"X\"), \"\\n\")\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\nprint(\"Y_scale:\\n\", workspace.FetchBlob(\"Y_scale\"))\n```\n\n**Result**\n\n```\nX:\n [[[[ 0.72985137]\n   [-0.3753357 ]\n   [ 2.7344604 ]\n   [-0.5937792 ]\n   [ 0.38440478]\n   [-2.1659644 ]]\n\n  [[-0.92846817]\n   [-0.9996144 ]\n   [ 0.212943  ]\n   [-1.968045  ]\n   [-0.77839696]\n   [ 0.45492038]]\n\n  [[-0.11263168]\n   [ 1.9901097 ]\n   [ 0.19275683]\n   [ 0.15630436]\n   [ 0.7536298 ]\n   [-0.77339894]]\n\n  [[ 0.8353551 ]\n   [-0.7784452 ]\n   [ 1.779317  ]\n   [ 0.22421335]\n   [ 1.3846219 ]\n   [-3.0546608 ]]\n\n  [[ 0.09977621]\n   [ 2.2071757 ]\n   [ 0.79971045]\n   [ 3.563886  ]\n   [-0.7169287 ]\n   [ 0.77170426]]\n\n  [[-1.4296649 ]\n   [ 0.19181213]\n   [ 0.45961624]\n   [-1.0201577 ]\n   [ 0.62854475]\n   [-0.6395456 ]]]]\n\nY:\n [[[[ 0.5160766 ]\n   [-0.26540157]\n   [ 1.9332271 ]\n   [-0.41986194]\n   [ 0.27181432]\n   [-1.5314047 ]]\n\n  [[-0.6565133 ]\n   [-0.7068181 ]\n   [ 0.15057328]\n   [-1.3914955 ]\n   [-0.5504022 ]\n   [ 0.32167578]]\n\n  [[-0.0796426 ]\n   [ 1.4070934 ]\n   [ 0.13629955]\n   [ 0.11052381]\n   [ 0.53288984]\n   [-0.5468682 ]]\n\n  [[ 0.5906759 ]\n   [-0.5504363 ]\n   [ 1.2580767 ]\n   [ 0.1585426 ]\n   [ 0.9790328 ]\n   [-2.1595135 ]]\n\n  [[ 0.07055242]\n   [ 1.5605361 ]\n   [ 0.5654725 ]\n   [ 2.5193207 ]\n   [-0.50693923]\n   [ 0.54567   ]]\n\n  [[-1.0108787 ]\n   [ 0.13563155]\n   [ 0.3249962 ]\n   [-0.72134334]\n   [ 0.44444424]\n   [-0.45222285]]]]\nY_scale:\n [[[[2.0000484]\n   [2.0000129]\n   [2.0006797]\n   [2.000032 ]\n   [2.0000134]\n   [2.0004265]]\n\n  [[2.0000784]\n   [2.0000908]\n   [2.000004 ]\n   [2.0003521]\n   [2.000055 ]\n   [2.0000188]]\n\n  [[2.0000012]\n   [2.00036  ]\n   [2.0000033]\n   [2.0000021]\n   [2.0000517]\n   [2.0000544]]\n\n  [[2.0000634]\n   [2.000055 ]\n   [2.0002878]\n   [2.0000045]\n   [2.0001743]\n   [2.0008483]]\n\n  [[2.000001 ]\n   [2.000443 ]\n   [2.0000582]\n   [2.0011547]\n   [2.0000467]\n   [2.0000541]]\n\n  [[2.0001857]\n   [2.0000033]\n   [2.0000193]\n   [2.0000947]\n   [2.000036 ]\n   [2.0000372]]]]\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 0,
        "description": "Amount of neighboring channels to sum over for normalization",
        "name": "size",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": 0.0,
        "description": "Multiplicative (scaling) factor.",
        "name": "alpha",
        "option": "optional",
        "type": "float32"
      },
      {
        "default": 0.0,
        "description": "Exponent.",
        "name": "beta",
        "option": "optional",
        "type": "float32"
      },
      {
        "default": 1.0,
        "description": "Additive factor.",
        "name": "bias",
        "option": "optional",
        "type": "float32"
      },
      {
        "default": 0,
        "description": "Order of blob dimensions.",
        "name": "order",
        "option": "optional",
        "type": "float32"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input data tensor (ReLU output).",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output tensor.",
        "name": "Y"
      },
      {
        "description": "*(type: Tensor`<float>`)* Output scale.",
        "name": "Y_scale"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LRNGradient",
    "support_level": "default"
  },
  {
    "name": "LSTMUnit",
    "description": "\nLSTMUnit computes the activations of a standard LSTM (without peephole\nconnections), in a sequence-length aware fashion.\n\nConcretely, given the (fused) inputs X (TxNxD), the previous cell\nstate (NxD), and the sequence lengths (N), computes the LSTM\nactivations, avoiding computation if the input is invalid (as in, the\nvalue at X{t][n] >= seqLengths[n].\n\n",
    "attributes": [
      {
        "description": "Bias term to add in while calculating forget gate",
        "name": "forget_bias",
        "option": "optional"
      },
      {
        "description": "When false, the sequence lengths input is left out, and all following inputs are shifted left by one.",
        "name": "sequence_lengths",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LSTMUnitGradient",
    "attributes": [
      {
        "description": "When false, the sequence lengths input is left out, and all following inputs are shifted left by one.",
        "name": "sequence_lengths",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "LT",
    "description": "\nPerforms element-wise less than comparison **<** (with limited broadcast support).\n\n\nIf necessary the right-hand-side argument will be broadcasted to match the\nshape of left-hand-side argument. When broadcasting is specified, the second\ntensor can either be of size 1 (a scalar value), or having its shape as a\ncontiguous subset of the first tensor's shape. The starting of the mutually\nequal shape is specified by the argument \"axis\", and if it is not set, suffix\nmatching is assumed. 1-dim expansion doesn't work yet.\n\nFor example, the following tensor shapes are supported (with broadcast=1):\n```\n  shape(A) = (2, 3, 4, 5), shape(B) = (,), i.e. B is a scalar\n  shape(A) = (2, 3, 4, 5), shape(B) = (5,)\n  shape(A) = (2, 3, 4, 5), shape(B) = (4, 5)\n  shape(A) = (2, 3, 4, 5), shape(B) = (3, 4), with axis=1\n  shape(A) = (2, 3, 4, 5), shape(B) = (2), with axis=0\n```\nArgument `broadcast=1` needs to be passed to enable broadcasting.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/elementwise_ops_schema.cc\n\n\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"LT\",\n    [\"A\",  \"B\"],\n    [\"C\"],\n)\n\nworkspace.FeedBlob(\"A\", np.array([1, 5, 2, 9, 12, 3]))\nworkspace.FeedBlob(\"B\", np.array([1, 3, 4, 9, 12, 8]))\nprint(\"A:\", workspace.FetchBlob(\"A\"))\nprint(\"B:\", workspace.FetchBlob(\"B\"))\nworkspace.RunOperatorOnce(op)\nprint(\"C:\", workspace.FetchBlob(\"C\"))\n\n```\n\n**Result**\n\n```\n\nA: [ 1  5  2  9 12  3]\nB: [ 1  3  4  9 12  8]\nC: [False False  True False False  True]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 0,
        "description": "Pass 1 to enable broadcasting.",
        "name": "broadcast",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": -1,
        "description": "Axis to concatenate on. If set, defines the broadcast dimensions.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<bool>`)* First operand, should share the type with the second operand.",
        "name": "A"
      },
      {
        "description": "*(type: Tensor`<bool>`)* Second operand. With broadcasting can be of smaller size than `A`. If broadcasting is disabled it should be of the same size.",
        "name": "B"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<bool>`)* Output tensor with same dimensions as `A`.",
        "name": "C"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MakeTwoClass",
    "description": "\nGiven a vector of probabilities, this operator transforms this into a 2-column\n matrix with complimentary probabilities for binary classification. In explicit\n terms, given the vector X, the output Y is vstack(1 - X, X).\n  ",
    "inputs": [
      {
        "description": "Input vector of probabilities",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "2-column matrix with complimentary probabilities of X for binary classification",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MakeTwoClassGradient",
    "support_level": "default"
  },
  {
    "name": "MapToKeyValue",
    "description": "Convert a map blob into key and value blob pairs",
    "inputs": [
      {
        "description": "Blob reference to the map",
        "name": "map blob"
      }
    ],
    "outputs": [
      {
        "description": "Blob reference to the key",
        "name": "key blob"
      },
      {
        "description": "Blob reference to the value",
        "name": "value blob"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MarginRankingCriterion",
    "description": "\nMarginRankingCriterion takes two input data X1 (Tensor),\nX2 (Tensor), and label Y (Tensor) to produce the\nloss (Tensor) where the loss function,\nloss(X1, X2, Y) = max(0, -Y * (X1 - X2) + margin), is applied to\nthe tensor elementwise.\n\nIf y == 1 then it assumed the first input should be ranked higher\n(have a larger value) than the second input, and vice-versa for\ny == -1.\n",
    "attributes": [
      {
        "description": "The margin value as a float. Default is 1.0.",
        "name": "margin",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "The left input vector as a 1-dim TensorCPU.",
        "name": "X1"
      },
      {
        "description": "The right input vector as a 1-dim TensorCPU.",
        "name": "X2"
      },
      {
        "description": "The label as a 1-dim TensorCPU with int value of 1 or -1.",
        "name": "Y"
      }
    ],
    "outputs": [
      {
        "description": "The output loss with the same dimensionality as X1.",
        "name": "loss"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MarginRankingCriterionGradient",
    "description": "\nMarginRankingCriterionGradient takes both X1, X2, Y and dY and\nuses them to update dX1, and dX2 according to the chain rule\nand derivatives of the loss function.\n",
    "support_level": "default"
  },
  {
    "name": "MatMul",
    "description": "\nMatrix multiplication $Y = A * B$, where `A` has size (M x K), `B` has size\n(K x N), and `Y` will have a size (M x N). To transpose `A` or `B` before\nmultiplication, pass 1 to the `trans_a` and/or `trans_b` arguments, which\nseparate the first and second dimensions of the respective matrices using\n`axis_a` and `axis_b`.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/matmul_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"MatMul\",\n    [\"A\", \"B\"],\n    [\"Y\"],\n)\n\nworkspace.FeedBlob(\"A\", np.random.randint(10, size=(3,3)).astype(np.float32))\nworkspace.FeedBlob(\"B\", np.random.randint(10, size=(3,3)).astype(np.float32))\nprint(\"A:\", workspace.FetchBlob(\"A\"))\nprint(\"B:\", workspace.FetchBlob(\"B\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n```\n\n**Result**\n\n```\nA: [[1. 8. 3.]\n [6. 4. 4.]\n [5. 4. 7.]]\nB: [[4. 0. 3.]\n [3. 1. 1.]\n [8. 5. 8.]]\nY: [[52. 23. 35.]\n [68. 24. 54.]\n [88. 39. 75.]]\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 1,
        "description": "Exclusive axis that divides the first and second dimension of matrix `A`.",
        "name": "axis_a",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": 1,
        "description": "Exclusive axis that divides the first and second dimension of matrix `B`.",
        "name": "axis_b",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": 0,
        "description": "Pass 1 to transpose `A` before multiplication and after the dimension adjustment using `axis_a`.",
        "name": "trans_a",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": 0,
        "description": "Pass 1 to transpose `B` before multiplication and after the dimension adjustment using `axis_b`.",
        "name": "trans_b",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* 2D matrix of size (M x K).",
        "name": "A"
      },
      {
        "description": "*(type: Tensor`<float>`)* 2D matrix of size (K x N).",
        "name": "B"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* 2D matrix of size (M x N).",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Max",
    "description": "\nElement-wise max of an arbitrary number of input tensors. This operation can be\nperformed in-place, by using the first input blob as the output blob. All inputs\nmust have the same shape and data type, and the output will have the same shape\nas the inputs.\n\nGithub Link:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/minmax_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Max\",\n    [\"X\", \"Y\", \"Z\"],\n    [\"X\"],\n)\n\nworkspace.FeedBlob(\"X\", (np.random.rand(3,3)).astype(np.float32))\nworkspace.FeedBlob(\"Y\", (np.random.rand(3,3)).astype(np.float32))\nworkspace.FeedBlob(\"Z\", (np.random.rand(3,3)).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\nprint(\"Z:\", workspace.FetchBlob(\"Z\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Max:\", workspace.FetchBlob(\"X\"))\n\n```\n\n**Result**\n\n```\n\nX:\n[[0.4496477  0.07061381 0.7139333 ]\n [0.83203    0.05970785 0.72786295]\n [0.75988126 0.04601283 0.32820013]]\nY:\n[[0.05683139 0.16872478 0.671098  ]\n [0.70739156 0.09878621 0.03416285]\n [0.34087983 0.94986707 0.67263436]]\nZ:\n[[0.48051122 0.07141234 0.85264146]\n [0.77086854 0.22082241 0.13154659]\n [0.42401117 0.995431   0.4263775 ]]\nMax:\n[[0.48051122 0.16872478 0.85264146]\n [0.83203    0.22082241 0.72786295]\n [0.75988126 0.995431   0.67263436]]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<Ord>`)* List of input tensors with the same shape.",
        "name": "X, Y, ..."
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<Ord>`)* Output tensor with same dimensions as input(s).Contains the maximum valued element at each location.",
        "name": "M"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MaxGradient",
    "support_level": "default"
  },
  {
    "name": "MaxPool",
    "category": "Pool",
    "description": "MaxPool \nconsumes an input blob and applies max pooling across the the blob according to\nkernel sizes, stride sizes, pad lengths and dilation. Max pooling consists of\ntaking the maximum value of a subset of the input tensor according to the kernel\nsize and downsampling the data into the output blob for further processing. The\n`brew` module has a wrapper for this operator for use in a `ModelHelper` object.\n\nPooling layers reduce the spatial dimensionality of the input blob. Each of the\noutput blob's dimensions will reduce according to:\n\n$$dim_{out}=\\frac{dim_{in}-kernel+2*pad}{stride}+1$$\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/pool_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/pool_op.cc\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/conv_pool_op_base.h\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"MaxPool\",\n    [\"X\"],\n    [\"Y\"],\n    kernel=2,\n    stride=2,\n)\n\nworkspace.FeedBlob(\"X\", np.random.randn(1, 1, 6, 6).astype(np.float32)) // NCHW\nprint(\"X:\\n\", workspace.FetchBlob(\"X\"), \"\\n\")\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n```\n\n**Result**\n\n```\nX:\n [[[[-2.8534958e-01 -1.7719941e+00 -8.2277227e-04  1.1088650e+00\n    -2.1476576e+00 -3.5070452e-01]\n   [-9.0058845e-01 -3.0070004e-01 -1.7907504e+00 -7.1746534e-01\n     1.2798511e+00 -3.2214901e-01]\n   [ 1.5806322e+00  1.6845188e+00 -2.6633200e-01 -3.8576153e-01\n    -9.6424848e-02 -3.9696163e-01]\n   [ 1.2572408e-01  6.3612902e-01 -3.9554062e-01 -6.9735396e-01\n    -9.1898698e-01 -1.9609968e-01]\n   [-1.1587460e+00  2.4605224e+00 -1.5497679e+00  1.3020347e-01\n    -8.1293899e-01 -7.8803545e-01]\n   [ 1.4323474e+00  1.3618395e+00  9.8975077e-02 -1.1307785e-01\n     7.2035044e-01  2.7642491e-01]]]]\n\nY:\n [[[[-0.28534958  1.108865    1.2798511 ]\n   [ 1.6845188  -0.266332   -0.09642485]\n   [ 2.4605224   0.13020347  0.72035044]]]]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 0,
        "name": "order"
      },
      {
        "default": 0,
        "name": "pad"
      },
      {
        "name": "cudnn_exhaustive_search",
        "type": "boolean",
        "visible": false
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input data tensor of shape NCHW or NHWC.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output data tensor.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MaxPool1D",
    "description": "MaxPool1D \nconsumes an input blob and applies max pooling across the the blob according to\nkernel sizes, stride sizes, pad lengths and dilation. Max pooling consists of\ntaking the maximum value of a subset of the input tensor according to the kernel\nsize and downsampling the data into the output blob for further processing. The\n`brew` module has a wrapper for this operator for use in a `ModelHelper` object.\n\nPooling layers reduce the spatial dimensionality of the input blob. Each of the\noutput blob's dimensions will reduce according to:\n\n$$dim_{out}=\\frac{dim_{in}-kernel+2*pad}{stride}+1$$\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/pool_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/pool_op.cc\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/conv_pool_op_base.h\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"MaxPool\",\n    [\"X\"],\n    [\"Y\"],\n    kernel=2,\n    stride=2,\n)\n\nworkspace.FeedBlob(\"X\", np.random.randn(1, 1, 6, 6).astype(np.float32)) // NCHW\nprint(\"X:\\n\", workspace.FetchBlob(\"X\"), \"\\n\")\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n```\n\n**Result**\n\n```\nX:\n [[[[-2.8534958e-01 -1.7719941e+00 -8.2277227e-04  1.1088650e+00\n    -2.1476576e+00 -3.5070452e-01]\n   [-9.0058845e-01 -3.0070004e-01 -1.7907504e+00 -7.1746534e-01\n     1.2798511e+00 -3.2214901e-01]\n   [ 1.5806322e+00  1.6845188e+00 -2.6633200e-01 -3.8576153e-01\n    -9.6424848e-02 -3.9696163e-01]\n   [ 1.2572408e-01  6.3612902e-01 -3.9554062e-01 -6.9735396e-01\n    -9.1898698e-01 -1.9609968e-01]\n   [-1.1587460e+00  2.4605224e+00 -1.5497679e+00  1.3020347e-01\n    -8.1293899e-01 -7.8803545e-01]\n   [ 1.4323474e+00  1.3618395e+00  9.8975077e-02 -1.1307785e-01\n     7.2035044e-01  2.7642491e-01]]]]\n\nY:\n [[[[-0.28534958  1.108865    1.2798511 ]\n   [ 1.6845188  -0.266332   -0.09642485]\n   [ 2.4605224   0.13020347  0.72035044]]]]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input data tensor of shape NCHW or NHWC.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output data tensor.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MaxPool1DGradient",
    "support_level": "default"
  },
  {
    "name": "MaxPool2D",
    "description": "MaxPool2D \nconsumes an input blob and applies max pooling across the the blob according to\nkernel sizes, stride sizes, pad lengths and dilation. Max pooling consists of\ntaking the maximum value of a subset of the input tensor according to the kernel\nsize and downsampling the data into the output blob for further processing. The\n`brew` module has a wrapper for this operator for use in a `ModelHelper` object.\n\nPooling layers reduce the spatial dimensionality of the input blob. Each of the\noutput blob's dimensions will reduce according to:\n\n$$dim_{out}=\\frac{dim_{in}-kernel+2*pad}{stride}+1$$\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/pool_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/pool_op.cc\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/conv_pool_op_base.h\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"MaxPool\",\n    [\"X\"],\n    [\"Y\"],\n    kernel=2,\n    stride=2,\n)\n\nworkspace.FeedBlob(\"X\", np.random.randn(1, 1, 6, 6).astype(np.float32)) // NCHW\nprint(\"X:\\n\", workspace.FetchBlob(\"X\"), \"\\n\")\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n```\n\n**Result**\n\n```\nX:\n [[[[-2.8534958e-01 -1.7719941e+00 -8.2277227e-04  1.1088650e+00\n    -2.1476576e+00 -3.5070452e-01]\n   [-9.0058845e-01 -3.0070004e-01 -1.7907504e+00 -7.1746534e-01\n     1.2798511e+00 -3.2214901e-01]\n   [ 1.5806322e+00  1.6845188e+00 -2.6633200e-01 -3.8576153e-01\n    -9.6424848e-02 -3.9696163e-01]\n   [ 1.2572408e-01  6.3612902e-01 -3.9554062e-01 -6.9735396e-01\n    -9.1898698e-01 -1.9609968e-01]\n   [-1.1587460e+00  2.4605224e+00 -1.5497679e+00  1.3020347e-01\n    -8.1293899e-01 -7.8803545e-01]\n   [ 1.4323474e+00  1.3618395e+00  9.8975077e-02 -1.1307785e-01\n     7.2035044e-01  2.7642491e-01]]]]\n\nY:\n [[[[-0.28534958  1.108865    1.2798511 ]\n   [ 1.6845188  -0.266332   -0.09642485]\n   [ 2.4605224   0.13020347  0.72035044]]]]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input data tensor of shape NCHW or NHWC.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output data tensor.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MaxPool2DGradient",
    "support_level": "default"
  },
  {
    "name": "MaxPool3D",
    "description": "MaxPool3D \nconsumes an input blob and applies max pooling across the the blob according to\nkernel sizes, stride sizes, pad lengths and dilation. Max pooling consists of\ntaking the maximum value of a subset of the input tensor according to the kernel\nsize and downsampling the data into the output blob for further processing. The\n`brew` module has a wrapper for this operator for use in a `ModelHelper` object.\n\nPooling layers reduce the spatial dimensionality of the input blob. Each of the\noutput blob's dimensions will reduce according to:\n\n$$dim_{out}=\\frac{dim_{in}-kernel+2*pad}{stride}+1$$\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/pool_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/pool_op.cc\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/conv_pool_op_base.h\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"MaxPool\",\n    [\"X\"],\n    [\"Y\"],\n    kernel=2,\n    stride=2,\n)\n\nworkspace.FeedBlob(\"X\", np.random.randn(1, 1, 6, 6).astype(np.float32)) // NCHW\nprint(\"X:\\n\", workspace.FetchBlob(\"X\"), \"\\n\")\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n```\n\n**Result**\n\n```\nX:\n [[[[-2.8534958e-01 -1.7719941e+00 -8.2277227e-04  1.1088650e+00\n    -2.1476576e+00 -3.5070452e-01]\n   [-9.0058845e-01 -3.0070004e-01 -1.7907504e+00 -7.1746534e-01\n     1.2798511e+00 -3.2214901e-01]\n   [ 1.5806322e+00  1.6845188e+00 -2.6633200e-01 -3.8576153e-01\n    -9.6424848e-02 -3.9696163e-01]\n   [ 1.2572408e-01  6.3612902e-01 -3.9554062e-01 -6.9735396e-01\n    -9.1898698e-01 -1.9609968e-01]\n   [-1.1587460e+00  2.4605224e+00 -1.5497679e+00  1.3020347e-01\n    -8.1293899e-01 -7.8803545e-01]\n   [ 1.4323474e+00  1.3618395e+00  9.8975077e-02 -1.1307785e-01\n     7.2035044e-01  2.7642491e-01]]]]\n\nY:\n [[[[-0.28534958  1.108865    1.2798511 ]\n   [ 1.6845188  -0.266332   -0.09642485]\n   [ 2.4605224   0.13020347  0.72035044]]]]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input data tensor of shape NCHW or NHWC.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output data tensor.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MaxPool3DGradient",
    "support_level": "default"
  },
  {
    "name": "MaxPoolGradient",
    "support_level": "default"
  },
  {
    "name": "Mean",
    "description": "\nElement-wise mean of an arbitrary number of input tensors. This operation can be\nperformed in-place, by using the first input blob as the output blob. All inputs\nmust have the same shape and data type, and the output will have the same shape\nas the inputs.\n\nGithub Link:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/mean_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Mean\",\n    [\"X\", \"Y\", \"Z\"],\n    [\"X\"],\n)\n\nworkspace.FeedBlob(\"X\", (np.random.rand(3,3)).astype(np.float32))\nworkspace.FeedBlob(\"Y\", (np.random.rand(3,3)).astype(np.float32))\nworkspace.FeedBlob(\"Z\", (np.random.rand(3,3)).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\nprint(\"Z:\", workspace.FetchBlob(\"Z\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Mean:\", workspace.FetchBlob(\"X\"))\n\n```\n\n**Result**\n\n```\n\nX:\n[[0.6035237  0.5305746  0.6298913 ]\n [0.9169737  0.01280353 0.16286302]\n [0.6017664  0.9946255  0.05128575]]\nY:\n[[0.07544111 0.45371833 0.08460239]\n [0.9708728  0.7422064  0.7933344 ]\n [0.97671497 0.3411384  0.73818344]]\nZ:\n[[0.08837954 0.90187573 0.46734726]\n [0.6308827  0.8719029  0.39888734]\n [0.90059936 0.92883426 0.5695987 ]]\nMean:\n[[0.25578147 0.6287229  0.39394698]\n [0.8395764  0.5423043  0.45169494]\n [0.8263602  0.75486606 0.45302266]]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<Ord>`)* List of input tensors with the same shape.",
        "name": "X, Y, ..."
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<Ord>`)* Output tensor with the same dimensions as inputs. Contains the mean values of the input tensors calculated element-wise.",
        "name": "M"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MeanGradient",
    "support_level": "default"
  },
  {
    "name": "MergeDenseFeatureTensors",
    "description": "Merge given multi-feature dense tensors  into one multi-feature tensor.\n  Single-feature representation:\n  - scalar features:\n    <feature full name> T\n  - list features:\n    <feature full name>.lengths int32\n    <feature full name>.values T\n  - map features:\n    <feature full name>.lengths int32\n    <feature full name>.keys K\n    <feature full name>.values V\n\n  Missing values are set to zero, and value presence flag is set accordingly:\n    <feature full name>.presence bool\n\n  Multi-feature representation:\n  - scalar features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values T\n  - list features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.values T\n  - map features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.keys K\n    <feature type>.values.values V\n\n  You can read more about representing batches of lists and maps here:\n  https://our.intern.facebook.com/intern/dex/caffe2/sparse-operations/\n",
    "attributes": [
      {
        "description": "feature ids",
        "name": "feature_ids",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "",
        "name": "in1"
      },
      {
        "description": ".presence",
        "name": "in1_presence"
      }
    ],
    "outputs": [
      {
        "description": ".lengths",
        "name": "out_lengths"
      },
      {
        "description": ".keys",
        "name": "out_keys"
      },
      {
        "description": ".values",
        "name": "out_values"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MergeDim",
    "description": "\nMerge first two dimensions in a single dimension with size dim(0) * dim(1).\n",
    "inputs": [
      {
        "description": "An input tensor.",
        "name": "data"
      }
    ],
    "outputs": [
      {
        "description": "Reshaped tensor.",
        "name": "reshaped"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MergeIdLists",
    "description": "\nMergeIdLists: Merge multiple ID_LISTs into a single ID_LIST.\n\nAn ID_LIST is a list of IDs (may be ints, often longs) that represents a single\nfeature. As described in https://caffe2.ai/docs/sparse-operations.html, a batch\nof ID_LIST examples is represented as a pair of lengths and values where the\n`lengths` (int32) segment the `values` or ids (int32/int64) into examples.\n\nGiven multiple inputs of the form lengths_0, values_0, lengths_1, values_1, ...\nwhich correspond to lengths and values of ID_LISTs of different features, this\noperator produces a merged ID_LIST that combines the ID_LIST features. The\nfinal merged output is described by a lengths and values vector.\n\nWARNING: The merge makes no guarantee about the relative order of ID_LISTs\nwithin a batch. This can be an issue if ID_LIST are order sensitive.\n",
    "inputs": [
      {
        "description": "Lengths of the ID_LISTs batch for first feature",
        "name": "lengths_0"
      },
      {
        "description": "Values of the ID_LISTs batch for first feature",
        "name": "values_0"
      }
    ],
    "outputs": [
      {
        "description": "Lengths of the merged ID_LISTs batch",
        "name": "merged_lengths"
      },
      {
        "description": "Values of the merged ID_LISTs batch",
        "name": "merged_values"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MergeMultiListFeatureTensors",
    "description": "Merge given multi-feature tensors with list features into one.\n  Single-feature representation:\n  - scalar features:\n    <feature full name> T\n  - list features:\n    <feature full name>.lengths int32\n    <feature full name>.values T\n  - map features:\n    <feature full name>.lengths int32\n    <feature full name>.keys K\n    <feature full name>.values V\n\n  Missing values are set to zero, and value presence flag is set accordingly:\n    <feature full name>.presence bool\n\n  Multi-feature representation:\n  - scalar features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values T\n  - list features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.values T\n  - map features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.keys K\n    <feature type>.values.values V\n\n  You can read more about representing batches of lists and maps here:\n  https://our.intern.facebook.com/intern/dex/caffe2/sparse-operations/\n",
    "inputs": [
      {
        "description": ".lengths",
        "name": "in1_lengths"
      },
      {
        "description": ".keys",
        "name": "in1_keys"
      },
      {
        "description": ".values.lengths",
        "name": "in1_values_lengths"
      },
      {
        "description": ".values.values",
        "name": "in1_values_values"
      }
    ],
    "outputs": [
      {
        "description": ".lengths",
        "name": "out_lengths"
      },
      {
        "description": ".keys",
        "name": "out_keys"
      },
      {
        "description": ".values.lengths",
        "name": "out_values_lengths"
      },
      {
        "description": ".values.values",
        "name": "out_values_values"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MergeMultiListFeatureTensorsGradient",
    "description": "Explode given multi-feature tensors with list features into many.\n  Single-feature representation:\n  - scalar features:\n    <feature full name> T\n  - list features:\n    <feature full name>.lengths int32\n    <feature full name>.values T\n  - map features:\n    <feature full name>.lengths int32\n    <feature full name>.keys K\n    <feature full name>.values V\n\n  Missing values are set to zero, and value presence flag is set accordingly:\n    <feature full name>.presence bool\n\n  Multi-feature representation:\n  - scalar features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values T\n  - list features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.values T\n  - map features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.keys K\n    <feature type>.values.values V\n\n  You can read more about representing batches of lists and maps here:\n  https://our.intern.facebook.com/intern/dex/caffe2/sparse-operations/\n",
    "inputs": [
      {
        "description": ".lengths",
        "name": "in1_lengths"
      },
      {
        "description": ".values.lengths",
        "name": "in1_values_lengths"
      },
      {
        "description": ".values.values_grad",
        "name": "out_values_values_grad"
      }
    ],
    "outputs": [
      {
        "description": ".values.values_grad",
        "name": "in1_values_values_grad"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MergeMultiMapFeatureTensors",
    "description": "Merge given multi-feature tensors with map features into one.\n  Single-feature representation:\n  - scalar features:\n    <feature full name> T\n  - list features:\n    <feature full name>.lengths int32\n    <feature full name>.values T\n  - map features:\n    <feature full name>.lengths int32\n    <feature full name>.keys K\n    <feature full name>.values V\n\n  Missing values are set to zero, and value presence flag is set accordingly:\n    <feature full name>.presence bool\n\n  Multi-feature representation:\n  - scalar features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values T\n  - list features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.values T\n  - map features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.keys K\n    <feature type>.values.values V\n\n  You can read more about representing batches of lists and maps here:\n  https://our.intern.facebook.com/intern/dex/caffe2/sparse-operations/\n",
    "inputs": [
      {
        "description": ".lengths",
        "name": "in1_lengths"
      },
      {
        "description": ".keys",
        "name": "in1_keys"
      },
      {
        "description": ".values.lengths",
        "name": "in1_values_lengths"
      },
      {
        "description": ".values.keys",
        "name": "in1_values_keys"
      },
      {
        "description": ".values.values",
        "name": "in1_values_values"
      }
    ],
    "outputs": [
      {
        "description": ".lengths",
        "name": "out_lengths"
      },
      {
        "description": ".keys",
        "name": "out_keys"
      },
      {
        "description": ".values_lengths",
        "name": "out_values_lengths"
      },
      {
        "description": ".values.keys",
        "name": "out_values_keys"
      },
      {
        "description": ".values.values",
        "name": "out_values_values"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MergeMultiMapFeatureTensorsGradient",
    "description": "Explode given multi-feature tensors with map features into many.\n  Single-feature representation:\n  - scalar features:\n    <feature full name> T\n  - list features:\n    <feature full name>.lengths int32\n    <feature full name>.values T\n  - map features:\n    <feature full name>.lengths int32\n    <feature full name>.keys K\n    <feature full name>.values V\n\n  Missing values are set to zero, and value presence flag is set accordingly:\n    <feature full name>.presence bool\n\n  Multi-feature representation:\n  - scalar features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values T\n  - list features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.values T\n  - map features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.keys K\n    <feature type>.values.values V\n\n  You can read more about representing batches of lists and maps here:\n  https://our.intern.facebook.com/intern/dex/caffe2/sparse-operations/\n",
    "inputs": [
      {
        "description": ".lengths",
        "name": "in1_lengths"
      },
      {
        "description": ".values.lengths",
        "name": "in1_values_lengths"
      },
      {
        "description": ".values.values_grad",
        "name": "out_values_values_grad"
      }
    ],
    "outputs": [
      {
        "description": ".values.values_grad",
        "name": "in1_values_values_grad"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MergeMultiScalarFeatureTensors",
    "description": "Merge given multi-feature tensors with scalar features into one.\n  Single-feature representation:\n  - scalar features:\n    <feature full name> T\n  - list features:\n    <feature full name>.lengths int32\n    <feature full name>.values T\n  - map features:\n    <feature full name>.lengths int32\n    <feature full name>.keys K\n    <feature full name>.values V\n\n  Missing values are set to zero, and value presence flag is set accordingly:\n    <feature full name>.presence bool\n\n  Multi-feature representation:\n  - scalar features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values T\n  - list features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.values T\n  - map features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.keys K\n    <feature type>.values.values V\n\n  You can read more about representing batches of lists and maps here:\n  https://our.intern.facebook.com/intern/dex/caffe2/sparse-operations/\n",
    "inputs": [
      {
        "description": ".lengths",
        "name": "in1_lengths"
      },
      {
        "description": ".keys",
        "name": "in1_keys"
      },
      {
        "description": ".values",
        "name": "in1_values"
      }
    ],
    "outputs": [
      {
        "description": ".lengths",
        "name": "out_lengths"
      },
      {
        "description": ".keys",
        "name": "out_keys"
      },
      {
        "description": ".values",
        "name": "out_values"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MergeMultiScalarFeatureTensorsGradient",
    "description": "Explode given multi-feature tensors with scalar features into many.\n  Single-feature representation:\n  - scalar features:\n    <feature full name> T\n  - list features:\n    <feature full name>.lengths int32\n    <feature full name>.values T\n  - map features:\n    <feature full name>.lengths int32\n    <feature full name>.keys K\n    <feature full name>.values V\n\n  Missing values are set to zero, and value presence flag is set accordingly:\n    <feature full name>.presence bool\n\n  Multi-feature representation:\n  - scalar features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values T\n  - list features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.values T\n  - map features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.keys K\n    <feature type>.values.values V\n\n  You can read more about representing batches of lists and maps here:\n  https://our.intern.facebook.com/intern/dex/caffe2/sparse-operations/\n",
    "inputs": [
      {
        "description": ".lengths",
        "name": "in1_lengths"
      },
      {
        "description": ".values_grad",
        "name": "out_values_grad"
      }
    ],
    "outputs": [
      {
        "description": ".values_grad",
        "name": "in1_values_grad"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MergeSingleListFeatureTensors",
    "description": "Merge given single-feature tensors with list features into one multi-feature tensor.\n  Single-feature representation:\n  - scalar features:\n    <feature full name> T\n  - list features:\n    <feature full name>.lengths int32\n    <feature full name>.values T\n  - map features:\n    <feature full name>.lengths int32\n    <feature full name>.keys K\n    <feature full name>.values V\n\n  Missing values are set to zero, and value presence flag is set accordingly:\n    <feature full name>.presence bool\n\n  Multi-feature representation:\n  - scalar features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values T\n  - list features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.values T\n  - map features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.keys K\n    <feature type>.values.values V\n\n  You can read more about representing batches of lists and maps here:\n  https://our.intern.facebook.com/intern/dex/caffe2/sparse-operations/\n",
    "attributes": [
      {
        "description": "feature ids",
        "name": "feature_ids",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": ".lengths",
        "name": "in1_lengths"
      },
      {
        "description": ".values",
        "name": "in1_values"
      },
      {
        "description": ".presence",
        "name": "in1_presence"
      }
    ],
    "outputs": [
      {
        "description": ".lengths",
        "name": "out_lengths"
      },
      {
        "description": ".keys",
        "name": "out_keys"
      },
      {
        "description": ".values.lengths",
        "name": "out_values_lengths"
      },
      {
        "description": ".values.values",
        "name": "out_values_values"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MergeSingleListFeatureTensorsGradient",
    "description": "Explode multi-feature tensors with list features into single-feature tensors.\n  Single-feature representation:\n  - scalar features:\n    <feature full name> T\n  - list features:\n    <feature full name>.lengths int32\n    <feature full name>.values T\n  - map features:\n    <feature full name>.lengths int32\n    <feature full name>.keys K\n    <feature full name>.values V\n\n  Missing values are set to zero, and value presence flag is set accordingly:\n    <feature full name>.presence bool\n\n  Multi-feature representation:\n  - scalar features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values T\n  - list features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.values T\n  - map features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.keys K\n    <feature type>.values.values V\n\n  You can read more about representing batches of lists and maps here:\n  https://our.intern.facebook.com/intern/dex/caffe2/sparse-operations/\n",
    "inputs": [
      {
        "description": ".lengths",
        "name": "in1_lengths"
      },
      {
        "description": ".presence",
        "name": "in1_presence"
      },
      {
        "description": ".values.values_grad",
        "name": "out_values_values"
      }
    ],
    "outputs": [
      {
        "description": ".values_grad",
        "name": "out1_values"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MergeSingleMapFeatureTensors",
    "description": "Merge given single-feature tensors with map features into one multi-feature tensor.\n  Single-feature representation:\n  - scalar features:\n    <feature full name> T\n  - list features:\n    <feature full name>.lengths int32\n    <feature full name>.values T\n  - map features:\n    <feature full name>.lengths int32\n    <feature full name>.keys K\n    <feature full name>.values V\n\n  Missing values are set to zero, and value presence flag is set accordingly:\n    <feature full name>.presence bool\n\n  Multi-feature representation:\n  - scalar features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values T\n  - list features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.values T\n  - map features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.keys K\n    <feature type>.values.values V\n\n  You can read more about representing batches of lists and maps here:\n  https://our.intern.facebook.com/intern/dex/caffe2/sparse-operations/\n",
    "attributes": [
      {
        "description": "feature ids",
        "name": "feature_ids",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": ".lengths",
        "name": "in1_lengths"
      },
      {
        "description": ".keys",
        "name": "in1_keys"
      },
      {
        "description": ".values",
        "name": "in1_values"
      },
      {
        "description": ".presence",
        "name": "in1_presence"
      }
    ],
    "outputs": [
      {
        "description": ".lengths",
        "name": "out_lengths"
      },
      {
        "description": ".keys",
        "name": "out_keys"
      },
      {
        "description": ".values.lengths",
        "name": "out_values_lengths"
      },
      {
        "description": ".values.keys",
        "name": "out_values_keys"
      },
      {
        "description": ".values.values",
        "name": "out_values_values"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MergeSingleMapFeatureTensorsGradient",
    "description": "Explode given multi-feature tensors with map features into multiple single-feature tensor.\n  Single-feature representation:\n  - scalar features:\n    <feature full name> T\n  - list features:\n    <feature full name>.lengths int32\n    <feature full name>.values T\n  - map features:\n    <feature full name>.lengths int32\n    <feature full name>.keys K\n    <feature full name>.values V\n\n  Missing values are set to zero, and value presence flag is set accordingly:\n    <feature full name>.presence bool\n\n  Multi-feature representation:\n  - scalar features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values T\n  - list features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.values T\n  - map features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.keys K\n    <feature type>.values.values V\n\n  You can read more about representing batches of lists and maps here:\n  https://our.intern.facebook.com/intern/dex/caffe2/sparse-operations/\n",
    "inputs": [
      {
        "description": ".lengths",
        "name": "in1_lengths"
      },
      {
        "description": ".presence",
        "name": "in1_presence"
      },
      {
        "description": ".values.values_grad",
        "name": "out_values_values_grad"
      }
    ],
    "outputs": [
      {
        "description": ".values_grad",
        "name": "in1_values_grad"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MergeSingleScalarFeatureTensors",
    "description": "Merge given single-feature tensors with scalar features into one multi-feature tensor.\n  Single-feature representation:\n  - scalar features:\n    <feature full name> T\n  - list features:\n    <feature full name>.lengths int32\n    <feature full name>.values T\n  - map features:\n    <feature full name>.lengths int32\n    <feature full name>.keys K\n    <feature full name>.values V\n\n  Missing values are set to zero, and value presence flag is set accordingly:\n    <feature full name>.presence bool\n\n  Multi-feature representation:\n  - scalar features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values T\n  - list features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.values T\n  - map features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.keys K\n    <feature type>.values.values V\n\n  You can read more about representing batches of lists and maps here:\n  https://our.intern.facebook.com/intern/dex/caffe2/sparse-operations/\n",
    "attributes": [
      {
        "description": "feature ids",
        "name": "feature_ids",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "",
        "name": "in1"
      },
      {
        "description": ".presence",
        "name": "in1_presence"
      }
    ],
    "outputs": [
      {
        "description": ".lengths",
        "name": "out_lengths"
      },
      {
        "description": ".keys",
        "name": "out_keys"
      },
      {
        "description": ".values",
        "name": "out_values"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MergeSingleScalarFeatureTensorsGradient",
    "description": "Explode multi-feature tensor of scalar features into one or moresingle-feature tensors\n  Single-feature representation:\n  - scalar features:\n    <feature full name> T\n  - list features:\n    <feature full name>.lengths int32\n    <feature full name>.values T\n  - map features:\n    <feature full name>.lengths int32\n    <feature full name>.keys K\n    <feature full name>.values V\n\n  Missing values are set to zero, and value presence flag is set accordingly:\n    <feature full name>.presence bool\n\n  Multi-feature representation:\n  - scalar features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values T\n  - list features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.values T\n  - map features:\n    <feature type>.lengths int32\n    <feature type>.keys int64\n    <feature type>.values.lengths int32\n    <feature type>.values.keys K\n    <feature type>.values.values V\n\n  You can read more about representing batches of lists and maps here:\n  https://our.intern.facebook.com/intern/dex/caffe2/sparse-operations/\n",
    "inputs": [
      {
        "description": ".presence",
        "name": "in1_presence"
      },
      {
        "description": ".values_grad",
        "name": ".values_grad"
      }
    ],
    "outputs": [
      {
        "description": "_grad of inputs",
        "name": "in1_grad"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Min",
    "description": "\nElement-wise min of an arbitrary number of input tensors. This operation can be performed in-place, by using the first input blob as the output blob. All inputs must have the same shape and data type, and the output will have the same shape as the inputs.\n\nGithub Link:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/minmax_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Min\",\n    [\"X\", \"Y\", \"Z\"],\n    [\"X\"],\n)\n\nworkspace.FeedBlob(\"X\", (np.random.rand(2,2)).astype(np.float32))\nworkspace.FeedBlob(\"Y\", (np.random.rand(2,2)).astype(np.float32))\nworkspace.FeedBlob(\"Z\", (np.random.rand(2,2)).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\nprint(\"Z:\", workspace.FetchBlob(\"Z\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Min:\", workspace.FetchBlob(\"X\"))\n\n```\n\n**Result**\n\n```\n\nX:\n[[0.32731926 0.4939747 ]\n [0.29242373 0.43460014]]\nY:\n[[0.40928316 0.916115  ]\n [0.77526504 0.29339448]]\nZ:\n[[0.7899794  0.90335774]\n [0.82599413 0.2843068 ]]\nMin:\n[[0.32731926 0.4939747 ]\n [0.29242373 0.2843068 ]]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<Ord>`)* List of input tensors with the same shape.",
        "name": "X, Y, ..."
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<Ord>`)* Output tensor with same dimensions as input(s).Contains the minimum valued element at each location.",
        "name": "M"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MinGradient",
    "support_level": "default"
  },
  {
    "name": "Mish",
    "description": "\nMish takes one input data (Tensor) and produces one output data\n(Tensor) where the Mish function, y = x * tanh(ln(1 + exp(x))), is applied to the\ntensor elementwise.\n",
    "inputs": [
      {
        "description": "1D input tensor",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "1D output tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MishGradient",
    "description": "\nMishGradient takes X, Y and dY and uses this to update dX according to the\nchain rule and derivatives of the Mish function.\n",
    "support_level": "default"
  },
  {
    "name": "Mod",
    "description": "\nElement-wise modulo operation. Each element in the output is the modulo result\nof the corresponding element in the input data. The divisor of the modulo is\nprovided by the `divisor` argument.\n\nGithub Link:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/mod_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Mod\",\n    [\"X\"],\n    [\"Y\"],\n    divisor=10\n)\n\nworkspace.FeedBlob(\"X\", (np.random.randint(100, size=(5,5))))\nprint(\"X before running op:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"X after running op:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX before running op:\n[[56 22 43 13 60]\n [ 4 55 58 10 45]\n [64 66  4  3 66]\n [10 36 47 52 78]\n [91  4 36 47 95]]\nX after running op:\n[[6 2 3 3 0]\n [4 5 8 0 5]\n [4 6 4 3 6]\n [0 6 7 2 8]\n [1 4 6 7 5]]\n\n ```\n\n </details>\n\n",
    "attributes": [
      {
        "default": 0,
        "description": "Divisor of the modulo operation (must be >= 1).",
        "name": "divisor",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": false,
        "description": "If true, sign of output matches divisor, else if false, sign follows dividend.",
        "name": "sign_follow_divisor",
        "option": "optional",
        "type": "boolean"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<int>`)* Input tensor with int32 or int64 data.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<int>`)* Output tensor of data with modulo operation applied.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Moments",
    "description": "\n  Computes the mean and variance of the input tensor's element along the\n  provided axes. The resulted tensor has the same rank as the input if keepdims\n  equals True.\n  If keepdims equals False, then the resulted tensor have the reduced dimension\n  pruned.\n",
    "attributes": [
      {
        "description": "A list of integers, along which to reduce. If axes is not provided, the op computes the element-wise mean and variance.",
        "name": "axes",
        "option": "optional"
      },
      {
        "description": "Keep the reduced dimension(s) or not, default True keeps the reduced dimension(s).",
        "name": "keepdims",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "An input tensor.",
        "name": "data"
      }
    ],
    "outputs": [
      {
        "description": "Reduced mean tensor.",
        "name": "mean"
      },
      {
        "description": "Reduced variance tensor.",
        "name": "variance"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MomentsGradient",
    "support_level": "default"
  },
  {
    "name": "MomentumSGD",
    "description": "\n\nComputes a momentum SGD update for an input gradient and momentum\nparameters. Concretely, given inputs (grad, m, lr) and parameters\n(momentum, nesterov), computes:\n\n    if not nesterov:\n        adjusted_gradient = lr * grad + momentum * m\n        return (adjusted_gradient, adjusted_gradient)\n    else:\n        m_new = momentum * m + lr * grad\n        return ((1 + momentum) * m_new - momentum * m, m_new)\n\nOutput is (grad, momentum)\n\nNote the difference to MomemtumSGDUpdate, which actually performs the\nparameter update (and is thus faster).\n",
    "support_level": "default"
  },
  {
    "name": "MomentumSGDUpdate",
    "description": "\n\nPerforms a momentum SGD update for an input gradient and momentum\nparameters. Concretely, given inputs (grad, m, lr, param) and arguments\n(momentum, nesterov), computes:\n\n    if not nesterov:\n        adjusted_gradient = lr * grad + momentum * m\n        param = param - adjusted_gradient\n        return (adjusted_gradient, adjusted_gradient, param)\n    else:\n        m_new = momentum * m + lr * grad\n        param = param - ((1 + momentum) * m_new - momentum * m),\n        return ((1 + momentum) * m_new - momentum * m, m_new, param)\n\nOutput is (grad, momentum, parameter).\n\nNote the difference to MomentumSGD, which returns a new gradient\nbut does not perform the parameter update.\n\n",
    "support_level": "default"
  },
  {
    "name": "MSRAFill",
    "support_level": "default"
  },
  {
    "name": "Mul",
    "description": "\nPerforms element-wise binary multiplication (with limited broadcast support).\n\nIf necessary the right-hand-side argument will be broadcasted to match the\nshape of left-hand-side argument. When broadcasting is specified, the second\ntensor can either be of size 1 (a scalar value), or having its shape as a\ncontiguous subset of the first tensor's shape. The starting of the mutually\nequal shape is specified by the argument \"axis\", and if it is not set, suffix\nmatching is assumed. 1-dim expansion doesn't work yet.\n\nFor example, the following tensor shapes are supported (with broadcast=1):\n```\n  shape(A) = (2, 3, 4, 5), shape(B) = (,), i.e. B is a scalar\n  shape(A) = (2, 3, 4, 5), shape(B) = (5,)\n  shape(A) = (2, 3, 4, 5), shape(B) = (4, 5)\n  shape(A) = (2, 3, 4, 5), shape(B) = (3, 4), with axis=1\n  shape(A) = (2, 3, 4, 5), shape(B) = (2), with axis=0\n```\nArgument `broadcast=1` needs to be passed to enable broadcasting.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/elementwise_ops_schema.cc\n\n\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Mul\",\n    [\"A\",  \"B\"],\n    [\"C\"],\n)\n\nworkspace.FeedBlob(\"A\", np.array([[1,2],[3,4]]))\nworkspace.FeedBlob(\"B\", np.array([[5,6],[7,8]]))\nprint(\"A:\", workspace.FetchBlob(\"A\"))\nprint(\"B:\", workspace.FetchBlob(\"B\"))\nworkspace.RunOperatorOnce(op)\nprint(\"C:\", workspace.FetchBlob(\"C\"))\n\n```\n\n**Result**\n\n```\n\nA:\n[[1 2]\n [3 4]]\nB:\n[[5 6]\n [7 8]]\nC:\n[[ 5 12]\n [21 32]]\n\n```\n\n</details>\n\n\n",
    "attributes": [
      {
        "default": 0,
        "description": "Pass 1 to enable broadcasting",
        "name": "broadcast",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": -1,
        "description": "Axis to concatenate on.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* First operand, should share the type with the second operand.",
        "name": "A"
      },
      {
        "description": "*(type: Tensor`<float>`)* Second operand. With broadcasting can be of smaller size than A. If broadcasting is disabled it should be of the same size as A.",
        "name": "B"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output tensor with same dimensions and type as A.",
        "name": "C"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "MulGradient",
    "support_level": "default"
  },
  {
    "name": "MultiClassAccuracy",
    "description": "\nRespectively compute accuracy score for each class given a number of instances\nand predicted scores of each class for each instance.\n",
    "inputs": [
      {
        "description": "2-D float tensor (N,D,) of predicted scores of each class for each data. N is the number of instances, i.e., batch size. D is number of possible classes/labels.",
        "name": "prediction"
      },
      {
        "description": "1-D int tensor (N,) of labels for each instance.",
        "name": "labels"
      }
    ],
    "outputs": [
      {
        "description": "1-D float tensor (D,) of accuracy for each class. If a class has no instance in the batch, its accuracy score is set to zero.",
        "name": "accuracies"
      },
      {
        "description": "1-D int tensor (D,) of number of instances for each class in the batch.",
        "name": "amounts"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "NanCheck",
    "description": "Identity operator, but checks all values for nan or inf",
    "inputs": [
      {
        "description": "Tensor to check for nan/inf",
        "name": "tensor"
      }
    ],
    "outputs": [
      {
        "description": "Tensor to copy input into if no NaNs or inf. Can be in-place",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "NCHW2NHWC",
    "description": "\nThe operator switches the order of data in a tensor from NCHW- sample index N,\nchannels C, height H and width W, to the NHWC order (this is for 2D images).\nIn general, this operator switches the order of data in a tensor from N C H_1\n... H_k to N H_1 ... H_k C for k-dimensional features, and currently supports\nk=1, 2, and 3.\n",
    "inputs": [
      {
        "description": "The input data (Tensor) in the NCHW order.",
        "name": "data"
      }
    ],
    "outputs": [
      {
        "description": "The output tensor (Tensor) in the NHWC order.",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "NE",
    "description": "\nPerforms element-wise not equal to comparison **!=** (with limited broadcast support).\n\n\nIf necessary the right-hand-side argument will be broadcasted to match the\nshape of left-hand-side argument. When broadcasting is specified, the second\ntensor can either be of size 1 (a scalar value), or having its shape as a\ncontiguous subset of the first tensor's shape. The starting of the mutually\nequal shape is specified by the argument \"axis\", and if it is not set, suffix\nmatching is assumed. 1-dim expansion doesn't work yet.\n\nFor example, the following tensor shapes are supported (with broadcast=1):\n```\n  shape(A) = (2, 3, 4, 5), shape(B) = (,), i.e. B is a scalar\n  shape(A) = (2, 3, 4, 5), shape(B) = (5,)\n  shape(A) = (2, 3, 4, 5), shape(B) = (4, 5)\n  shape(A) = (2, 3, 4, 5), shape(B) = (3, 4), with axis=1\n  shape(A) = (2, 3, 4, 5), shape(B) = (2), with axis=0\n```\nArgument `broadcast=1` needs to be passed to enable broadcasting.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/elementwise_ops_schema.cc\n\n\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"NE\",\n    [\"A\",  \"B\"],\n    [\"C\"],\n)\n\nworkspace.FeedBlob(\"A\", np.array([1, 5, 2, 9, 12, 3]))\nworkspace.FeedBlob(\"B\", np.array([1, 3, 4, 9, 12, 8]))\nprint(\"A:\", workspace.FetchBlob(\"A\"))\nprint(\"B:\", workspace.FetchBlob(\"B\"))\nworkspace.RunOperatorOnce(op)\nprint(\"C:\", workspace.FetchBlob(\"C\"))\n\n```\n\n**Result**\n\n```\nA: [ 1  5  2  9 12  3]\nB: [ 1  3  4  9 12  8]\nC: [False  True  True False False  True]\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 0,
        "description": "Pass 1 to enable broadcasting.",
        "name": "broadcast",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": -1,
        "description": "Axis to concatenate on. If set, defines the broadcast dimensions.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<bool>`)* First operand, should share the type with the second operand.",
        "name": "A"
      },
      {
        "description": "*(type: Tensor`<bool>`)* Second operand. With broadcasting can be of smaller size than `A`. If broadcasting is disabled it should be of the same size.",
        "name": "B"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<bool>`)* Output tensor with same dimensions as `A`.",
        "name": "C"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "NegateGradient",
    "description": "\nNegagteGradient operator in forward pass simply copies input to the\noutput, and in backward pass, flips the sign of the output gradient\n",
    "support_level": "default"
  },
  {
    "name": "Negative",
    "description": "\nComputes the element-wise negative of the input.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/negative_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Negative\",\n    [\"X\"],\n    [\"Y\"]\n)\n\nworkspace.FeedBlob(\"X\", (np.random.rand(3,3).astype(np.float32)))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n```\n\n**Result**\n\n```\nX: [[0.83296907 0.61407167 0.32562155]\n [0.59304523 0.03111175 0.29365504]\n [0.09478621 0.5424558  0.73940724]]\nY: [[-0.83296907 -0.61407167 -0.32562155]\n [-0.59304523 -0.03111175 -0.29365504]\n [-0.09478621 -0.5424558  -0.73940724]]\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* 1D input tensor.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* 1D output tensor.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "NGramFromCategorical",
    "support_level": "default"
  },
  {
    "name": "NHWC2NCHW",
    "description": "\nThe operator switches the order of data in a tensor from NHWC- sample index N,\nheight H, width H and channels C, to the NCHW order (this is for 2D images).\nIn general, this operator switches the order of data in a tensor from N H_1 ...\nH_k C to N C H_1 ... H_k for k-dimensional features, and currently supports\nk=1, 2, and 3.\n",
    "inputs": [
      {
        "description": "The input data (Tensor) in the NHWC order.",
        "name": "data"
      }
    ],
    "outputs": [
      {
        "description": "The output tensor (Tensor) in the NCHW order.",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Normalize",
    "description": "\nGiven a matrix, apply L2-normalization along the specified dimension.\n",
    "attributes": [
      {
        "description": "axis to normalize",
        "name": "axis",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "NormalizeGradient",
    "attributes": [
      {
        "description": "axis to normalize",
        "name": "axis",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "NormalizeL1",
    "description": "\nGiven a matrix, apply L1-normalization along the specified axis.\n",
    "attributes": [
      {
        "description": "axis to normalize",
        "name": "axis",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "NormalizePlanarYUV",
    "support_level": "default"
  },
  {
    "name": "Not",
    "description": "\nPerforms element-wise negation on input tensor `X`.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/elementwise_ops_schema.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n\"Not\",\n[\"X\"],\n[\"Y\"],\n)\n\nworkspace.FeedBlob(\"X\", (np.random.rand(3, 3) > 0.5))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n[[ True False False]\n[False False False]\n[ True  True  True]]\nY:\n[[False  True  True]\n[ True  True  True]\n[False False False]]\n\n```\n\n</details>\n\n    ",
    "inputs": [
      {
        "description": "*(Tensor`<bool>`)* Input tensor.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(Tensor`<bool>`)* Negated output tensor.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "NumpyTile",
    "inputs": [
      {
        "description": "The input tensor.",
        "name": "data"
      },
      {
        "description": "1-D Tensor specifying how many times to repeat each axis.",
        "name": "repeats"
      }
    ],
    "outputs": [
      {
        "description": "Tensor that will contain input replicated along the given axis.",
        "name": "tiled_data"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "OneHot",
    "description": "\nThe *OneHot* op accepts two inputs *indices* and *index_size_tensor*, and produces a single output *one_hots*.  For each index in *indices* the op creates a one-hot row in *one_hots* of length *index_size_tensor* where all entries are zero except the entry at the index is 1. The size of *one_hots* is *len(indices)* x *index_size_tensor*.\n\nGithub Links:\n\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/one_hot_ops.h\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/one_hot_ops.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"OneHot\",\n    [\"indices\", \"index_size_tensor\"],\n    [\"one_hots\"],\n)\n\nworkspace.FeedBlob(\"indices\", np.array([0,1,2,3,4]).astype(np.long))\nprint(\"indices:\\n\", workspace.FetchBlob(\"indices\"))\n\nworkspace.FeedBlob(\"index_size_tensor\", np.array([5]).astype(np.long))\nprint(\"index_size_tensor:\\n\", workspace.FetchBlob(\"index_size_tensor\"))\n\nworkspace.RunOperatorOnce(op)\nprint(\"one_hots: \\n\", workspace.FetchBlob(\"one_hots\"))\n\n```\n\n**Result**\n\n```\n\nindices:\n [0 1 2 3 4]\nindex_size_tensor:\n [5]\none_hots:\n [[1. 0. 0. 0. 0.]\n [0. 1. 0. 0. 0.]\n [0. 0. 1. 0. 0.]\n [0. 0. 0. 1. 0.]\n [0. 0. 0. 0. 1.]]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "The active index for each example in the batch.",
        "name": "indices"
      },
      {
        "description": "Scalar with the size of the index. Must be in CPU context",
        "name": "index_size_tensor"
      }
    ],
    "outputs": [
      {
        "description": "Matrix of size len(indices) x index_size",
        "name": "one_hots"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Onnxifi",
    "description": "\n    The Onnxifi operator is a black-box operator to lower the computation to Onnxifi backend\n    ",
    "attributes": [
      {
        "description": "(string default=\"\") Serialized ONNX model to be converted to backend representation",
        "name": "onnx_model",
        "option": "optional"
      },
      {
        "description": "Initialization pair indicating the mapping of the name between NetDef and ONNX model",
        "name": "initializers",
        "option": "optional"
      },
      {
        "description": "A list of key/value pairs indicating which input index to look up for real batch size for the given max output batch size",
        "name": "output_resize_hints",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ONNXWhile",
    "description": "\n*** EXPERIMENTAL. This operator is a work-in-progress. No assumption should be\nmade about the stability or correctness of this op. ***\n\nGeneric Looping construct confirming to the ONNX Loop operator spec. This loop\nhas multiple termination conditions:\n\n1. Trip count. Iteration count specified at runtime. Set by specifying the\n    input M. Optional. Set to empty string to omit. Note that a static trip\n    count (specified at graph construction time) can be specified by passing\n    in a constant node for input M.\n2. Loop termination condition. This is an input to the op that determines\n    whether to run the first interation and also a loop-carried dependency for\n    the body graph. The body graph must yield a value for the condition\n    variable, whether this input is provided or not.\n\nThis table summarizes the operating modes of this operator with equivalent\nC-style code:\n\nOperator inputs defined as (max_trip_count, condition_var). Omitted optional\ninputs are represented as empty string. Concretely, in this caffe2 op an input\nis marked as omitted by setting its 'has_{name}' argument to False.\n\n    input (\"\", \"\"):\n        for (int i=0; ; ++i) {\n          cond = ... // Note this value is ignored, but is required in the body\n        }\n\n    input (\"\", cond) // Note this is analogous to a while loop\n        bool cond = ...;\n        for (int i=0; cond; ++i) {\n          cond = ...;\n        }\n\n    input (\"\", 1) // Note this is analogous to a do-while loop\n        bool cond = true\n        for (int i=0; cond; ++i) {\n          cond = ...;\n        }\n\n    input (trip_count, \"\") // Note this is analogous to a for loop\n        int trip_count = ...\n        for (int i=0; i < trip_count; ++i) {\n          cond = ...; // ignored\n        }\n\n    input (trip_count, cond)\n        int trip_count = ...;\n        bool cond = ...;\n        for (int i=0; i < trip_count && cond; ++i) {\n          cond = ...;\n        }\n    ",
    "attributes": [
      {
        "description": "Net executed on each iteration",
        "name": "body",
        "option": "optional"
      },
      {
        "description": "Whether to use the trip count input",
        "name": "has_trip_count",
        "option": "optional"
      },
      {
        "description": "Whether to use the condition input",
        "name": "has_cond",
        "option": "optional"
      },
      {
        "description": "Whether to save the scopes across iterations, as in for backprop",
        "name": "save_scopes",
        "option": "optional"
      },
      {
        "description": "Do not create new scopes. Use this only if you're certain there will be no name collision, for example if you're converting from a fully-SSA IR",
        "name": "disable_scopes",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Number of iterations to go out to. Used if the flag has_trip_count is True.",
        "name": "max_trip_count"
      },
      {
        "name": "condition"
      },
      {
        "name": "initial",
        "option": "variadic"
      },
      {
        "description": "Dynamic condition value for the first iteration. For all subsequent iterations, the condition from the body graph is used. This input is used if the flag has_cond is true.",
        "name": "first_iter_condition"
      }
    ],
    "outputs": [
      {
        "name": "final_and_scan_outputs",
        "option": "variadic"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Or",
    "description": "\nPerforms element-wise logical operation **or** (with limited broadcast support).\nBoth input operands should be of type `bool`.\n\n\nIf necessary the right-hand-side argument will be broadcasted to match the\nshape of left-hand-side argument. When broadcasting is specified, the second\ntensor can either be of size 1 (a scalar value), or having its shape as a\ncontiguous subset of the first tensor's shape. The starting of the mutually\nequal shape is specified by the argument \"axis\", and if it is not set, suffix\nmatching is assumed. 1-dim expansion doesn't work yet.\n\nFor example, the following tensor shapes are supported (with broadcast=1):\n```\n  shape(A) = (2, 3, 4, 5), shape(B) = (,), i.e. B is a scalar\n  shape(A) = (2, 3, 4, 5), shape(B) = (5,)\n  shape(A) = (2, 3, 4, 5), shape(B) = (4, 5)\n  shape(A) = (2, 3, 4, 5), shape(B) = (3, 4), with axis=1\n  shape(A) = (2, 3, 4, 5), shape(B) = (2), with axis=0\n```\nArgument `broadcast=1` needs to be passed to enable broadcasting.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/elementwise_ops_schema.cc\n\n\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Or\",\n    [\"A\",  \"B\"],\n    [\"C\"],\n)\n\nworkspace.FeedBlob(\"A\", (np.random.rand(3, 3) > 0.5))\nworkspace.FeedBlob(\"B\", (np.random.rand(3, 3) > 0.5))\nprint(\"A:\", workspace.FetchBlob(\"A\"))\nprint(\"B:\", workspace.FetchBlob(\"B\"))\nworkspace.RunOperatorOnce(op)\nprint(\"C:\", workspace.FetchBlob(\"C\"))\n\n```\n\n**Result**\n\n```\n\nA:\n[[False  True  True]\n [False  True  True]\n [ True  True  True]]\nB:\n[[False  True False]\n [ True  True  True]\n [False  True False]]\nC:\n[[False  True  True]\n [ True  True  True]\n [ True  True  True]]\n\n```\n\n</details>\n\n    ",
    "attributes": [
      {
        "default": 0,
        "description": "Pass 1 to enable broadcasting.",
        "name": "broadcast",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": -1,
        "description": "Axis to concatenate on. If set, defines the broadcast dimensions.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<bool>`)* First operand.",
        "name": "A"
      },
      {
        "description": "*(type: Tensor`<bool>`)* Second operand. With broadcasting can be of smaller size than `A`. If broadcasting is disabled it should be of the same size.",
        "name": "B"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<bool>`)* Output tensor of booleans. Has same dimensions as input `A`.",
        "name": "C"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "PackedInt8BGRANHWCToNCHWCStylizerPreprocess",
    "support_level": "default"
  },
  {
    "name": "PackRecords",
    "description": "\nGiven a dataset under a schema specified by the `fields` argument, pack all\nthe input tensors into one, where each tensor element represents a row of data\n(batch of size 1). This format allows easier use with the rest of Caffe2\noperators.\n",
    "attributes": [
      {
        "description": "List of strings representing the string names in the formatspecified in the doc for CreateTreeCursor.",
        "name": "fields",
        "option": "optional"
      }
    ],
    "outputs": [
      {
        "description": "One dimensional tensor having a complex type of SharedTensorVectorPtr. In order to reverse it back to the original input it has to be inserted into UnPackRecordsOp.",
        "name": "tensor"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "PackRNNSequence",
    "description": "\nPack values based on the length blob. Each number from length blob represents\nthe corresponding values that need to be packed. The dimension for each pack\nis the same as the maximum number from the length blob (padding with zero is\nimplemented for smaller length value). The overall output dimension is:\nT * N * D, where T is the max number of lengths, N is the size of lengths,\nand D is the dimension of each feature value. The following example shows\nthe input and output of this operator:\n\n\nGiven:\n  values = [v1, v2, v3, v4, v5, v6, v7, v8]\n  lengths = [2, 3, 1, 2];\n\n\nOutput:\n  output = [\n    [v1, v3, v6, v7],\n    [v2, v4, 0,  v8],\n    [0,  v5, 0,  0 ],\n  ]\n\n\nOne application for this operator is the transfer data into the format that is\nused for RNN models. Note that the gradient operator of PackRNNSequence is\nUnpackRNNSequence.\n",
    "inputs": [
      {
        "description": "Data tensor, contains a sequence of features",
        "name": "values"
      },
      {
        "description": "lengths with each number representing the pack size.",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "Output tensor after packing",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "PackSegments",
    "description": "Map N dim tensor to N+1 dim based on length blob. Sequences that     are shorter than the longest sequence are padded with zeros.",
    "attributes": [
      {
        "description": "The pre-defined max_length for the packed segments",
        "name": "max_length",
        "option": "optional"
      },
      {
        "description": "Padding number in the packed segments. Use true to pad     -infinity, otherwise pad zeros",
        "name": "pad_minf",
        "option": "optional"
      },
      {
        "description": "bool whether to return presence mask, false by default",
        "name": "return_presence_mask",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "1-d int/long tensor contains the length in each of the output.",
        "name": "lengths"
      },
      {
        "description": "N dim Tensor.",
        "name": "tensor"
      }
    ],
    "outputs": [
      {
        "description": "N + 1 dim Tensorwhere dim(1) is the max length, dim(0) is the batch size.",
        "name": "packed_tensor"
      },
      {
        "description": "2 dim boolean tensor, false where packed_tensor is padded, true otherwise.",
        "name": "presence_mask"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "PadEmptySamples",
    "description": "\nPad empty field given lengths and index features,\n\nInput(0) is a blob pointing to the lengths of samples in one batch,\n[Input(1),... Input(num_fields)] a list of tensors containing the data for\neach field of the features.\n\nPadEmptySamples is thread safe.\n",
    "inputs": [
      {
        "description": "A blob containing a pointer to the lengths.",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "Tensor containing lengths with empty sample padded.",
        "name": "out_lengths"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "PadImage",
    "description": "\nPadImage pads values around the boundary of an image according to the pad\nvalues and stride sizes defined by the ConvPoolOpBase operator.\n  ",
    "inputs": [
      {
        "description": "Input data tensor from the previous operator; dimensions depend on whether the NCHW or NHWC operators are being used. For example, in the former, the input has size (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data. The corresponding permutation of dimensions is used in the latter case. ",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "Output data tensor from padding the H and W dimensions on the tensor. Dimensions will vary based on various pad and stride sizes.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "PadImageGradient",
    "support_level": "default"
  },
  {
    "name": "PairWiseLoss",
    "description": "\nOperator computes the pair wise loss between all pairs within a batch\n using the logit loss function on the difference in scores between pairs\n",
    "inputs": [
      {
        "description": "Input blob from the previous layer, which is almost always the result of a softmax operation; X is a 2D array of size N x 1where N is the batch size. For more info: D. Sculley, Large Scale Learning to Rank. https://www.eecs.tufts.edu/~dsculley/papers/large-scale-rank.pdf",
        "name": "X"
      },
      {
        "description": "Blob containing the labels used to compare the input",
        "name": "label"
      },
      {
        "description": "Optional input blob that contains the lengthsof multiple sessions. The summation of this blob must be equalto the size of blob X. If lengths blob is provided, the outputblob has the same size as lengths blob, and the cross entropyis computed within each session.",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "Output blob after the cross entropy computation",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "PairWiseLossGradient",
    "support_level": "default"
  },
  {
    "name": "Partition",
    "description": "\nSplits the input int tensor into multiple ones according to the first tensor.\n\nTakes the first input and partitions it to shards according to the remainder of\nvalues modulo the number of partitions. It requires that the first tensor is of\nintegral type. The number of partitions is derived as (num_output / num_input).\n\nIf additional inputs are present they must have the same shape as the first\ninput, optionally with extra trailing dimensions. They will be partitioned\naccordingly to the first input.\n\nOptional arg 'pack_first_input' transforms the first tensor values as\nX_ij / num_partitions.\n\nOutputs are ordered as\nX_0_part_0, X_1_part_0, ..., X_N-1_part_0, X_0_part_1, ..., X_N-1_part_K-1\n",
    "attributes": [
      {
        "description": "(int, default 0) If set, the operator transforms the first tensor values as floor(X_ij / num_partitions)",
        "name": "pack_first_input",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor containing data to be partitioned. The number of input tensors might be greater than 1 but must have the same shape as the previous tensors.",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Output Partitions. The number of output tensors has to be a multiple of the number of input tensors.",
        "name": "partitions"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Percentile",
    "description": "\n    This operator is used to find percentile representations for raw values, given a sample\n    set of raw values, labeled with their corresponding percentiles from the same distribution.\n    In particular, this operator takes as input a tensor of floats to find the percentile values\n    for, a 2D tensor of floats, where the first column of the tensor represents sampled values,\n    and the second column represents the percentile labels, and a tensor  of integers lengths.\n\n    This lengths tensor is used because the operator works on multiple sets of raw values at the same time. For\n    example, for an input:\n    original_values=[[3, 5, 3],[5, 1, 6]], lengths = [2, 1, 1], value_to_pct = [[3, 0.2], [5, 0.5], [1, 0.3], [3. 0.6]]\n\n    Our operator expects that each column i of the input tensor is sampled from distribution i. Lengths tells\n    us that the first two elements in value_to_pct are sampled from distribution 1, the next is from distribution two,\n    and the last is from distribution 3. We expect the output of our operator to give us [[0.2, 1.0, 0.6], [0.5, 0.3, 1.0]].\n\n    To calculate the percentile of an element, we check to see if its value is already mapped to\n    a percentile in value_to_pct. If so, we return that value. If not, we linearly interpolate between\n    the two closest values in value_to_pct. If the value is larger than all values in value_to_pct, we\n    return 1. If it's smaller than all the values, we return 0.\n\n",
    "inputs": [
      {
        "description": "Input 2D tensor of floats, representing the original, raw data to calculate percentiles for.",
        "name": "original_values"
      },
      {
        "description": "Sorted 2D tensor, with 2 columns. Each element in the first column is a float representing the raw value of a sample. Its corresponding element in the next column represents the percentile it maps to.",
        "name": "value_to_pct"
      },
      {
        "description": "1D tensor, representing the length of each distribution. We expect that the sum of elements of this tensor is equal to the total length of value_to_pct.",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "1D tensor of floats, with the same dimensions as the flattened input tensor. Each element of this tensor, percentile_values[i], corresponds to the percentile calculated for original_values[i].",
        "name": "percentile_values"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Perplexity",
    "description": "\nPerplexity calculates how well a probability distribution predicts a sample.\nPerplexity takes a 1-D tensor containing a batch of probabilities. Each value\nin the tensor belongs to a different sample and represents the probability of\nthe model predicting the true label for that sample. The operator returns a\nsingle (float) perplexity value for the batch.\n",
    "inputs": [
      {
        "description": "The input data as Tensor. It contains a batch oftrue label or target probabilities",
        "name": "probabilities"
      }
    ],
    "outputs": [
      {
        "description": "The output- a single (float) perplexity value for the batch",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "PiecewiseLinearTransform",
    "description": "\nPiecewiseLinearTransform takes inputs -- predictions, a 2-D or 1-D tensor\n(Tensor) of size (batch_size x prediction_dimensions). The piecewise\nlinear functions are stored in bounds, slopes and intercepts. The output tensor\nhas the same shape of input `predictions` and contains the predictions\ntransformed by the piecewise linear functions. Each column of predictions has\nits own piecewise linear transformation functions. Therefore the size of\npiecewise function parameters are pieces x prediction_dimensions, except for\nbinary predictions where only the positive prediction needs them. Note that in\neach piece, low bound is excluded while high bound is included. Also the\npiecewise linear function must be continuous.\n\nNotes\n- If the input is binary predictions (Nx2 or Nx1 tensor), set the binary arg\nto true so that one group of piecewise linear functions is needed (see\ndetails below).\n- The transform parameters (bounds, slopes, intercepts) can be passed either\nthrough args or through input blobs.\n- If we have multiple groups of piecewise linear functions, each group has the\nsame number of pieces.\n- If a prediction is out of the bounds, it is capped to the smallest or largest\nbound.\n",
    "attributes": [
      {
        "description": "1-D vector of size (prediction_dimensions x (pieces+1)) contain the upper bounds of each piece of linear function. One special case is the first bound is the lower bound of whole piecewise function and we treat it the same as the left most functions. (bounds, slopes, intercepts) can be passed through either arg or input blobs.",
        "name": "bounds",
        "option": "optional"
      },
      {
        "description": "1-D vector of size (prediction_dimensions x pieces) containing the slopes of linear function",
        "name": "slopes",
        "option": "optional"
      },
      {
        "description": "1-D vector of size (prediction_dimensions x pieces) containing the intercepts of linear function",
        "name": "intercepts",
        "option": "optional"
      },
      {
        "description": "If set true, we assume the input is a Nx1 or Nx2 tensor. If it is Nx1 tensor, it is positive predictions. If the input is Nx2 tensor, its first column is negative predictions and second column is positive and negative + positive = 1. We just need one group of piecewise linear functions for the positive predictions.",
        "name": "binary",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "2-D tensor (Tensor) of size (num_batches x num_classes) containing scores",
        "name": "predictions"
      },
      {
        "description": "See bounds in Arg. (bounds, slopes, intercepts) can be passed through either arg or input blobs.",
        "name": "bounds (optional)"
      },
      {
        "description": "See slopes in Arg. (bounds, slopes, intercepts) can be passed through either arg or input blobs.",
        "name": "slopes (optional)"
      },
      {
        "description": "See intercepts in Arg. (bounds, slopes, intercepts) can be passed through either arg or input blobs.",
        "name": "intercepts (optional)"
      }
    ],
    "outputs": [
      {
        "description": "2-D tensor (Tensor) of size (num_batches x num_classes) containing transformed predictions",
        "name": "transforms"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Pow",
    "description": "\nThe *Pow* op takes an input data tensor $X$ and an exponent parameter *exponent*, which can be a scalar or another tensor. As output, it produces a single output data tensor $Y$, where the function $f(x) = x^{exponent}$ has been applied to $X$ elementwise.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/pow_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/pow_op.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Pow\",\n    [\"X\", \"exponent\"],\n    [\"Y\"],\n    broadcast=1\n)\n\nworkspace.FeedBlob(\"X\", np.array([1,2,3,4,5,6]).astype(np.float32))\nprint(\"X: \", workspace.FetchBlob(\"X\"))\n\nworkspace.FeedBlob(\"exponent\", np.array([2]).astype(np.float32))\nprint(\"exponent: \", workspace.FetchBlob(\"exponent\"))\n\nworkspace.RunOperatorOnce(op)\nprint(\"Y: \", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:  [1. 2. 3. 4. 5. 6.]\nexponent:  [2.]\nY:  [ 1.  4.  9. 16. 25. 36.]\n\n```\n\n</details>\n\n\n",
    "attributes": [
      {
        "description": "The exponent of the power function. Do not use if setting exponent via input.",
        "name": "exponent",
        "option": "optional"
      },
      {
        "default": -1,
        "description": "",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": false,
        "description": "",
        "name": "broadcast",
        "option": "optional",
        "type": "boolean"
      }
    ],
    "inputs": [
      {
        "description": "Input data blob to be operated on.",
        "name": "X"
      },
      {
        "description": "Exponent blob containing the exponent(s) for calculation. Do not use if setting exponent via argument.",
        "name": "exponent"
      }
    ],
    "outputs": [
      {
        "description": "Output data blob with the same shape as the input.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "PRelu",
    "category": "Activation",
    "description": "\n\nThe *PRelu* op takes input data tensor $X$, an input slope tensor $slope$, and produces one output tensor $Y$ of the same shape as $X.$ The op performs the element wise *PRelu* operation, defined as\n\n$$y=prelu(x) =\\begin{cases}slope * x & x < 0\\\\x & otherwise\\end{cases}$$\n\nNote, is slope is size 1, the value is shared across the channels, otherwise $X$ and $slope$ must be the same shape. See [Delving Deep into Rectifiers: Surpassing Human-Level Performance on ImageNet Classification](https://arxiv.org/abs/1502.01852) for more information.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/prelu_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/prelu_op.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"PRelu\",\n    [\"X\",\"Slope\"],\n    [\"Y\"],\n)\n\nworkspace.FeedBlob(\"X\", np.random.randn(3, 3).astype(np.float32))\nprint(\"X:\\n\", workspace.FetchBlob(\"X\"), \"\\n\")\n\nworkspace.FeedBlob(\"Slope\", np.array([0.1]).astype(np.float32))\nprint(\"Slope:\\n\", workspace.FetchBlob(\"Slope\"), \"\\n\")\n\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n [[ 0.3957382  -0.19725518 -0.26991343]\n [ 1.5513182  -0.27427664 -0.14584002]\n [-0.4121164   0.9292345   0.96426094]]\n\nSlope:\n [0.1]\n\nY:\n [[ 0.3957382  -0.01972552 -0.02699134]\n [ 1.5513182  -0.02742766 -0.014584  ]\n [-0.04121164  0.9292345   0.96426094]]\n\n```\n\n</details>\n\n\n",
    "inputs": [
      {
        "description": "Input tensor of data to be operated on.",
        "name": "X"
      },
      {
        "description": "1D input slope tensor. If `Slope` is of size 1, the value is shared across different channels",
        "name": "Slope"
      }
    ],
    "outputs": [
      {
        "description": "Output tensor, with same shape as $X$.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "PReluGradient",
    "description": "\n\nPReluGradient takes both Y and dY and uses this to update dX and dW according\nto the chain rule and derivatives of the rectified linear function.\n\n",
    "support_level": "default"
  },
  {
    "name": "PrependDim",
    "description": "\nReshape the tensor by prepending a dimension of fixed size and dividing the\nsize of the next dimension by that amount.\n",
    "attributes": [
      {
        "description": "Size of the dimension to prepend.",
        "name": "dim_size",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "An input tensor.",
        "name": "data"
      }
    ],
    "outputs": [
      {
        "description": "Reshaped tensor.",
        "name": "reshaped"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Print",
    "description": "Logs shape and contents of input tensor to stderr or to a file.",
    "attributes": [
      {
        "description": "(bool) if 1, saves contents to the root folder of the current workspace, appending the tensor contents to a file named after the blob name. Otherwise, logs to stderr.",
        "name": "to_file",
        "option": "optional"
      },
      {
        "description": "(int, default 0) If set, prints the first `limit` elements of tensor. If 0, prints the first `k_limit_default`(1000) elements of tensor",
        "name": "limit",
        "option": "optional"
      },
      {
        "description": "(int, default 1) Print tensor every `every_n` runs",
        "name": "every_n",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "The tensor to print.",
        "name": "tensor"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Python",
    "support_level": "default"
  },
  {
    "name": "PythonDLPack",
    "support_level": "default"
  },
  {
    "name": "PythonDLPackGradient",
    "support_level": "default"
  },
  {
    "name": "PythonGradient",
    "support_level": "default"
  },
  {
    "name": "QuantDecode",
    "description": "\nDecode inputs using codebook. This is a general LUT operator that returns\ntensors with values from codebook (input 0) based on given indices in\ncodes (input 1 ~ n).\n\n\nExample:\n\n\nInput:\n  codebook = [1.5, 2.5, 3.5]\n  codes_0 = [0, 1, 1, 2]\n  codes_1 = [2, 0, 0]\n\n\nOutput:\n  decoded_0 = [1.5, 2.5, 2.5, 3.5]\n  decoded_1 = [3.5, 1.5, 1.5]\n",
    "inputs": [
      {
        "description": "Codebook in 1d tensor (float)",
        "name": "codebook"
      },
      {
        "description": "Encoded codes 0 (uint8/uint16/int32)",
        "name": "codes_0"
      },
      {
        "description": "Encoded codes 1 if existed (uint8/uint16/int32)",
        "name": "codes_1"
      },
      {
        "description": "Encoded codes n if existed (uint8/uint16/int32)",
        "name": "codes_n"
      }
    ],
    "outputs": [
      {
        "description": "Decoded tensor for codes_0 (float)",
        "name": "decoded_0"
      },
      {
        "description": "Decoded tensor for codes_1 (float)",
        "name": "decoded_1"
      },
      {
        "description": "Decoded tensor for codes_n (float)",
        "name": "decoded_n"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "QuantDecodeGradient",
    "support_level": "default"
  },
  {
    "name": "Quantile",
    "description": "\n    Calculate the quantile for the value in the given list of tensors.\n",
    "attributes": [
      {
        "description": "If true (default), apply abs() on the tensor values.",
        "name": "abs",
        "option": "optional"
      },
      {
        "description": "multiplicative tolerance of the quantile_value.",
        "name": "tol",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* List of input tensors.",
        "name": "X1, X2, ..."
      }
    ],
    "outputs": [
      {
        "description": "Value at the given quantile",
        "name": "quantile_value"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Range",
    "description": "\nGenerates an output tensor within the half-open interval $[start, stop)$ (the interval including start but excluding stop).\n- The `start` input is optional, and defaults to 0 when not set.\n- The `step` input is optional, and defaults to 1 when not set.\n- The type of the `output` tensor is determined by the types of inputs used.\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/utility_ops.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/utility_ops.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Range\",\n    [\"start\", \"stop\", \"step\"],\n    [\"output\"]\n)\n\nworkspace.FeedBlob(\"start\", np.array(4, dtype=np.int32))\nworkspace.FeedBlob(\"stop\", np.array(17, dtype=np.int32))\nworkspace.FeedBlob(\"step\", np.array(2, dtype=np.int32))\nprint(\"start:\", workspace.FetchBlob(\"start\"))\nprint(\"stop:\", workspace.FetchBlob(\"stop\"))\nprint(\"step:\", workspace.FetchBlob(\"step\"))\nworkspace.RunOperatorOnce(op)\nprint(\"output:\", workspace.FetchBlob(\"output\"))\n\n```\n\n**Result**\n\n```\n\nstart: 4\nstop: 17\nstep: 2\noutput: [ 4  6  8 10 12 14 16]\n\n```\n\n</details>\n        ",
    "inputs": [
      {
        "description": "(*Tensor*): [OPTIONAL] scalar or 1-element tensor containing the start of the interval (inclusive) (default=0)",
        "name": "start"
      },
      {
        "description": "(*Tensor*): scalar or 1-element tensor containing the end of the interval (exclusive)",
        "name": "stop"
      },
      {
        "description": "(*Tensor*): [OPTIONAL] scalar or 1-element tensor specifying the spacing between values (default=1)",
        "name": "step"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor*): 1D tensor of same type as inputs that contains the sequence",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "RangeFill",
    "support_level": "default"
  },
  {
    "name": "ReadNextBatch",
    "description": "\nRead the next batch of examples out of the given cursor and data blobs.\n\nInput(0) is a blob pointing to a TreeCursor, and\n[Input(1),... Input(num_fields)] a list of tensors containing the data for\neach field of the dataset.\n\nReadNextBatch is thread safe.\n",
    "attributes": [
      {
        "description": "Number of top-level entries to read.",
        "name": "batch_size",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "A blob containing a pointer to the cursor.",
        "name": "cursor"
      },
      {
        "description": "First dataset field",
        "name": "dataset_field_0"
      }
    ],
    "outputs": [
      {
        "description": "Tensor containing the next batch for field 0.",
        "name": "field_0"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ReadRandomBatch",
    "description": "\nRead the next batch of examples out of the given cursor,\nidx blob, offset matrix and data blobs.\n\nInput(0) is a blob pointing to a TreeCursor,\nInput(1) is a blob pointing to the shuffled idx\nInput(2) is a blob pointing to the offset matrix and\n[Input(3),... Input(num_fields)] a list of tensors containing the data for\neach field of the dataset.\n\nReadRandomBatch is thread safe.\n",
    "attributes": [
      {
        "description": "Number of top-level entries to read.",
        "name": "batch_size",
        "option": "optional"
      },
      {
        "description": "(bool) Repeat the dataset indefinitely",
        "name": "loop_over",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "A blob containing a pointer to the cursor.",
        "name": "cursor"
      },
      {
        "description": "idx with a shuffled order.",
        "name": "idx"
      },
      {
        "description": "offset matrix containing length offset info.",
        "name": "offsetsmat"
      },
      {
        "description": "First dataset field",
        "name": "dataset_field_0"
      }
    ],
    "outputs": [
      {
        "description": "Tensor containing the next batch for field 0.",
        "name": "field_0"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ReceiveTensor",
    "description": "\nReceives the tensor from another node.\n",
    "attributes": [
      {
        "description": "(int) he rank to receive the tensor from.",
        "name": "src",
        "option": "optional"
      },
      {
        "description": "(int) a tag to receive the tensor with.",
        "name": "tag",
        "option": "optional"
      },
      {
        "description": "(bool) if set, only send the content and assume that the receiver has already known the tensor's shape and information.",
        "name": "raw_buffer",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "The common world.",
        "name": "comm_world"
      },
      {
        "description": "In-place output. If raw_buffer is specified, Y should have pre-allocated data and type..",
        "name": "Y"
      },
      {
        "description": "An int CPUtensor of size 1 specifying the rank. If given, this overrides the 'from' argument of the op.",
        "name": "src"
      },
      {
        "description": "An int CPUtensor of size 1 specifying the tag to send the tensor with. This overrides the 'tag' argument of the op.",
        "name": "tag"
      }
    ],
    "outputs": [
      {
        "description": "The received tensor.",
        "name": "Y"
      },
      {
        "description": "The sender that sent the message as a CPUTensor of size 1 and of type int.",
        "name": "src"
      },
      {
        "description": "The tag that the message is sent with as a CPUTensor of size 1 and of type int.",
        "name": "tag"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Reciprocal",
    "description": "\nPerforms element-wise reciprocal ($\\1/x$) of input tensor $X$.\n\nGithub Link:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/reciprocal_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Reciprocal\",\n    [\"X\"],\n    [\"Y\"],\n)\n\nworkspace.FeedBlob(\"X\", (np.random.randint(10, size=(3,3))).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n[[8. 3. 3.]\n [4. 0. 0.]\n [1. 2. 5.]]\nY:\n[[0.125 0.3333333  0.3333333 ]\n [0.25  inf        inf       ]\n [1     0.5        0.2       ]]\n\n```\n\n</details>\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input data tensor.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output tensor.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ReciprocalGradient",
    "support_level": "default"
  },
  {
    "name": "RecurrentNetwork",
    "description": "\nRun the input network in a recurrent fashion. This can be used to\nimplement fairly general recurrent neural networks (RNNs).\n\nThe operator proceeds as follows.\n\n- First, initialized the states from the input recurrent states\n- For each timestep T, apply the links (that map offsets from input/output\ntensors into the inputs/outputs for the `step` network)\n- Finally, alias the recurrent states to the specified output blobs.\n\nThis is a fairly special-case meta-operator, and so the implementation\nis somewhat complex. It trades of generality (and frankly usability)\nagainst performance and control (compared to e.g. TF\ndynamic_rnn, Theano scan, etc).\n\nSee the usage examples for a flavor of how to use it.\n",
    "support_level": "default"
  },
  {
    "name": "RecurrentNetworkBlobFetcher",
    "description": "\nRetrieves blobs from scratch workspaces (which contain intermediate recurrent\nnetwork computation for each timestep) and puts them in the global\nworkspace under CPUContext.\n",
    "attributes": [
      {
        "description": "Prefix string to prepend extracted blobs.",
        "name": "prefix",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Name of scratch workspace blob returned by recurrent network.",
        "name": "ScratchWorkspaceBlob"
      }
    ],
    "outputs": [
      {
        "description": "1D tensor of strings containing extracted blob names.",
        "name": "blob_names"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "RecurrentNetworkGradient",
    "support_level": "default"
  },
  {
    "name": "Reduce",
    "description": "\nDoes a reduce operation from every node to the root node. Currently only\nSum is supported.\n",
    "attributes": [
      {
        "description": "(int, default 0) the root to run reduce into.",
        "name": "root",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "The common world.",
        "name": "comm_world"
      },
      {
        "description": "A tensor to be reduced.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "The reduced result on root, not set for other nodes.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ReduceBackMax",
    "description": "\nReduces the input tensor along the last dimension of the by applying **max**.\n\nCan reduce more than one of the \"last\" dimensions by setting `num_reduce_dim`.\n\nA second (optional) input, `lengths`, can be passed, which enforces that only a subset of the elements are considered in the max operation.\n- If input tensor `X` has shape $(d_0, d_1, d_2, ..., d_n)$, `lengths` must have shape $(d_0 * d_1 * d_2 * ... * d_{n-1})$.\n- The values of the `lengths` tensor determine how many of the values to consider for each vector in the $d_{n-1}$ dimension.\n\nFor example if $X = [[1,5,2,9],[4,1,8,2],[2,7,0,3]]$ and $lengths = [2,3,1]$, then $Y = [max(1,5), max(4,1,8), max(2)] = [5, 8, 2]$\n\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/reduce_front_back_max_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"ReduceBackMax\",\n    [\"X\"],\n    [\"Y\"],\n    num_reduce_dim=2\n)\n\nworkspace.FeedBlob(\"X\", np.random.randint(10, size=(1,2,3,3)).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n[[[[2. 5. 1.]\n   [6. 1. 9.]\n   [8. 5. 9.]]\n\n  [[5. 7. 8.]\n   [9. 9. 6.]\n   [6. 5. 0.]]]]\nY: [[9. 9.]]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "(*int*): number of dimensions to reduce (default=1)",
        "name": "num_reduce_dims",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "(*Tensor`<float>`*): input tensor",
        "name": "X"
      },
      {
        "description": "(*Tensor`<int>`*): number of elements in each sample",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor`<float>`*): reduced tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ReduceBackMaxGradient",
    "support_level": "default"
  },
  {
    "name": "ReduceBackMean",
    "description": "\nReduces the input tensor along the last dimension of the by applying **mean**.\n\nCan reduce more than one of the \"last\" dimensions by setting `num_reduce_dim`.\n\nA second (optional) input, `lengths`, can be passed, which enforces that only a subset of the elements are considered in the mean operation.\n- If input tensor `X` has shape $(d_0, d_1, d_2, ..., d_n)$, `lengths` must have shape $(d_0 * d_1 * d_2 * ... * d_{n-1})$.\n- The values of the `lengths` tensor determine how many of the values to consider for each vector in the $d_{n-1}$ dimension.\n\nFor example if $X = [[1,5,2,9],[4,1,8,2],[2,7,0,3]]$ and $lengths = [2,3,1]$, then $Y = [mean(1,5), mean(4,1,8), mean(2)] = [3, 4.333, 2]$\n\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/reduce_front_back_mean_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"ReduceBackMean\",\n    [\"X\"],\n    [\"Y\"],\n    num_reduce_dim=2\n)\n\nworkspace.FeedBlob(\"X\", np.random.randint(10, size=(1,2,3,3)).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n[[[[5. 9. 0.]\n   [8. 4. 0.]\n   [2. 2. 4.]]\n\n  [[9. 0. 9.]\n   [7. 9. 7.]\n   [1. 0. 2.]]]]\nY: [[3.7777777 4.888889 ]]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "(*int*): number of dimensions to reduce (default=1)",
        "name": "num_reduce_dims",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "(*Tensor`<float>`*): input tensor",
        "name": "X"
      },
      {
        "description": "(*Tensor`<int>`*): number of elements in each sample",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor`<float>`*): reduced tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ReduceBackMeanGradient",
    "support_level": "default"
  },
  {
    "name": "ReduceBackSum",
    "description": "\nReduces the input tensor along the last dimension of the by applying **sum**.\n\nCan reduce more than one of the \"last\" dimensions by setting `num_reduce_dim`.\n\nA second (optional) input, `lengths`, can be passed, which enforces that only a subset of the elements are considered in the sum operation.\n- If input tensor `X` has shape $(d_0, d_1, d_2, ..., d_n)$, `lengths` must have shape $(d_0 * d_1 * d_2 * ... * d_{n-1})$.\n- The values of the `lengths` tensor determine how many of the values to consider for each vector in the $d_{n-1}$ dimension.\n\nFor example if $X = [[1,5,2,9],[4,1,8,2],[2,7,0,3]]$ and $lengths = [2,3,1]$, then $Y = [sum(1,5), sum(4,1,8), sum(2)] = [6, 13, 2]$\n\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/reduce_front_back_sum_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"ReduceBackSum\",\n    [\"X\"],\n    [\"Y\"],\n    num_reduce_dim=2\n)\n\nworkspace.FeedBlob(\"X\", np.random.randint(10, size=(1,2,3,3)).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n[[[[2. 7. 7.]\n   [1. 1. 0.]\n   [9. 7. 2.]]\n\n  [[6. 6. 4.]\n   [1. 2. 6.]\n   [6. 6. 3.]]]]\nY: [[36. 40.]]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "(*int*): number of dimensions to reduce (default=1)",
        "name": "num_reduce_dims",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "(*Tensor`<float>`*): input tensor",
        "name": "X"
      },
      {
        "description": "(*Tensor`<int>`*): number of elements in each sample",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor`<float>`*): reduced tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ReduceBackSumGradient",
    "support_level": "default"
  },
  {
    "name": "ReduceFrontMax",
    "description": "\nReduces the input tensor along the last dimension of the by applying **max**.\n\nCan reduce more than one of the \"first\" dimensions by setting `num_reduce_dim`.\n\nA second (optional) input, `lengths`, can be passed, which enforces that only a subset of the elements are considered in the max operation.\n- If input tensor `X` has shape $(d_0, d_1, d_2, ..., d_n)$, `lengths` must have shape $(d_1 * d_2 * ... * d_{n})$.\n- The values of the `lengths` tensor determine how many of the values to consider for each vector in the $d_{0}$ dimension.\n\nFor example if $X = [[1,5,2,9],[4,1,8,2],[2,7,0,3]]$ and $lengths = [2,3,1,2]$, then $Y = [max(1,4), max(5,1,7), max(2), max(9,2)] = [4, 7, 2, 9]$\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/reduce_front_back_max_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"ReduceFrontMax\",\n    [\"X\"],\n    [\"Y\"],\n    num_reduce_dim=2\n)\n\nworkspace.FeedBlob(\"X\", np.random.randint(10, size=(2,3,3)).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n[[[2. 8. 1.]\n  [9. 6. 6.]\n  [7. 7. 0.]]\n\n [[4. 3. 9.]\n  [9. 2. 7.]\n  [6. 4. 7.]]]\nY: [9. 8. 9.]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "(*int*): number of dimensions to reduce (default=1)",
        "name": "num_reduce_dims",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "(*Tensor`<float>`*): input tensor",
        "name": "X"
      },
      {
        "description": "(*Tensor`<int>`*): number of elements in each sample",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor`<float>`*): reduced tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ReduceFrontMaxGradient",
    "support_level": "default"
  },
  {
    "name": "ReduceFrontMean",
    "description": "\nReduces the input tensor along the last dimension of the by applying **mean**.\n\nCan reduce more than one of the \"first\" dimensions by setting `num_reduce_dim`.\n\nA second (optional) input, `lengths`, can be passed, which enforces that only a subset of the elements are considered in the mean operation.\n- If input tensor `X` has shape $(d_0, d_1, d_2, ..., d_n)$, `lengths` must have shape $(d_1 * d_2 * ... * d_{n})$.\n- The values of the `lengths` tensor determine how many of the values to consider for each vector in the $d_{0}$ dimension.\n\nFor example if $X = [[1,5,2,9],[4,1,8,2],[2,7,0,3]]$ and $lengths = [2,3,1,2]$, then $Y = [mean(1,4), mean(5,1,7), mean(2), mean(9,2)] = [2.5, 4.333, 2, 5.5]$\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/reduce_front_back_mean_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"ReduceFrontMean\",\n    [\"X\"],\n    [\"Y\"],\n    num_reduce_dim=2\n)\n\nworkspace.FeedBlob(\"X\", np.random.randint(10, size=(2,3,3)).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n[[[5. 0. 9.]\n  [4. 1. 1.]\n  [9. 0. 8.]]\n\n [[2. 6. 7.]\n  [6. 2. 6.]\n  [0. 4. 5.]]]\nY: [4.3333335    2.1666667     6.]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "(*int*): number of dimensions to reduce (default=1)",
        "name": "num_reduce_dims",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "(*Tensor`<float>`*): input tensor",
        "name": "X"
      },
      {
        "description": "(*Tensor`<int>`*): number of elements in each sample",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor`<float>`*): reduced tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ReduceFrontMeanGradient",
    "support_level": "default"
  },
  {
    "name": "ReduceFrontSum",
    "description": "\nReduces the input tensor along the last dimension of the by applying **sum**.\n\nCan reduce more than one of the \"first\" dimensions by setting `num_reduce_dim`.\n\nA second (optional) input, `lengths`, can be passed, which enforces that only a subset of the elements are considered in the sum operation.\n- If input tensor `X` has shape $(d_0, d_1, d_2, ..., d_n)$, `lengths` must have shape $(d_1 * d_2 * ... * d_{n})$.\n- The values of the `lengths` tensor determine how many of the values to consider for each vector in the $d_{0}$ dimension.\n\nFor example, if $X = [[1,5,2,9],[4,1,8,2],[2,7,0,3]]$ and $lengths = [2,3,1,2]$, then $Y = [sum(1,4), sum(5,1,7), sum(2), sum(9,2)] = [2.5, 4.333, 2, 5.5]$\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/reduce_front_back_sum_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"ReduceFrontSum\",\n    [\"X\"],\n    [\"Y\"],\n    num_reduce_dim=2\n)\n\nworkspace.FeedBlob(\"X\", np.random.randint(10, size=(2,3,3)).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n[[[4. 1. 1.]\n  [0. 6. 7.]\n  [7. 8. 6.]]\n\n [[5. 7. 7.]\n  [0. 1. 6.]\n  [2. 9. 0.]]]\nY: [18. 32. 27.]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "(*int*): number of dimensions to reduce (default=1)",
        "name": "num_reduce_dims",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "(*Tensor`<float>`*): input tensor",
        "name": "X"
      },
      {
        "description": "(*Tensor`<int>`*): number of elements in each sample",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor`<float>`*): reduced tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ReduceFrontSumGradient",
    "support_level": "default"
  },
  {
    "name": "ReduceFrontWeightedSum",
    "description": "\nReduces the input tensor along the first dimension of the input tensor by\napplying 'WeightedSum'. This op acts in a similar way to SortedSegmentWeightedSum and\nUnsortedSegmentWeightedSum but as if all input slices belong to a single segment.\n\nInput slices are first scaled by SCALARS and then summed element-wise. It doesn't change the shape of the individual blocks.\n  ",
    "attributes": [
      {
        "description": "Produce also gradient for `weights`. For now it's only supported in `Lengths`-based operators",
        "name": "grad_on_weights",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor for the summation",
        "name": "DATA"
      },
      {
        "description": "Scalar multipliers for the input slices. Must be a vector with the length matching the number of slices",
        "name": "SCALARS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated tensor",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ReduceFrontWeightedSumGradient",
    "support_level": "default"
  },
  {
    "name": "ReduceL1",
    "description": "\nComputes the **L1 norm** of the input tensor's elements along the provided `axes`. The resulting tensor has the same rank as the input if the `keepdims` argument equals 1 (default). If `keepdims` is set to 0, then the `axes` dimensions are pruned.\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/reduce_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"ReduceL1\",\n    [\"X\"],\n    [\"Y\"],\n    axes=(0,1),\n    keepdims=0\n)\n\nworkspace.FeedBlob(\"X\", np.random.randint(10, size=(1,2,5,5)).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n[[[[ 2.  7.  6.  4.  5.]\n   [ 2.  1.  9.  8.  7.]\n   [ 4.  9.  1.  0.  0.]\n   [ 6.  4.  0.  8.  1.]\n   [ 1.  7.  1.  0.  2.]]\n\n  [[ 5.  8.  1.  7.  7.]\n   [ 4.  5.  6.  5.  4.]\n   [ 1.  9.  6.  6.  3.]\n   [ 6.  6.  8.  8.  4.]\n   [ 2.  3.  5.  8.  1.]]]]\n\nY:\n[[  7.  15.   7.  11.  12.]\n [  6.   6.  15.  13.  11.]\n [  5.  18.   7.   6.   3.]\n [ 12.  10.   8.  16.   5.]\n [  3.  10.   6.   8.   3.]]\n\n```\n\n</details>\n\n\n",
    "attributes": [
      {
        "description": "(*Tuple(int)*): list of axes to reduce",
        "name": "axes",
        "option": "optional"
      },
      {
        "description": "(*int*): set to 1 to keep the reduced dimension(s) (default=1), else set to 0 to not keep the reduced dimension(s)",
        "name": "keepdims",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "(*Tensor`<float>`*): input tensor",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor`<float>`*): reduced tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ReduceL1Gradient",
    "support_level": "default"
  },
  {
    "name": "ReduceL2",
    "description": "\nComputes the **L2 norm** of the input tensor's elements along the provided `axes`. The resulting tensor has the same rank as the input if the `keepdims` argument equals 1 (default). If `keepdims` is set to 0, then the `axes` dimensions are pruned.\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/reduce_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"ReduceL2\",\n    [\"X\"],\n    [\"Y\"],\n    axes=(0,1),\n    keepdims=0\n)\n\nworkspace.FeedBlob(\"X\", np.random.randint(10, size=(1,2,5,5)).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n[[[[ 8.  0.  2.  5.  1.]\n   [ 1.  3.  0.  4.  0.]\n   [ 1.  3.  6.  7.  7.]\n   [ 6.  9.  8.  4.  6.]\n   [ 6.  1.  5.  7.  3.]]\n\n  [[ 2.  4.  6.  2.  8.]\n   [ 1.  1.  8.  0.  8.]\n   [ 5.  9.  0.  3.  2.]\n   [ 1.  7.  3.  7.  3.]\n   [ 6.  8.  9.  8.  7.]]]]\n\nY:\n[[  8.24621105   4.           6.3245554    5.38516474   8.06225777]\n [  1.41421354   3.1622777    8.           4.           8.        ]\n [  5.09901953   9.48683262   6.           7.6157732    7.28010988]\n [  6.08276272  11.40175438   8.54400349   8.06225777   6.70820379]\n [  8.48528099   8.06225777  10.29563046  10.63014603   7.6157732 ]]\n\n```\n\n</details>\n\n\n",
    "attributes": [
      {
        "description": "(*Tuple(int)*): list of axes to reduce",
        "name": "axes",
        "option": "optional"
      },
      {
        "description": "(*int*): set to 1 to keep the reduced dimension(s) (default=1), else set to 0 to not keep the reduced dimension(s)",
        "name": "keepdims",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "(*Tensor`<float>`*): input tensor",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor`<float>`*): reduced tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ReduceL2Gradient",
    "support_level": "default"
  },
  {
    "name": "ReduceMax",
    "description": "\n  Computes the max of the input tensor's element along the provided axes.\n  The resulted tensor has the same rank as the input if keepdims equal True.\n  If keepdims equal false, then the resulted tensor have the reduced dimension\n  pruned.\n",
    "attributes": [
      {
        "description": "A list of integers, along which to reduce.",
        "name": "axes",
        "option": "optional"
      },
      {
        "description": "Keep the reduced dimension(s) or not, default True keeps the reduced dimension(s).",
        "name": "keepdims",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "An input tensor.",
        "name": "data"
      }
    ],
    "outputs": [
      {
        "description": "Reduced output tensor.",
        "name": "reduced"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ReduceMaxGradient",
    "support_level": "default"
  },
  {
    "name": "ReduceMean",
    "description": "\nComputes the **mean** of the input tensor's elements along the provided `axes`. The resulting tensor has the same rank as the input if the `keepdims` argument equals 1 (default). If `keepdims` is set to 0, then the `axes` dimensions are pruned.\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/reduce_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"ReduceMean\",\n    [\"X\"],\n    [\"Y\"],\n    axes=(0,1),\n    keepdims=0\n)\n\nworkspace.FeedBlob(\"X\", np.random.randint(10, size=(1,2,5,5)).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n[[[[9. 0. 3. 6. 0.]\n   [3. 4. 5. 0. 9.]\n   [6. 9. 1. 1. 5.]\n   [6. 2. 3. 7. 7.]\n   [3. 1. 1. 0. 1.]]\n\n  [[4. 3. 9. 8. 1.]\n   [8. 2. 0. 4. 0.]\n   [8. 9. 9. 0. 2.]\n   [7. 2. 5. 8. 9.]\n   [5. 9. 1. 9. 0.]]]]\nY:\n[[6.5 1.5 6.  7.  0.5]\n [5.5 3.  2.5 2.  4.5]\n [7.  9.  5.  0.5 3.5]\n [6.5 2.  4.  7.5 8. ]\n [4.  5.  1.  4.5 0.5]]\n\n```\n\n</details>\n\n\n",
    "attributes": [
      {
        "description": "(*Tuple(int)*): list of axes to reduce",
        "name": "axes",
        "option": "optional"
      },
      {
        "description": "(*int*): set to 1 to keep the reduced dimension(s) (default=1), else set to 0 to not keep the reduced dimension(s)",
        "name": "keepdims",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "(*Tensor`<float>`*): input tensor",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor`<float>`*): reduced tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ReduceMeanGradient",
    "support_level": "default"
  },
  {
    "name": "ReduceMin",
    "description": "\n  Computes the min of the input tensor's element along the provided axes.\n  The resulted tensor has the same rank as the input if keepdims equal True.\n  If keepdims equal false, then the resulted tensor have the reduced dimension\n  pruned.\n",
    "attributes": [
      {
        "description": "A list of integers, along which to reduce.",
        "name": "axes",
        "option": "optional"
      },
      {
        "description": "Keep the reduced dimension(s) or not, default True keeps the reduced dimension(s).",
        "name": "keepdims",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "An input tensor.",
        "name": "data"
      }
    ],
    "outputs": [
      {
        "description": "Reduced output tensor.",
        "name": "reduced"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ReduceMinGradient",
    "support_level": "default"
  },
  {
    "name": "ReduceScatter",
    "description": "\nDoes reduce-scatter operation among the nodes. Currently only Sum is supported.\n",
    "inputs": [
      {
        "description": "The common world.",
        "name": "comm_world"
      },
      {
        "description": "A tensor to be reduce-scattered.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "The reduced tensor, scattered on all nodes.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ReduceSum",
    "description": "\nComputes the **sum** of the input tensor's elements along the provided `axes`. The resulting tensor has the same rank as the input if the `keepdims` argument equals 1 (default). If `keepdims` is set to 0, then the `axes` dimensions are pruned.\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/reduce_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"ReduceSum\",\n    [\"X\"],\n    [\"Y\"],\n    axes=(0,1),\n    keepdims=0\n)\n\nworkspace.FeedBlob(\"X\", np.random.randint(10, size=(1,2,5,5)).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n[[[[5. 3. 7. 9. 5.]\n   [4. 5. 1. 8. 3.]\n   [1. 0. 9. 7. 6.]\n   [7. 5. 0. 3. 1.]\n   [6. 4. 4. 8. 3.]]\n\n  [[8. 9. 6. 7. 7.]\n   [5. 5. 4. 7. 0.]\n   [9. 7. 6. 6. 7.]\n   [7. 5. 2. 4. 2.]\n   [4. 5. 1. 9. 4.]]]]\nY:\n[[13. 12. 13. 16. 12.]\n [ 9. 10.  5. 15.  3.]\n [10.  7. 15. 13. 13.]\n [14. 10.  2.  7.  3.]\n [10.  9.  5. 17.  7.]]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "(*Tuple(int)*): list of axes to reduce",
        "name": "axes",
        "option": "optional"
      },
      {
        "description": "(*int*): set to 1 to keep the reduced dimension(s) (default=1), else set to 0 to not keep the reduced dimension(s)",
        "name": "keepdims",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "(*Tensor`<float>`*): input tensor",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor`<float>`*): reduced tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ReduceSumGradient",
    "support_level": "default"
  },
  {
    "name": "ReduceTailSum",
    "description": "\nReduce the tailing dimensions\n",
    "inputs": [
      {
        "description": "The matrix",
        "name": "mat"
      }
    ],
    "outputs": [
      {
        "description": "Output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Relu",
    "category": "Activation",
    "description": "\nApplies rectified linear unit operation to the input data element-wise. The Relu operation takes one input $X$, produces one output $Y$, and is defined as:\n\n$$Y = max(0,X)$$\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/relu_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/relu_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n  \"Relu\",\n  [\"X\"],\n  [\"Y\"]\n  )\n\nworkspace.FeedBlob(\"X\", np.random.randn(4, 4).astype(np.float32)) // NCHW\nprint(\"X:\\n\", workspace.FetchBlob(\"X\"), \"\\n\")\n\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n [[-1.4655551   0.64575136  0.7921748   0.4150579 ]\n [ 0.41085166 -0.2837964   0.9881425  -1.9300346 ]\n [ 0.39705405  0.44639114  0.9940703   0.2926532 ]\n [-0.6726489   0.01330667  1.101319    0.33858967]]\n\nY:\n [[0.         0.64575136 0.7921748  0.4150579 ]\n [0.41085166 0.         0.9881425  0.        ]\n [0.39705405 0.44639114 0.9940703  0.2926532 ]\n [0.         0.01330667 1.101319   0.33858967]]\n\n```\n\n</details>\n\n\n",
    "attributes": [
      {
        "name": "cudnn_exhaustive_search",
        "type": "boolean",
        "visible": false
      }
    ],
    "inputs": [
      {
        "description": "1D input tensor",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "1D output tensor with same shape as input",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ReluGradient",
    "description": "\nReluGradient takes both Y and dY and uses this to update dX according to the\nchain rule and derivatives of the rectified linear function.\n",
    "support_level": "default"
  },
  {
    "name": "ReluN",
    "description": "\nRelu takes one input data (Tensor) and produces one output data\n(Tensor) where the rectified linear function, y = min(max(0, x), n),\nis applied to the tensor elementwise.\n",
    "attributes": [
      {
        "description": "the cap of output",
        "name": "n",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "1D input tensor",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "1D input tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ReluNGradient",
    "description": "\nReluGradient takes both Y and dY and uses this to update dX according to the\nchain rule and derivatives of the rectified linear function.\n",
    "attributes": [
      {
        "description": "the cap of forward op output",
        "name": "n",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "RemoveDataBlocks",
    "description": "\nShrink the data tensor by removing data blocks with given zero-based indices in\nthe outermost dimension of the tensor. Indices are not assumed in any order or\nunique but with the range [0, blocks_size). Indices could be empty.\n  ",
    "inputs": [
      {
        "description": "a N-D data tensor, N >= 1",
        "name": "data"
      },
      {
        "description": "zero-based indices of blocks to be removed",
        "name": "indices"
      }
    ],
    "outputs": [
      {
        "description": "data after removing data blocks indexed by 'indices'",
        "name": "shrunk data"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "RemovePadding",
    "description": "\nRemove padding around the edges of each segment of the input data. This is the\nreverse operation of **AddPadding**, and uses the same arguments and conventions\nfor input and output data format.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/sequence_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\naddpad_op = core.CreateOperator(\n    \"AddPadding\",\n    [\"X\", \"lengths_add\"],\n    [\"Y\", \"lengths_out_add\"],\n    padding_width=1\n)\n\nrmpad_op = core.CreateOperator(\n    \"RemovePadding\",\n    [\"Y\", \"lengths_rm\"],\n    [\"Z\", \"lengths_out_rm\"],\n    padding_width=1\n)\n\nworkspace.FeedBlob(\"X\", (np.random.randint(20, size=(3,5))))\nworkspace.FeedBlob(\"lengths_add\", np.array([3]).astype(np.int32))\nworkspace.FeedBlob(\"lengths_rm\", np.array([5]).astype(np.int32))\n\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(addpad_op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\nprint(\"lengths_out_add:\", workspace.FetchBlob(\"lengths_out_add\"))\n\nworkspace.RunOperatorOnce(rmpad_op)\nprint(\"Z:\", workspace.FetchBlob(\"Z\"))\nprint(\"lengths_out_rm:\", workspace.FetchBlob(\"lengths_out_rm\"))\n```\n\n**Result**\n\n```\nX: [[17 19  1  9  1]\n [19  3  5 19  1]\n [16  0  0  0  4]]\nY: [[ 0  0  0  0  0]\n [17 19  1  9  1]\n [19  3  5 19  1]\n [16  0  0  0  4]\n [ 0  0  0  0  0]]\nlengths_out_add: [5]\nZ: [[17 19  1  9  1]\n [19  3  5 19  1]\n [16  0  0  0  4]]\nlengths_out_rm: [3]\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "Outer-size of padding to remove around each range.",
        "name": "padding_width",
        "option": "optional",
        "type": "int64"
      },
      {
        "description": "[OPTIONAL] Specifies a different end-padding width. If this is not set, will use same as `padding_width`.",
        "name": "end_padding_width",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor ($T<N, D_1, ..., D_n>$).",
        "name": "data_in"
      },
      {
        "description": "*(type: Tensor`<int>`)* Number of elements in each range. sum(lengths) = N. If not provided, considers all data as a single segment.",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor)* Padded data tensor ($T<N + 2*padding_width, D_1, ..., D_n>$).",
        "name": "data_out"
      },
      {
        "description": "*(type: Tensor`<int>`)* [OPTIONAL] Lengths for each padded range.",
        "name": "lengths_out"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ReplaceNaN",
    "description": "\nReplace the NaN (not a number) element in the input tensor with argument `value`\n",
    "attributes": [
      {
        "description": "the value to replace NaN, the default is 0",
        "name": "value (optional)",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor",
        "name": "input"
      },
      {
        "description": "Output tensor",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ReservoirSampling",
    "description": "\nCollect `DATA` tensor into `RESERVOIR` of size `num_to_collect`. `DATA` is\nassumed to be a batch.\n\nIn case where 'objects' may be repeated in data and you only want at most one\ninstance of each 'object' in the reservoir, `OBJECT_ID` can be given for\ndeduplication. If `OBJECT_ID` is given, then you also need to supply additional\nbook-keeping tensors. See input blob documentation for details.\n\nThis operator is thread-safe.\n",
    "attributes": [
      {
        "description": "The number of random samples to append for each positive samples",
        "name": "num_to_collect",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "The reservoir; should be initialized to empty tensor",
        "name": "RESERVOIR"
      },
      {
        "description": "Number of examples seen so far; should be initialized to 0",
        "name": "NUM_VISITED"
      },
      {
        "description": "Tensor to collect from. The first dimension is assumed to be batch size. If the object to be collected is represented by multiple tensors, use `PackRecords` to pack them into single tensor.",
        "name": "DATA"
      },
      {
        "description": "Mutex to prevent data race",
        "name": "MUTEX"
      },
      {
        "description": "(Optional, int64) If provided, used for deduplicating object in the reservoir",
        "name": "OBJECT_ID"
      },
      {
        "description": "(Optional) Auxiliary bookkeeping map. This should be created from  `CreateMap` with keys of type int64 and values of type int32",
        "name": "OBJECT_TO_POS_MAP_IN"
      },
      {
        "description": "(Optional) Tensor of type int64 used for bookkeeping in deduplication",
        "name": "POS_TO_OBJECT_IN"
      }
    ],
    "outputs": [
      {
        "description": "Same as the input",
        "name": "RESERVOIR"
      },
      {
        "description": "Same as the input",
        "name": "NUM_VISITED"
      },
      {
        "description": "(Optional) Same as the input",
        "name": "OBJECT_TO_POS_MAP"
      },
      {
        "description": "(Optional) Same as the input",
        "name": "POS_TO_OBJECT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ResetCounter",
    "description": "\nResets a count-down counter with initial value specified by the `init_count`\nargument.\n\n  Github Links:\n  - https://github.com/pytorch/pytorch/blob/master/caffe2/operators/counter_ops.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\ncreatecounter_op = core.CreateOperator(\n    \"CreateCounter\",\n    [],\n    [\"counter\"],\n    init_count=5\n)\n\nretrievecount_op = core.CreateOperator(\n    \"RetrieveCount\",\n    [\"counter\"],\n    [\"count\"]\n)\n\ncheckcounterdone_op = core.CreateOperator(\n    \"CheckCounterDone\",\n    [\"counter\"],\n    [\"done\"]\n)\n\ncountup_op = core.CreateOperator(\n    \"CountUp\",\n    [\"counter\"],\n    [\"previous_count\"],\n)\n\ncountdown_op = core.CreateOperator(\n    \"CountDown\",\n    [\"counter\"],\n    [\"done\"],\n)\n\nresetcounter_op = core.CreateOperator(\n    \"ResetCounter\",\n    [\"counter\"],\n    [\"previous_count\"],\n    init_count=3\n)\n\n\n// Create counter\nworkspace.RunOperatorOnce(createcounter_op)\nprint(\"'counter' pointer:\", workspace.FetchBlob(\"counter\"))\n\n\n// Retrieve initial counter value\nworkspace.RunOperatorOnce(retrievecount_op)\nprint(\"Initial 'count':\", workspace.FetchBlob(\"count\"))\n\n\n// Check if counter is done\nworkspace.RunOperatorOnce(checkcounterdone_op)\nprint(\"Initial 'done' value:\", workspace.FetchBlob(\"done\"))\n\n\n// Test CountUp operator\nprint(\"\\nTesting CountUp operator...\")\nfor i in range(5):\n    workspace.RunOperatorOnce(countup_op)\n    print(\"'previous_count' after CountUp:\", workspace.FetchBlob(\"previous_count\"))\n\nworkspace.RunOperatorOnce(retrievecount_op)\nprint(\"'count' value after CountUp test:\", workspace.FetchBlob(\"count\"))\n\n\n// Test CountDown operator\nprint(\"\\nTesting CountDown operator...\")\nfor i in range(11):\n    workspace.RunOperatorOnce(countdown_op)\n    workspace.RunOperatorOnce(retrievecount_op)\n    print(\"'count' value after CountDown: {}\\t'done' value: {}\".format(workspace.FetchBlob(\"count\"), workspace.FetchBlob(\"done\")))\n```\n\n**Result**\n\n```\n'counter' pointer: counter, a C++ native class of type std::__1::unique_ptr<caffe2::Counter<long long>, std::__1::default_delete<caffe2::Counter<long long> > >.\nInitial 'count': 5\nInitial 'done' value: False\n\nTesting CountUp operator...\n'previous_count' after CountUp: 5\n'previous_count' after CountUp: 6\n'previous_count' after CountUp: 7\n'previous_count' after CountUp: 8\n'previous_count' after CountUp: 9\n'count' value after CountUp test: 10\n\nTesting CountDown operator...\n'count' value after CountDown: 9        'done' value: False\n'count' value after CountDown: 8        'done' value: False\n'count' value after CountDown: 7        'done' value: False\n'count' value after CountDown: 6        'done' value: False\n'count' value after CountDown: 5        'done' value: False\n'count' value after CountDown: 4        'done' value: False\n'count' value after CountDown: 3        'done' value: False\n'count' value after CountDown: 2        'done' value: False\n'count' value after CountDown: 1        'done' value: False\n'count' value after CountDown: 0        'done' value: False\n'count' value after CountDown: -1        'done' value: True\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 0,
        "description": "Resets counter to this value, must be >= 0.",
        "name": "init_count",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<ptr>`)* A blob pointing to an instance of a counter.",
        "name": "counter"
      }
    ],
    "outputs": [
      {
        "description": "*(type: int)* [OPTIONAL] count value BEFORE this operation.",
        "name": "previous_value"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ResetCursor",
    "description": "\nResets the offsets for the given TreeCursor. This operation is thread safe.\n",
    "inputs": [
      {
        "description": "A blob containing a pointer to the cursor.",
        "name": "cursor"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Reshape",
    "category": "Shape",
    "description": "\nReshape the input tensor similar to numpy's\n[reshape](https://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html).\n\nTakes a tensor as input and an optional tensor specifying the new shape. When\nthe second input is absent, an extra argument shape must be specified. Outputs\nthe reshaped tensor as well as the original shape.\n\nAt most one dimension of the new shape can be -1. In this case, the value is\ninferred from the size of the tensor and the remaining dimensions. A dimension\ncould also be 0, in which case the actual dimension value is going to be copied\nfrom the input tensor.\n\nFor empty tensor, we will set the -1 dimension to be 0 (if one dimension is -1).\nWhen the tensor is empty, dimension of 0 will remain to be 0.\nE.g: data=np.empty(shape=[4, 0]), shape=[0, -1], the output tensor will be\nnp.emtpy(shape=[0, 0])\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/reshape_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Reshape\",\n    [\"data\"],\n    [\"reshaped\", \"old_shape\"],\n    shape=(3,2)\n)\n\nworkspace.FeedBlob(\"data\", (np.random.randint(100, size=(6))))\nprint(\"data:\", workspace.FetchBlob(\"data\"))\nworkspace.RunOperatorOnce(op)\nprint(\"reshaped:\", workspace.FetchBlob(\"reshaped\"))\nprint(\"old_shape:\", workspace.FetchBlob(\"old_shape\"))\n```\n\n**Result**\n\n```\ndata: [86 60 85 96  7 37]\nreshaped: [[86 60]\n          [85 96]\n          [ 7 37]]\nold_shape: [6]\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "New shape. Do not set if using `new_shape` input.",
        "name": "shape",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor)* Input tensor.",
        "name": "data"
      },
      {
        "description": "*(type: Tensor`<int>`)* [OPTIONAL] Tensor containing new shape.",
        "name": "new_shape"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor)* Reshaped output tensor.",
        "name": "reshaped"
      },
      {
        "description": "*(type: Tensor`<int>`)* Tensor containing old shape of `data`.",
        "name": "old_shape"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ResizeLike",
    "description": "\nProduces tensor containing data of first input and shape of second input.\n",
    "inputs": [
      {
        "description": "Tensor whose data will be copied into the output.",
        "name": "data"
      },
      {
        "description": "Tensor whose shape will be applied to output.",
        "name": "shape_tensor"
      }
    ],
    "outputs": [
      {
        "description": "Tensor with data of input 0 and shape of input 1.",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ResizeNearest",
    "description": "\nResizes the spatial dimensions of the input using nearest neighbor\ninterpolation. The `width_scale` and `height_scale` arguments\ncontrol the size of the output, which is given by:\noutput_width = floor(input_width * width_scale)\noutput_height = floor(output_height * height_scale)\n",
    "attributes": [
      {
        "description": "Scale along width dimension",
        "name": "width_scale",
        "option": "optional"
      },
      {
        "description": "Scale along height dimension",
        "name": "height_scale",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor",
        "name": "X"
      },
      {
        "description": "1D, 2-element, Scales tensor, [height_scale, width_scale]",
        "name": "scales"
      }
    ],
    "outputs": [
      {
        "description": "Output tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ResizeNearest3D",
    "description": "\nResizes the spatial dimensions of the input tensor using nearest neighbor\ninterpolation. The `width_scale` and `height_scale` arguments\ncontrol the size of the output, which is given by:\noutput_width = floor(input_width * width_scale)\noutput_height = floor(output_height * height_scale)\nAssumptions:\n  - Only resize height and width\n  - Both width_scale and height_scale scale are 2\n",
    "attributes": [
      {
        "description": "Scale along temporal dimension",
        "name": "temporal_scale",
        "option": "optional"
      },
      {
        "description": "Scale along width dimension",
        "name": "width_scale",
        "option": "optional"
      },
      {
        "description": "Scale along height dimension",
        "name": "height_scale",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "Output tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ResizeNearest3DGradient",
    "attributes": [
      {
        "description": "Scale along temporal dimension",
        "name": "temporal_scale",
        "option": "optional"
      },
      {
        "description": "Scale along width dimension",
        "name": "width_scale",
        "option": "optional"
      },
      {
        "description": "Scale along height dimension",
        "name": "height_scale",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ResizeNearestGradient",
    "attributes": [
      {
        "description": "Scale along width dimension",
        "name": "width_scale",
        "option": "optional"
      },
      {
        "description": "Scale along height dimension",
        "name": "height_scale",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "RetrieveCount",
    "description": "\nRetrieve the current value from the counter as an integer.\n\n  Github Links:\n  - https://github.com/pytorch/pytorch/blob/master/caffe2/operators/counter_ops.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\ncreatecounter_op = core.CreateOperator(\n    \"CreateCounter\",\n    [],\n    [\"counter\"],\n    init_count=5\n)\n\nretrievecount_op = core.CreateOperator(\n    \"RetrieveCount\",\n    [\"counter\"],\n    [\"count\"]\n)\n\ncheckcounterdone_op = core.CreateOperator(\n    \"CheckCounterDone\",\n    [\"counter\"],\n    [\"done\"]\n)\n\ncountup_op = core.CreateOperator(\n    \"CountUp\",\n    [\"counter\"],\n    [\"previous_count\"],\n)\n\ncountdown_op = core.CreateOperator(\n    \"CountDown\",\n    [\"counter\"],\n    [\"done\"],\n)\n\nresetcounter_op = core.CreateOperator(\n    \"ResetCounter\",\n    [\"counter\"],\n    [\"previous_count\"],\n    init_count=3\n)\n\n\n// Create counter\nworkspace.RunOperatorOnce(createcounter_op)\nprint(\"'counter' pointer:\", workspace.FetchBlob(\"counter\"))\n\n\n// Retrieve initial counter value\nworkspace.RunOperatorOnce(retrievecount_op)\nprint(\"Initial 'count':\", workspace.FetchBlob(\"count\"))\n\n\n// Check if counter is done\nworkspace.RunOperatorOnce(checkcounterdone_op)\nprint(\"Initial 'done' value:\", workspace.FetchBlob(\"done\"))\n\n\n// Test CountUp operator\nprint(\"\\nTesting CountUp operator...\")\nfor i in range(5):\n    workspace.RunOperatorOnce(countup_op)\n    print(\"'previous_count' after CountUp:\", workspace.FetchBlob(\"previous_count\"))\n\nworkspace.RunOperatorOnce(retrievecount_op)\nprint(\"'count' value after CountUp test:\", workspace.FetchBlob(\"count\"))\n\n\n// Test CountDown operator\nprint(\"\\nTesting CountDown operator...\")\nfor i in range(11):\n    workspace.RunOperatorOnce(countdown_op)\n    workspace.RunOperatorOnce(retrievecount_op)\n    print(\"'count' value after CountDown: {}\\t'done' value: {}\".format(workspace.FetchBlob(\"count\"), workspace.FetchBlob(\"done\")))\n```\n\n**Result**\n\n```\n'counter' pointer: counter, a C++ native class of type std::__1::unique_ptr<caffe2::Counter<long long>, std::__1::default_delete<caffe2::Counter<long long> > >.\nInitial 'count': 5\nInitial 'done' value: False\n\nTesting CountUp operator...\n'previous_count' after CountUp: 5\n'previous_count' after CountUp: 6\n'previous_count' after CountUp: 7\n'previous_count' after CountUp: 8\n'previous_count' after CountUp: 9\n'count' value after CountUp test: 10\n\nTesting CountDown operator...\n'count' value after CountDown: 9        'done' value: False\n'count' value after CountDown: 8        'done' value: False\n'count' value after CountDown: 7        'done' value: False\n'count' value after CountDown: 6        'done' value: False\n'count' value after CountDown: 5        'done' value: False\n'count' value after CountDown: 4        'done' value: False\n'count' value after CountDown: 3        'done' value: False\n'count' value after CountDown: 2        'done' value: False\n'count' value after CountDown: 1        'done' value: False\n'count' value after CountDown: 0        'done' value: False\n'count' value after CountDown: -1        'done' value: True\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<ptr>`)* A blob pointing to an instance of a counter.",
        "name": "counter"
      }
    ],
    "outputs": [
      {
        "description": "*(type: int)* Current count value.",
        "name": "count"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ReversePackedSegs",
    "description": "\nReverse segments in a 3-D tensor (lengths, segments, embeddings,), leaving\npaddings unchanged. This operator is used to reverse input of a recurrent neural\nnetwork to make it a BRNN.\n  ",
    "inputs": [
      {
        "description": "a 3-D (lengths, segments, embeddings,) tensor.",
        "name": "data"
      },
      {
        "description": "length of each segment.",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "a (lengths, segments, embeddings,) tensor with each segment reversedand paddings unchanged.",
        "name": "reversed data"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "RMACRegions",
    "description": "\nComputes a fixed-grid of RMAC region coordinates at various levels\nas described in https://arxiv.org/abs/1511.05879.\n",
    "attributes": [
      {
        "description": "Number of scales to sample regions at.",
        "name": "scales",
        "option": "optional"
      },
      {
        "description": "Overlap between consecutive regions.",
        "name": "overlap",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "The input 4D tensor of shape NCHW.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "The output RMAC regions for all items in the batch. Tensor of shape (N x 5) following the ROIPoolOp format - each row is of the format (batch_index x1 y1 x2 y2) where x1, y1, x2, y2 are the region co-ordinates. Each region is repeated N times corresponding to each item in the batch.",
        "name": "RMAC_REGIONS"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "RMSNorm",
    "attributes": [
      {
        "description": "(int) default to 1; Describes axis of the inputs. Defaults to one because the 0th axis most likely describes the batch size",
        "name": "axis",
        "option": "optional"
      },
      {
        "description": "(float) default to 0.001. Small value to be added to the stdev when dividing out by that value. This prevents division by zero.",
        "name": "epsilon",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor which layer normalization will be applied to",
        "name": "input"
      },
      {
        "description": "scale tensor for elementwise_affine, the shape should be the same as the dimensions of X begin from axis",
        "name": "gamma"
      },
      {
        "description": "bias tensor for elementwise_affine, the shape should be the same as the dimensions of X begin from axis",
        "name": "beta"
      }
    ],
    "outputs": [
      {
        "description": "Normalized values",
        "name": "output"
      },
      {
        "description": "Reciprocal of root mean square for each feature vector",
        "name": "rrms"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "RMSNormGradient",
    "support_level": "default"
  },
  {
    "name": "RmsProp",
    "description": "\nComputes the RMSProp update\n(http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf).\nConcretely, given inputs (grad, mean_squares, mom, lr), computes:\n\n    mean_squares_o = mean_squares + (1 - decay) * (square(grad) - mean_squares)\n    mom_o = momentum * mom + lr * grad / sqrt(epsilon + mean_squares_o)\n    grad_o = mom_o\n\nReturns (grad_o, mean_squares_o, mom_o).\n",
    "support_level": "default"
  },
  {
    "name": "rnn_internal_accumulate_gradient_input",
    "description": "\nInternal RNN operator.\n",
    "support_level": "default"
  },
  {
    "name": "rnn_internal_apply_link",
    "description": "\nInternal RNN operator.\n",
    "support_level": "default"
  },
  {
    "name": "RoIAlign",
    "description": "\nRegion of Interest (RoI) align operation as used in Mask R-CNN.\n",
    "attributes": [
      {
        "description": "(float) default 1.0; Spatial scale of the input feature map X relative to the input image. E.g., 0.0625 if X has a stride of 16 w.r.t. the input image.",
        "name": "spatial_scale",
        "option": "optional"
      },
      {
        "description": "(int) default 1; Pooled output Y's height.",
        "name": "pooled_h",
        "option": "optional"
      },
      {
        "description": "(int) default 1; Pooled output Y's width.",
        "name": "pooled_w",
        "option": "optional"
      },
      {
        "description": "(int) default -1; number of sampling points in the interpolation grid used to compute the output value of each pooled output bin. If > 0, then exactly sampling_ratio x sampling_ratio grid points are used. If <= 0, then an adaptive number of grid points are used (computed as ceil(roi_width / pooled_w), and likewise for height).",
        "name": "sampling_ratio",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "4D feature map input of shape (N, C, H, W).",
        "name": "X"
      },
      {
        "description": "2D input of shape (R, 4 or 5) specifying R RoIs representing: batch index in [0, N - 1], x1, y1, x2, y2. The RoI coordinates are in the coordinate system of the input image. For inputs corresponding to a single image, batch index can be excluded to have just 4 columns.",
        "name": "RoIs"
      }
    ],
    "outputs": [
      {
        "description": "4D output of shape (R, C, pooled_h, pooled_w). The r-th batch element is a pooled feature map cooresponding to the r-th RoI.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "RoIAlignGradient",
    "inputs": [
      {
        "description": "See RoIPoolF.",
        "name": "X"
      },
      {
        "description": "See RoIPoolF.",
        "name": "RoIs"
      },
      {
        "description": "Gradient of forward output 0 (Y)",
        "name": "dY"
      }
    ],
    "outputs": [
      {
        "description": "Gradient of forward input 0 (X)",
        "name": "dX"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "RoIAlignRotated",
    "description": "\nSimilar to RoIAlign but can handle rotated region proposals.\nBased on https://arxiv.org/abs/1703.01086.\n",
    "attributes": [
      {
        "description": "(float) default 1.0; Spatial scale of the input feature map X relative to the input image. E.g., 0.0625 if X has a stride of 16 w.r.t. the input image.",
        "name": "spatial_scale",
        "option": "optional"
      },
      {
        "description": "(int) default 1; Pooled output Y's height.",
        "name": "pooled_h",
        "option": "optional"
      },
      {
        "description": "(int) default 1; Pooled output Y's width.",
        "name": "pooled_w",
        "option": "optional"
      },
      {
        "description": "(int) default -1; number of sampling points in the interpolation grid used to compute the output value of each pooled output bin. If > 0, then exactly sampling_ratio x sampling_ratio grid points are used. If <= 0, then an adaptive number of grid points are used (computed as ceil(roi_width / pooled_w), and likewise for height).",
        "name": "sampling_ratio",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "4D feature map input of shape (N, C, H, W).",
        "name": "X"
      },
      {
        "description": "2D input of shape (R, 5 or 6) specifying R RoIs representing: batch index in [0, N - 1], center_x, center_y, width, height, angle. The RoI coordinates are in the coordinate system of the input image. `angle` should be specified in degrees and represents the RoI rotated counter-clockwise. For inputs corresponding to a single image, batch index can be excluded to have just 5 columns.",
        "name": "RoIs"
      }
    ],
    "outputs": [
      {
        "description": "4D output of shape (R, C, pooled_h, pooled_w). The r-th batch element is a pooled feature map cooresponding to the r-th RoI.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "RoIPool",
    "description": "\nCarries out ROI Pooling for Faster-RCNN.\nDepending on the mode, there are multiple output cases:\n\n  Output case #1: Y, argmaxes (train mode)\n  Output case #2: Y           (test mode)\n",
    "attributes": [
      {
        "description": "If set, run in test mode and skip computation of argmaxes (used for gradient computation). Only one output tensor is produced. (Default: false).",
        "name": "is_test",
        "option": "optional"
      },
      {
        "description": "A StorageOrder string (Default: \"NCHW\").",
        "name": "order",
        "option": "optional"
      },
      {
        "description": "The pooled output height (Default: 1).",
        "name": "pooled_h",
        "option": "optional"
      },
      {
        "description": "The pooled output width (Default: 1).",
        "name": "pooled_w",
        "option": "optional"
      },
      {
        "description": "Multiplicative spatial scale factor to translate ROI coords from their input scale to the scale used when pooling (Default: 1.0).",
        "name": "spatial_scale",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "The input 4-D tensor of data. Only NCHW order is currently supported.",
        "name": "X"
      },
      {
        "description": "RoIs (Regions of Interest) to pool over. Should be a 2-D tensor of shape (num_rois, 5) given as [[batch_id, x1, y1, x2, y2], ...].",
        "name": "rois"
      }
    ],
    "outputs": [
      {
        "description": "RoI pooled output 4-D tensor of shape (num_rois, channels, pooled_h, pooled_w).",
        "name": "Y"
      },
      {
        "description": "Argmaxes corresponding to indices in X used for gradient computation. Only output if arg \"is_test\" is false.",
        "name": "argmaxes"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "RoIPoolGradient",
    "support_level": "default"
  },
  {
    "name": "RowMul",
    "description": "\nGiven a matrix A and column vector w, the output is the multiplication of row i\nof A and element i of w, e.g. C[i][j] = A[i][j] * w[i]. This operator should be\ndeprecated when the gradient operator of Mul with broadcast is implemented.\n",
    "inputs": [
      {
        "description": "The matrix",
        "name": "mat"
      },
      {
        "description": "The column vector",
        "name": "w"
      }
    ],
    "outputs": [
      {
        "description": "Output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Rowwise8BitQuantizedToFloat",
    "description": "\nGiven uint8 tensor, quantized using 8bit row-wise\nquantization, and auxiliary scales and biases, this operator\nrestores float tensor in the following way. We take input 8bits tensor\nof size  (m_1, m_2, ..., m_n), n >= 2, reshape it  into matrix of size\n(m_1, m_2 x... x m_n). We compute element r_{ij} of output matrix as\nr_{ij} * s_i + b_i and after this we reshape this output matrix into\noutput tensor of size (m_1, m_2, ..., m_n).\n",
    "inputs": [
      {
        "description": "quantized_input",
        "name": "quantized_input"
      },
      {
        "description": "Matrix of floats, each row r_i of which stores a pair s_i, b_i -- scale and bias for i-th row",
        "name": "scale_bias"
      }
    ],
    "outputs": [
      {
        "name": null
      },
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "RowWiseCounter",
    "description": "\n    Count the number recent update on rows. Exponential decay is\n    applied on the counter with decay rate r, such that\n    r^{counter_halflife} = 0.5; If counter_halflife is nonpositive,\n    this operator is turned off.\n",
    "attributes": [
      {
        "description": "Default -1: off",
        "name": "counter_halflife",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Iter at last update",
        "name": "prev_iter"
      },
      {
        "description": "update counter",
        "name": "update_counter"
      },
      {
        "description": "Sparse indices",
        "name": "indices"
      },
      {
        "description": "current iteration",
        "name": "iter"
      }
    ],
    "outputs": [
      {
        "description": "Updated iter at last update",
        "name": "output_prev_iter"
      },
      {
        "description": "Output update counter",
        "name": "output_update_counter"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "RowwiseMax",
    "description": "\nCompute row-wise max reduction of the input tensor. This op takes one input, $X$, of shape $BxMxN$, where $B$ is the batch size, $M$ is number of rows, and $N$ is number of columns. The output of this op, $Y$, is a matrix of shape $BxM$, with one row for each element of the batch, and the same number of columns as the number of rows of the input tensor.\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/reduction_ops.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/reduction_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"RowwiseMax\",\n    [\"X\"],\n    [\"Y\"]\n)\n\n// Create X, simulating a batch of 2, 4x4 matricies\nX = np.random.randint(0,high=20,size=(2,4,4))\nprint(\"X:\\n\",X)\n\n// Feed X into workspace\nworkspace.FeedBlob(\"X\", X.astype(np.float32))\n\n// Run op\nworkspace.RunOperatorOnce(op)\n\n// Collect Output\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n [[[ 5 12 10  1]\n  [ 4 16  2 15]\n  [ 5 11 12 15]\n  [15  4 17 19]]\n\n [[16  5  5 13]\n  [17  2  1 17]\n  [18  3 19  5]\n  [14 16 10 16]]]\nY:\n [[12. 16. 15. 19.]\n [16. 17. 19. 16.]]\n\n```\n\n</details>\n\n    ",
    "inputs": [
      {
        "description": "A tensor of dimensions $B x M x N$ to compute rowwise-max. Here, $B$ is batch size, and $M$ and $N$ are the number of rows and columns of each element of the batch, respectively.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "The output tensor of shape $B x M$, where each row represents the row-wise maximums for that element of the input batch.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "RowwiseMaxGradient",
    "support_level": "default"
  },
  {
    "name": "RowWiseSparseAdagrad",
    "description": "\n\nGiven inputs (param, moment, indices, grad, lr), runs a modified sparse Adagrad\nupdate on (param, grad, moment[indices], lr), and returns (new_param,\nnew_momwnr), where moment is a 1D tensor with length equal to the number of\nrows in param: shape(moment) == shape(param)[0]. Each element of moment is\napplied to an entire row of param, and the new moment is calculated by adding\nthe average squared sum of gradients across each row. Note that indices must\nalso be a 1D tensor indexing into the rows of param.\n\n",
    "attributes": [
      {
        "description": "Default 1e-5",
        "name": "epsilon",
        "option": "optional"
      },
      {
        "name": "weight_decay",
        "description": "Default 0",
        "option": "optional"
      },
      {
        "name": "counter_halflife",
        "description": "Optional arg when weight_decay is adjusted by frequency (default -1)",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated",
        "name": "param"
      },
      {
        "description": "Moment history",
        "name": "moment"
      },
      {
        "description": "Sparse indices",
        "name": "indices"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "learning rate",
        "name": "lr"
      },
      {
        "name": "counter",
        "description": "Optional input when weight_decay is adjusted by frequency ignored when counter_halflife == -1"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters",
        "name": "output_param"
      },
      {
        "description": "Updated moment",
        "name": "output_moment_1"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "RowWiseSparseAdagradFusedWithSparseLengthsMeanGradient",
    "description": "\n\nFused operator of\nSparseLengthsIndicesInGradientMeanGradient (gradient of SparseLengthsMean) +\nRowWiseSparseAdagrad.\n\nGiven inputs (param, moment, indices, grad, lr), runs the row-wise sparse\nAdaGrad update on (param, grad, moment[indices], lr), and returns (new_param,\nnew_moment) as in the dense case. Additional input (lengths) is for fused\nSparseLengthsMeanGradient operator.\n\n",
    "attributes": [
      {
        "description": "Default 1e-5",
        "name": "epsilon",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated",
        "name": "param"
      },
      {
        "description": "Moment history",
        "name": "moment"
      },
      {
        "description": "Integer vector containing indices of the first dimension of param for the slices that are being updated",
        "name": "indices"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "learning rate",
        "name": "lr"
      },
      {
        "description": "Non negative vector with sum of elements equal to indices length",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters",
        "name": "output_param"
      },
      {
        "description": "Updated moment",
        "name": "output_moment"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "RowWiseSparseAdagradFusedWithSparseLengthsMeanGradientApprox",
    "description": "\n\nFused operator of\nSparseLengthsIndicesInGradientMeanGradient (gradient of SparseLengthsMean) +\nRowWiseSparseAdagrad.\n\nGiven inputs (param, moment, indices, grad, lr), runs the row-wise sparse\nAdaGrad update on (param, grad, moment[indices], lr), and returns (new_param,\nnew_moment) as in the dense case. Additional input (lengths) is for fused\nSparseLengthsMeanGradient operator.\n\n",
    "attributes": [
      {
        "description": "rounding option: 0 for nearest rounding, 1 for stochastic rounding",
        "name": "round_option",
        "option": "optional"
      },
      {
        "description": "Default 1e-5",
        "name": "epsilon",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated",
        "name": "param"
      },
      {
        "description": "Moment history",
        "name": "moment"
      },
      {
        "description": "Integer vector containing indices of the first dimension of param for the slices that are being updated",
        "name": "indices"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "learning rate",
        "name": "lr"
      },
      {
        "description": "Non negative vector with sum of elements equal to indices length",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters",
        "name": "output_param"
      },
      {
        "description": "Updated moment",
        "name": "output_moment"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "RowWiseSparseAdagradFusedWithSparseLengthsSumGradient",
    "description": "\n\nFused operator of\nSparseLengthsIndicesInGradientSumGradient (gradient of SparseLengthsSum) +\nRowWiseSparseAdagrad.\n\nGiven inputs (param, moment, indices, grad, lr), runs the row-wise sparse\nAdaGrad update on (param, grad, moment[indices], lr), and returns (new_param,\nnew_moment) as in the dense case. Additional input (lengths) is for fused\nSparseLengthsSumGradient operator.\n\n",
    "attributes": [
      {
        "description": "Default 1e-5",
        "name": "epsilon",
        "option": "optional"
      },
      {
        "description": "rounding option: 0 for nearest rounding, 1 for stochastic rounding",
        "name": "round_option",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated",
        "name": "param"
      },
      {
        "description": "Moment history",
        "name": "moment"
      },
      {
        "description": "Integer vector containing indices of the first dimension of param for the slices that are being updated",
        "name": "indices"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "learning rate",
        "name": "lr"
      },
      {
        "description": "Non negative vector with sum of elements equal to indices length",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters",
        "name": "output_param"
      },
      {
        "description": "Updated moment",
        "name": "output_moment"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "RowWiseSparseAdagradFusedWithSparseLengthsSumGradientApprox",
    "description": "\n\nFused operator of\nSparseLengthsIndicesInGradientSumGradient (gradient of SparseLengthsSum) +\nRowWiseSparseAdagrad.\n\nGiven inputs (param, moment, indices, grad, lr), runs the row-wise sparse\nAdaGrad update on (param, grad, moment[indices], lr), and returns (new_param,\nnew_moment) as in the dense case. Additional input (lengths) is for fused\nSparseLengthsSumGradient operator.\n\n",
    "attributes": [
      {
        "description": "rounding option: 0 for nearest rounding, 1 for stochastic rounding",
        "name": "round_option",
        "option": "optional"
      },
      {
        "description": "Default 1e-5",
        "name": "epsilon",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated",
        "name": "param"
      },
      {
        "description": "Moment history",
        "name": "moment"
      },
      {
        "description": "Integer vector containing indices of the first dimension of param for the slices that are being updated",
        "name": "indices"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "learning rate",
        "name": "lr"
      },
      {
        "description": "Non negative vector with sum of elements equal to indices length",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters",
        "name": "output_param"
      },
      {
        "description": "Updated moment",
        "name": "output_moment"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "RowWiseSparseAdagradFusedWithSparseLengthsWeightedSumGradient",
    "description": "\n\nFused operator of SparseLengthsIndicesInGradientWeightedSumWithMainInputGradient\n(gradient of SparseLengthsWeightedSum) + RowWiseSparseAdagrad, where weights are\npositional weights computed with LengthsRangeFill + Gather pattern.\n\nGiven inputs (param, moment, indices, grad, lr), runs the row-wise sparse\nAdaGrad update on (param, grad, moment[indices], lr), and returns (new_param,\nnew_moment) as in the dense case.\nThere're auxiliary inputs (aux_param) for which gradient is computed and\nreturns (aux_grad).\nYet additional input (lengths) is for fused SparseLengthsWeightedSumGradient\noperator.\n\n",
    "attributes": [
      {
        "description": "Default 1e-5",
        "name": "epsilon",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated",
        "name": "param"
      },
      {
        "description": "Moment history",
        "name": "moment"
      },
      {
        "description": "Auxiliary parameters to be updated",
        "name": "aux_param"
      },
      {
        "description": "Integer vector containing indices of the first dimension of param for the slices that are being updated",
        "name": "indices"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "learning rate",
        "name": "lr"
      },
      {
        "description": "Non negative vector with sum of elements equal to indices length",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters",
        "name": "output_param"
      },
      {
        "description": "Updated moment",
        "name": "output_moment"
      },
      {
        "description": "Auxiliary gradient",
        "name": "aux_grad"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "RowWiseSparseAdagradFusedWithSparseLengthsWeightedSumGradientApprox",
    "description": "\n\nApproximately fused operator of\nSparseLengthsIndicesInGradientWeightedSumWithMainInputGradient\n(gradient of SparseLengthsWeightedSum) + RowWiseSparseAdagrad, where weights are\npositional weights computed with LengthsRangeFill + Gather pattern.\n\nGiven inputs (param, moment, indices, grad, lr), runs the row-wise sparse\nAdaGrad update on (param, grad, moment[indices], lr), and returns (new_param,\nnew_moment) as in the dense case.\nThere's race condition w.r.t. ordering between reading params and writing to\nparam, hence the name Approx.\nThere're auxiliary inputs (aux_param) for which gradient is computed\nand returns (aux_grad).\nYet additional input (lengths) is for fused SparseLengthsWeightedSumGradient\noperator.\n\n",
    "attributes": [
      {
        "description": "Default 1e-5",
        "name": "epsilon",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated",
        "name": "param"
      },
      {
        "description": "Moment history",
        "name": "moment"
      },
      {
        "description": "Auxiliary parameters to be updated",
        "name": "aux_param"
      },
      {
        "description": "Integer vector containing indices of the first dimension of param for the slices that are being updated",
        "name": "indices"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "learning rate",
        "name": "lr"
      },
      {
        "description": "Non negative vector with sum of elements equal to indices length",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters",
        "name": "output_param"
      },
      {
        "description": "Updated moment",
        "name": "output_moment"
      },
      {
        "description": "Auxiliary gradient",
        "name": "aux_grad"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "RowWiseSparseAdam",
    "description": "\n\n    Computes a modified Adam Update for the sparse case.\n    Given inputs (param, moment1, moment2, indices, grad, lr, iter), runs the\n    Adam update on (param, moment1[indices], moment2[indices], lr, iter) and returns\n    (new_param, new_moment1, new_moment2), where moment2 is a 1D tensor\n    with length equal to the number of rows in param:\n    shape(moment2) == shape(param)[0]. Each element of  moment2 is\n    applied to an entire row of param, and the new moment2 values are\n    calculated by averaging across the row.\n\n    ",
    "attributes": [
      {
        "description": "Default 0.9",
        "name": "beta1",
        "option": "optional"
      },
      {
        "description": "Default 0.999",
        "name": "beta2",
        "option": "optional"
      },
      {
        "description": "Default 1e-5",
        "name": "epsilon",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated",
        "name": "param"
      },
      {
        "description": "First moment history",
        "name": "moment_1"
      },
      {
        "description": "Second moment history",
        "name": "moment_2"
      },
      {
        "description": "Sparse indices",
        "name": "indices"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "learning rate",
        "name": "lr"
      },
      {
        "description": "iteration number",
        "name": "iter"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters",
        "name": "output_param"
      },
      {
        "description": "Updated first moment",
        "name": "output_moment_1"
      },
      {
        "description": "Updated second moment",
        "name": "output_moment_2"
      },
      {
        "description": "Optional Effective gradient",
        "name": "output_grad"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Rsqrt",
    "description": "Computes the element-wise rsqrt of the input.",
    "inputs": [
      {
        "description": "ND input tensor",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "ND output tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "RsqrtGradient",
    "support_level": "default"
  },
  {
    "name": "SafeDequeueBlobs",
    "description": "\nDequeue the blobs from queue. When the queue is closed and empty, the output\nstatus will be set to true which can be used as exit criteria for execution\nstep.\nThe 1st input is the queue and the last output is the status. The rest are\ndata blobs.\n",
    "attributes": [
      {
        "description": "(default 1) If > 1, multiple records will be dequeued and tensors for each column will be concatenated. This requires all tensors in the records to be at least 1D, and to have the same inner dimensions.",
        "name": "num_records",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "The shared pointer for the BlobsQueue",
        "name": "queue"
      }
    ],
    "outputs": [
      {
        "description": "The blob to store the dequeued data",
        "name": "blob"
      },
      {
        "description": "Is set to 0/1 depending on the success of dequeue",
        "name": "status"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SafeEnqueueBlobs",
    "description": "\nEnqueue the blobs into queue. When the queue is closed and full, the output\nstatus will be set to true which can be used as exit criteria for execution\nstep.\nThe 1st input is the queue and the last output is the status. The rest are\ndata blobs.\n",
    "inputs": [
      {
        "description": "The shared pointer for the BlobsQueue",
        "name": "queue"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Save",
    "description": "\nSaves a set of blobs to a db. It takes $[1, \\infty)$ number of inputs and has\nno output. The contents of the inputs are written into the db using the\nsettings specified by the arguments.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/load_save_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Save\",\n    [\"X\", \"Y\", \"Z\"],\n    [],\n    db=\"test_db2\",\n    db_type=\"leveldb\",\n    blob_name_overrides=[\"x_scores\", \"y_scores\", \"z_scores\"]\n)\n\nworkspace.FeedBlob(\"X\", np.random.randint(20, size=(5,5)))\nworkspace.FeedBlob(\"Y\", np.random.randint(20, size=(5,5)))\nworkspace.FeedBlob(\"Z\", np.random.randint(20, size=(5,5)))\nworkspace.RunOperatorOnce(op)\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 0,
        "description": "If set to non-zero, save the db directly to the path specified by the `db` arg. If not set (default), prepend the path of the current root folder of the workspace to the path specified by the `db` arg.",
        "name": "absolute_path",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": "",
        "description": "Characters in the provided blob names that match `strip_prefix` will be removed prior to saving. Also, characters that precede `strip_prefix` will be removed. Useful for removing device scope from blob names.",
        "name": "strip_prefix",
        "option": "optional",
        "type": "string"
      },
      {
        "description": "If set, used as blob names instead of original blob names. Must be same length as number of blobs.",
        "name": "blob_name_overrides",
        "option": "optional",
        "type": "string[]"
      },
      {
        "description": "The output path of the db. See the `absolute_path` arg details for options regarding the current root folder of the workspace.",
        "name": "db",
        "option": "optional",
        "type": "string"
      },
      {
        "description": "Type of db to save (options: \"lmdb\", \"leveldb\", \"minidb\").",
        "name": "db_type",
        "option": "optional",
        "type": "string"
      },
      {
        "default": "kDefaultChunkSize",
        "description": "The chunk size to split tensor data into. If not set, caffe2_tensor_chunk_size will be used",
        "name": "chunk_size",
        "option": "optional",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor)* Input tensor(s).",
        "name": "X"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Scale",
    "description": "\nScale takes one input data (Tensor) and produces one output data\n(Tensor) whose value is the input data tensor scaled element-wise.\n",
    "attributes": [
      {
        "description": "(float, default 1.0) the scale to apply.",
        "name": "scale",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ScaleBlobs",
    "description": "\nScaleBlobs takes one or more input data (Tensor) and produces one\nor more output data (Tensor) whose value is the input data tensor\nscaled element-wise.\n",
    "attributes": [
      {
        "description": "(float, default 1.0) the scale to apply.",
        "name": "scale",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Scatter",
    "description": "\nUpdate values of the tensor by overriding current value specified by indices.\n\nWrites all values from the tensor UPDATES into DATA at the indices specified in the INDICES tensor.\nFor each value in DATA, its output index is specified by its index in UPDATES and by the corresponding value in INDICES for the specified axis.\n\nFor a 3-D tensor, DATA is updated as:\n\nDATA[INDICES[i][j][k]][j][k] = UPDATES[i][j][k]  # if axis == 0\nDATA[i][INDICES[i][j][k]][k] = UPDATES[i][j][k]  # if axis == 1\nDATA[i][j][INDICES[i][j][k]] = UPDATES[i][j][k]  # if axis == 2\n\nCurrently only works on CPU because of access to INDICES.\n",
    "attributes": [
      {
        "default": 1,
        "description": "Which dimension to scatter on.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "Tensor to be updated.",
        "name": "DATA"
      },
      {
        "description": "1-D list of indices on the first dimensionof X_0 that need to be updated",
        "name": "INDICES"
      },
      {
        "description": "Update slices, with shape len(INDICES) + shape(X_0)[1:]",
        "name": "UPDATES"
      }
    ],
    "outputs": [
      {
        "description": "The updated output.",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ScatterAssign",
    "description": "\nUpdate slices of the tensor in-place by overriding current value.\n\nNote: The op pretty much ignores the exact shapes of the input arguments and\ncares only about sizes. It's done for performance consideration to avoid\nunnecessary reshapes. Only first dimension of X_0 is important, let's call it\nN. If M is the total size of X_0 and K is the size of INDICES then X_i is\nassumed to be of shape K x (M / N) regardless of the real shape.\n\nNote: Each update in INDICES is applied independently which means that if\nduplicated elements are present in INDICES arbitrary one will win.\n\nCurrently only works on CPU because of access to INDICES.\n",
    "inputs": [
      {
        "description": "Tensor to be updated.",
        "name": "DATA"
      },
      {
        "description": "1-D list of indices on the first dimensionof X_0 that need to be updated",
        "name": "INDICES"
      },
      {
        "description": "Update slices, with shape len(INDICES) + shape(X_0)[1:]",
        "name": "SLICES"
      }
    ],
    "outputs": [
      {
        "description": "Has to be exactly the same tensor as the input 0",
        "name": "DATA"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ScatterWeightedSum",
    "description": "\nSimilar to WeightedSum, computes the weighted sum of several tensors, with\nthe difference that inputs are sliced tensors. The first tensor has to be\nin-place and only slices of it on the first dimension as indexed by INDICES\nwill be updated.\n\nNote: The op pretty much ignores the exact shapes of the input arguments and\ncares only about sizes. It's done for performance consideration to avoid\nunnecessary reshapes. Only first dimension of X_0 is important, let's call it\nN. If M is the total size of X_0 and K is the size of INDICES then X_i is\nassumed to be of shape K x (M / N) regardless of the real shape.\n\nNote: Each update in INDICES is applied independently which means that if\nduplicated elements are present in INDICES the corresponding slice of X_0\nwill be scaled multiple times. Manual collapsing of INDICES is required\nbeforehand if necessary.\n\nNote: Updates are applied sequentially by inputs which might have undesired\nconsequences if the input tensor is accessed concurrently by different op\n(e.g. when doing Hogwild). Other threads might see intermediate results even\non individual slice level, e.g. X_0 scaled by weight_0 but without any\nupdates applied.\n\nCurrently only works on CPU because of access to INDICES.\n",
    "inputs": [
      {
        "description": "Tensor to be updated.",
        "name": "X_0"
      },
      {
        "description": "Scalar weight for X_0, applied only to slices affected.",
        "name": "Weight_0"
      },
      {
        "description": "1-D list of indices on the first dimension of X_0 that need to be updated",
        "name": "INDICES"
      },
      {
        "description": "Update slices, with shape len(INDICES) + shape(X_0)[1:]",
        "name": "X_1"
      },
      {
        "description": "Scalar weight for X_1 update",
        "name": "Weight_1"
      }
    ],
    "outputs": [
      {
        "description": "Has to be exactly the same tensor as the input 0",
        "name": "X_0"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SegmentIdsToLengths",
    "description": "\nTransfers a vector of segment ids to a vector of segment lengths. This operation\nsupports non-consecutive segment ids. Segments not appearing in the input vector\nwill have length 0. If the second input is provided, the number of segments =\nthe size of its first dimension. Otherwise, the number of segments = the last\nindex in the first input vector + 1.\n\nIn general, for consecutive, zero-based segment IDs, this is the inverse\noperation of LengthsToSegmentIds, except that a vector of segment IDs\ncannot represent empty segments at the end (if the second input is absent).\n",
    "inputs": [
      {
        "description": "1-D int32_t or int64_t tensor of segment ids",
        "name": "segment_ids"
      },
      {
        "description": "if provided, number of segments = the size of its first dimension",
        "name": "data (optional)"
      }
    ],
    "outputs": [
      {
        "description": "1-D int64_t tensor of segment lengths",
        "name": "lengths"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SegmentIdsToRanges",
    "description": "\nTransfers a vector of segment ids to a vector of segment ranges. This operation\nsupports non-consecutive segment ids. Segments not appearing in the input vector\nwill have length 0. If the second input is provided, the number of segments =\nthe size of its first dimension. Otherwise, the number of segments = the last\nindex in the first input vector + 1.\n",
    "inputs": [
      {
        "description": "1-D int32_t or int64_t tensor of segment ids",
        "name": "segment_ids"
      },
      {
        "description": "if provided, number of segments = the size of its first dimension",
        "name": "data (optional)"
      }
    ],
    "outputs": [
      {
        "description": "1-D int64_t tensor of segment lengths",
        "name": "lengths"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SegmentOneHot",
    "description": "\nGiven a sequence of indices, segmented by the lengths tensor, returns a matrix\nthat has the elements in each sequence set to 1.0, and 0.0 everywhere else.\n",
    "inputs": [
      {
        "description": "Size of each segment.",
        "name": "lengths"
      },
      {
        "description": "Active indices, of size sum(lengths)",
        "name": "indices"
      },
      {
        "description": "Size of the index",
        "name": "index_size_tensor"
      }
    ],
    "outputs": [
      {
        "description": "Matrix of size len(lengths) x index_size",
        "name": "one_hots"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SelfBinningHistogram",
    "description": "\n            Computes a histogram for values in the given list of tensors.\n            For logging activation histograms for post-hoc analyses, consider using the\n            HistogramObserver observer.\n            For iteratively computing a histogram for all input tensors encountered through\n            history, consider using the AccumulateHistogram operator.\n            ",
    "attributes": [
      {
        "description": "Number of bins to use for the histogram. Must be >= 1.",
        "name": "num_bins",
        "option": "optional"
      },
      {
        "description": "A string indicating 'linear' or 'logarithmic' spacing for the bins.",
        "name": "bin_spacing",
        "option": "optional"
      },
      {
        "description": "A float that's used as the starting point for logarithmic spacing. Since logarithmic spacing cannot contain <=0 values this value will be used to represent all such values.",
        "name": "logspace_start",
        "option": "optional"
      },
      {
        "description": "Apply abs() on every input value.",
        "name": "abs",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* List of input tensors.",
        "name": "X1, X2, ..."
      }
    ],
    "outputs": [
      {
        "description": "1D tensor of edges of the bins, of dimension [num_bins+1]. The range appears as: [first, ..., last), wherein the i-th element expresses the start of a bin and i+1-th value represents the exclusive end of that bin.",
        "name": "histogram_values"
      },
      {
        "description": "1D tensor of counts of each bin, of dimension [num_bins+1]. It is guaranteed to end with a 0 since the last edge is exclusive.",
        "name": "histogram_counts"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Selu",
    "description": "\n\nThe *Selu* op takes one input tensor $X$, an argument $alpha$, an argument $scale$, and produces one output tensor $Y$ of the same shape as $X.$ The op performs the element wise *Selu* operation, defined as\n\n$$y=selu(x) =\\begin{cases}scale (\\alpha e^{x} - \\alpha) & x < 0\\\\scale * x & otherwise\\end{cases}$$\n\nThe default value of *alpha* is 1.6732632423543772848170429916717 and the default value of *scale* is 1.0507009873554804934193349852946. See [Self-Normalizing Neural Networks](https://arxiv.org/abs/1706.02515) for more information.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/selu_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/selu_op.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Selu\",\n    [\"X\"],\n    [\"Y\"],\n)\n\nworkspace.FeedBlob(\"X\", np.random.randn(3, 3).astype(np.float32))\nprint(\"X:\\n\", workspace.FetchBlob(\"X\"), \"\\n\")\n\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n [[ 1.1613879  -0.27111396 -1.2076733 ]\n [ 1.3442237  -1.0701777   1.2070968 ]\n [ 0.23810555  0.9740916  -1.7872391 ]]\n\nY:\n [[ 1.2202715  -0.4174965  -1.2326177 ]\n [ 1.4123772  -1.1551634   1.2682979 ]\n [ 0.25017774  1.023479   -1.4637551 ]]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 1.673263,
        "description": "Alpha constant in equation.",
        "name": "alpha",
        "option": "optional",
        "type": "float32"
      },
      {
        "default": 1.0507,
        "description": "Scale constant in equation.",
        "name": "scale",
        "option": "optional",
        "type": "float32"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor of data to be operated on.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "Output tensor with same shape as input.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SeluGradient",
    "description": "\nSeluGradient takes both Y and dY and uses this to update dX according to the\nchain rule and derivatives of the selu function.\n",
    "attributes": [
      {
        "description": "(float) default to 1.6732~; affects the activation function itself.This should go with the weight initialization in the paper.  See https://arxiv.org/abs/1706.02515",
        "name": "alpha",
        "option": "optional"
      },
      {
        "description": "(float) default to 1.0507~; affects the activation function itself.",
        "name": "scale",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "input tensor",
        "name": "Y"
      },
      {
        "description": "input tensor",
        "name": "dY"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SendTensor",
    "description": "\nSends the tensor to another node.\n",
    "attributes": [
      {
        "description": "The rank to send the tensor to.",
        "name": "dst",
        "option": "optional"
      },
      {
        "description": "(int) a tag to send the tensor with.",
        "name": "tag",
        "option": "optional"
      },
      {
        "description": "(bool) if set, only send the content and assume that the receiver has already known the tensor's shape and information.",
        "name": "raw_buffer",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "The common world.",
        "name": "comm_world"
      },
      {
        "description": "A tensor to be allgathered.",
        "name": "X"
      },
      {
        "description": "An int CPUtensor of size 1 specifying the rank. If given, this overrides the 'to' argument of the op.",
        "name": "dst"
      },
      {
        "description": "An int CPUtensor of size 1 specifying the tag to send the tensor with. This overrides the 'tag' argument of the op.",
        "name": "tag"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SequenceMask",
    "description": "\nMask op designed for use in attention mechanisms for sequence modeling tasks.\nSupports batching: given batch_dim, collapses dims 0 through batch_dim into a\nsingle dimension, e.g. if tensor dims are [4,2,1,3,4] and batch_dim=2, first\ncollapse tensor to [4*2*1,3,4], then mask each batch [i,:,:].\n\n\nTwo current operating modes:\n\n\n1) Given a 2D input tensor and 1D tensor of sequence lengths, for each row i in\nthe input tensor, set elements in that row to -inf if their column index\nj >= sequence_lengths[i]. This mode takes two inputs and argument mode =\n'sequence'\n\n\n2) Triangular mask. Given row index i and column index j, set elements to -inf\ngiven the following conditions:\n\n      mode='upper', x_ij = -inf if j < i\n      mode='lower', x_ij = -inf if j > i\n      mode='upperdiag', x_ij = -inf if j <= i\n      mode='lowerdiag', x_ij = -inf if j >= i\n\nThis mode takes one input.\n\n\n3) Window Mask. Given a 2D input tensor and 1D tensor of window centers,\nfor each row i in the input tensor, set elements in that row to -inf\nif their column index j outside [center - radius, center + radius].\nThis mode takes two inputs and argument mode = 'sequence'.\nArgument 'radius' should be provided.\n",
    "attributes": [
      {
        "description": "(string) Mode selection. Possible values: 'sequence', 'upper', 'lower', 'upperdiag', 'lowerdiag'",
        "name": "mode",
        "option": "optional"
      },
      {
        "description": "(int) Beginning axis of row elements. All dimensions to the left will be treated as row indices and those to the right (inclusive) will be treated as column indices in the 2D mask",
        "name": "axis",
        "option": "optional"
      },
      {
        "description": "(bool) operate in gradient mode",
        "name": "grad",
        "option": "optional"
      },
      {
        "description": "(int) radius of windows in window mode",
        "name": "radius",
        "option": "optional"
      },
      {
        "description": "(int) batch dimension of tensor (optional)",
        "name": "batch",
        "option": "optional"
      },
      {
        "description": "(int) used when mask should be repeated for one or more data dimensions (beginning at this axis).  (currently only supported for sequence mode without batch argument)",
        "name": "repeat_from_axis",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Tensor to apply masking to",
        "name": "input"
      },
      {
        "description": "1D Tensor of sequence lengths for mode #1",
        "name": "sequence_lengths"
      }
    ],
    "outputs": [
      {
        "description": "Input tensor with masking applied",
        "name": "masked_tensor"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Shape",
    "description": "\nProduce a 1D int64 tensor with the shape of the input tensor.\nIf called with an optional argument `axes`, the result will only\ncontain the dimensions of specified axes.\n\nGithub Link:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/shape_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Shape\",\n    [\"X\"],\n    [\"shape\"],\n)\n\nworkspace.FeedBlob(\"X\", (np.random.randint(10, size=(2,3))))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"shape:\", workspace.FetchBlob(\"shape\"))\n\n```\n\n**Result**\n\n```\n\nX:\n[[3 2 5]\n [5 7 3]]\nshape: [2 3]\n\n```\n\n</details>\n\n      ",
    "attributes": [
      {
        "description": "Array of interested axes.If given, this operator only returns the dimensions of the given axes.Otherwise, the operator returns the dimensions of all axes.",
        "name": "axes",
        "option": "optional",
        "type": "int64[]"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor)* Input tensor.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor)* Output tensor containing shape of input tensor.",
        "name": "shape"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Sigmoid",
    "category": "Activation",
    "description": "\nApply the Sigmoid function element-wise to the input tensor. This is often used\nas a non-linear activation function in a neural network. The sigmoid function is\ndefined as:\n\n$$Sigmoid(x) = \\frac{1}{1+\\exp(-x)}$$\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/sigmoid_op.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Sigmoid\",\n    [\"X\"],\n    [\"Y\"]\n)\n\nworkspace.FeedBlob(\"X\", np.random.randn(5).astype(np.float32))\nprint(\"input:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"sigmoid:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\ninput: [ 1.5744036   0.31632107  1.7842269   1.4450722  -2.1726978 ]\nsigmoid: [0.8284105  0.57842743 0.85621804 0.80923885 0.10222916]\n\n```\n\n</details>\n\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input tensor.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output tensor.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SigmoidCrossEntropyWithLogits",
    "description": "\nGiven two matrices logits and targets, of same shape,\n(batch_size, num_classes), computes the sigmoid cross entropy between the two.\nReturns a tensor of shape (batch_size,) of losses for each example.\n",
    "attributes": [
      {
        "description": "default is false; if enabled, will use the log d trick to avoid the vanishing\ngradients early on; see Goodfellow et. al (2014)",
        "name": "log_D_trick",
        "option": "optional"
      },
      {
        "description": "default is false; if enabled, the model will be allowed to train on an unjoined\ndataset, where some examples might be false negative and might appear\nin the dataset later as (true) positive example.",
        "name": "unjoined_lr_loss",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "matrix of logits for each example and class.",
        "name": "logits"
      },
      {
        "description": "matrix of targets, same shape as logits.",
        "name": "targets"
      }
    ],
    "outputs": [
      {
        "description": "Vector with the total xentropy for each example.",
        "name": "xentropy"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SigmoidCrossEntropyWithLogitsGradient",
    "support_level": "default"
  },
  {
    "name": "SigmoidGradient",
    "description": "\nSigmoidGradient takes both Y and dY and uses this to update dX according to the\nchain rule and derivatives of the sigmoid function.\n",
    "support_level": "default"
  },
  {
    "name": "Sign",
    "description": "\nComputes sign for each element of the input: -1, 0 or 1.\n\nGithub Link:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/elementwise_ops_schema.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n\"Sign\",\n[\"X\"],\n[\"Y\"],\n)\n\nworkspace.FeedBlob(\"X\", (np.random.rand(3, 3).astype(np.float32) - np.random.rand(3, 3).astype(np.float32)))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n[[ 0.02816287  0.22408086 -0.30342305]\n[-0.18481976  0.03948995  0.39698976]\n[-0.63304734 -0.6919183  -0.31524038]]\nY:\n[[ 1.  1. -1.]\n[-1.  1.  1.]\n[-1. -1. -1.]]\n\n```\n\n</details>\n\n    ",
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input data tensor.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output tensor.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Sin",
    "description": "\nCalculates the sine of the given input tensor, element-wise.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/sin_op.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Sin\",\n    [\"X\"],\n    [\"Y\"]\n)\n\nworkspace.FeedBlob(\"X\", np.random.rand(5).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX: [0.8466114  0.1803606  0.5601509  0.04959291 0.64770824]\nY: [0.74903965 0.17938434 0.5313141  0.04957259 0.60336035]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input tensor.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output tensor calculated as the sine of the input tensor, element-wise.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SinGradient",
    "support_level": "default"
  },
  {
    "name": "Sinh",
    "description": "\nCalculates the hyperbolic sine of the given input tensor, element-wise.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/sinh_op.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Sinh\",\n    [\"X\"],\n    [\"Y\"]\n)\n\nworkspace.FeedBlob(\"X\", np.random.rand(5).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX: [0.98907769 0.52907848 0.03216429 0.94983935 0.47881418]\nY: [1.15841695 0.5541099  0.03216984 1.09924557 0.49732079]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "Input tensor",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "The hyperbolic sine values of the input tensor, computed element-wise",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SinhGradient",
    "support_level": "default"
  },
  {
    "name": "SinusoidPositionEncoding",
    "description": "\nCalculates a sinusoid position encoding tensor as described\nin https://arxiv.org/abs/1706.03762. Takes a 2-D tensor\n(of size M x K) of positions as input, the embedding size\nas an argument, and outputs a position encoding tensor of\nsize (M x K x embedding_size). Here M is typically the max\nsequence length and K is typically the batch size.\nThe input tensor must satisfy input[m, 0] == input[m, k] for all k.\n\nEncoded as amplitude * SIN(pos/alpha^(i/embedding_size)) if i is even,\nelse amplitude * COS(pos/alpha^(i/embedding_size)). Here, pos is the position,\nalpha and amplitude are tuning parameters, i is the current dimension for\nthe embedding, and embedding_size is the number of total dimensions in\nthe embedding.\n",
    "attributes": [
      {
        "description": "Desired embedding size/number of dimensions -- defaults to 100",
        "name": "embedding_size",
        "option": "optional"
      },
      {
        "description": "Sinusoid tuning parameter -- defaults to 10000",
        "name": "alpha",
        "option": "optional"
      },
      {
        "description": "Amplitude of Sin/Cos output",
        "name": "amplitude",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "2-D tensor of positions to be encoded",
        "name": "positions"
      }
    ],
    "outputs": [
      {
        "description": "3-D tensor representing the positional encoding",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Size",
    "description": "\nReturn a 1D tensor of type *int64* that contains the number of elements of the input tensor.\n\nGithub Link:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/utility_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Size\",\n    [\"X\"],\n    [\"size\"],\n)\n\nworkspace.FeedBlob(\"X\", (np.random.randint(10, size=(3,3))))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"size:\", workspace.FetchBlob(\"size\"))\n\nworkspace.ResetWorkspace()\n\nworkspace.FeedBlob(\"X\", (np.random.rand(6,4)))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"size:\", workspace.FetchBlob(\"size\"))\n\n```\n\n**Result**\n\n```\n\nX:\n[[3 7 0]\n [0 1 6]\n [5 0 8]]\nsize: 9\nX:\n[[0.92017884 0.32115368 0.68692035 0.64135016]\n [0.8723328  0.77830265 0.80688656 0.25524236]\n [0.37970216 0.76407047 0.85689564 0.30692883]\n [0.69352573 0.42531502 0.16415212 0.59209324]\n [0.52684188 0.37094846 0.60670079 0.6489272 ]\n [0.94715906 0.34800557 0.61898769 0.28947359]]\nsize: 24\n\n```\n\n</details>\n\n      ",
    "inputs": [
      {
        "description": "*(type: Tensor)* Input tensor to calculate number of elements.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor)* 1D tensor of type int64 that contains the number of elements in the input tensor *X*.",
        "name": "size"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Slice",
    "category": "Tensor",
    "description": "\nProduces a slice of the input tensor.\n\n- Currently, only slicing in a single dimension is supported.\n\n- Start and end indices are either passed as two 1D input tensors or using the `starts` and `ends` arguments.\n\n- If a negative value is passed for any of the start or end indices, it represents |value| - 1 elements before the end of that dimension. End indices are non-inclusive unless negative (end index -1 means up to and including the last element).\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/slice_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Slice\",\n    [\"X\"],\n    [\"Y\"],\n    starts=(0,1),\n    ends=(-1,3)\n)\n\nworkspace.FeedBlob(\"X\", np.array([[1,2,3,4],[5,6,7,8]]))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n[[1 2 3 4]\n [5 6 7 8]]\nY:\n[[2 3]\n [6 7]]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "(*Tuple(int)*): list of starting indices",
        "name": "starts",
        "option": "optional"
      },
      {
        "description": "(*Tuple(int)*): list of ending indices",
        "name": "ends",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "(*Tensor*): tensor to extract slices from",
        "name": "X"
      },
      {
        "description": "(*Tensor`<int>`*): 1D tensor of start-indices for each dimension of data (dimensions following the sliced one might be omitted)",
        "name": "starts"
      },
      {
        "description": "(*Tensor`<int>`*): 1D tensor of end-indices for each dimension of data (dimensions following the sliced one might be omitted)",
        "name": "ends"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor*): sliced output tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SliceGradient",
    "support_level": "default"
  },
  {
    "name": "Snapshot",
    "support_level": "default"
  },
  {
    "name": "Softmax",
    "category": "Activation",
    "description": "\n\nApplies the Softmax function to an n-dimensional input Tensor rescaling them so\nthat the elements of the n-dimensional output Tensor lie in the range (0,1) and\nsum to 1. The softmax operator is typically the last layer in a classifier network,\nas its output can be interpreted as confidence probabilities of an input belonging\nto each class. The input is a 2-D tensor (Tensor) of size (batch_size x\ninput_feature_dimensions). The output tensor has the same shape and contains the\nsoftmax normalized values of the corresponding input. The softmax function is\ndefined as follows:\n\n$$softmax(x_i) = \\frac{\\exp(x_i)}{\\sum_{j} \\exp(x_j)}$$\n\nThe input does not need to explicitly be a 2D vector; rather, it will be coerced\ninto one. For an arbitrary n-dimensional tensor `X` in\n$[a_0, a_1, ..., a_{k-1}, a_k, ..., a_{n-1}]$, where k is the `axis` provided,\nthen `X` will be coerced into a 2-dimensional tensor with dimensions\n$[(a_0 * ... * a_{k-1}), (a_k * ... * a_{n-1})]$. For the default case where\n`axis`=1, the `X` tensor will be coerced into a 2D tensor of dimensions\n$[a_0, (a_1 * ... * a_{n-1})]$, where $a_0$ is often the batch size. In this\nsituation, we must have $a_0 = N$ and $a_1 * ... * a_{n-1} = D$. Each of these\ndimensions must be matched correctly, or else the operator will throw errors.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/softmax_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/softmax_op.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Softmax\",\n    [\"X\"],\n    [\"Y\"]\n)\n\nworkspace.FeedBlob(\"X\", np.random.randn(1, 5).astype(np.float32))\nprint(\"input:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"softmax:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\ninput: [[ 0.0417839   0.61960053 -0.23150268 -0.64389366 -3.0000346 ]]\nsoftmax: [[0.24422921 0.43525138 0.18582782 0.12303016 0.01166145]]\n\n```\n\n</details>\n\n\n\n",
    "attributes": [
      {
        "default": 1,
        "description": "Axis of the inputs when coerced to 2D matrix.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "The input tensor that's coerced into a 2D matrix of size (NxD) as described above.",
        "name": "input"
      },
      {
        "description": "*(type: Tensor`<float>`)* Input tensor that's coerced into a 2D matrix of size (NxD) as described above.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "The softmax normalized output values with the same shape as input tensor.",
        "name": "output"
      },
      {
        "description": "*(type: Tensor`<float>`)* The softmax normalized output tensor with the same shape as input tensor.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SoftmaxGradient",
    "support_level": "default"
  },
  {
    "name": "SoftmaxWithLoss",
    "description": "\nCombined Softmax and Cross-Entropy loss operator. The operator first computes the softmax normalized values for each layer in the batch of the given input, then computes cross-entropy loss. This operator is numerically more stable than separate `Softmax` and `CrossEntropy` ops. The inputs are a 2-D tensor `logits` of size (batch_size x input_feature_dimensions), which represents the unscaled log probabilities, and a 1-dimensional integer `labels` tensor for ground truth. An optional third input blob (`weight_tensor`) can be used to weight the samples for the loss, which is useful if the training set is unbalanced. This operator outputs a `softmax` tensor which contains the probability for each label for each example (same shape is `logits` input), and a scalar `loss` value, which is the averaged cross-entropy loss between the softmax probabilities and the ground truth values. Use parameter `label_prob`=1 to enable inputting labels as a probability distribution.\n\nSoftmax cross-entropy loss function:\n\n$$loss(x, class) = -\\log{\\biggl(\\frac{\\exp(x[class])}{\\sum_{j} \\exp(x[j])}\\biggr)} = -x[class] + \\log{\\biggl(\\sum_{j} \\exp(x[j])\\biggr)}$$\n\nor if the `weight_tensor` has been passed:\n\n$$loss(x, class) = weight[class]\\biggl(-x[class] + \\log{\\biggl(\\sum_{j} \\exp(x[j])\\biggr)}\\biggr)$$\n\nThe `logits` input does not need to explicitly be a 2D vector; rather, it will be coerced into one. For an arbitrary n-dimensional tensor `X` in $[a_0, a_1, ..., a_{k-1}, a_k, ..., a_{n-1}]$, where k is the `axis` provided, then `X` will be coerced into a 2-dimensional tensor with dimensions $[(a_0 * ... * a_{k-1}), (a_k * ... * a_{n-1})]$. For the default case where `axis`=1, the `X` tensor will be coerced into a 2D tensor of dimensions $[a_0, (a_1 * ... * a_{n-1})]$, where $a_0$ is often the batch size. In this situation, we must have $a_0 = N$ and $a_1 * ... * a_{n-1} = D$. Each of these dimensions must be matched correctly, or else the operator will throw errors.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/softmax_with_loss_op.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"SoftmaxWithLoss\",\n    [\"logits\", \"labels\"],\n    [\"softmax\", \"avgloss\"]\n)\n\nworkspace.FeedBlob(\"logits\", np.random.randn(1, 5).astype(np.float32))\nworkspace.FeedBlob(\"labels\", np.asarray([4]).astype(np.int32))\nprint(\"logits:\", workspace.FetchBlob(\"logits\"))\nprint(\"labels:\", workspace.FetchBlob(\"labels\"))\nworkspace.RunOperatorOnce(op)\nprint(\"softmax:\", workspace.FetchBlob(\"softmax\"))\nprint(\"avgloss:\", workspace.FetchBlob(\"avgloss\"))\n\n```\n\n**Result**\n\n```\n\nlogits: [[-0.3429451  -0.80375195  0.23104447  1.4569176  -0.5268362 ]]\nlabels: [4]\nsoftmax: [[0.09721052 0.0613179  0.17258129 0.58800864 0.0808817 ]]\navgloss: 2.5147676\n\n```\n\n</details>\n\n<details>\n\n<summary> <b>Example 2</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"SoftmaxWithLoss\",\n    [\"logits\", \"labels\"],\n    [\"softmax\", \"avgloss\"],\n    scale=5.0\n)\n\nworkspace.FeedBlob(\"logits\", np.asarray([[.1, .4, .7, 1.5, .2]]).astype(np.float32))\nworkspace.FeedBlob(\"labels\", np.asarray([4]).astype(np.int32))\nprint(\"logits:\", workspace.FetchBlob(\"logits\"))\nprint(\"labels:\", workspace.FetchBlob(\"labels\"))\nworkspace.RunOperatorOnce(op)\nprint(\"softmax:\", workspace.FetchBlob(\"softmax\"))\nprint(\"avgloss:\", workspace.FetchBlob(\"avgloss\"))\n\n```\n\n**Result**\n\n```\n\nlogits: [[0.1 0.4 0.7 1.5 0.2]]\nlabels: [4]\nsoftmax: [[0.10715417 0.144643   0.19524762 0.4345316  0.11842369]]\navgloss: 10.667433\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 0,
        "description": "Setting to 1 enables inputting labels as probability distribution.",
        "name": "label_prob",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": 1,
        "description": "Axis of the inputs when coerced to 2D.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      },
      {
        "description": "Average loss output scaling factor (must be >= 0).",
        "name": "scale",
        "option": "optional",
        "type": "float32"
      },
      {
        "default": "'NCHW'",
        "description": "Order of blob dimensions (only 'NCHW' is supported currently).",
        "name": "order",
        "option": "optional",
        "type": "string"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input tensor.",
        "name": "logits"
      },
      {
        "description": "*(type: Tensor`<float>`)* Ground truth label tensor.",
        "name": "labels"
      },
      {
        "description": "*(type: Tensor`<float>`)* [OPTIONAL] Blob used to weight the samples for the loss.",
        "name": "weight_tensor"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Softmax output tensor.",
        "name": "softmax"
      },
      {
        "description": "*(type: float)* Averaged cross-entropy loss output.",
        "name": "loss"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SoftmaxWithLossGradient",
    "support_level": "default"
  },
  {
    "name": "Softplus",
    "description": "\nSoftplus takes one input data tensor $X$ and produces one output data tensor $Y,$ where the softplus function, $y = ln(e^x + 1)$, is applied to $X$ elementwise.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/softplus_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/softplus_op.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Softplus\",\n    [\"X\"],\n    [\"Y\"],\n)\n\nworkspace.FeedBlob(\"X\", np.random.randn(3, 3).astype(np.float32))\nprint(\"X:\\n\", workspace.FetchBlob(\"X\"), \"\\n\")\n\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n [[-0.5380011   0.65190786  0.55673236]\n [-0.16272168  0.5451048   0.30880353]\n [-0.76606876 -0.6238556  -0.40444514]]\n\nY:\n [[0.4598992  1.0713093  1.0097669 ]\n [0.61509246 1.0023911  0.8594219 ]\n [0.38174385 0.42909983 0.5112337 ]]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "Input data blob to be operated on.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "Output data blob with same shape as input.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SoftplusGradient",
    "support_level": "default"
  },
  {
    "name": "Softsign",
    "description": "\n*Softsign* takes one input data tensor $X$ and produces one output data $Y,$ where the softsign function, $y = \\frac{x}{1+ |x|}$, is applied to $X$ elementwise. This operation can be done in an in-place fashion too, by providing the same input and output blobs.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/softsign_op.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Softsign\",\n    [\"X\"],\n    [\"Y\"],\n)\n\nworkspace.FeedBlob(\"X\", np.random.randn(3, 3).astype(np.float32))\nprint(\"X:\\n\", workspace.FetchBlob(\"X\"), \"\\n\")\n\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\\n\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n [[-1.3060539   0.7242748  -1.9907674 ]\n [-0.64802396 -0.03244735  0.7455406 ]\n [-0.298492   -0.5774271   2.8364444 ]]\n\nY:\n [[-0.5663588   0.420046   -0.6656376 ]\n [-0.39321268 -0.03142761  0.4271116 ]\n [-0.2298759  -0.36605626  0.739342  ]]\n\n```\n\n</details>\n\n\n",
    "inputs": [
      {
        "description": "Input data blob to be operated on.",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Output data blob with same shape as input",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SoftsignGradient",
    "description": "\nCalculates the softsign gradient (sgn(x)/(1+|x|)^2) of the given input tensor\nelement-wise.\n",
    "inputs": [
      {
        "description": "1-D input tensor",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "The softsign gradient (sgn(x)/(1+|x|)^2) values of the input tensor computed element-wise",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SortAndShuffle",
    "description": "\nCompute the sorted indices given a field index to sort by and break the sorted\nindices into chunks of shuffle_size * batch_size and shuffle each chunk,\nfinally we shuffle between batches. If sort_by_field_idx is -1 we skip sort.\n\nFor example, we have data sorted as\n1,2,3,4,5,6,7,8,9,10,11,12\n\nand batchSize = 2 and shuffleSize = 3, when we shuffle we get:\n[3,1,4,6,5,2] [12,10,11,8,9,7]\n\nAfter this we will shuffle among different batches with size 2\n[3,1],[4,6],[5,2],[12,10],[11,8],[9,7]\n\nWe may end up with something like\n[9,7],[5,2],[12,10],[4,6],[3,1],[11,8]\n\nInput(0) is a blob pointing to a TreeCursor, and\n[Input(1),... Input(num_fields)] a list of tensors containing the data for\neach field of the dataset.\n\nSortAndShuffle is thread safe.\n",
    "inputs": [
      {
        "description": "A blob containing a pointer to the cursor.",
        "name": "cursor"
      },
      {
        "description": "First dataset field",
        "name": "dataset_field_0"
      }
    ],
    "outputs": [
      {
        "description": "Tensor containing sorted indices.",
        "name": "indices"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SortedSegmentMean",
    "description": "\nApplies 'Mean' to each segment of input tensor. Segments need to be sorted and\ncontiguous. See also UnsortedSegmentMean that doesn't have this requirement.\n\nSEGMENT_IDS is a vector that maps each of the first dimension slices of the\nDATA to a particular group (segment). Values belonging to the same segment are\naggregated together.\n\nThe first dimension of the output is equal to the number of input segments,\ni.e. `SEGMENT_IDS[-1]+1`. Other dimensions are inherited from the input tensor.\n\nMean computes the element-wise mean of the input slices. Operation doesn't change the shape of the individual blocks.\n  ",
    "inputs": [
      {
        "description": "Input tensor, slices of which are aggregated.",
        "name": "DATA"
      },
      {
        "description": "Vector with the same length as the first dimension of DATA and values in the range 0..K-1 and in increasing order that maps each slice of DATA to one of the segments",
        "name": "SEGMENT_IDS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated output tensor. Has the first dimension of K (the number of segments).",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SortedSegmentMeanGradient",
    "support_level": "default"
  },
  {
    "name": "SortedSegmentRangeLogMeanExp",
    "description": "\nApplies 'LogMeanExp' to each segment of input tensor. In order to allow for more\nefficient implementation of 'LogMeanExp', the input segments have to be contiguous\nand non-empty.\n\nSEGMENT_IDS is a vector that maps each of the first dimension slices of the\nDATA to a particular group (segment). Values belonging to the same segment are\naggregated together.\n\nThe first dimension of the output is equal to the number of input segments,\ni.e. `SEGMENT_IDS[-1]+1`. Other dimensions are inherited from the input tensor.\n\nLogMeanExp computes the element-wise log of the mean of exponentials of input slices. Operation doesn't change the shape of individual blocks.\n  ",
    "inputs": [
      {
        "description": "Input tensor to be aggregated",
        "name": "DATA"
      },
      {
        "description": "Vector with the same length as the first dimension of DATA and values in the range 0..K-1 and in increasing order that maps each slice of DATA to one of the segments",
        "name": "SEGMENT_IDS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated tensor with the first dimension of K and the other dimentsions inherited from DATA",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SortedSegmentRangeLogMeanExpGradient",
    "support_level": "default"
  },
  {
    "name": "SortedSegmentRangeLogSumExp",
    "description": "\nApplies 'LogSumExp' to each segment of input tensor. In order to allow for more\nefficient implementation of 'LogSumExp', the input segments have to be contiguous\nand non-empty.\n\nSEGMENT_IDS is a vector that maps each of the first dimension slices of the\nDATA to a particular group (segment). Values belonging to the same segment are\naggregated together.\n\nThe first dimension of the output is equal to the number of input segments,\ni.e. `SEGMENT_IDS[-1]+1`. Other dimensions are inherited from the input tensor.\n\nLogSumExp computes the element-wise log of the sum of exponentials of input slices. Operation doesn't change the shape of individual blocks.\n  ",
    "inputs": [
      {
        "description": "Input tensor to be aggregated",
        "name": "DATA"
      },
      {
        "description": "Vector with the same length as the first dimension of DATA and values in the range 0..K-1 and in increasing order that maps each slice of DATA to one of the segments",
        "name": "SEGMENT_IDS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated tensor with the first dimension of K and the other dimentsions inherited from DATA",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SortedSegmentRangeLogSumExpGradient",
    "support_level": "default"
  },
  {
    "name": "SortedSegmentRangeMax",
    "description": "\nApplies 'Max' to each segment of input tensor. In order to allow for more\nefficient implementation of 'Max', the input segments have to be contiguous\nand non-empty.\n\nSEGMENT_IDS is a vector that maps each of the first dimension slices of the\nDATA to a particular group (segment). Values belonging to the same segment are\naggregated together.\n\nThe first dimension of the output is equal to the number of input segments,\ni.e. `SEGMENT_IDS[-1]+1`. Other dimensions are inherited from the input tensor.\n\nMax computation is done element-wise, so that each element of the output slice corresponds to the max value of the respective elements in the input slices. Operation doesn't change the shape of individual blocks. This implementation imitates torch nn.Max operator. If the maximum value occurs more than once, the operator will return the first occurrence of value. When computing the gradient using the backward propagation, the gradient input corresponding to the first occurrence of the maximum value will be used.\n  ",
    "inputs": [
      {
        "description": "Input tensor to be aggregated",
        "name": "DATA"
      },
      {
        "description": "Vector with the same length as the first dimension of DATA and values in the range 0..K-1 and in increasing order that maps each slice of DATA to one of the segments",
        "name": "SEGMENT_IDS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated tensor with the first dimension of K and the other dimentsions inherited from DATA",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SortedSegmentRangeMaxGradient",
    "support_level": "default"
  },
  {
    "name": "SortedSegmentRangeMean",
    "description": "\nApplies 'Mean' to each segment of input tensor. In order to allow for more\nefficient implementation of 'Mean', the input segments have to be contiguous\nand non-empty.\n\nSEGMENT_IDS is a vector that maps each of the first dimension slices of the\nDATA to a particular group (segment). Values belonging to the same segment are\naggregated together.\n\nThe first dimension of the output is equal to the number of input segments,\ni.e. `SEGMENT_IDS[-1]+1`. Other dimensions are inherited from the input tensor.\n\nMean computation is done element-wise, so that each element of the output slice corresponds to the average value of the respective elements in the input slices. Operation doesn't change the shape of individual blocks.\n  ",
    "inputs": [
      {
        "description": "Input tensor to be aggregated",
        "name": "DATA"
      },
      {
        "description": "Vector with the same length as the first dimension of DATA and values in the range 0..K-1 and in increasing order that maps each slice of DATA to one of the segments",
        "name": "SEGMENT_IDS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated tensor with the first dimension of K and the other dimentsions inherited from DATA",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SortedSegmentRangeMeanGradient",
    "support_level": "default"
  },
  {
    "name": "SortedSegmentRangeSum",
    "description": "\nApplies 'Sum' to each segment of input tensor. In order to allow for more\nefficient implementation of 'Sum', the input segments have to be contiguous\nand non-empty.\n\nSEGMENT_IDS is a vector that maps each of the first dimension slices of the\nDATA to a particular group (segment). Values belonging to the same segment are\naggregated together.\n\nThe first dimension of the output is equal to the number of input segments,\ni.e. `SEGMENT_IDS[-1]+1`. Other dimensions are inherited from the input tensor.\n\nSummation is done element-wise across slices of the input tensor and doesn't change the shape of the individual blocks.\n  ",
    "inputs": [
      {
        "description": "Input tensor to be aggregated",
        "name": "DATA"
      },
      {
        "description": "Vector with the same length as the first dimension of DATA and values in the range 0..K-1 and in increasing order that maps each slice of DATA to one of the segments",
        "name": "SEGMENT_IDS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated tensor with the first dimension of K and the other dimentsions inherited from DATA",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SortedSegmentRangeSumGradient",
    "support_level": "default"
  },
  {
    "name": "SortedSegmentSum",
    "description": "\nApplies 'Sum' to each segment of input tensor. Segments need to be sorted and\ncontiguous. See also UnsortedSegmentSum that doesn't have this requirement.\n\nSEGMENT_IDS is a vector that maps each of the first dimension slices of the\nDATA to a particular group (segment). Values belonging to the same segment are\naggregated together.\n\nThe first dimension of the output is equal to the number of input segments,\ni.e. `SEGMENT_IDS[-1]+1`. Other dimensions are inherited from the input tensor.\n\nSummation is done element-wise across slices of the input tensor and doesn't change the shape of the individual blocks.\n  ",
    "inputs": [
      {
        "description": "Input tensor, slices of which are aggregated.",
        "name": "DATA"
      },
      {
        "description": "Vector with the same length as the first dimension of DATA and values in the range 0..K-1 and in increasing order that maps each slice of DATA to one of the segments",
        "name": "SEGMENT_IDS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated output tensor. Has the first dimension of K (the number of segments).",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SortedSegmentSumGradient",
    "support_level": "default"
  },
  {
    "name": "SortedSegmentWeightedSum",
    "description": "\nApplies 'WeightedSum' to each segment of input tensor. Segments need to be sorted and\ncontiguous. See also UnsortedSegmentWeightedSum that doesn't have this requirement.\n\nSEGMENT_IDS is a vector that maps each of the first dimension slices of the\nDATA to a particular group (segment). Values belonging to the same segment are\naggregated together.\n\nThe first dimension of the output is equal to the number of input segments,\ni.e. `SEGMENT_IDS[-1]+1`. Other dimensions are inherited from the input tensor.\n\nInput slices are first scaled by SCALARS and then summed element-wise. It doesn't change the shape of the individual blocks.\n  ",
    "attributes": [
      {
        "description": "Produce also gradient for `weights`. For now it's only supported in `Lengths`-based operators",
        "name": "grad_on_weights",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor for the summation",
        "name": "DATA"
      },
      {
        "description": "Scalar multipliers for the input slices. Must be a vector with the length matching the number of slices",
        "name": "SCALARS"
      },
      {
        "description": "Vector with the same length as the first dimension of DATA and values in the range 0..K-1 and in increasing order that maps each slice of DATA to one of the segments",
        "name": "SEGMENT_IDS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated output tensor. Has the first dimension of K (the number of segments).",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SortedSegmentWeightedSumGradient",
    "support_level": "default"
  },
  {
    "name": "SpaceToBatch",
    "description": "\nZero-pads and then rearranges (permutes) blocks of spatial data into batch. More specifically, this op outputs a copy of the input tensor where values from the height and width dimensions are moved to the batch dimension. After the zero-padding is according to the `pad` argument, both height and width of the input must be divisible by the `block_size`. Only \"NCHW\" order is currently supported.\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/space_batch_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"SpaceToBatch\",\n    [\"X\"],\n    [\"Y\"],\n    pad=2,\n    block_size=3\n)\n\nworkspace.FeedBlob(\"X\", np.random.rand(1,3,5,5).astype(np.float32))\nprint(\"X.shape:\", workspace.FetchBlob(\"X\").shape)\nworkspace.RunOperatorOnce(op)\nprint(\"Y.shape:\", workspace.FetchBlob(\"Y\").shape)\n\n```\n\n**Result**\n\n```\n\nX.shape: (1, 3, 5, 5)\nY.shape: (9, 3, 3, 3)\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "(*int*): exclusive axis that divides the first and second dimension of matrix `A` (default=0)",
        "name": "pad",
        "option": "optional"
      },
      {
        "description": "(*int*): height/width of spatial blocks to be moved (default=2)",
        "name": "block_size",
        "option": "optional"
      },
      {
        "description": "(*string*): order of dimensions of input and output blobs; only \"NCHW\" order is currently supported (default=\"NCHW\")",
        "name": "order",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "(*Tensor`<float>`*): input tensor (NCHW order)",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor`<float>`*): output tensor (NCHW order)",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseAdadelta",
    "description": "\n\nGiven inputs (param, moment, moment_delta, indices, grad, lr),\nruns the dense AdaDelta update on (param, grad, moment[indices],\n moment_delta[indices], lr), and returns (new_param, new_moment,\n new_moment_delta) as in the dense case.\n\n",
    "attributes": [
      {
        "description": "Default 1e-5",
        "name": "epsilon",
        "option": "optional"
      },
      {
        "description": "Default 0.95, the squared gradient sum is decayed by this factor.",
        "name": "decay",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated",
        "name": "param"
      },
      {
        "description": "Average of squared gradients",
        "name": "moment"
      },
      {
        "description": "Average of squared parameter updates",
        "name": "moment_delta"
      },
      {
        "description": "Sparse indices",
        "name": "indices"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "learning rate",
        "name": "lr"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters",
        "name": "output_param"
      },
      {
        "description": "Updated average squared gradient",
        "name": "output_moment"
      },
      {
        "description": "Updated average of squared parameter updates",
        "name": "output_moment_delta"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseAdagrad",
    "description": "\n\nGiven inputs (param, moment, indices, grad, lr), runs the dense AdaGrad\nupdate on (param, grad, moment[indices], lr), and returns (new_param,\nnew_moment) as in the dense case.\n\n",
    "attributes": [
      {
        "description": "Default 1e-5",
        "name": "epsilon",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated",
        "name": "param"
      },
      {
        "description": "Moment history",
        "name": "moment"
      },
      {
        "description": "Sparse indices",
        "name": "indices"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "learning rate",
        "name": "lr"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters",
        "name": "output_param"
      },
      {
        "description": "Updated moment",
        "name": "output_moment_1"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseAdagradFusedWithSparseLengthsMeanGradient",
    "description": "\n\nFused operator of\nSparseLengthsIndicesInGradientMeanGradient (gradient of SparseLengthsMean) +\nSparseAdagrad.\n\nGiven inputs (param, moment, indices, grad, lr), runs the sparse AdaGrad\nupdate on (param, grad, moment[indices], lr), and returns (new_param,\nnew_moment) as in the dense case. Additional input (lengths) is for fused\nSparseLengthsIndicesInGradientMeanGradient operator.\n\n",
    "attributes": [
      {
        "description": "Default 1e-5",
        "name": "epsilon",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated",
        "name": "param"
      },
      {
        "description": "Moment history",
        "name": "moment"
      },
      {
        "description": "Integer vector containing indices of the first dimension of param for the slices that are being updated",
        "name": "indices"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "learning rate",
        "name": "lr"
      },
      {
        "description": "Non negative vector with sum of elements equal to indices length",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters",
        "name": "output_param"
      },
      {
        "description": "Updated moment",
        "name": "output_moment"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseAdagradFusedWithSparseLengthsMeanGradientApprox",
    "description": "\n\nFused operator of\nSparseLengthsIndicesInGradientMeanGradient (gradient of SparseLengthsMean) +\nSparseAdagrad.\n\nGiven inputs (param, moment, indices, grad, lr), runs the sparse AdaGrad\nupdate on (param, grad, moment[indices], lr), and returns (new_param,\nnew_moment) as in the dense case. Additional input (lengths) is for fused\nSparseLengthsIndicesInGradientMeanGradient operator.\n\n",
    "attributes": [
      {
        "description": "Default 1e-5",
        "name": "epsilon",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated",
        "name": "param"
      },
      {
        "description": "Moment history",
        "name": "moment"
      },
      {
        "description": "Integer vector containing indices of the first dimension of param for the slices that are being updated",
        "name": "indices"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "learning rate",
        "name": "lr"
      },
      {
        "description": "Non negative vector with sum of elements equal to indices length",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters",
        "name": "output_param"
      },
      {
        "description": "Updated moment",
        "name": "output_moment"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseAdagradFusedWithSparseLengthsSumGradient",
    "description": "\n\nFused operator of\nSparseLengthsIndicesInGradientSumGradient (gradient of SparseLengthsSum) +\nSparseAdagrad.\n\nGiven inputs (param, moment, indices, grad, lr), runs the sparse AdaGrad\nupdate on (param, grad, moment[indices], lr), and returns (new_param,\nnew_moment) as in the dense case. Additional input (lengths) is for fused\nSparseLengthsIndicesInGradientSumGradient operator.\n\n",
    "attributes": [
      {
        "description": "Default 1e-5",
        "name": "epsilon",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated",
        "name": "param"
      },
      {
        "description": "Moment history",
        "name": "moment"
      },
      {
        "description": "Integer vector containing indices of the first dimension of param for the slices that are being updated",
        "name": "indices"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "learning rate",
        "name": "lr"
      },
      {
        "description": "Non negative vector with sum of elements equal to indices length",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters",
        "name": "output_param"
      },
      {
        "description": "Updated moment",
        "name": "output_moment"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseAdagradFusedWithSparseLengthsSumGradientApprox",
    "description": "\n\nFused operator of\nSparseLengthsIndicesInGradientSumGradient (gradient of SparseLengthsSum) +\nSparseAdagrad.\n\nGiven inputs (param, moment, indices, grad, lr), runs the sparse AdaGrad\nupdate on (param, grad, moment[indices], lr), and returns (new_param,\nnew_moment) as in the dense case. Additional input (lengths) is for fused\nSparseLengthsIndicesInGradientSumGradient operator.\n\n",
    "attributes": [
      {
        "description": "Default 1e-5",
        "name": "epsilon",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated",
        "name": "param"
      },
      {
        "description": "Moment history",
        "name": "moment"
      },
      {
        "description": "Integer vector containing indices of the first dimension of param for the slices that are being updated",
        "name": "indices"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "learning rate",
        "name": "lr"
      },
      {
        "description": "Non negative vector with sum of elements equal to indices length",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters",
        "name": "output_param"
      },
      {
        "description": "Updated moment",
        "name": "output_moment"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseAdagradFusedWithSparseLengthsWeightedSumGradient",
    "description": "\n\nFused operator of SparseLengthsIndicesInGradientWeightedSumWithMainInputGradient\n(gradient of SparseLengthsWeightedSum) + SparseAdagrad, where weights are\npositional weights computed with LengthsRangeFill + Gather pattern.\n\nGiven inputs (param, moment, indices, grad, lr), runs the sparse AdaGrad\nupdate on (param, grad, moment[indices], lr), and returns (new_param,\nnew_moment) as in the dense case.\nThere're auxiliary inputs (aux_param) for which gradient is computed\nand returns (aux_grad).\nYet additional input (lengths) is for fused\nSparseLengthsIndicesInGradientWeightedSumWithMainInputGradient operator.\n\n",
    "attributes": [
      {
        "description": "Default 1e-5",
        "name": "epsilon",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated",
        "name": "param"
      },
      {
        "description": "Moment history",
        "name": "moment"
      },
      {
        "description": "Auxiliary parameters to be updated",
        "name": "aux_param"
      },
      {
        "description": "Integer vector containing indices of the first dimension of param for the slices that are being updated",
        "name": "indices"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "learning rate",
        "name": "lr"
      },
      {
        "description": "Non negative vector with sum of elements equal to indices length",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters",
        "name": "output_param"
      },
      {
        "description": "Updated moment",
        "name": "output_moment"
      },
      {
        "description": "Auxiliary gradient",
        "name": "aux_grad"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseAdagradFusedWithSparseLengthsWeightedSumGradientApprox",
    "description": "\n\nApproximately fused operator of\nSparseLengthsIndicesInGradientWeightedSumWithMainInputGradient\n(gradient of SparseLengthsWeightedSum) + SparseAdagrad, where weights are\npositional weights computed with LengthsRangeFill + Gather pattern.\n\nGiven inputs (param, moment, indices, grad, lr), runs the sparse AdaGrad\nupdate on (param, grad, moment[indices], lr), and returns (new_param,\nnew_moment) as in the dense case.\nThere's race condition w.r.t. ordering between reading params and writing to\nparam, hence the name Approx.\nThere're auxiliary inputs (aux_param) for which gradient is computed and\nreturns (aux_grad).\nYet additional input (lengths) is for fused\nSparseLengthsIndicesInGradientWeightedSumWithMainInputGradient operator.\n\n",
    "attributes": [
      {
        "description": "Default 1e-5",
        "name": "epsilon",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated",
        "name": "param"
      },
      {
        "description": "Moment history",
        "name": "moment"
      },
      {
        "description": "Auxiliary parameters to be updated",
        "name": "aux_param"
      },
      {
        "description": "Integer vector containing indices of the first dimension of param for the slices that are being updated",
        "name": "indices"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "learning rate",
        "name": "lr"
      },
      {
        "description": "Non negative vector with sum of elements equal to indices length",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters",
        "name": "output_param"
      },
      {
        "description": "Updated moment",
        "name": "output_moment"
      },
      {
        "description": "Auxiliary gradients",
        "name": "aux_grad"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseAdam",
    "description": "\n\n    Computes the Adam Update for the sparse case.\n    Given inputs (param, moment1, moment2, indices, grad, lr, iter), runs the dense\n    Adam on (param, moment1[indices], momemnt2[indices], lr, iter) and returns\n    (new_param, new_moment1, new_moment2) as in dense case.\n    Adam can be customized as Rectified Adam (RAdam) by setting enableRAdam = true.\n\n    ",
    "attributes": [
      {
        "description": "Default 0.9",
        "name": "beta1",
        "option": "optional"
      },
      {
        "description": "Default 0.999",
        "name": "beta2",
        "option": "optional"
      },
      {
        "description": "Default 1e-5",
        "name": "epsilon",
        "option": "optional"
      },
      {
        "description": "Default false",
        "name": "enableRAdam",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated",
        "name": "param"
      },
      {
        "description": "First moment history",
        "name": "moment_1"
      },
      {
        "description": "Second moment history",
        "name": "moment_2"
      },
      {
        "description": "Sparse indices",
        "name": "indices"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "learning rate",
        "name": "lr"
      },
      {
        "description": "iteration number",
        "name": "iter"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters",
        "name": "output_param"
      },
      {
        "description": "Updated first moment",
        "name": "output_moment_1"
      },
      {
        "description": "Updated second moment",
        "name": "output_moment_2"
      },
      {
        "description": "Optional Effective gradient",
        "name": "output_grad"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseDropoutWithReplacement",
    "description": "\n\n`SparseDropoutWithReplacement` takes a 1-d input tensor and a lengths tensor.\nValues in the Lengths tensor represent how many input elements consitute each\nexample in a given batch.  The set of input values for an example will be\nreplaced with the single dropout value with probability given by the `ratio`\nargument.\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"SparseDropoutWithReplacement\",\n    [\"X\", \"Lengths\"],\n    [\"Y\", \"OutputLengths\"],\n    ratio=0.5,\n    replacement_value=-1\n)\n\nworkspace.FeedBlob(\"X\", np.array([1, 2, 3, 4, 5]).astype(np.int64))\nworkspace.FeedBlob(\"Lengths\", np.array([2, 3]).astype(np.int32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nprint(\"Lengths:\", workspace.FetchBlob(\"Lengths\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\nprint(\"OutputLengths:\", workspace.FetchBlob(\"OutputLengths\"))\n```\n\n**Result**\n\n```\nX: [1, 2, 3, 4, 5]\nLengths: [2, 3]\nY: [1, 2, -1]\nOutputLengths: [2, 1]\n```\n\n</details>\n\n",
    "attributes": [
      {
        "default": 0.0,
        "description": "Probability of an element to be replaced.",
        "name": "ratio",
        "option": "optional",
        "type": "float32"
      },
      {
        "default": 0,
        "description": "Value elements are replaced with.",
        "name": "replacement_value",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<int64_t>`)* Input data tensor.",
        "name": "X"
      },
      {
        "description": "*(type: Tensor`<int32_t>`)* Lengths tensor for input.",
        "name": "Lengths"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<int64_t>`)* Output tensor.",
        "name": "Y"
      },
      {
        "description": "*(type: Tensor`<int32_t>`)* Output tensor.",
        "name": "OutputLengths"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseFtrl",
    "support_level": "default"
  },
  {
    "name": "SparseLengthsIndicesInGradientMeanGradient",
    "support_level": "default"
  },
  {
    "name": "SparseLengthsIndicesInGradientSumGradient",
    "support_level": "default"
  },
  {
    "name": "SparseLengthsIndicesInGradientWeightedSumGradient",
    "support_level": "default"
  },
  {
    "name": "SparseLengthsIndicesInGradientWeightedSumWithMainInputGradient",
    "support_level": "default"
  },
  {
    "name": "SparseLengthsMean",
    "description": "\nPulls in slices of the input tensor, groups them into segments and applies\n'Mean' to each segment. Segments are defined by their LENGTHS.\n\nThis op is basically Gather and LengthsMean fused together.\n\nINDICES should contain integers in range 0..N-1 where N is the first dimension\nof DATA. INDICES represent which slices of DATA need to be pulled in.\n\nLENGTHS is a vector that defines slice sizes by first dimension of DATA. Values\nbelonging to the same segment are aggregated together. sum(LENGTHS) has\nto match INDICES size.\n\nThe first dimension of the output is equal to the number of input segment,\ni.e. `len(LENGTHS)`. Other dimensions are inherited from the input tensor.\n\nMean computes the element-wise mean of the input slices. Operation doesn't change the shape of the individual blocks.\n  ",
    "inputs": [
      {
        "description": "Input tensor, slices of which are aggregated.",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Non negative vector with sum of elements equal to INDICES length",
        "name": "LENGTHS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated output tensor. Has the first dimension of K (the number of segments).",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsMean2BitRowwiseSparse",
    "description": "\nPerforms SparseLengthsMean, but operating on 2-bit rowwise quantized matrices\nwith fused storage (where each row stores quantized values, and then 2-byte\nfp16 scale and bias), and where rows are pruned.\n",
    "inputs": [
      {
        "description": "uint8 tensor obtained with operator FloatToFused2BitRowwiseQuantized",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      },
      {
        "description": "Integer vector mapping uncompressed indices to compressed indices",
        "name": "COMPRESSED_INDICES_MAPPING"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsMean4BitRowwiseSparse",
    "description": "\nPerforms SparseLengthsMean, but operating on 4-bit rowwise quantized matrices\nwith fused storage (where each row stores quantized values, and then 2-byte\nfp16 scale and bias), and where rows are pruned.\n",
    "inputs": [
      {
        "description": "uint8 tensor obtained with operator FloatToFused4BitRowwiseQuantized",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      },
      {
        "description": "Integer vector mapping uncompressed indices to compressed indices",
        "name": "COMPRESSED_INDICES_MAPPING"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsMean8BitRowwiseSparse",
    "description": "\nPerforms SparseLengthsMean, but operating on 8-bit rowwise quantized matrices\nwith fused storage (where each row stores quantized values, and then 4-byte\nfp32 scale and bias), and where rows are pruned.\n",
    "inputs": [
      {
        "description": "uint8 tensor obtained with operator FloatToFused4BitRowwiseQuantized",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      },
      {
        "description": "Integer vector mapping uncompressed indices to compressed indices",
        "name": "COMPRESSED_INDICES_MAPPING"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsMean8BitsRowwise",
    "description": "\nVariation of SparseLengthsMean operator, where DATA is\nstored using 8bits. DATA was quantized with 8Bit row-wise\nquantization (see doc to FloatToRowwiseQuantized8Bits operator). To\nrestore DATA from 8Bit, we use additional input that stores scales\nand biases.\n",
    "inputs": [
      {
        "description": "uint8 tensor obtained with operator FloatToRowwiseQuantized8Bits",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      },
      {
        "description": "Matrix of floats, each row r_i of which stores a pair s_i, b_i -- scale and bias for i-th row",
        "name": "scale_bias"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsMeanFused2BitRowwise",
    "description": "\nPerforms the same operation as SparseLengthsMean, but\noperating on 2-bit rowwise quantized matrices with fused storage\n(where each row stores quantized values, and then 2-byte fp16 scale and bias).\n",
    "inputs": [
      {
        "description": "uint8 tensor obtained with operator FloatToFused2BitRowwiseQuantized",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsMeanFused4BitRowwise",
    "description": "\nPerforms the same operation as SparseLengthsMean, but\noperating on 4-bit rowwise quantized matrices with fused storage\n(where each row stores quantized values, and then 2-byte fp16 scale and bias).\n",
    "inputs": [
      {
        "description": "uint8 tensor obtained with operator FloatToFused4BitRowwiseQuantized",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsMeanFused8BitRowwise",
    "description": "\nPerforms the same operation as SparseLengthsMean, but\noperating on 8-bit rowwise quantized matrices with fused storage\n(where each row stores quantized values, and then 4-byte scale and 4-byte bias).\n",
    "inputs": [
      {
        "description": "uint8 tensor obtained with operator FloatToFused8BitRowwiseQuantized",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsMeanGradient",
    "support_level": "default"
  },
  {
    "name": "SparseLengthsPositionalWeightedSum",
    "description": "\nVariation of SparseLengthsWeightedSum operator, where, for each row,\nweights are accessed by indices [0..L-1], where L is the length of given row.\nThis is basically a fused operator of LengthsRangeFill + Gather +\nSparseWeightedSum\n",
    "inputs": [
      {
        "description": "uint8 tensor obtained with operator FloatToRowwiseQuantized8Bits",
        "name": "DATA"
      },
      {
        "description": "Scalar multipliers for the input slices. Must be a vector with the length matching the length of DATA",
        "name": "WEIGHT"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsSum",
    "description": "\nPulls in slices of the input tensor, groups them into segments and applies\n'Sum' to each segment. Segments are defined by their LENGTHS.\n\nThis op is basically Gather and LengthsSum fused together.\n\nINDICES should contain integers in range 0..N-1 where N is the first dimension\nof DATA. INDICES represent which slices of DATA need to be pulled in.\n\nLENGTHS is a vector that defines slice sizes by first dimension of DATA. Values\nbelonging to the same segment are aggregated together. sum(LENGTHS) has\nto match INDICES size.\n\nThe first dimension of the output is equal to the number of input segment,\ni.e. `len(LENGTHS)`. Other dimensions are inherited from the input tensor.\n\nSummation is done element-wise across slices of the input tensor and doesn't change the shape of the individual blocks.\n  ",
    "inputs": [
      {
        "description": "Input tensor, slices of which are aggregated.",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Non negative vector with sum of elements equal to INDICES length",
        "name": "LENGTHS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated output tensor. Has the first dimension of K (the number of segments).",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsSum2BitRowwiseSparse",
    "description": "\nPerforms SparseLengthsSum, but operating on 2-bit rowwise quantized matrices\nwith fused storage (where each row stores quantized values, and then 2-byte\nfp16 scale and 2-byte fp16 bias), and where rows are pruned.\n",
    "inputs": [
      {
        "description": "uint8 tensor obtained with operator FloatToFused2BitRowwiseQuantized",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      },
      {
        "description": "Integer vector mapping uncompressed indices to compressed indices",
        "name": "COMPRESSED_INDICES_MAPPING"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsSum4BitRowwiseSparse",
    "description": "\nPerforms SparseLengthsSum, but operating on 4-bit rowwise quantized matrices\nwith fused storage (where each row stores quantized values, and then 2-byte\nfp16 scale and 2-byte fp16 bias), and where rows are pruned.\n",
    "inputs": [
      {
        "description": "uint8 tensor obtained with operator FloatToFused4BitRowwiseQuantized",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      },
      {
        "description": "Integer vector mapping uncompressed indices to compressed indices",
        "name": "COMPRESSED_INDICES_MAPPING"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsSum8BitRowwiseSparse",
    "description": "\nPerforms SparseLengthsSum, but operating on 8-bit rowwise quantized matrices\nwith fused storage (where each row stores quantized values, and then 4-byte\nfp32 scale and 4-byte fp32 bias), and where rows are pruned.\n",
    "inputs": [
      {
        "description": "uint8 tensor obtained with operator FloatToFused4BitRowwiseQuantized",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      },
      {
        "description": "Integer vector mapping uncompressed indices to compressed indices",
        "name": "COMPRESSED_INDICES_MAPPING"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsSum8BitsRowwise",
    "description": "\nVariation of SparseLengthsSum operator, where DATA is\nstored using 8bits. DATA was quantized with 8Bit row-wise\nquantization (see doc to FloatToRowwiseQuantized8Bits operator). To\nrestore DATA from 8Bit, we use additional input that stores scales\nand biases.\n",
    "inputs": [
      {
        "description": "uint8 tensor obtained with operator FloatToRowwiseQuantized8Bits",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      },
      {
        "description": "Matrix of floats, each row r_i of which stores a pair s_i, b_i -- scale and bias for i-th row",
        "name": "scale_bias"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsSumFused2BitRowwise",
    "description": "\nPerforms the same operation as SparseLengthsSum, but operating on\n2-bit rowwise quantized matrices with fused storage (where each row\nstores quantized values, and then 2-byte fp16 scale and bias).\n",
    "inputs": [
      {
        "description": "uint8 tensor obtained with operator FloatToFused2BitRowwiseQuantized",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsSumFused4BitRowwise",
    "description": "\nPerforms the same operation as SparseLengthsSum, but operating on\n4-bit rowwise quantized matrices with fused storage (where each row\nstores quantized values, and then 2-byte fp16 scale and bias).\n",
    "inputs": [
      {
        "description": "uint8 tensor obtained with operator FloatToFused4BitRowwiseQuantized",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsSumFused8BitRowwise",
    "description": "\nPerforms the same operation as SparseLengthsSum, but operating on\n8-bit rowwise quantized matrices with fused storage (where each row\nstores quantized values, and then 4-byte scale and 4-byte bias).\n",
    "inputs": [
      {
        "description": "uint8 tensor obtained with operator FloatToFused8BitRowwiseQuantized",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsSumGradient",
    "support_level": "default"
  },
  {
    "name": "SparseLengthsSumSparseLookup",
    "description": "\nThis op converts compressed indices of SparseLengthsSum*Sparse to\nuncompressed indices of SparseLengthsSum*. For compressed indices that maps\nto -1. It means it will correspond to a zero row in the uncompressed data.\nTherefore we will remove this indices and adjust the lengths.\n",
    "inputs": [
      {
        "description": "Integer vector containing compressed indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of INDICES",
        "name": "LENGTHS"
      },
      {
        "description": "Integer vector mapping uncompressed indices to compressed indices",
        "name": "COMPRESSED_INDICES_MAPPING"
      },
      {
        "description": "Vector of weights to scale rows of DATA with before reduction. Same size as INDICES.",
        "name": "WEIGHTS"
      }
    ],
    "outputs": [
      {
        "description": "Uncompressed indices",
        "name": "output_indices"
      },
      {
        "description": "Adjusted lengths",
        "name": "output_lengths"
      },
      {
        "description": "Adjusted weights",
        "name": "output_weights"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsWeightedMean8BitsRowwise",
    "description": "\nVariation of SparseLengthsWeightedMean operator, where\nDATA is stored using 8bits. DATA was quantized with 8Bit row-wise\nquantization (see doc to FloatToRowwiseQuantized8Bits operator). To\nrestore DATA from 8Bit, we use additional input that stores scales\nand biases.\n",
    "inputs": [
      {
        "description": "uint8 tensor obtained with operator FloatToRowwiseQuantized8Bits",
        "name": "DATA"
      },
      {
        "description": "Scalar multipliers for the input slices. Must be a vector with the length matching the length of INDICES",
        "name": "SCALARS"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      },
      {
        "description": "Matrix of floats, each row r_i of which stores a pair s_i, b_i -- scale and bias for i-th row",
        "name": "scale_bias"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsWeightedSum",
    "description": "\nPulls in slices of the input tensor, groups them into segments and applies\n'WeightedSum' to each segment. Segments are defined by their LENGTHS.\n\nThis op is basically Gather and LengthsWeightedSum fused together.\n\nINDICES should contain integers in range 0..N-1 where N is the first dimension\nof DATA. INDICES represent which slices of DATA need to be pulled in.\n\nLENGTHS is a vector that defines slice sizes by first dimension of DATA. Values\nbelonging to the same segment are aggregated together. sum(LENGTHS) has\nto match INDICES size.\n\nThe first dimension of the output is equal to the number of input segment,\ni.e. `len(LENGTHS)`. Other dimensions are inherited from the input tensor.\n\nInput slices are first scaled by SCALARS and then summed element-wise. It doesn't change the shape of the individual blocks.\n  ",
    "attributes": [
      {
        "description": "Produce also gradient for `weights`. For now it's only supported in `Lengths`-based operators",
        "name": "grad_on_weights",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor for the summation",
        "name": "DATA"
      },
      {
        "description": "Scalar multipliers for the input slices. Must be a vector with the length matching the number of slices",
        "name": "SCALARS"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Non negative vector with sum of elements equal to INDICES length",
        "name": "LENGTHS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated output tensor. Has the first dimension of K (the number of segments).",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsWeightedSum2BitRowwiseSparse",
    "description": "\nPerforms SparseLengthsWeightedSum, but operating on 2-bit rowwise quantized\nmatrices with fused storage (where each row stores quantized values, and then\n2-byte fp16 scale and bias), and where rows are pruned.\n",
    "inputs": [
      {
        "description": "uint8 tensor obtained with operator FloatToFused2BitRowwiseQuantized",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      },
      {
        "description": "Vector of weights to scale rows of DATA with before reduction",
        "name": "WEIGHTS"
      },
      {
        "description": "Integer vector mapping uncompressed indices to compressed indices",
        "name": "COMPRESSED_INDICES_MAPPING"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsWeightedSum4BitRowwiseSparse",
    "description": "\nPerforms SparseLengthsWeightedSum, but operating on 4-bit rowwise quantized\nmatrices with fused storage (where each row stores quantized values, and then\n2-byte fp16 scale and bias), and where rows are pruned.\n",
    "inputs": [
      {
        "description": "uint8 tensor obtained with operator FloatToFused4BitRowwiseQuantized",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      },
      {
        "description": "Vector of weights to scale rows of DATA with before reduction",
        "name": "WEIGHTS"
      },
      {
        "description": "Integer vector mapping uncompressed indices to compressed indices",
        "name": "COMPRESSED_INDICES_MAPPING"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsWeightedSum8BitRowwiseSparse",
    "description": "\nPerforms SparseLengthsWeightedSum, but operating on 8-bit rowwise quantized\nmatrices with fused storage (where each row stores quantized values, and then\n4-byte fp32 scale and bias), and where rows are pruned.\n",
    "inputs": [
      {
        "description": "uint8 tensor obtained with operator FloatToFused4BitRowwiseQuantized",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      },
      {
        "description": "Vector of weights to scale rows of DATA with before reduction",
        "name": "WEIGHTS"
      },
      {
        "description": "Integer vector mapping uncompressed indices to compressed indices",
        "name": "COMPRESSED_INDICES_MAPPING"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsWeightedSum8BitsRowwise",
    "description": "\nVariation of SparseLengthsWeightedSum operator, where\nDATA is stored using 8bits. DATA was quantized with 8Bit row-wise\nquantization (see doc to FloatToRowwiseQuantized8Bits operator). To\nrestore DATA from 8Bit, we use additional input that stores scales\nand biases.\n",
    "inputs": [
      {
        "description": "uint8 tensor obtained with operator FloatToRowwiseQuantized8Bits",
        "name": "DATA"
      },
      {
        "description": "Scalar multipliers for the input slices. Must be a vector with the length matching the length of INDICES",
        "name": "SCALARS"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      },
      {
        "description": "Matrix of floats, each row r_i of which stores a pair s_i, b_i -- scale and bias for i-th row",
        "name": "scale_bias"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsWeightedSumFused2BitRowwise",
    "description": "\nPerforms the same operation as SparseLengthsWeightedSum,\nbut operating on 2-bit rowwise quantized matrices with fused storage\n(where each row stores quantized values, and then 2-byte fp16 scale and bias).\n",
    "inputs": [
      {
        "description": "uint8 tensor obtained with operator FloatToFused2BitRowwiseQuantized",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      },
      {
        "description": "Vector of weights to scale rows of DATA with before reduction",
        "name": "WEIGHTS"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsWeightedSumFused4BitRowwise",
    "description": "\nPerforms the same operation as SparseLengthsWeightedSum,\nbut operating on 4-bit rowwise quantized matrices with fused storage\n(where each row stores quantized values, and then 2-byte fp16 scale and bias).\n",
    "inputs": [
      {
        "description": "uint8 tensor obtained with operator FloatToFused4BitRowwiseQuantized",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      },
      {
        "description": "Vector of weights to scale rows of DATA with before reduction",
        "name": "WEIGHTS"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsWeightedSumFused8BitRowwise",
    "description": "\nPerforms the same operation as SparseLengthsWeightedSum,\nbut operating on 8-bit rowwise quantized matrices with fused storage\n(where each row stores quantized values, and then 4-byte scale and 4-byte bias).\n",
    "inputs": [
      {
        "description": "uint8 tensor obtained with operator FloatToFused8BitRowwiseQuantized",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same sum of elements as the first dimension of DATA",
        "name": "LENGTHS"
      },
      {
        "description": "Vector of weights to scale rows of DATA with before reduction",
        "name": "WEIGHTS"
      }
    ],
    "outputs": [
      {
        "description": "output",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseLengthsWeightedSumGradient",
    "support_level": "default"
  },
  {
    "name": "SparseLengthsWeightedSumWithMainInputGradient",
    "support_level": "default"
  },
  {
    "name": "SparseLpRegularizer",
    "description": "\nGiven a sparse matrix, apply Lp regularization.  Currently only L1 and L2 are implemented.\n",
    "attributes": [
      {
        "description": "Value of p in the Lp regularization to use. The default is 2.0.",
        "name": "p",
        "option": "optional"
      },
      {
        "description": "Value of lambda (multiplier for the regularization term). The default is 1e-5.",
        "name": "reg_lambda",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be regularized",
        "name": "param"
      },
      {
        "description": "Sparse indices",
        "name": "indices"
      },
      {
        "description": "Gradient computed (optional - not used, this argument is for backwards compatibility)",
        "name": "grad"
      }
    ],
    "outputs": [
      {
        "description": "Regularized parameters",
        "name": "output_param"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseMomentumSGDUpdate",
    "description": "\n\nPerforms a momentum SGD update analogous to MomentumSGDUpdate, but using a\nGradientSlice and indices into the full param and momentum tables. Both param\nand momentum should be in-place (corresponding inputs and outputs should be the\nsame blobs).\n\n\n\n",
    "attributes": [
      {
        "description": "Momentum hyperparameter.",
        "name": "momentum",
        "option": "optional"
      },
      {
        "description": "(boolean) Whether to use Nesterov Accelerated Gradient.",
        "name": "nesterov",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "GradientSlice with gradients for updated indices.",
        "name": "grad"
      },
      {
        "description": "Momentum blob, same shape as param.",
        "name": "moment"
      },
      {
        "description": "Learning rate.",
        "name": "lr"
      },
      {
        "description": "Full parameter blob.",
        "name": "param"
      },
      {
        "description": "Indices (in first dimension of param) where updates are performed.",
        "name": "indices"
      }
    ],
    "outputs": [
      {
        "description": "Adjusted gradient.",
        "name": "output_grad"
      },
      {
        "description": "Updated momentum.",
        "name": "output_moment"
      },
      {
        "description": "Updated parameter",
        "name": "output_param"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseNormalize",
    "description": "\nGiven a sparse matrix, apply max_norm or constant_norm sparse regularization.\n",
    "attributes": [
      {
        "description": "A bool variable to control whether to use max norm     or constant norm. When use_max_norm = false, constant norm is used so that     all the embedding vectors are scaled to have a L2 norm equals to A     (see blow argument norm=A). If use_max_norm = true,     max norm is used so that embedding is scaled so that its l2 norm is no larger     than A. If an embedding's norm is less than A originally,     the embedding is left unchanged.    The default is True.",
        "name": "use_max_norm",
        "option": "optional"
      },
      {
        "description": "L2 norm of the embedding. The default is 1.0.",
        "name": "norm",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be normalized",
        "name": "param"
      },
      {
        "description": "Sparse indices",
        "name": "indices"
      },
      {
        "description": "Gradient computed (optional - not used, this argument is for backwards compatibility)",
        "name": "grad"
      }
    ],
    "outputs": [
      {
        "description": "Normalized parameters",
        "name": "output_param"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseSortedSegmentMean",
    "description": "\nPulls in slices of the input tensor, groups them into segments and applies\n'Mean' to each segment. Segments need to be sorted and contiguous. See also\nSparseUnsortedSegmentMean that doesn't have this requirement.\n\nThis op is basically Gather and SortedSegmentMean fused together.\n\nINDICES should contain integers in range 0..N-1 where N is the first dimension\nof DATA. INDICES represent which slices of DATA need to be pulled in.\n\nSEGMENT_IDS is a vector that maps each referenced slice of the DATA to a\nparticular group (segment). Values belonging to the same segment are aggregated\ntogether. SEGMENT_IDS should have the same dimension as INDICES.\n\nThe first dimension of the output is equal to the number of input segments,\ni.e. `SEGMENT_IDS[-1]+1`. Other dimensions are inherited from the input tensor.\n\nMean computes the element-wise mean of the input slices. Operation doesn't change the shape of the individual blocks.\n  ",
    "inputs": [
      {
        "description": "Input tensor, slices of which are aggregated.",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same length as INDICES and values in the range 0..K-1 and in increasing order that maps each slice of DATA referenced by INDICES to one of the segments",
        "name": "SEGMENT_IDS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated output tensor. Has the first dimension of K (the number of segments).",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseSortedSegmentMeanGradient",
    "support_level": "default"
  },
  {
    "name": "SparseSortedSegmentSum",
    "description": "\nPulls in slices of the input tensor, groups them into segments and applies\n'Sum' to each segment. Segments need to be sorted and contiguous. See also\nSparseUnsortedSegmentSum that doesn't have this requirement.\n\nThis op is basically Gather and SortedSegmentSum fused together.\n\nINDICES should contain integers in range 0..N-1 where N is the first dimension\nof DATA. INDICES represent which slices of DATA need to be pulled in.\n\nSEGMENT_IDS is a vector that maps each referenced slice of the DATA to a\nparticular group (segment). Values belonging to the same segment are aggregated\ntogether. SEGMENT_IDS should have the same dimension as INDICES.\n\nThe first dimension of the output is equal to the number of input segments,\ni.e. `SEGMENT_IDS[-1]+1`. Other dimensions are inherited from the input tensor.\n\nSummation is done element-wise across slices of the input tensor and doesn't change the shape of the individual blocks.\n  ",
    "inputs": [
      {
        "description": "Input tensor, slices of which are aggregated.",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same length as INDICES and values in the range 0..K-1 and in increasing order that maps each slice of DATA referenced by INDICES to one of the segments",
        "name": "SEGMENT_IDS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated output tensor. Has the first dimension of K (the number of segments).",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseSortedSegmentSumGradient",
    "support_level": "default"
  },
  {
    "name": "SparseSortedSegmentWeightedSum",
    "description": "\nPulls in slices of the input tensor, groups them into segments and applies\n'WeightedSum' to each segment. Segments need to be sorted and contiguous. See also\nSparseUnsortedSegmentWeightedSum that doesn't have this requirement.\n\nThis op is basically Gather and SortedSegmentWeightedSum fused together.\n\nINDICES should contain integers in range 0..N-1 where N is the first dimension\nof DATA. INDICES represent which slices of DATA need to be pulled in.\n\nSEGMENT_IDS is a vector that maps each referenced slice of the DATA to a\nparticular group (segment). Values belonging to the same segment are aggregated\ntogether. SEGMENT_IDS should have the same dimension as INDICES.\n\nThe first dimension of the output is equal to the number of input segments,\ni.e. `SEGMENT_IDS[-1]+1`. Other dimensions are inherited from the input tensor.\n\nInput slices are first scaled by SCALARS and then summed element-wise. It doesn't change the shape of the individual blocks.\n  ",
    "attributes": [
      {
        "description": "Produce also gradient for `weights`. For now it's only supported in `Lengths`-based operators",
        "name": "grad_on_weights",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor for the summation",
        "name": "DATA"
      },
      {
        "description": "Scalar multipliers for the input slices. Must be a vector with the length matching the number of slices",
        "name": "SCALARS"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Vector with the same length as INDICES and values in the range 0..K-1 and in increasing order that maps each slice of DATA referenced by INDICES to one of the segments",
        "name": "SEGMENT_IDS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated output tensor. Has the first dimension of K (the number of segments).",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseSortedSegmentWeightedSumGradient",
    "support_level": "default"
  },
  {
    "name": "SparseStorm",
    "description": "\n\nThis operator implement the STORM (https://arxiv.org/abs/1905.10018)\noptimization algorithm. Given inputs (param, moment, grad_sq_sum, grad,\nindices, lr), computes the dense STORM update on (param, moment[indices],\ngrad_sq_sum, grad, lr), and returns (new_param, new_moment, new_grad_sq_sum)\nas in the dense case.\n",
    "attributes": [
      {
        "description": "Momentum hyperparameter, c in the original paper.",
        "name": "momentum",
        "option": "optional"
      },
      {
        "description": "denominator in adaptive learning rate, w in the original paper.",
        "name": "beta",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated.",
        "name": "param"
      },
      {
        "description": "Moment history.",
        "name": "moment"
      },
      {
        "description": "Sum of observed squared gradients.",
        "name": "grad_sq_sum"
      },
      {
        "description": "Gradients computed.",
        "name": "grad"
      },
      {
        "description": "Sparse indices.",
        "name": "indices"
      },
      {
        "description": "Learning rate, k in the original paper.",
        "name": "lr"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters.",
        "name": "output_param"
      },
      {
        "description": "Updated moment.",
        "name": "output_moment"
      },
      {
        "description": "Updated sum of squared gradients.",
        "name": "output_grad_sq_sum"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseToDense",
    "description": "\nConvert sparse representations to dense with given indices.\n\nTransforms a sparse representation of map<id, value> represented as `indices`\nvector and `values` tensor into a compacted tensor where the first dimension\nis determined by the first dimension of the 3rd input if it is given or the\nmax index. Missing values are filled with zeros.\n\nThe op supports duplicated indices and performs summation over corresponding\nvalues. This behavior is useful for converting GradientSlices into dense\nrepresentation.\n\nAfter running this op:\n\n  output[indices[i], :] += values[i]  // sum over all indices[i] equal to the index\n  output[j, ...] = 0 if j not in indices\n",
    "inputs": [
      {
        "description": "1-D int32/int64 tensor of concatenated ids of data",
        "name": "indices"
      },
      {
        "description": "Data tensor, first dimension has to match `indices`, basic numeric types are supported",
        "name": "values"
      },
      {
        "description": "Optional: if provided, the first dimension of output is the first dimension of this tensor.",
        "name": "data_to_infer_dim"
      }
    ],
    "outputs": [
      {
        "description": "Output tensor of the same type as `values` of shape `[len(lengths), len(mask)] + shape(default_value)` (if `lengths` is not provided the first dimension is omitted)",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseToDenseMask",
    "description": "\nConvert sparse representations to dense with given indices.\n\nTransforms a sparse representation of map<id, value> represented as `indices`\nvector and `values` tensor into a compacted tensor where the first dimension\ncorresponds to each id provided in the mask argument. Missing values are filled\nwith the value of `default_value`. After running this op:\n\n  output[j, :] = values[i] // where mask[j] == indices[i]\n  output[j, ...] = default_value // when mask[j] doesn't appear in indices\n\nIf `lengths` is provided and not empty, an extra \"batch\" dimension is prepended\nto the output.\n\n`values` and `default_value` can have additional matching dimensions\n(the operation is performed on the entire subtensor in this case).\n\nFor example, if `lengths` is supplied and `values` is a 1-D vector of floats\nand `default_value` is a float scalar, the output is going to be a float\nmatrix of size `len(lengths) X len(mask)`.\n",
    "attributes": [
      {
        "description": "list(int) argument with desired ids on the 'dense' output dimension",
        "name": "mask",
        "option": "optional"
      },
      {
        "description": "bool whether to return presence mask, false by default",
        "name": "return_presence_mask",
        "option": "optional"
      },
      {
        "description": "int argument representing the maximum number of invalid row ids that can be skipped before returning an error. 50 by default",
        "name": "max_skipped_indices",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "1-D int32/int64 tensor of concatenated ids of data",
        "name": "indices"
      },
      {
        "description": "Data tensor, first dimension has to match `indices`",
        "name": "values"
      },
      {
        "description": "Default value for the output if the id is not present in `indices`. Must have the same type as `values` and the same shape, but without the first dimension",
        "name": "default_value"
      },
      {
        "description": "Optional lengths to represent a batch of `indices` and `values`.",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "Output tensor of the same type as `values` of shape `[len(lengths), len(mask)] + shape(default_value)` (if `lengths` is not provided the first dimension is omitted)",
        "name": "output"
      },
      {
        "description": "Bool tensor of shape `[len(lengths), len(mask)]` (if `lengths` is not provided the first dimension is omitted). True when a value for given id was present, false otherwise.",
        "name": "presence_mask"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseToDenseMaskGradient",
    "description": "\nThe output is the gradient of the input value from SparseToDenseMask. The\ngradient for default_value has not been implemented.\n",
    "support_level": "default"
  },
  {
    "name": "SparseUnsortedSegmentMean",
    "description": "\nPulls in slices of the input tensor, groups them into segments and applies\n'Mean' to each segment. Segments ids can appear in arbitrary order (unlike in\nSparseSortedSegmentMean).\n\nThis op is basically Gather and UnsortedSegmentMean fused together.\n\nINDICES should contain integers in range 0..N-1 where N is the first dimension\nof DATA. INDICES represent which slices of DATA need to be pulled in.\n\nSEGMENT_IDS is a vector that maps each referenced slice of the DATA to a\nparticular group (segment). Values belonging to the same segment are aggregated\ntogether. SEGMENT_IDS should have the same dimension as INDICES.\n\nIf `num_segments` argument is passed it would be used as a first dimension for\nthe output. Otherwise, it'd be dynamically calculated from as the max value of\nSEGMENT_IDS plus one. Other output dimensions are inherited from the input\ntensor.\n\nMean computes the element-wise mean of the input slices. Operation doesn't change the shape of the individual blocks.\n  ",
    "inputs": [
      {
        "description": "Input tensor, slices of which are aggregated.",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Integer vector with the same length as INDICES that maps each slice of DATA referenced by INDICES to one of the segments",
        "name": "SEGMENT_IDS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated output tensor. Has the first dimension of equal to the number of segments.",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseUnsortedSegmentMeanGradient",
    "support_level": "default"
  },
  {
    "name": "SparseUnsortedSegmentSum",
    "description": "\nPulls in slices of the input tensor, groups them into segments and applies\n'Sum' to each segment. Segments ids can appear in arbitrary order (unlike in\nSparseSortedSegmentSum).\n\nThis op is basically Gather and UnsortedSegmentSum fused together.\n\nINDICES should contain integers in range 0..N-1 where N is the first dimension\nof DATA. INDICES represent which slices of DATA need to be pulled in.\n\nSEGMENT_IDS is a vector that maps each referenced slice of the DATA to a\nparticular group (segment). Values belonging to the same segment are aggregated\ntogether. SEGMENT_IDS should have the same dimension as INDICES.\n\nIf `num_segments` argument is passed it would be used as a first dimension for\nthe output. Otherwise, it'd be dynamically calculated from as the max value of\nSEGMENT_IDS plus one. Other output dimensions are inherited from the input\ntensor.\n\nSummation is done element-wise across slices of the input tensor and doesn't change the shape of the individual blocks.\n  ",
    "inputs": [
      {
        "description": "Input tensor, slices of which are aggregated.",
        "name": "DATA"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Integer vector with the same length as INDICES that maps each slice of DATA referenced by INDICES to one of the segments",
        "name": "SEGMENT_IDS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated output tensor. Has the first dimension of equal to the number of segments.",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseUnsortedSegmentSumGradient",
    "support_level": "default"
  },
  {
    "name": "SparseUnsortedSegmentWeightedSum",
    "description": "\nPulls in slices of the input tensor, groups them into segments and applies\n'WeightedSum' to each segment. Segments ids can appear in arbitrary order (unlike in\nSparseSortedSegmentWeightedSum).\n\nThis op is basically Gather and UnsortedSegmentWeightedSum fused together.\n\nINDICES should contain integers in range 0..N-1 where N is the first dimension\nof DATA. INDICES represent which slices of DATA need to be pulled in.\n\nSEGMENT_IDS is a vector that maps each referenced slice of the DATA to a\nparticular group (segment). Values belonging to the same segment are aggregated\ntogether. SEGMENT_IDS should have the same dimension as INDICES.\n\nIf `num_segments` argument is passed it would be used as a first dimension for\nthe output. Otherwise, it'd be dynamically calculated from as the max value of\nSEGMENT_IDS plus one. Other output dimensions are inherited from the input\ntensor.\n\nInput slices are first scaled by SCALARS and then summed element-wise. It doesn't change the shape of the individual blocks.\n  ",
    "attributes": [
      {
        "description": "Produce also gradient for `weights`. For now it's only supported in `Lengths`-based operators",
        "name": "grad_on_weights",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor for the summation",
        "name": "DATA"
      },
      {
        "description": "Scalar multipliers for the input slices. Must be a vector with the length matching the number of slices",
        "name": "SCALARS"
      },
      {
        "description": "Integer vector containing indices of the first dimension of DATA for the slices that are being aggregated",
        "name": "INDICES"
      },
      {
        "description": "Integer vector with the same length as INDICES that maps each slice of DATA referenced by INDICES to one of the segments",
        "name": "SEGMENT_IDS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated output tensor. Has the first dimension of equal to the number of segments.",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SparseUnsortedSegmentWeightedSumGradient",
    "support_level": "default"
  },
  {
    "name": "SparseWngrad",
    "description": "\n\nThis operator implement the optimization algorithm\nin https://arxiv.org/abs/1803.02865 by Wu, Ward and Bottou.\nGiven inputs (param, seq_b, indices, grad, lr), runs the dense WnGrad\nupdate on (param, grad, seq_b, lr), and returns (new_param,\nnew_seq_b) as in the dense case.\n\n",
    "attributes": [
      {
        "description": "Default 1e-5",
        "name": "epsilon",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated",
        "name": "param"
      },
      {
        "description": "seq_b history",
        "name": "seq_b"
      },
      {
        "description": "Sparse indices",
        "name": "indices"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "learning rate",
        "name": "lr"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters",
        "name": "output_param"
      },
      {
        "description": "Updated seq_b",
        "name": "output_seq_b"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SpatialBN",
    "category": "Normalization",
    "description": "\nApplies spatial batch normalization to the input tensor as described in the original paper, [Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift](https://arxiv.org/abs/1502.03167). Be aware, this operator has two different output sets, depending on the value of *is_test*. According to the paper, the primary operation of spatial batch normalization is:\n\n$$Y = \\frac{X - \\mu_x}{\\sqrt{\\sigma^2_{x} + \\epsilon}}*\\gamma + b$$\n\nIn the equation, $\\mu_x$ is the *mean*, $X$ is the input data, $\\sigma^2_{x}$ is the *var*, $\\epsilon$ is *epsilon*, $\\gamma$ is the *scale*, $b$ is the *bias*, and $Y$ is the output data. The *momentum* arg also affects this calculation in the computation of the running mean and variance. The influence of *momentum* is as follows:\n\n$$running\\_mean = running\\_mean * momentum + mean * (1 - momentum)$$\n\n$$running\\_var = running\\_var * momentum + var * (1 - momentum)$$\n\nOutput when is_test = 0 (train mode): *Y, mean, var, saved_mean, saved_var*\n\nOutput when is_test = 1 (test mode): *Y*\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/spatial_batch_norm_op.cc\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/spatial_batch_norm_op.h\n\n",
    "attributes": [
      {
        "default": 0,
        "description": "If set to nonzero, run spatial batch normalization in test mode.",
        "name": "is_test",
        "type": "int64"
      },
      {
        "default": 1e-05,
        "description": "The epsilon value to use to avoid division by zero.",
        "name": "epsilon",
        "option": "optional",
        "type": "float32"
      },
      {
        "default": "NCHW",
        "description": "Specifies the order of the input data blob, where $N$ is batch size, $C$ is number of channels, $H$ is spatial height, and $W$ is spatial width. The only other valid option is \"NHWC\".",
        "name": "order",
        "option": "optional",
        "type": "string"
      },
      {
        "default": 0.9,
        "description": "Factor used in computing the running mean and variance. e.g., running_mean = running_mean x momentum + mean x (1 - momentum)",
        "name": "momentum",
        "option": "optional",
        "type": "float32"
      },
      {
        "default": 1,
        "description": "Specifies the number of batches to apply normalization on. Requires specifying the optional sums and sumsq inputs that provide statistics across multiple batches from which mean and variance can be determined.",
        "name": "num_batches",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "name": "input"
      },
      {
        "description": "The scale as a 1-dimensional tensor of size $C$ to be applied to the output.",
        "name": "scale"
      },
      {
        "description": "The bias as a 1-dimensional tensor of size $C$ to be applied to the output.",
        "name": "bias"
      },
      {
        "description": "The running mean (training) or the estimated mean (testing) as a 1-dimensional tensor of size $C$.",
        "name": "mean"
      },
      {
        "description": "The running variance (training) or the estimated variance (testing) as a 1-dimensional tensor of size $C$.",
        "name": "var"
      },
      {
        "description": "The input 4-dimensional tensor of shape $NCHW$ or $NHWC$ depending on the order parameter.",
        "name": "X"
      },
      {
        "description": "*(optional)* Per-channel sums of elements to be used to determine the mean and variance for this batch.",
        "name": "sums"
      },
      {
        "description": "*(optional)* Per-channel sum of elements squared per channel to be used to determine the variance for this batch.",
        "name": "sumsq"
      }
    ],
    "outputs": [
      {
        "description": "The output 4-dimensional tensor of the same shape as $X$.",
        "name": "Y"
      },
      {
        "description": "The running mean after the spatial BN operator. Must be in-place with the input *mean*. Should not be used for testing.",
        "name": "mean"
      },
      {
        "description": "The running variance after the spatial BN operator. Must be in-place with the input *var*. Should not be used for testing.",
        "name": "var"
      },
      {
        "description": "Saved mean used during training to speed up gradient computation. Should not be used for testing.",
        "name": "saved_mean"
      },
      {
        "description": "Saved variance used during training to speed up gradient computation. Should not be used for testing.",
        "name": "saved_var"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SpatialBNGradient",
    "support_level": "default"
  },
  {
    "name": "SpatialSoftmaxWithLoss",
    "description": "\nCombined Spatial Softmax and Cross-Entropy loss operator.\nSimilar to SoftmaxWithLoss, this operator computes the spatial softmax\nnormalized values for each layer in the batch of the given input, after which\ncross-entropy loss is computed. This operator is numerically more stable than\nseparate Softmax and CrossEntropy ops. The inputs are a 2-D tensor\n(Tensor) of size (batch_size x input_feature_dimensions) and tensor of\nlabels (ground truth).\nOutput is tensor with the probability for each label in a pixel for each example\n(N x D x W x H) and averaged loss (scalar).\nFor spatial softmax, weighting is by x,y position of the input.\n",
    "inputs": [
      {
        "description": "Unscaled log probabilities",
        "name": "logits"
      },
      {
        "description": "Ground truth",
        "name": "labels"
      },
      {
        "description": "Optional blob to be used to weight the samples for the loss. With        spatial set, weighting is by x,y of the input",
        "name": "weight_tensor"
      }
    ],
    "outputs": [
      {
        "description": "Tensor with softmax cross entropy loss",
        "name": "softmax"
      },
      {
        "description": "Average loss",
        "name": "loss"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SpatialSoftmaxWithLossGradient",
    "support_level": "default"
  },
  {
    "name": "Split",
    "description": "\nSplit an `input` tensor into a list of tensors, along the axis specified by the `axis` dimension. The lengths of the split can be specified using argument `split` or optional second input blob to the operator. Otherwise, the tensor is split to equal sized parts.\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/concat_split_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Split\",\n    [\"input\"],\n    [\"output_0\",\"output_1\",\"output_2\"],\n    split=(3,2,4),\n    axis=0\n)\n\nworkspace.FeedBlob(\"input\", np.random.randint(10, size=(9)))\nprint(\"input:\", workspace.FetchBlob(\"input\"))\nworkspace.RunOperatorOnce(op)\nprint(\"output_0:\", workspace.FetchBlob(\"output_0\"))\nprint(\"output_1:\", workspace.FetchBlob(\"output_1\"))\nprint(\"output_2:\", workspace.FetchBlob(\"output_2\"))\n\n```\n\n**Result**\n\n```\n\ninput: [2 2 6 6 6 0 5 7 4]\noutput_0: [2 2 6]\noutput_1: [6 6]\noutput_2: [0 5 7 4]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "(*int*): axis to split on",
        "name": "axis",
        "option": "optional"
      },
      {
        "description": "Pass non-zero integer to remove the axis specified in `axis` to all input tensors.",
        "name": "add_axis",
        "option": "optional",
        "type": "int64"
      },
      {
        "description": "(*Tuple(int)*): length of each output",
        "name": "split",
        "option": "optional"
      },
      {
        "description": "(*string*): order of dimensions of input and output blobs; either \"NCHW\" or \"NHWC\"",
        "name": "order",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "(*Tensor*): tensor to split",
        "name": "input"
      },
      {
        "description": "(*Tensor`<int>`*): [OPTIONAL] list of output lengths (see also arg `split`)",
        "name": "split"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor*): output tensor",
        "name": "[output_0, output_1, ...]"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SplitByLengths",
    "description": "\nSplit a tensor into a list of tensors, given a lengths input, along the specified\n'axis'. If `K` outputs are provided, the op assumes `len(lengths) % K == 0`.\nThe `input` will be split into `K` parts. Each part of length\n`sum(lengths[i*k:i*k+k))`\n\n<details>\n\n<summary> <b>Example 1</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"SplitByLengths\",\n    [\"input\", \"lengths\"],\n    [\"output_0\",\"output_1\",\"output_2\"],\n    axis=0\n)\n\nworkspace.FeedBlob(\"input\", np.random.randint(10, size=(9)))\nworkspace.FeedBlob(\"lengths\", np.array([3,2,4], dtype=np.int32))\nprint(\"input:\", workspace.FetchBlob(\"input\"))\nprint(\"lengths:\", workspace.FetchBlob(\"lengths\"))\nworkspace.RunOperatorOnce(op)\nprint(\"output_0:\", workspace.FetchBlob(\"output_0\"))\nprint(\"output_1:\", workspace.FetchBlob(\"output_1\"))\nprint(\"output_2:\", workspace.FetchBlob(\"output_2\"))\n\n```\n\n**Result**\n\n```\n\ninput: [2 2 6 6 6 0 5 7 4]\nlengths: [3 2 4]\noutput_0: [2 2 6]\noutput_1: [6 6]\noutput_2: [0 5 7 4]\n\n```\n\n<summary> <b>Example 2</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"SplitByLengths\",\n    [\"input\", \"lengths\"],\n    [\"output_0\",\"output_1\",\"output_2\"],\n    axis=0,\n    use_scaling_lengths=true,\n)\n\nworkspace.FeedBlob(\"input\", np.random.randint(10, size=(9)))\nworkspace.FeedBlob(\"lengths\", np.array([1,1,1], dtype=np.int32))\nprint(\"input:\", workspace.FetchBlob(\"input\"))\nprint(\"lengths:\", workspace.FetchBlob(\"lengths\"))\nprint(\"output_0:\", workspace.FetchBlob(\"output_0\"))\nprint(\"output_1:\", workspace.FetchBlob(\"output_1\"))\nprint(\"output_2:\", workspace.FetchBlob(\"output_2\"))\n\n```\n\n**Result**\n\n```\n\ninput: [2 2 6 6 6 0 5 7 4]\nlengths: [1 1 1]\noutput_0: [2 2 6]\noutput_1: [6 6 6]\noutput_2: [5 7 4]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "Which axis to split on",
        "name": "axis",
        "option": "optional"
      },
      {
        "description": "Either NHWC or NCWH, will split on C axis, defaults to NCHW",
        "name": "order",
        "option": "optional"
      },
      {
        "description": "(*bool*): Enables automatic scaling of the lengths values. When enabled will automatically find a value K >= 1, such that sum(lengths) * K == len(input).",
        "name": "use_scaling_lengths",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "The tensor to split",
        "name": "input"
      },
      {
        "description": "The tensor `l_i` indicates the logic block of input.",
        "name": "legnths"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Sqr",
    "description": "\nPerforms element-wise squaring ($x^2$) of input tensor.\n\nGithub Link:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/sqr_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Sqr\",\n    [\"X\"],\n    [\"Y\"],\n)\n\nworkspace.FeedBlob(\"X\", (np.random.randint(10, size=(3,3))).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n[[4. 6. 2.]\n [0. 1. 6.]\n [9. 2. 7.]]\nY:\n[[16. 36.  4.]\n [ 0.  1. 36.]\n [81.  4. 49.]]\n\n```\n\n</details>\n\n    ",
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input data tensor.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output tensor.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Sqrt",
    "description": "\nPerforms element-wise square-root ($\\sqrt{x}$) of input tensor $X$.\n\nGithub Link:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/sqrt_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Sqrt\",\n    [\"X\"],\n    [\"Y\"],\n)\n\nworkspace.FeedBlob(\"X\", (np.random.randint(10, size=(3,3))).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n[[8. 3. 3.]\n [4. 0. 0.]\n [1. 2. 5.]]\nY:\n[[2.8284268  1.7320508  1.7320508 ]\n [1.9999999  0.         0.        ]\n [0.99999994 1.4142134  2.236068  ]]\n\n```\n\n</details>\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* Input data tensor.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output tensor.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SquaredL2Distance",
    "description": "\nGiven two input float tensors X, Y, and produces one output float tensor\nof the L2 difference between X and Y that is computed as ||(X - Y)^2 / 2||.\n",
    "inputs": [
      {
        "description": "1D or 2D input tensor",
        "name": "X"
      },
      {
        "description": "1D or 2D input tensor (must have the same shape as X)",
        "name": "Y"
      }
    ],
    "outputs": [
      {
        "description": "1D output tensor",
        "name": "Z"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SquaredL2DistanceGradient",
    "support_level": "default"
  },
  {
    "name": "SquareRootDivide",
    "description": "\nGiven DATA tensor with first dimension N and SCALE vector of the same size N\nproduces an output tensor with same dimensions as DATA. Which consists of DATA\nslices. i-th slice is divided by sqrt(SCALE[i]) elementwise. If SCALE[i] == 0\noutput slice is identical to the input one (no scaling)\n\nExample:\n\n  Data = [\n    [2.0, 4.0],\n    [9.0, 12.0]\n  ]\n\n  SCALE = [4, 9]\n\n  OUTPUT = [\n    [1.0, 2.0],\n    [3.0, 4.0]\n  ]\n\n",
    "support_level": "default"
  },
  {
    "name": "Squeeze",
    "category": "Transform",
    "description": "\nThe *Squeeze* op removes single-dimensional entries from the shape of the input tensor *data,* and produces a single output tensor *squeezed*. The op also takes an argument *dims* with a list of dimensions to squeeze. If the same blob is provided as input and output, the operation is copy-free. This is the exact inverse operation of *ExpandDims* given the same *dims* argument.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/expand_squeeze_dims_op.h\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/expand_squeeze_dims_op.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Squeeze\",\n    [\"data\"],\n    [\"squeezed\"],\n    dims=[0,1],\n)\n\nworkspace.FeedBlob(\"data\", np.zeros((1,1,100,100)).astype(np.float32))\nprint(\"data.shape:\", workspace.FetchBlob(\"data\").shape)\n\nworkspace.RunOperatorOnce(op)\nprint(\"squeezed.shape:\", workspace.FetchBlob(\"squeezed\").shape)\n\n```\n\n**Result**\n\n```\n\ndata.shape: (1, 1, 100, 100)\nsqueezed.shape: (100, 100)\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "List of dimensions of *data* to squeeze out.",
        "name": "dims",
        "option": "optional",
        "type": "int64[]"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor of data to be operated on.",
        "name": "data"
      }
    ],
    "outputs": [
      {
        "description": "Reshaped tensor with same data as input.",
        "name": "squeezed"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "StatRegistryCreate",
    "description": "\nCreate a StatRegistry object that will contain a map of performance counters\nkeyed by name. A StatRegistry is used to gather and retrieve performance\ncounts throughout the caffe2 codebase.\n",
    "outputs": [
      {
        "description": "A Blob pointing to the newly created StatRegistry.",
        "name": "handle"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "StatRegistryExport",
    "attributes": [
      {
        "description": "(default true) Whether to atomically reset the counters afterwards.",
        "name": "reset",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "If provided, export values from given StatRegistry.Otherwise, export values from the global singleton StatRegistry.",
        "name": "handle"
      }
    ],
    "outputs": [
      {
        "description": "1D string tensor with exported key names",
        "name": "keys"
      },
      {
        "description": "1D int64 tensor with exported values",
        "name": "values"
      },
      {
        "description": "The unix timestamp at counter retrieval.",
        "name": "timestamps"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "StatRegistryUpdate",
    "description": "\nUpdate the given StatRegistry, or the global StatRegistry,\nwith the values of counters for the given keys.\n",
    "inputs": [
      {
        "description": "1D string tensor with the key names to update.",
        "name": "keys"
      },
      {
        "description": "1D int64 tensor with the values to update.",
        "name": "values"
      },
      {
        "description": "If provided, update the given StatRegistry. Otherwise, update the global singleton.",
        "name": "handle"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "StdDevPut",
    "description": "\n      Consume a value and pushes it to the global stat registry as an standard deviation.\n\n      Github Links:\n      - https://github.com/pytorch/pytorch/blob/master/caffe2/operators/stats_put_ops.cc\n\n        ",
    "attributes": [
      {
        "description": "(*str*): name of the stat. If not present, then uses name of input blob",
        "name": "name",
        "option": "optional"
      },
      {
        "description": "(*int64_t*): number to multiply input values by (used when inputting floats, as stats can only receive integers",
        "name": "magnitude_expand",
        "option": "optional"
      },
      {
        "description": "(*boolean*): whether or not to clamp inputs to the max inputs allowed",
        "name": "bound",
        "option": "optional"
      },
      {
        "description": "(*float*): Optionally provide a default value for receiving empty tensors",
        "name": "default_value",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "(*Tensor`<number>`*): A scalar tensor, representing any numeric value",
        "name": "value"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "StopGradient",
    "description": "\nStopGradient is a helper operator that does no actual numerical computation,\nand in the gradient computation phase stops the gradient from being computed\nthrough it.\n",
    "support_level": "default"
  },
  {
    "name": "StoreAdd",
    "description": "\nAdd a value to a remote counter. If the key is not set, the store\ninitializes it to 0 and then performs the add operation. The operation\nreturns the resulting counter value.\n",
    "attributes": [
      {
        "description": "key of the counter (required)",
        "name": "blob_name",
        "option": "optional"
      },
      {
        "description": "value that is added (optional, default: 1)",
        "name": "add_value",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "unique_ptr<StoreHandler>",
        "name": "handler"
      }
    ],
    "outputs": [
      {
        "description": "the current value of the counter",
        "name": "value"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "StoreGet",
    "description": "\nGet a blob from a store. The key is the output blob's name. The key\ncan be overridden by specifying the 'blob_name' argument.\n",
    "attributes": [
      {
        "description": "alternative key for the blob (optional)",
        "name": "blob_name",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "unique_ptr<StoreHandler>",
        "name": "handler"
      }
    ],
    "outputs": [
      {
        "description": "data blob",
        "name": "data"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "StoreSet",
    "description": "\nSet a blob in a store. The key is the input blob's name and the value\nis the data in that blob. The key can be overridden by specifying the\n'blob_name' argument.\n",
    "attributes": [
      {
        "description": "alternative key for the blob (optional)",
        "name": "blob_name",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "unique_ptr<StoreHandler>",
        "name": "handler"
      },
      {
        "description": "data blob",
        "name": "data"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "StoreWait",
    "description": "\nWait for the specified blob names to be set. The blob names can be passed\neither as an input blob with blob names or as an argument.\n",
    "attributes": [
      {
        "description": "names of the blobs to wait for (optional)",
        "name": "blob_names",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "unique_ptr<StoreHandler>",
        "name": "handler"
      },
      {
        "description": "names of the blobs to wait for (optional)",
        "name": "names"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Storm",
    "description": "\n\nComputes the STORM (https://arxiv.org/abs/1905.10018) update for an input\ngradient and accumulated history of gradients. Concretely, given inputs\n(param, moment, grad_sq_sum, grad, lr), computes:\n\n    new_grad_sq_sum = grad_sq_sum + norm(grad)^2\n    effective_lr = lr / (beta + new_grad_sq_sum)^1/3\n    alpha = momentum * square(effective_lr)\n    new_moment = grad + (1 - alpha) * (moment - grad)\n    new_param = param + effective_lr * new_moment\n\nand returns (new_param, new_moment, new_grad_sq_sum).\n\nNote that due to caffe2 limitation, it is difficult to re-calculate gradient\nin the previous iteration using the current example. We simplied calculation\nfor new_moment by using the gradient from the current iteration.\n\n",
    "attributes": [
      {
        "description": "Momentum hyperparameter, c in the original paper.",
        "name": "momentum",
        "option": "optional"
      },
      {
        "description": "denominator in adaptive learning rate, w in the original paper.",
        "name": "beta",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated.",
        "name": "param"
      },
      {
        "description": "Moment history.",
        "name": "moment"
      },
      {
        "description": "Sum of observed squared gradients.",
        "name": "grad_sq_sum"
      },
      {
        "description": "Gradients computed.",
        "name": "grad"
      },
      {
        "description": "Learning rate, k in the original paper.",
        "name": "lr"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters.",
        "name": "output_param"
      },
      {
        "description": "Updated moment.",
        "name": "output_moment"
      },
      {
        "description": "Updated sum of squared gradients.",
        "name": "output_grad_sq_sum"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "StringEndsWith",
    "description": "\nPerforms the ends-with check on each string in the input tensor.\nReturns tensor of boolean of the same dimension of input.\n",
    "attributes": [
      {
        "description": "The suffix to check input strings against.",
        "name": "suffix",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Tensor of std::string.",
        "name": "strings"
      }
    ],
    "outputs": [
      {
        "description": "Tensor of bools of same shape as input.",
        "name": "bools"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "StringEquals",
    "description": "\nPerforms equality check on each string in the input tensor.\nReturns tensor of booleans of the same dimension as input.\n",
    "attributes": [
      {
        "description": "The text to check input strings equality against.",
        "name": "text",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Tensor of std::string.",
        "name": "strings"
      }
    ],
    "outputs": [
      {
        "description": "Tensor of bools of same shape as input.",
        "name": "bools"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "StringIndexCreate",
    "description": "\nCreates a dictionary that maps string keys to consecutive integers\nfrom 1 to max_elements. Zero is reserved for unknown keys.\n",
    "attributes": [
      {
        "description": "Max number of elements, including the zero entry.",
        "name": "max_elements",
        "option": "optional"
      }
    ],
    "outputs": [
      {
        "description": "Pointer to an Index instance.",
        "name": "handle"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "StringJoin",
    "description": "\nTakes a 1-D or a 2-D tensor as input and joins elements in each row with the\nprovided delimiter. Output is a 1-D tensor of size equal to the first dimension\nof the input. Each element in the output tensor is a string of concatenated\nelements corresponding to each row in the input tensor. For 1-D input, each\nelement is treated as a row.\n",
    "attributes": [
      {
        "description": "Delimiter for join (Default: \",\").",
        "name": "delimiter",
        "option": "optional"
      },
      {
        "description": "Axis for the join (either 0 or 1)",
        "name": "axis",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "1-D or 2-D tensor",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "1-D tensor of strings created by joining row elements from the input tensor.",
        "name": "strings"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "StringPrefix",
    "description": "\nComputes the element-wise string prefix of the string tensor.\nInput strings that are shorter than prefix length will be returned unchanged.\nNOTE: Prefix is computed on number of bytes, which may lead to wrong behavior\nand potentially invalid strings for variable-length encodings such as utf-8.\n",
    "attributes": [
      {
        "description": "Maximum size of the prefix, in bytes.",
        "name": "length",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Tensor of std::string.",
        "name": "strings"
      }
    ],
    "outputs": [
      {
        "description": "Tensor of std::string containing prefixes for each input.",
        "name": "prefixes"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "StringStartsWith",
    "description": "\nPerforms the starts-with check on each string in the input tensor.\nReturns tensor of boolean of the same dimension of input.\n",
    "attributes": [
      {
        "description": "The prefix to check input strings against.",
        "name": "prefix",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Tensor of std::string.",
        "name": "strings"
      }
    ],
    "outputs": [
      {
        "description": "Tensor of bools of same shape as input.",
        "name": "bools"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "StringSuffix",
    "description": "\nComputes the element-wise string suffix of the string tensor.\nInput strings that are shorter than suffix length will be returned unchanged.\nNOTE: Prefix is computed on number of bytes, which may lead to wrong behavior\nand potentially invalid strings for variable-length encodings such as utf-8.\n",
    "attributes": [
      {
        "description": "Maximum size of the suffix, in bytes.",
        "name": "length",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Tensor of std::string.",
        "name": "strings"
      }
    ],
    "outputs": [
      {
        "description": "Tensor of std::string containing suffixes for each output.",
        "name": "suffixes"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "StumpFunc",
    "description": "\nConverts each input element into either high_ or low_value\nbased on the given threshold.\n",
    "inputs": [
      {
        "description": "tensor of float",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "tensor of float",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "StumpFuncIndex",
    "description": "\nSplit the elements and return the indices based on the given threshold.\n",
    "inputs": [
      {
        "description": "tensor of float",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "tensor of int64 indices for elements below/equal threshold",
        "name": "Index_Low"
      },
      {
        "description": "tensor of int64 indices for elements above threshold",
        "name": "Index_High"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Sub",
    "description": "\nPerforms element-wise binary subtraction (with limited broadcast support).\n\nIf necessary the right-hand-side argument will be broadcasted to match the\nshape of left-hand-side argument. When broadcasting is specified, the second\ntensor can either be of size 1 (a scalar value), or having its shape as a\ncontiguous subset of the first tensor's shape. The starting of the mutually\nequal shape is specified by the argument \"axis\", and if it is not set, suffix\nmatching is assumed. 1-dim expansion doesn't work yet.\n\nFor example, the following tensor shapes are supported (with broadcast=1):\n```\n  shape(A) = (2, 3, 4, 5), shape(B) = (,), i.e. B is a scalar\n  shape(A) = (2, 3, 4, 5), shape(B) = (5,)\n  shape(A) = (2, 3, 4, 5), shape(B) = (4, 5)\n  shape(A) = (2, 3, 4, 5), shape(B) = (3, 4), with axis=1\n  shape(A) = (2, 3, 4, 5), shape(B) = (2), with axis=0\n```\nArgument `broadcast=1` needs to be passed to enable broadcasting.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/elementwise_ops_schema.cc\n\n\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Sub\",\n    [\"A\",  \"B\"],\n    [\"C\"],\n)\n\nworkspace.FeedBlob(\"A\", np.array([[10,12],[4,14]]))\nworkspace.FeedBlob(\"B\", np.array([[5,16],[1,19]]))\nprint(\"A:\", workspace.FetchBlob(\"A\"))\nprint(\"B:\", workspace.FetchBlob(\"B\"))\nworkspace.RunOperatorOnce(op)\nprint(\"C:\", workspace.FetchBlob(\"C\"))\n\n```\n\n**Result**\n\n```\n\nA:\n[[10 12]\n [ 4 14]]\nB:\n[[ 5 16]\n [ 1 19]]\nC:\n[[ 5 -4]\n [ 3 -5]]\n\n```\n\n</details>\n\n\n",
    "attributes": [
      {
        "default": 0,
        "description": "Pass 1 to enable broadcasting",
        "name": "broadcast",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": -1,
        "description": "Axis to concatenate on.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* First operand, should share the type with the second operand.",
        "name": "A"
      },
      {
        "description": "*(type: Tensor`<float>`)* Second operand. With broadcasting can be of smaller size than A. If broadcasting is disabled it should be of the same size as A.",
        "name": "B"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Output tensor with same dimensions and type as A.",
        "name": "C"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SubGradient",
    "support_level": "default"
  },
  {
    "name": "Sum",
    "description": "\nElement-wise sum of each of the input tensors. The first input tensor can be used\nin-place as the output tensor, in which case the sum will be done in place and\nresults will be accumulated the first input tensor. All inputs and outputs must\nhave the same shape and data type.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/elementwise_sum_op.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Sum\",\n    [\"A\",  \"B\"],\n    [\"C\"],\n)\n\nworkspace.FeedBlob(\"A\", np.array([[1,2],[3,4]]).astype(np.float32))\nworkspace.FeedBlob(\"B\", np.array([[5,6],[7,8]]).astype(np.float32))\nprint(\"A:\", workspace.FetchBlob(\"A\"))\nprint(\"B:\", workspace.FetchBlob(\"B\"))\nworkspace.RunOperatorOnce(op)\nprint(\"C:\", workspace.FetchBlob(\"A\"))\n\n```\n\n**Result**\n\n```\n\nA: [[1. 2.]\n [3. 4.]]\nB: [[5. 6.]\n [7. 8.]]\nC: [[1. 2.]\n [3. 4.]]\n\n```\n\n</details>\n\n<details>\n\n<summary> <b>Example 2</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Sum\",\n    [\"A\",  \"B\"],\n    [\"A\"],  // inplace\n)\n\nworkspace.FeedBlob(\"A\", np.array([[1,2,5],[8,3,4]]).astype(np.float32))\nworkspace.FeedBlob(\"B\", np.array([[9,5,6],[6,7,8]]).astype(np.float32))\nprint(\"A:\", workspace.FetchBlob(\"A\"))\nprint(\"B:\", workspace.FetchBlob(\"B\"))\nworkspace.RunOperatorOnce(op)\nprint(\"A after Sum:\", workspace.FetchBlob(\"A\"))\n\n```\n\n**Result**\n\n```\n\nA: [[1. 2. 5.]\n [8. 3. 4.]]\nB: [[9. 5. 6.]\n [6. 7. 8.]]\nA after Sum: [[10.  7. 11.]\n [14. 10. 12.]]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "*(type: Tensor`<float>`)* First tensor to be added element-wise.",
        "name": "A"
      },
      {
        "description": "*(type: Tensor`<float>`)* Second tensor to be added element-wise.",
        "name": "B"
      },
      {
        "description": "First of the input tensors. Can be inplace.",
        "name": "data_0"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<float>`)* Sum of A and B.",
        "name": "C"
      },
      {
        "description": "Output tensor. Same dimension as inputs.",
        "name": "sum"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SumElements",
    "description": "\nSums the elements of the input tensor. Tensor type must be float32.\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/reduction_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nsum_op = core.CreateOperator(\n    \"SumElements\",\n    [\"X\"],\n    [\"Y\"]\n)\n\navg_op = core.CreateOperator(\n    \"SumElements\",\n    [\"X\"],\n    [\"Y\"],\n    average=True\n)\n\nworkspace.FeedBlob(\"X\", np.random.randint(10, size=(3,3)).astype(np.float32))\nprint(\"X:\\n\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(sum_op)\nprint(\"Y (sum_op):\", workspace.FetchBlob(\"Y\"))\nworkspace.RunOperatorOnce(avg_op)\nprint(\"Y (avg_op):\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n [[7. 2. 5.]\n [9. 4. 2.]\n [1. 2. 5.]]\nY (sum_op): 37.0\nY (avg_op): 4.111111\n\n```\n\n</details>\n\n    ",
    "attributes": [
      {
        "description": "(*bool*): set to True to compute the average of the elements rather than the sum",
        "name": "average",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "(*Tensor`<float>`*): blob pointing to an instance of a counter",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor`<float>`*): Scalar tensor containing the sum (or average)",
        "name": "sum"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SumElementsGradient",
    "support_level": "default"
  },
  {
    "name": "SumElementsInt",
    "description": "Sums the integer elements of the input tensor.",
    "inputs": [
      {
        "description": "Tensor to sum up",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "Scalar sum",
        "name": "sum"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SumInt",
    "support_level": "default"
  },
  {
    "name": "Summarize",
    "description": "\nSummarize computes four statistics of the input tensor (Tensor)- min,\nmax, mean and standard deviation. The output will be written to a 1-D tensor of\nsize 4 if an output tensor is provided. Else, if the argument 'to_file' is\ngreater than 0, the values are written to a log file in the root folder.\n",
    "attributes": [
      {
        "description": "(int, default 0) flag to indicate if the summarized statistics have to be written to a log file.",
        "name": "to_file",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "The input data as Tensor.",
        "name": "data"
      }
    ],
    "outputs": [
      {
        "description": "1-D tensor (Tensor) of size 4 containing min, max, mean and standard deviation",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SumReduceLike",
    "description": "\nSumReduceLike operator takes 2 tensors as input. It performs reduce sum to the\nfirst input so that the output looks like the second one.\nIt assumes that the first input\nhas more dimensions than the second, and the dimensions of the second input is\nthe contiguous subset of the dimensions of the first.\nFor example, the following tensor shapes are supported:\n\n  shape(A) = (2, 3, 4, 5), shape(B) = (4, 5)\n  shape(A) = (2, 3, 4, 5), shape(B) = (,), i.e. B is a scalar\n  shape(A) = (2, 3, 4, 5), shape(B) = (3, 4), with axis=1\n  shape(A) = (2, 3, 2, 5), shape(B) = (2), with axis=0\n    ",
    "attributes": [
      {
        "description": "If set, defines the starting dimension for reduction. Args `axis` and `axis_str` cannot be used simultaneously.",
        "name": "axis",
        "option": "optional"
      },
      {
        "description": "If set, it could only be N or C or H or W. `order` arg should also be provided. It defines the reduction dimensions on NCHW or NHWC. Args `axis` and `axis_str` cannot be used simultaneously.",
        "name": "axis_str",
        "option": "optional"
      },
      {
        "description": "Either NHWC or HCWH",
        "name": "order",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "First operand, should share the type with the second operand.",
        "name": "A"
      },
      {
        "description": "Second operand. With broadcasting can be of smaller size than A. If broadcasting is disabled it should be of the same size.",
        "name": "B"
      }
    ],
    "outputs": [
      {
        "description": "Result, has same dimensions and type as B",
        "name": "C"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SumRelu",
    "inputs": [
      {
        "description": "First of the input tensors. Can be inplace.",
        "name": "data_0"
      }
    ],
    "outputs": [
      {
        "description": "Output tensor. Same dimension as inputs.",
        "name": "sum"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SumSqrElements",
    "description": "Sums the squares elements of the input tensor.",
    "attributes": [
      {
        "description": "whether to average or not",
        "name": "average",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Tensor to sum up",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "Scalar sum of squares",
        "name": "sum"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SwapBestPath",
    "description": "\nGiven a sequence of indices and a matrix, enforce that these indices have the\nbest columnwise scores\nscore\n",
    "inputs": [
      {
        "description": "N*D predictions matrix",
        "name": "predictions"
      },
      {
        "description": "N*1 vector holds the best path indices ",
        "name": "bestPath"
      }
    ],
    "outputs": [
      {
        "description": "N*D updated predictions matrix",
        "name": "new_predictions"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Swish",
    "description": "\nSwish takes one input data (Tensor) and produces one output data\n(Tensor) where the swish function, y = x / (1 + exp(-x)), is applied to the\ntensor elementwise.\n",
    "inputs": [
      {
        "description": "1D input tensor",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "1D output tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SwishGradient",
    "description": "\nSwishGradient takes X, Y and dY and uses this to update dX according to the\nchain rule and derivatives of the swish function.\n",
    "support_level": "default"
  },
  {
    "name": "Tan",
    "description": "\nCalculates the tangent of the given input tensor, element-wise.\n",
    "inputs": [
      {
        "description": "Input tensor",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "The tangent of the input tensor computed element-wise",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "TanGradient",
    "support_level": "default"
  },
  {
    "name": "Tanh",
    "description": "\nCalculates the hyperbolic tangent of the given input tensor element-wise. This\noperation can be done in an in-place fashion too, by providing the same input\nand output blobs.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/tanh_op.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Tanh\",\n    [\"X\"],\n    [\"X\"],\n)\n\nworkspace.FeedBlob(\"X\", np.random.randn(3, 3).astype(np.float32))\nprint(\"X:\\n\", workspace.FetchBlob(\"X\"), \"\\n\")\n\nworkspace.RunOperatorOnce(op)\nprint(\"X:\\n\", workspace.FetchBlob(\"X\"))\n\n```\n\n**Result**\n\n```\n\nX:\n [[ 2.032603   -2.3556721  -0.14955314]\n [ 0.39309832 -1.1020128  -0.92951244]\n [-0.62815386  0.21342885  1.4002231 ]]\n\nX:\n [[ 0.9662601  -0.982175   -0.14844811]\n [ 0.3740282  -0.8012209  -0.73036647]\n [-0.55677974  0.21024609  0.8853999 ]]\n\n```\n\n</details>\n\n",
    "inputs": [
      {
        "description": "1-D input tensor",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "The hyperbolic tangent values of the input tensor, computed element-wise",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "TanhGradient",
    "support_level": "default"
  },
  {
    "name": "TensorProtosDBInput",
    "description": "\nTensorProtosDBInput is a simple input operator that basically reads things\nfrom a db where each key-value pair stores an index as key, and a TensorProtos\nobject as value. These TensorProtos objects should have the same size, and they\nwill be grouped into batches of the given size. The DB Reader is provided as\ninput to the operator and it returns as many output tensors as the size of the\nTensorProtos object. Each output will simply be a tensor containing a batch of\ndata with size specified by the 'batch_size' argument containing data from the\ncorresponding index in the TensorProtos objects in the DB.\n",
    "attributes": [
      {
        "description": "(int, default 0) the number of samples in a batch. The default value of 0 means that the operator will attempt to insert the entire data in a single output blob.",
        "name": "batch_size",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "A pre-initialized DB reader. Typically, this is obtained by calling CreateDB operator with a db_name and a db_type. The resulting output blob is a DB Reader tensor",
        "name": "data"
      }
    ],
    "outputs": [
      {
        "description": "The output tensor in which the batches of data are returned. The number of output tensors is equal to the size of (number of TensorProto's in) the TensorProtos objects stored in the DB as values. Each output tensor will be of size specified by the 'batch_size' argument of the operator",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "TensorVectorSize",
    "description": "Get the size of the input vector",
    "inputs": [
      {
        "description": "std::unique_ptr<std::vector<Tensor> >",
        "name": "tensor vector"
      }
    ],
    "outputs": [
      {
        "description": "int32_t size",
        "name": "size"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "TextFileReaderRead",
    "description": "Read a batch of rows from the given text file reader instance. Expects the number of fields to be equal to the number of outputs. Each output is a 1D tensor containing the values for the given field for each row. When end of file is reached, returns empty tensors.",
    "attributes": [
      {
        "description": "Maximum number of rows to read.",
        "name": "batch_size",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Pointer to an existing TextFileReaderInstance.",
        "name": "handler"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ThresholdedRelu",
    "description": "\nThresholdedRelu takes one input data (Tensor) and produces one output data\n(Tensor) where the rectified linear function, y = x for x > alpha, y = 0\notherwise, is applied to the tensor elementwise.\n",
    "attributes": [
      {
        "description": "(float) defaults to 1.0.",
        "name": "alpha",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "1D input tensor",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "1D input tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ThresholdedReluGradient",
    "description": "\nThresholdedReluGradient takes both Y and dY and uses this to update dX\naccording to the chain rule and derivatives of the rectified linear function.\n",
    "support_level": "default"
  },
  {
    "name": "ThrowChildThreadException",
    "support_level": "default"
  },
  {
    "name": "ThrowException",
    "support_level": "default"
  },
  {
    "name": "Tile",
    "description": "\nConstructs a tensor by tiling a given tensor along a specified axis. This operation creates a new tensor by replicating the input tensor a number of times specified by the `tiles` argument along the `axis` dimension. The output tensor's `axis` dimension has $(X.dims(axis) * tiles)$ elements.\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/tile_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Tile\",\n    [\"X\", \"tiles\", \"axis\"],\n    [\"Y\"]\n)\n\nworkspace.FeedBlob(\"X\", np.random.randint(10, size=(5,5)))\nworkspace.FeedBlob(\"tiles\", np.array([5]).astype(np.int32))\nworkspace.FeedBlob(\"axis\", np.array([1]).astype(np.int32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\n\n```\n\n**Result**\n\n```\n\nX:\n[[9 1 7 1 3]\n [2 3 6 2 5]\n [0 9 2 6 4]\n [5 8 1 5 9]\n [2 0 1 3 7]]\nY:\n[[9 1 7 1 3 9 1 7 1 3 9 1 7 1 3 9 1 7 1 3 9 1 7 1 3]\n [2 3 6 2 5 2 3 6 2 5 2 3 6 2 5 2 3 6 2 5 2 3 6 2 5]\n [0 9 2 6 4 0 9 2 6 4 0 9 2 6 4 0 9 2 6 4 0 9 2 6 4]\n [5 8 1 5 9 5 8 1 5 9 5 8 1 5 9 5 8 1 5 9 5 8 1 5 9]\n [2 0 1 3 7 2 0 1 3 7 2 0 1 3 7 2 0 1 3 7 2 0 1 3 7]]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "(*int*): number of replicas",
        "name": "tiles",
        "option": "optional"
      },
      {
        "description": "(*int*): axis to replicate along",
        "name": "axis",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "(*Tensor*): input tensor",
        "name": "X"
      },
      {
        "description": "(*Tensor`<int>`*): [OPTIONAL] number of replicas (overrides `tiles` argument)",
        "name": "tiles"
      },
      {
        "description": "(*Tensor`<int>`*): [OPTIONAL] axis to replicate along (overrides `axis` argument)",
        "name": "axis"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor*): output tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "TileGradient",
    "support_level": "default"
  },
  {
    "name": "TimerBegin",
    "description": "\nStart a wallclock timer, returning a scalar tensor containing a pointer to it. The timer is stopped by calling **TimerEnd**.\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/stats_ops.cc\n\n    ",
    "attributes": [
      {
        "description": "(*str*): name of the timer object; if not set use output name",
        "name": "counter_name",
        "option": "optional"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor`<ptr>`*): pointer to a timer object",
        "name": "timer"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "TimerEnd",
    "description": "\nStop a timer started with **TimerBegin**. Publishes a CAFFE_EVENT.\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/stats_ops.cc\n\n    ",
    "inputs": [
      {
        "description": "(*Tensor`<ptr>`*): pointer to a timer object; obtained from **TimerBegin** op",
        "name": "timer"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "TimerGet",
    "description": "\nQueries the current time of a timer object in nanoseconds.\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/stats_ops.cc\n\n    ",
    "inputs": [
      {
        "description": "(*Tensor`<ptr>`*): pointer to a timer object; obtained from **TimerBegin** op",
        "name": "timer"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor`<int64>`*): scalar containing time in nanoseconds",
        "name": "nanos"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "TimerGetAndEnd",
    "description": "\nQueries the current time of a timer in nanos, stops the timer publishing a CAFFE_EVENT.\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/stats_ops.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\ntimerbegin_op = core.CreateOperator(\n    \"TimerBegin\",\n    [],\n    [\"timer\"]\n)\n\ntimerget_op = core.CreateOperator(\n    \"TimerGet\",\n    [\"timer\"],\n    [\"nanos\"]\n)\n\ntimerend_op = core.CreateOperator(\n    \"TimerEnd\",\n    [\"timer\"],\n    []\n)\n\ntimergetandend_op = core.CreateOperator(\n    \"TimerGetAndEnd\",\n    [\"timer\"],\n    [\"nanos\"]\n)\n\n// Test TimerBegin/TimerGet/TimerEnd\nworkspace.RunOperatorOnce(timerbegin_op)\nprint(\"timer:\", workspace.FetchBlob(\"timer\"))\nworkspace.RunOperatorOnce(timerget_op)\nprint(\"nanos:\", workspace.FetchBlob(\"nanos\"))\nworkspace.RunOperatorOnce(timerend_op)\n\n\n// Test TimerBegin/TimerGetAndEnd\nworkspace.RunOperatorOnce(timerbegin_op)\nprint(\"timer:\", workspace.FetchBlob(\"timer\"))\nworkspace.RunOperatorOnce(timergetandend_op)\nprint(\"nanos:\", workspace.FetchBlob(\"nanos\"))\n\n```\n\n**Result**\n\n```\n\ntimer: b'timer, a C++ native class of type caffe2::TimerInstance*.'\nnanos: 361140\ntimer: b'timer, a C++ native class of type caffe2::TimerInstance*.'\nnanos: [252250]\n\n```\n\n</details>\n\n      ",
    "inputs": [
      {
        "description": "(*Tensor`<ptr>`*): pointer to a timer object; obtained from **TimerBegin** op",
        "name": "timer"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor`<int64>`*): scalar tensor containing time in nanoseconds",
        "name": "nanos"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "TopK",
    "description": "\nRetrieve the top-K elements of the last dimension.\nGiven an input tensor of shape $(a_1, a_2, ..., a_n, r)$. `k` can be passed as an integer argument or a 1D tensor containing a single integer.\nReturns up to three outputs:\n\n1. Value tensor of shape $(a_1, a_2, ..., a_n, k)$ which contains the values of the top k elements along the last dimension\n2. Index tensor of shape $(a_1, a_2, ..., a_n, k)$ which contains the indices of the top k elements (original indices from the input tensor).\n3. [OPTIONAL] Flattened index tensor of shape $(a_1 * a_2 * ... * a_n * k,)$.\n\nGiven two equivalent values, this operator uses the indices along the last dimension as a tiebreaker. That is, the element with the lower index will appear first.\n\nGithub Links:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/top_k.cc\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"TopK\",\n    [\"X\"],\n    [\"Values\", \"Indices\", \"Flattened_indices\"],\n    k=2\n)\n\nworkspace.FeedBlob(\"X\", np.random.randint(10, size=(3,3,3)).astype(np.float32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Values:\", workspace.FetchBlob(\"Values\"))\nprint(\"Indices:\", workspace.FetchBlob(\"Indices\"))\nprint(\"Flattened_indices:\", workspace.FetchBlob(\"Flattened_indices\"))\n\n```\n\n**Result**\n\n```\n\nX:\n[[[6. 7. 0.]\n  [8. 7. 7.]\n  [1. 5. 6.]]\n\n [[0. 6. 1.]\n  [2. 8. 4.]\n  [1. 2. 9.]]\n\n [[4. 3. 7.]\n  [0. 1. 7.]\n  [0. 1. 8.]]]\nValues:\n[[[7. 6.]\n  [8. 7.]\n  [6. 5.]]\n\n [[6. 1.]\n  [8. 4.]\n  [9. 2.]]\n\n [[7. 4.]\n  [7. 1.]\n  [8. 1.]]]\nIndices:\n[[[1 0]\n  [0 1]\n  [2 1]]\n\n [[1 2]\n  [1 2]\n  [2 1]]\n\n [[2 0]\n  [2 1]\n  [2 1]]]\nFlattened_indices: [ 1  0  3  4  8  7 10 11 13 14 17 16 20 18 23 22 26 25]\n\n```\n\n</details>\n\n  ",
    "inputs": [
      {
        "description": "(*Tensor`<float>`*): input tensor of shape $(a_1, a_2, ..., a_n, r)$",
        "name": "X"
      },
      {
        "description": "(*int*): number of top elements to retrieve",
        "name": "k"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor`<float>`*): output tensor of shape $(a_1, a_2, ..., a_n, k)$",
        "name": "Values"
      },
      {
        "description": "(*Tensor`<int>`*): tensor of indices of shape $(a_1, a_2, ..., a_n, k)$; indices values refer to each element's index in the last dimension of the `X` input tensor",
        "name": "Indices"
      },
      {
        "description": "(*Tensor`<int>`*): tensor of indices of shape $(a_1 * a_2 * ... * a_n * k,)$; indices values refer to each element's index in the flattened input tensor `X`",
        "name": "Flattened_indices"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "TopKGradient",
    "support_level": "default"
  },
  {
    "name": "Transpose",
    "category": "Transform",
    "description": "\nTranspose the input tensor by permuting the axes of the input according\nto the `axes` argument. Similar to numpy's\n[transpose](https://docs.scipy.org/doc/numpy/reference/generated/numpy.transpose.html)\nfunction.\n\nFor example, when axes=(1, 0, 2), given an input tensor of shape\n(1, 2, 3), the output shape will be (2, 1, 3).\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/transpose_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Transpose\",\n    [\"X\"],\n    [\"Y\"],\n    axes=(0,3,1,2)\n)\n\nx = np.random.rand(1,32,32,3)\nworkspace.FeedBlob(\"X\", x)\nprint(\"X.shape (NHWC order):\", workspace.FetchBlob(\"X\").shape)\nworkspace.RunOperatorOnce(op)\nprint(\"Y.shape (NCHW order):\", workspace.FetchBlob(\"Y\").shape)\n```\n\n**Result**\n\n```\nX.shape (NHWC order): (1, 32, 32, 3)\nY.shape (NCHW order): (1, 3, 32, 32)\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "Order to permute axes of input tensor. Reverses the dimensions by default.",
        "name": "axes",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor)* Input tensor.",
        "name": "X"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor)* Transposed output.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "TrimDataset",
    "description": "\nTrim the given dataset inplace, given the dataset blobs and the field specs.\nTrimming happens such that the dataset will contain the largest possible number\nof records that is a multiple of the 'multiple_of' argument.\n",
    "attributes": [
      {
        "description": "List of strings representing the string names in the formatspecified in the doc for CreateTreeCursor.",
        "name": "fields",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "TT",
    "description": "\nThe TT-layer serves as a low-rank decomposition of a fully connected layer. The\ninputs are the same as to a fully connected layer, but the number of parameters\nare greatly reduced and forward computation time can be drastically reduced\nespecially for layers with large weight matrices. The multiplication is computed\nas a product of the input vector with each of the cores that make up the TT\nlayer. Given the input sizes (inp_sizes), output sizes(out_sizes), and the ranks\nof each of the cores (tt_ranks), the ith core will have size:\n\n    inp_sizes[i] * tt_ranks[i] * tt_ranks[i + 1] * out_sizes[i].\n\nThe complexity of the computation is dictated by the sizes of inp_sizes,\nout_sizes, and tt_ranks, where there is the trade off between accuracy of the\nlow-rank decomposition and the speed of the computation.\n",
    "attributes": [
      {
        "description": "(int[]) Input sizes of cores. Indicates the input size of the individual cores; the size of the input vector X must match the product of the inp_sizes array.",
        "name": "inp_sizes",
        "option": "optional"
      },
      {
        "description": "(int[]) Output sizes of cores. Indicates the output size of the individual cores; the size of the output vector Y must match the product of the out_sizes array.",
        "name": "out_sizes",
        "option": "optional"
      },
      {
        "description": "(int[]) Ranks of cores. Indicates the ranks of the individual cores; lower rank means larger compression, faster computation but reduce accuracy.",
        "name": "tt_ranks",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor from previous layer with size (M x K), where M is the batch size and K is the input size.",
        "name": "X"
      },
      {
        "description": "1D blob containing the bias vector",
        "name": "b"
      },
      {
        "description": "1D blob containing each individual cores with sizes specified above.",
        "name": "cores"
      }
    ],
    "outputs": [
      {
        "description": "Output tensor from previous layer with size (M x N), where M is the batch size and N is the output size.",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "TTLinearGradient",
    "support_level": "default"
  },
  {
    "name": "TTSparseLengthsSum",
    "description": "\nThis operator introduce a new, parameter efficient embedding layer, termed TT embedding, which\ncan be plugged in into any model and trained end-to-end. The benefits of our compressed TT layer\nare twofold. Firstly, instead of storing huge embedding matrix, it stores a sequence of much smaller\n2-dimensional and 3-dimensional tensors, necessary for reconstructing the required embeddings,\nwhich allows compressing the model significantly at the cost of a negligible performance drop.\nSecondly, the overall number of parameters can be relatively small (and constant) during the whole\ntraining stage, which allows to use larger batches or train efficiently in a case of limited resources.\n",
    "attributes": [
      {
        "description": "vector<int>: factorization of voc size",
        "name": "factor_i",
        "option": "optional"
      },
      {
        "description": "vector<int>: factorization of emb size",
        "name": "factor_j",
        "option": "optional"
      },
      {
        "description": "int[] Ranks of cores",
        "name": "ranks",
        "option": "optional"
      },
      {
        "description": "int: the size of each embedding entry",
        "name": "emb_size",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "tensor core 0",
        "name": "core0"
      },
      {
        "description": "tensor core 1",
        "name": "core1"
      },
      {
        "description": "tensor core 2",
        "name": "core2"
      },
      {
        "description": "index for embedding",
        "name": "index"
      },
      {
        "description": "segment lengths",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated tensor",
        "name": "OUTPUT"
      },
      {
        "description": "intermediate mm result from core0 for backward path",
        "name": "core0_output"
      },
      {
        "description": "intermediate mm result from core1 for backward path",
        "name": "core1_output"
      },
      {
        "description": "the index for each core",
        "name": "indices"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "TTSparseLengthsSumGradient",
    "support_level": "default"
  },
  {
    "name": "UniformFill",
    "description": "\nFill the output tensor with float samples from uniform distribution [`min`, `max`].\n\n- The range can be defined either by arguments or input blobs. `min` and `max` are inclusive.\n    - If the range is given by input blobs, you also need to give the shape as input.\n    - When the range is given as arguments, this operator enforces min <= max. When the range is given as inputs, the constraint is not enforced.\n    - When the range is given as inputs and max < min, the first dimension of the output is set to 0. This behavior is allowed so that dynamically sampling indices into a dynamically sized tensor is possible.\n- The shape of the output can be given as argument or input.\n\nGithub Links:\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/filler_op.h\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/filler_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop_1 = core.CreateOperator(\n    \"UniformFill\",\n    [],\n    [\"output\"],\n    min=5.5,\n    max=10.5,\n    shape=(3,3)\n)\n\nop_2 = core.CreateOperator(\n    \"UniformFill\",\n    [\"shape\", \"min\", \"max\"],\n    [\"output\"],\n    input_as_shape=1\n)\n\n// Test arg-based op\nworkspace.RunOperatorOnce(op_1)\nprint(\"output (op_1):\\n\", workspace.FetchBlob(\"output\"))\n\n// Test input-based op\nworkspace.ResetWorkspace()\nworkspace.FeedBlob(\"shape\", np.array([5,5]))\nworkspace.FeedBlob(\"min\", np.array(13.8, dtype=np.float32))\nworkspace.FeedBlob(\"max\", np.array(19.3, dtype=np.float32))\nworkspace.RunOperatorOnce(op_2)\nprint(\"output (op_2):\\n\", workspace.FetchBlob(\"output\"))\n\n```\n\n**Result**\n\n```\n\noutput (op_1):\n [[8.894862  8.225005  6.7890406]\n [9.588293  7.1072135 7.7234955]\n [8.210596  6.0202913 9.665462 ]]\noutput (op_2):\n [[18.965155 15.603871 15.038921 17.14872  18.134571]\n [18.84237  17.845276 19.214737 16.970337 15.494069]\n [18.754795 16.724329 15.311974 16.962536 18.60965 ]\n [15.186268 15.264773 18.73341  19.077969 14.237255]\n [15.917589 15.844325 16.248466 17.006554 17.502048]]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "(*float*): minimum value, inclusive",
        "name": "min",
        "option": "optional"
      },
      {
        "description": "(*float*): maximum value, inclusive",
        "name": "max",
        "option": "optional"
      },
      {
        "description": "(*Tuple(int)*): shape of the output, do not set when `input_as_shape`=1",
        "name": "shape",
        "option": "optional"
      },
      {
        "description": "(*int*): set to 1 to use the first input as shape; `shape` input must be in CPU context",
        "name": "input_as_shape",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "(*Tensor`<int>`*): 1-D tensor of the shape of the output, must be used with `input_as_shape` argument",
        "name": "shape"
      },
      {
        "description": "(*Tensor`<float>`*): scalar tensor containing minimum value, inclusive",
        "name": "min"
      },
      {
        "description": "(*Tensor`<float>`*): scalar tensor containing maximum value, inclusive",
        "name": "max"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor`<float>`*): filled output tensor",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "UniformIntFill",
    "description": "\nFill the output tensor with int32 samples from uniform distribution [`min`, `max`].\n\n- The range can be defined either by arguments or input blobs. `min` and `max` are inclusive.\n    - If the range is given by input blobs, you also need to give the shape as input.\n    - When the range is given as arguments, this operator enforces min <= max. When the range is given as inputs, the constraint is not enforced.\n    - When the range is given as inputs and max < min, the first dimension of the output is set to 0. This behavior is allowed so that dynamically sampling indices into a dynamically sized tensor is possible.\n- The shape of the output can be given as argument or input.\n\nGithub Links:\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/filler_op.h\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/filler_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop_1 = core.CreateOperator(\n    \"UniformIntFill\",\n    [],\n    [\"output\"],\n    min=5,\n    max=10,\n    shape=(3,3)\n)\n\nop_2 = core.CreateOperator(\n    \"UniformIntFill\",\n    [\"shape\", \"min\", \"max\"],\n    [\"output\"],\n    input_as_shape=1\n)\n\n// Test arg-based op\nworkspace.RunOperatorOnce(op_1)\nprint(\"output (op_1):\\n\", workspace.FetchBlob(\"output\"))\n\n// Test input-based op\nworkspace.ResetWorkspace()\nworkspace.FeedBlob(\"shape\", np.array([5,5]))\nworkspace.FeedBlob(\"min\", np.array(13, dtype=np.int32))\nworkspace.FeedBlob(\"max\", np.array(19, dtype=np.int32))\nworkspace.RunOperatorOnce(op_2)\nprint(\"output (op_2):\\n\", workspace.FetchBlob(\"output\"))\n\n```\n\n**Result**\n\n```\n\noutput (op_1):\n [[ 6 10  7]\n [ 5 10  6]\n [ 7  5 10]]\noutput (op_2):\n [[19 13 15 13 13]\n [14 17 14 15 15]\n [17 14 19 13 13]\n [17 18 16 13 18]\n [14 15 16 18 16]]\n\n```\n\n</details>\n\n    ",
    "attributes": [
      {
        "description": "(*int*): minimum value, inclusive",
        "name": "min",
        "option": "optional"
      },
      {
        "description": "(*int*): maximum value, inclusive",
        "name": "max",
        "option": "optional"
      },
      {
        "description": "(*Tuple(int)*): shape of the output, do not set when `input_as_shape`=1",
        "name": "shape",
        "option": "optional"
      },
      {
        "description": "(*int*): set to 1 to use the first input as shape; `shape` input must be in CPU context",
        "name": "input_as_shape",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "(*Tensor`<int>`*): 1-D tensor of the shape of the output, must be used with `input_as_shape` argument",
        "name": "shape"
      },
      {
        "description": "(*Tensor`<int>`*): scalar tensor containing minimum value, inclusive",
        "name": "min"
      },
      {
        "description": "(*Tensor`<int>`*): scalar tensor containing maximum value, inclusive",
        "name": "max"
      }
    ],
    "outputs": [
      {
        "description": "(*Tensor`<int>`*): filled output tensor",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Unique",
    "description": "\nDeduplicates input indices vector and optionally produces reverse remapping.\nThere's no guarantees on the ordering of the output indices.\n",
    "inputs": [
      {
        "description": "1D tensor of int32 or int64 indices.",
        "name": "indices"
      }
    ],
    "outputs": [
      {
        "description": "1D tensor of deduped entries.",
        "name": "unique_indices"
      },
      {
        "description": "(optional) mapping from `indices` to `unique_indices`. This has the same shape as `indices`. Its elements are the indices into `unique_indices` such that `Gather(['unique_indices', 'remapping'])` yields `indices`.",
        "name": "remapping"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "UniqueUniformFill",
    "description": "\nFill the output tensor with uniform samples between min and max (inclusive).\nIf the second input is given, its elements will be excluded from uniform\nsampling. Using the second input will require you to provide shape via the first\ninput.\n",
    "attributes": [
      {
        "description": "Minimum value, inclusive",
        "name": "min",
        "option": "optional"
      },
      {
        "description": "Maximum value, inclusive",
        "name": "max",
        "option": "optional"
      },
      {
        "description": "The data type for the elements of the output tensor.Strictly must be one of the types from DataType enum in TensorProto.This only supports INT32 and INT64 now. If not set, assume INT32",
        "name": "dtype",
        "option": "optional"
      },
      {
        "description": "The shape of the output tensor.Cannot set the shape argument and pass in an input at the same time.",
        "name": "shape",
        "option": "optional"
      },
      {
        "description": "The additional dimensions appended at the end of the shape indicatedby the input blob. Cannot set the extra_shape argument when there is no input blob.",
        "name": "extra_shape",
        "option": "optional"
      },
      {
        "description": "1D tensor containing the desired output shape. First input must be in CPU context.",
        "name": "input_as_shape",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor to provide shape information",
        "name": "input"
      },
      {
        "description": "(optional) Avoid elements in this tensor. Elements must be unique.",
        "name": "avoid"
      }
    ],
    "outputs": [
      {
        "description": "Output tensor of unique uniform samples",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "UnPackRecords",
    "description": "\nGiven a packed dataset (packed by the PackRecordsOp) and the `fields` argument\ndescribing the datasets schema, return the original dataset format. Number of\nreturned tensors is equal to the number of fields in the `fields` argument.\n\nThe first input is the packed tensor to be unpacked. Optionally, you can provide\nprototype tensors to give the expected shapes of the output tensors. This is\nhelpful when you expected to unpack empty tensor, e.g., output of a sampling\nprocess.\n",
    "attributes": [
      {
        "description": "List of strings representing the string names in the formatspecified in the doc for CreateTreeCursor.",
        "name": "fields",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "The tensor to be unpacked",
        "name": "packed_tensor"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "UnpackRNNSequence",
    "description": "\nThis is the reverse operator for PackRNNSequence. It maps the packed values\nback to sequence values based on the length blob. Each number from length blob\nrepresents the corresponding values that has been grouped. The dimension\nfor each pack is the same as the maximum number from the length blob (padding\nwith zero was implemented for smaller length value). The overall output\ndimension is: M * D, where M is the sum of lengths, and D is the dimension of\neach feature value. The following example shows the input and output of\nthis operator:\n\n\nGiven:\n  values = [\n    [v1, v3, v6, v7],\n    [v2, v4, 0,  v8],\n    [0,  v5, 0,  0 ],\n  ]\n  lengths = [2, 3, 1, 2]\n\n\nOutput:\n  output = [v1, v2, v3, v4, v5, v6, v7, v8];\n\n\nOne application for this operator is the transfer data from the format of RNN\nback to sequence values. Note that the gradient operator of\nUnpackRNNSequence is PackRNNSequence.\n",
    "inputs": [
      {
        "description": "Data tensor, contains the packed features",
        "name": "values"
      },
      {
        "description": "lengths with each number representing the pack size.",
        "name": "lengths"
      }
    ],
    "outputs": [
      {
        "description": "Output tensor before packing",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "UnpackSegments",
    "description": "Map N+1 dim tensor to N dim based on length blob",
    "attributes": [
      {
        "description": "The pre-defined max_length for the packed segments",
        "name": "max_length",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "1-d int/long tensor contains the length in each of the input.",
        "name": "lengths"
      },
      {
        "description": "N+1 dim Tensor.",
        "name": "tensor"
      }
    ],
    "outputs": [
      {
        "description": "N dim Tensor",
        "name": "packed_tensor"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "UnsafeCoalesce",
    "description": "\nCoalesce the N inputs into N outputs and a single coalesced output blob.\nThis allows operations that operate over multiple small kernels (e.g.\nbiases in a deep CNN) to be coalesced into a single larger operation,\namortizing the kernel launch overhead, synchronization costs for\ndistributed computation, etc.\nThe operator:\n- computes the total size of the coalesced blob by summing the input sizes\n- allocates the coalesced output blob as the total size\n- copies the input vectors into the coalesced blob, at the correct offset.\n- aliases each Output(i) to- point into the coalesced blob, at the corresponding offset for Input(i).\nThis is 'unsafe' as the output vectors are aliased, so use with\ncaution.\n",
    "support_level": "default"
  },
  {
    "name": "UnsortedSegmentMean",
    "description": "\nApplies 'Mean' to each segment of input tensor. Segments ids can appear in\narbitrary order (unlike in SortedSegmentMean).\n\nSEGMENT_IDS is a vector that maps each of the first dimension slices of the\nDATA to a particular group (segment). Values belonging to the same segment are\naggregated together.\n\nIf `num_segments` argument is passed it would be used as a first dimension for\nthe output. Otherwise, it'd be dynamically calculated from as the max value of\nSEGMENT_IDS plus one. Other output dimensions are inherited from the input\ntensor.\n\nMean computes the element-wise mean of the input slices. Operation doesn't change the shape of the individual blocks.\n  ",
    "attributes": [
      {
        "description": "Optional int argument specifying the number of output segments and thus the first dimension of the output",
        "name": "num_segments",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor, slices of which are aggregated.",
        "name": "DATA"
      },
      {
        "description": "Integer vector with the same length as the first dimension of DATA that maps each slice of DATA to one of the segments",
        "name": "SEGMENT_IDS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated output tensor. Has the first dimension of equal to the number of segments.",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "UnsortedSegmentMeanGradient",
    "support_level": "default"
  },
  {
    "name": "UnsortedSegmentSum",
    "description": "\nApplies 'Sum' to each segment of input tensor. Segments ids can appear in\narbitrary order (unlike in SortedSegmentSum).\n\nSEGMENT_IDS is a vector that maps each of the first dimension slices of the\nDATA to a particular group (segment). Values belonging to the same segment are\naggregated together.\n\nIf `num_segments` argument is passed it would be used as a first dimension for\nthe output. Otherwise, it'd be dynamically calculated from as the max value of\nSEGMENT_IDS plus one. Other output dimensions are inherited from the input\ntensor.\n\nSummation is done element-wise across slices of the input tensor and doesn't change the shape of the individual blocks.\n  ",
    "attributes": [
      {
        "description": "Optional int argument specifying the number of output segments and thus the first dimension of the output",
        "name": "num_segments",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor, slices of which are aggregated.",
        "name": "DATA"
      },
      {
        "description": "Integer vector with the same length as the first dimension of DATA that maps each slice of DATA to one of the segments",
        "name": "SEGMENT_IDS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated output tensor. Has the first dimension of equal to the number of segments.",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "UnsortedSegmentSumGradient",
    "support_level": "default"
  },
  {
    "name": "UnsortedSegmentWeightedSum",
    "description": "\nApplies 'WeightedSum' to each segment of input tensor. Segments ids can appear in\narbitrary order (unlike in SortedSegmentWeightedSum).\n\nSEGMENT_IDS is a vector that maps each of the first dimension slices of the\nDATA to a particular group (segment). Values belonging to the same segment are\naggregated together.\n\nIf `num_segments` argument is passed it would be used as a first dimension for\nthe output. Otherwise, it'd be dynamically calculated from as the max value of\nSEGMENT_IDS plus one. Other output dimensions are inherited from the input\ntensor.\n\nInput slices are first scaled by SCALARS and then summed element-wise. It doesn't change the shape of the individual blocks.\n  ",
    "attributes": [
      {
        "description": "Optional int argument specifying the number of output segments and thus the first dimension of the output",
        "name": "num_segments",
        "option": "optional"
      },
      {
        "description": "Produce also gradient for `weights`. For now it's only supported in `Lengths`-based operators",
        "name": "grad_on_weights",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor for the summation",
        "name": "DATA"
      },
      {
        "description": "Scalar multipliers for the input slices. Must be a vector with the length matching the number of slices",
        "name": "SCALARS"
      },
      {
        "description": "Integer vector with the same length as the first dimension of DATA that maps each slice of DATA to one of the segments",
        "name": "SEGMENT_IDS"
      }
    ],
    "outputs": [
      {
        "description": "Aggregated output tensor. Has the first dimension of equal to the number of segments.",
        "name": "OUTPUT"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "UnsortedSegmentWeightedSumGradient",
    "support_level": "default"
  },
  {
    "name": "UpsampleBilinear",
    "description": "\nResizes the spatial dimensions of the input using bilinear\ninterpolation. The `width_scale` and `height_scale` arguments\ncontrol the size of the output, which is given by:\noutput_width = floor(input_width * width_scale)\noutput_height = floor(output_height * height_scale)\n",
    "attributes": [
      {
        "description": "Scale along width dimension",
        "name": "width_scale",
        "option": "optional"
      },
      {
        "description": "Scale along height dimension",
        "name": "height_scale",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Input tensor",
        "name": "X"
      },
      {
        "description": "1D, 2-element, Scales tensor, [height_scale, width_scale]",
        "name": "scales"
      }
    ],
    "outputs": [
      {
        "description": "Output tensor",
        "name": "Y"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "UpsampleBilinearGradient",
    "attributes": [
      {
        "description": "Scale along width dimension",
        "name": "width_scale",
        "option": "optional"
      },
      {
        "description": "Scale along height dimension",
        "name": "height_scale",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "VariableLengthSequencePadding",
    "description": "\nSuper special-case operator. Used to pad a tensor to mimic pytorch's\npad_packed_sequence.\n\nGiven an input tensor INPUT of size NxBxM and an input tensor LENS\nof size B, where\n\nN = maximum sequence length\nB = batch size\nM = hidden size\n\nset each element of INPUT to zero if it is is past the end of the\ncorresponding sequence (i.e. if LENS[j] > i for an index (i,j,k)).\n\n",
    "support_level": "default"
  },
  {
    "name": "ViterbiPath",
    "description": "\nGiven a predictions matrix and a transitions matrix, get the path with the best\nscore\n",
    "inputs": [
      {
        "description": "N*D predictions matrix",
        "name": "predictions"
      },
      {
        "description": "D*D transitions matrix",
        "name": "transitions"
      }
    ],
    "outputs": [
      {
        "description": "N*1 vector holds the best path indices",
        "name": "viterbi_path"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "WallClockTime",
    "description": "Time since epoch in nanoseconds.",
    "outputs": [
      {
        "description": "The time in nanoseconds.",
        "name": "time"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "WeightedMultiSampling",
    "description": "\nThe operator performs sampling based on the input sampling weights.\nAll weights are cummulative probability thus sorted. The output is\na 1-D tensor (Tensor). If two inputs are given, the second input\nis used to provide shape of the output sample tensor. Otherwise, we use\nargument `num_samples` to determine the number of samples to generate.\n",
    "attributes": [
      {
        "description": "number of samples to sample from the input data",
        "name": "num_samples",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "An optional 1-D Tensor.Input cumulative sampling probability (such as [0.2, 0.5, 0.8, 1.5]). All weights must be non-negative numbers. Note that the last value of CDF is not necessary 1. If the last value is not 1, all values in sampling_cdf will be scaled by this number.",
        "name": "sampling_cdf"
      },
      {
        "description": "Tensor whose shape will be applied to output.",
        "name": "shape_tensor (optional)"
      }
    ],
    "outputs": [
      {
        "description": "The output tensor contains indices sampled from distribution givenby the weight vector in the input tensorThe output is a 1-D Tensor of size determined by argument`num_samples` or the second input tensor.",
        "name": "sampled_indexes"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "WeightedSample",
    "description": "\nThe operator performs sampling based on the input sampling weights for\neach batch. All weights must be non-negative numbers.\nThe input is a 2-D tensor (Tensor) of size (batch_size x weights_dim).\nFor each batch, an index is randomly sampled from the distribution given by\nthe weights of the corresponding batch.\nThe output is a 1-D tensor (Tensor) of size (batch_size x 1) and\ncontains the index(es) of the sampled output.\n",
    "inputs": [
      {
        "description": "A 2-D Tensor of size (batch_size x weights_dim).All weights must be non-negative numbers.",
        "name": "sampling_weights"
      },
      {
        "description": "An optional 2-D Tensor of size (batch_size x weights_dim).Its values correspond to the sampling weights.",
        "name": "sampling_values"
      }
    ],
    "outputs": [
      {
        "description": "The output tensor contains index(es) sampled from distribution givenby the weight vector(s) in the input tensorThe output is a 1-D Tensor of size (batch_size x 1)",
        "name": "sampled_indexes"
      },
      {
        "description": "The output tensor contains value(s) selected by the sampled index(es)It is a 1-D Tensor of size (batch_size x 1)",
        "name": "sampled_values"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "WeightedSampleDequeueBlobs",
    "description": "\nDequeue the blobs from multiple queues. When one of queues is closed and empty,\nthe output status will be set to true which can be used as exit criteria for\nexecution step.\nThe 1st input is the queue and the last output is the status. The rest are\ndata blobs.\n",
    "attributes": [
      {
        "description": "Weights for sampling from multiple queues",
        "name": "weights",
        "option": "optional"
      },
      {
        "description": "The index of the blob (among the output blob list) that will be used to store the index of the table chosen to read the current batch.",
        "name": "table_idx_blob",
        "option": "optional"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "WeightedSigmoidCrossEntropyWithLogits",
    "description": "\nGiven three matrices: logits, targets, weights, all of the same shape,\n(batch_size, num_classes), computes the weighted sigmoid cross entropy between\nlogits and targets. Specifically, at each position r,c, this computes\nweights[r, c] * crossentropy(sigmoid(logits[r, c]), targets[r, c]), and then\naverages over each row.\nReturns a tensor of shape (batch_size,) of losses for each example.\n",
    "inputs": [
      {
        "description": "matrix of logits for each example and class.",
        "name": "logits"
      },
      {
        "description": "matrix of targets, same shape as logits.",
        "name": "targets"
      },
      {
        "description": "matrix of weights, same shape as logits.",
        "name": "weights"
      }
    ],
    "outputs": [
      {
        "description": "Vector with the total xentropy for each example.",
        "name": "xentropy"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "WeightedSigmoidCrossEntropyWithLogitsGradient",
    "support_level": "default"
  },
  {
    "name": "WeightedSum",
    "description": "\nElement-wise weighted sum of several data, weight tensor pairs.\nInput should be in the form X_0, weight_0, X_1, weight_1, ... where X_i all\nhave the same shape, and weight_i are size 1 tensors that specifies the weight\nof each vector. Note that if one wants to do in-place computation, it could\nonly be done with X_0 also as the output, but not other X_i.\n",
    "inputs": [
      {
        "description": "Weight of the first input in the sum.",
        "name": "weight_0"
      }
    ],
    "outputs": [
      {
        "description": "Result containing weighted elem-wise sum of inputs.",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "WeightedSumGradient",
    "support_level": "default"
  },
  {
    "name": "WeightScale",
    "description": "\nEvery `stepsize` iterations, multiply the weights by a constant `scale`:\n    nw = w * scale\n",
    "attributes": [
      {
        "description": "Every iteration number to do weight scaling",
        "name": "stepsize",
        "option": "optional"
      },
      {
        "description": "After iter passes this bound, do not perform the weight rescaling",
        "name": "upper_bound_iter",
        "option": "optional"
      },
      {
        "description": "The multiplicative factor applied to weights.",
        "name": "scale",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Current weights",
        "name": "w"
      },
      {
        "description": "Training Iteration",
        "name": "iter"
      }
    ],
    "outputs": [
      {
        "description": "Updated weights",
        "name": "nw"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Where",
    "description": "\nOperator Where takes three input data (Tensor, Tensor, Tensor) and\nproduces one output data (Tensor) where z = c ? x : y is applied elementwise.\n",
    "inputs": [
      {
        "description": "input tensor containing booleans",
        "name": "C"
      },
      {
        "description": "input tensor",
        "name": "X"
      },
      {
        "description": "input tensor",
        "name": "Y"
      }
    ],
    "outputs": [
      {
        "description": "output tensor",
        "name": "Z"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "While",
    "description": "\n'While' control operator, first input is a scalar boolean blob that stores loop's\ncondition value. Accepts 'loop_net' (required) and 'cond_net' (optional) arguments for\nloop's body and condition subnets respectively. If condition subnet is specified,\nit is executed before the first and after each iteration. Subnets are executed in\nthe same workspace as 'While'.\n    ",
    "attributes": [
      {
        "description": "Net executed on each iteration",
        "name": "loop_net",
        "option": "optional"
      },
      {
        "description": "Net to (re)compute condition value",
        "name": "cond_net",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Scalar boolean condition",
        "name": "condition"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Wngrad",
    "description": "\n\nComputes the WnGrad update for an input gradient and accumulated\nhistory. This operator implement the optimization algorithm\nin https://arxiv.org/abs/1803.02865 by Wu, Ward and Bottou.\nConcretely, given inputs (param, grad, seq_b, learning_rate),\ncomputes\n\n    new_seq_b = seq_b + 1 / seq_b * norm(grad)^2\n    effective_lr = learning_rate / (new_seq_b + epsilon)\n    update = learning_rate * grad / (new_seq_b + epsilon)\n    new_param = param + update\nand returns (new_param, new_seq_b).\n\nOptionally returns effective_lr and update as well.\n\n",
    "attributes": [
      {
        "description": "Default 1e-5",
        "name": "epsilon",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated",
        "name": "param"
      },
      {
        "description": "Seq_b history",
        "name": "seq_b"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "learning rate",
        "name": "lr"
      }
    ],
    "outputs": [
      {
        "description": "Updated parameters",
        "name": "output_param"
      },
      {
        "description": "Updated seq_b",
        "name": "output_seq_b"
      },
      {
        "description": "(optional) Effective learning rate",
        "name": "output_effective_lr"
      },
      {
        "description": "(optional) Actual update that is applied.",
        "name": "output_update"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "XavierFill",
    "description": "\nThis op fills an output tensor with values sampled from a uniform distribution with the range determined by the desired shape of the output. Rather, than specifying the range of values manually, the novelty of Xavier Fill is that it automatically scales the range of the distribution it draws from based on the size of the desired output tensor. For more information check out the paper [Understanding the difficulty of training deep feedforward neural networks](http://proceedings.mlr.press/v9/glorot10a/glorot10a.pdf). The output tensor shape is specified by the *shape* argument. However, if *input_as_shape* is set to *true*, then the *input* should be a 1D tensor containing the desired output shape (the dimensions specified in *extra_shape* will also be appended). In this case, the *shape* argument should **not** be set.\n\n*Note: Do not set the shape argument and pass in an input at the same time.*\n\nGithub Links:\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/filler_op.h\n- https://github.com/caffe2/caffe2/blob/master/caffe2/operators/filler_op.cc\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"XavierFill\",\n    [],\n    [\"out\"],\n    shape=[3,3],\n)\n\nworkspace.RunOperatorOnce(op)\nprint(\"Out:\\n\", workspace.FetchBlob(\"out\"))\n\n```\n\n**Result**\n\n```\n\nOut:\n [[-0.8412168   0.33207083 -0.88418937]\n [ 0.43059897 -0.8340702   0.07781601]\n [ 0.93261135 -0.24542928 -0.3980782 ]]\n\n```\n\n</details>\n\n",
    "attributes": [
      {
        "description": "Desired shape of the *output* tensor.",
        "name": "shape",
        "option": "optional",
        "type": "int64[]"
      },
      {
        "description": "The additional dimensions appended at the end of the *shape* indicated by the input blob. Cannot set the *extra_shape* argument when there is no input blob.",
        "name": "extra_shape",
        "option": "optional",
        "type": "int64[]"
      },
      {
        "default": false,
        "description": "set to *True* to use the *input* as shape. First, input must be in CPU context.",
        "name": "input_as_shape",
        "option": "optional",
        "type": "boolean"
      }
    ],
    "inputs": [
      {
        "description": "(Optional) 1D tensor specifying the shape of the output. Must be used with *input_as_shape=True*",
        "name": "input"
      }
    ],
    "outputs": [
      {
        "description": "Output tensor of random values drawn from an automatically scaled uniform distribution, based on the size of the output tensor. If the shape argument is set, this is the shape specified by the shape argument, and if the *input* exists and *input_as_shape=True*, it is the shape specified by the *input* tensor.",
        "name": "output"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Xor",
    "description": "\nPerforms element-wise logical operation **xor** (with limited broadcast support).\nBoth input operands should be of type `bool`.\n\n\nIf necessary the right-hand-side argument will be broadcasted to match the\nshape of left-hand-side argument. When broadcasting is specified, the second\ntensor can either be of size 1 (a scalar value), or having its shape as a\ncontiguous subset of the first tensor's shape. The starting of the mutually\nequal shape is specified by the argument \"axis\", and if it is not set, suffix\nmatching is assumed. 1-dim expansion doesn't work yet.\n\nFor example, the following tensor shapes are supported (with broadcast=1):\n```\n  shape(A) = (2, 3, 4, 5), shape(B) = (,), i.e. B is a scalar\n  shape(A) = (2, 3, 4, 5), shape(B) = (5,)\n  shape(A) = (2, 3, 4, 5), shape(B) = (4, 5)\n  shape(A) = (2, 3, 4, 5), shape(B) = (3, 4), with axis=1\n  shape(A) = (2, 3, 4, 5), shape(B) = (2), with axis=0\n```\nArgument `broadcast=1` needs to be passed to enable broadcasting.\n\nGithub Links:\n\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/elementwise_ops_schema.cc\n\n\n\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\n\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"Xor\",\n    [\"A\",  \"B\"],\n    [\"C\"],\n)\n\nworkspace.FeedBlob(\"A\", (np.random.rand(3, 3) > 0.5))\nworkspace.FeedBlob(\"B\", (np.random.rand(3, 3) > 0.5))\nprint(\"A:\", workspace.FetchBlob(\"A\"))\nprint(\"B:\", workspace.FetchBlob(\"B\"))\nworkspace.RunOperatorOnce(op)\nprint(\"C:\", workspace.FetchBlob(\"C\"))\n\n```\n\n**Result**\n\n```\n\nA:\n[[ True  True  True]\n [False False  True]\n [False  True False]]\nB:\n[[False False False]\n [ True  True  True]\n [False False False]]\nC:\n[[ True  True  True]\n [ True  True False]\n [False  True False]]\n\n```\n\n</details>\n\n    ",
    "attributes": [
      {
        "default": 0,
        "description": "Pass 1 to enable broadcasting.",
        "name": "broadcast",
        "option": "optional",
        "type": "int64"
      },
      {
        "default": -1,
        "description": "Axis to concatenate on. If set, defines the broadcast dimensions.",
        "name": "axis",
        "option": "optional",
        "type": "int64"
      }
    ],
    "inputs": [
      {
        "description": "*(type: Tensor`<bool>`)* First operand.",
        "name": "A"
      },
      {
        "description": "*(type: Tensor`<bool>`)* Second operand. With broadcasting can be of smaller size than `A`. If broadcasting is disabled it should be of the same size.",
        "name": "B"
      }
    ],
    "outputs": [
      {
        "description": "*(type: Tensor`<bool>`)* Output tensor of booleans. Has same dimensions as input `A`.",
        "name": "C"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "YellowFin",
    "description": "\n\nComputes the YellowFin update (https://arxiv.org/abs/1706.03471) and performs\nmomentum SGD optimization step. lr and mu are not being shared between\nparameters. curv_win, g_avg, g2_avg and scalars_memory are just auxiliary\nmemory for computing moving averages (see the publication). Takes arguments\nbeta: coefficient for moving averages,\ncurv_win_width: timeframe when average squared gradient is being stored,\nepsilon: for numerical purposes,\nnesterov and zero_debias for debias of moving average.\n\n",
    "attributes": [
      {
        "description": "Default 0.999",
        "name": "beta",
        "option": "optional"
      },
      {
        "description": "Default 20",
        "name": "curv_win_width",
        "option": "optional"
      },
      {
        "description": "Default 1e-6",
        "name": "epsilon",
        "option": "optional"
      },
      {
        "description": "Default false",
        "name": "nesterov",
        "option": "optional"
      },
      {
        "description": "Default true",
        "name": "zero_debias",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "description": "Parameters to be updated",
        "name": "param"
      },
      {
        "description": "Momentum",
        "name": "moment"
      },
      {
        "description": "Learning rate",
        "name": "lr"
      },
      {
        "description": "Momentum coefficient",
        "name": "mu"
      },
      {
        "description": "Memory for latest curvature ranges",
        "name": "curv_win"
      },
      {
        "description": "Moving average of gradient",
        "name": "g_avg"
      },
      {
        "description": "Moving average of squared gradient",
        "name": "g2_avg"
      },
      {
        "description": "Memory for stateful scalars",
        "name": "scalars_memory"
      },
      {
        "description": "Gradient computed",
        "name": "grad"
      },
      {
        "description": "Iteration number",
        "name": "iter"
      }
    ],
    "outputs": [
      {
        "description": "Parameters to be updated",
        "name": "output_param"
      },
      {
        "description": "Momentum",
        "name": "output_moment"
      },
      {
        "description": "Output learning rate",
        "name": "output_lr"
      },
      {
        "description": "Output momentum coefficient",
        "name": "output_mu"
      },
      {
        "description": "Output memory for latest curvature ranges",
        "name": "output_curv_win"
      },
      {
        "description": "Output moving average of gradient",
        "name": "output_g_avg"
      },
      {
        "description": "Output moving average of squared gradient",
        "name": "output_g2_avg"
      },
      {
        "description": "Output memory for stateful scalars",
        "name": "output_scalars_memory"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "ZeroGradient",
    "description": "\nZeroGradient operators doesn't produce any output blobs. One can use\nthis operator to produce 0 gradient for the input blob.\n",
    "support_level": "default"
  },
  {
    "name": "DecayAdagrad",
    "description": "\n\nComputes the DecayAdagrad update for an\ninput gradient and momentum parameters. Concretely, given inputs\n(param, m1, m2, c, grad, lr, iters),\n\n    t = iters + 1\n    m1_o = (beta1 * m1) + (1 - beta1) * grad\n    m2_o = m2 + np.square(grad)\n    c = 1.0 or (1 - power(beta1, t))\n    grad_o = m1_o / c / (sqrt(m2_o) + epsilon)\n    param_o = param + lr * (grad_o + weight_decay * param)\n\nand returns (param_o, m1_o, m2_o)\n\n",
    "attributes": [
      {
        "name": "beta1",
        "description": "Default 0.9",
        "option": "optional"
      },
      {
        "name": "beta2",
        "description": "Default 0.999",
        "option": "optional"
      },
      {
        "name": "epsilon",
        "description": "Default 1e-5",
        "option": "optional"
      },
      {
        "name": "weight_decay",
        "description": "Default 0.0",
        "option": "optional"
      },
      {
        "name": "bias_correction_first",
        "description": "Default True",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "name": "param",
        "description": "Parameters to be updated"
      },
      {
        "name": "moment_1",
        "description": "First moment history"
      },
      {
        "name": "moment_2",
        "description": "Second moment history"
      },
      {
        "name": "grad",
        "description": "Gradient computed"
      },
      {
        "name": "lr",
        "description": "learning rate"
      },
      {
        "name": "iter",
        "description": "iteration number"
      }
    ],
    "outputs": [
      {
        "name": "output_param",
        "description": "Updated parameters"
      },
      {
        "name": "output_moment_1",
        "description": "Updated first moment"
      },
      {
        "name": "output_moment_2",
        "description": "Updated second moment"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Log1p",
    "description": "\nCalculates Log1p of the given input tensor element-wise. This\noperation can be done in an in-place fashion too, by providing the same input\nand output blobs.\n\nGithub Link:\n- https://github.com/pytorch/pytorch/blob/master/caffe2/operators/log1p_op.cc\n",
    "inputs": [
      {
        "name": "input",
        "description": "Input data blob to be operated on."
      }
    ],
    "outputs": [
      {
        "name": "output",
        "description": "Output data blob with same shape as input"
      }
    ],
    "support_level": "default"
  },
  {
    "name": "Log1pGradient",
    "support_level": "default"
  },
  {
    "name": "SparseItemwiseDropoutWithReplacement",
    "description": "\n\n`SparseItemwiseDropoutWithReplacement` takes a 1-d input tensor and a lengths tensor.\nValues in the Lengths tensor represent how many input elements consitute each\nexample in a given batch.  The each input value in the tensor of an example can be\nreplaced with the replacement value with probability given by the `ratio`\nargument.\n\n<details>\n\n<summary> <b>Example</b> </summary>\n\n**Code**\n\n```\nworkspace.ResetWorkspace()\n\nop = core.CreateOperator(\n    \"SparseItemwiseDropoutWithReplacement\",\n    [\"X\", \"Lengths\"],\n    [\"Y\", \"OutputLengths\"],\n    ratio=0.5,\n    replacement_value=-1\n)\n\nworkspace.FeedBlob(\"X\", np.array([1, 2, 3, 4, 5]).astype(np.int64))\nworkspace.FeedBlob(\"Lengths\", np.array([2, 3]).astype(np.int32))\nprint(\"X:\", workspace.FetchBlob(\"X\"))\nprint(\"Lengths:\", workspace.FetchBlob(\"Lengths\"))\nworkspace.RunOperatorOnce(op)\nprint(\"Y:\", workspace.FetchBlob(\"Y\"))\nprint(\"OutputLengths:\", workspace.FetchBlob(\"OutputLengths\"))\n```\n\n**Result**\n\n```\nX: [1, 2, 3, 4, 5]\nLengths: [2, 3]\nY: [1, 2, -1]\nOutputLengths: [2, 1]\n```\n\n</details>\n\n",
    "attributes": [
      {
        "name": "ratio",
        "type": "float32",
        "default": 0.0,
        "description": "Probability of an element to be replaced.",
        "option": "optional"
      },
      {
        "name": "replacement_value",
        "type": "int64",
        "default": 0,
        "description": "Value elements are replaced with.",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "name": "X",
        "description": "*(type: Tensor`<int64_t>`)* Input data tensor."
      },
      {
        "name": "Lengths",
        "description": "*(type: Tensor`<int32_t>`)* Lengths tensor for input."
      }
    ],
    "outputs": [
      {
        "name": "Y",
        "description": "*(type: Tensor`<int64_t>`)* Output tensor."
      },
      {
        "name": "OutputLengths",
        "description": "*(type: Tensor`<int32_t>`)* Output tensor."
      }
    ],
    "support_level": "default"
  },
  {
    "name": "EstimateAllBlobSizes",
    "description": "\nReturns two outputs: a 1D tensor of strings containing the names\nof each blob in the active workspace, and a 1D tensor of integers containing the\nestimated serialized size of each blob (in bytes).\n",
    "attributes": [
      {
        "name": "include_shared",
        "description": "(bool, default true) Whether to include blobs inherited from parent workspaces.",
        "option": "optional"
      },
      {
        "name": "options",
        "description": "(string, default empty) A BlobSerializationOptions message specifying options for how specific blobs should be serialized.",
        "option": "optional"
      }
    ],
    "outputs": [
      {
        "name": "blob_names",
        "description": "1D tensor of strings containing blob names."
      },
      {
        "name": "blob_sizes",
        "description": "1D tensor of int64_t containing blob sizes."
      }
    ],
    "support_level": "default"
  },
  {
    "name": "SmartDecaySparseAdam",
    "description": "\n\n    Computes the Adam Update for the sparse case.\n    Given inputs (param, moment1, moment2, indices, grad, lr, iter), runs the dense\n    Adam on (param, moment1[indices], momemnt2[indices], lr, iter) and returns\n    (new_param, new_moment1, new_moment2) as in dense case.\n    Adam can be customized as Rectified Adam (RAdam) by setting enableRAdam = true.\n\n    ",
    "attributes": [
      {
        "name": "beta1",
        "description": "Default 0.9",
        "option": "optional"
      },
      {
        "name": "beta2",
        "description": "Default 0.999",
        "option": "optional"
      },
      {
        "name": "epsilon",
        "description": "Default 1e-5",
        "option": "optional"
      }
    ],
    "inputs": [
      {
        "name": "param",
        "description": "Parameters to be updated"
      },
      {
        "name": "moment_1",
        "description": "First moment history"
      },
      {
        "name": "moment_2",
        "description": "Second moment history"
      },
      {
        "name": "last_seen",
        "description": "Minibatch index when each weight was last seen"
      },
      {
        "name": "indices",
        "description": "Sparse indices"
      },
      {
        "name": "grad",
        "description": "Gradient computed"
      },
      {
        "name": "lr",
        "description": "learning rate"
      },
      {
        "name": "iter",
        "description": "iteration number"
      }
    ],
    "outputs": [
      {
        "name": "output_param",
        "description": "Updated parameters"
      },
      {
        "name": "output_moment_1",
        "description": "Updated first moment"
      },
      {
        "name": "output_moment_2",
        "description": "Updated second moment"
      },
      {
        "name": "output_last_seen",
        "description": "Updated minibatch index when each weight was last seen"
      }
    ],
    "support_level": "default"
  }
]
