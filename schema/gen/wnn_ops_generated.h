// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WNNOPS_WNN_H_
#define FLATBUFFERS_GENERATED_WNNOPS_WNN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 6,
             "Non-compatible flatbuffers version included");

#include "tensor_generated.h"
#include "type_generated.h"

namespace wnn {

struct Conv2DCommon;
struct Conv2DCommonBuilder;
struct Conv2DCommonT;

struct Conv2D;
struct Conv2DBuilder;
struct Conv2DT;

struct Pool;
struct PoolBuilder;
struct PoolT;

struct AdaptiveAvgPool2D;
struct AdaptiveAvgPool2DBuilder;
struct AdaptiveAvgPool2DT;

struct LayerNorm;
struct LayerNormBuilder;
struct LayerNormT;

struct BatchNorm;
struct BatchNormBuilder;
struct BatchNormT;

struct Relu;
struct ReluBuilder;
struct ReluT;

struct Relu6;
struct Relu6Builder;
struct Relu6T;

struct Softmax;
struct SoftmaxBuilder;
struct SoftmaxT;

struct PRelu;
struct PReluBuilder;
struct PReluT;

struct ELU;
struct ELUBuilder;
struct ELUT;

struct LRN;
struct LRNBuilder;
struct LRNT;

struct FC;
struct FCBuilder;
struct FCT;

struct Input;
struct InputBuilder;
struct InputT;

struct ArgMax;
struct ArgMaxBuilder;
struct ArgMaxT;

struct Binary;
struct BinaryBuilder;
struct BinaryT;

struct Unary;
struct UnaryBuilder;
struct UnaryT;

struct Eltwise;
struct EltwiseBuilder;
struct EltwiseT;

struct Reduction;
struct ReductionBuilder;
struct ReductionT;

struct Squeeze;
struct SqueezeBuilder;
struct SqueezeT;

struct Gather;
struct GatherBuilder;
struct GatherT;

struct ExpandDims;
struct ExpandDimsBuilder;
struct ExpandDimsT;

struct Flatten;
struct FlattenBuilder;
struct FlattenT;

inline const flatbuffers::TypeTable *Conv2DCommonTypeTable();

inline const flatbuffers::TypeTable *Conv2DTypeTable();

inline const flatbuffers::TypeTable *PoolTypeTable();

inline const flatbuffers::TypeTable *AdaptiveAvgPool2DTypeTable();

inline const flatbuffers::TypeTable *LayerNormTypeTable();

inline const flatbuffers::TypeTable *BatchNormTypeTable();

inline const flatbuffers::TypeTable *ReluTypeTable();

inline const flatbuffers::TypeTable *Relu6TypeTable();

inline const flatbuffers::TypeTable *SoftmaxTypeTable();

inline const flatbuffers::TypeTable *PReluTypeTable();

inline const flatbuffers::TypeTable *ELUTypeTable();

inline const flatbuffers::TypeTable *LRNTypeTable();

inline const flatbuffers::TypeTable *FCTypeTable();

inline const flatbuffers::TypeTable *InputTypeTable();

inline const flatbuffers::TypeTable *ArgMaxTypeTable();

inline const flatbuffers::TypeTable *BinaryTypeTable();

inline const flatbuffers::TypeTable *UnaryTypeTable();

inline const flatbuffers::TypeTable *EltwiseTypeTable();

inline const flatbuffers::TypeTable *ReductionTypeTable();

inline const flatbuffers::TypeTable *SqueezeTypeTable();

inline const flatbuffers::TypeTable *GatherTypeTable();

inline const flatbuffers::TypeTable *ExpandDimsTypeTable();

inline const flatbuffers::TypeTable *FlattenTypeTable();

enum OpType : int32_t {
  OpType_argmax = 0,
  OpType_argmin = 1,
  OpType_const_ = 2,
  OpType_conv1d = 3,
  OpType_conv2d = 4,
  OpType_conv3d = 5,
  OpType_pool2d = 6,
  OpType_pool3d = 7,
  OpType_adaptive_avg_pool2d = 8,
  OpType_batchnorm = 9,
  OpType_layernorm = 10,
  OpType_relu = 11,
  OpType_relu6 = 12,
  OpType_elu = 13,
  OpType_prelu = 14,
  OpType_leakyrelu = 15,
  OpType_tanh = 16,
  OpType_silu = 17,
  OpType_mish = 18,
  OpType_hardswish = 19,
  OpType_hardsigmoid = 20,
  OpType_sigmoid = 21,
  OpType_fc = 22,
  OpType_flatten = 23,
  OpType_matmul = 24,
  OpType_fc_share = 25,
  OpType_lstm = 26,
  OpType_onehot = 27,
  OpType_transpose = 28,
  OpType_gather = 29,
  OpType_split = 30,
  OpType_concat = 31,
  OpType_activation = 32,
  OpType_binary_op = 33,
  OpType_fill = 34,
  OpType_pad = 35,
  OpType_reshape = 36,
  OpType_instancenorm = 37,
  OpType_conv_depthwise = 38,
  OpType_quantized_avgpool = 39,
  OpType_quantized_concat = 40,
  OpType_quantized_matmul = 41,
  OpType_quantized_relu = 42,
  OpType_quantized_relu6 = 43,
  OpType_quantized_softmax = 44,
  OpType_roipooling = 45,
  OpType_roialign = 46,
  OpType_unary = 47,
  OpType_unary_square = 48,
  OpType_unary_sqrt = 49,
  OpType_binary = 50,
  OpType_binary_add = 51,
  OpType_binary_mul = 52,
  OpType_binary_div = 53,
  OpType_binary_sub = 54,
  OpType_softmax = 55,
  OpType_scatternd = 56,
  OpType_gathernd = 57,
  OpType_nms = 58,
  OpType_input = 59,
  OpType_output = 60,
  OpType_extra = 61,
  OpType_eltwise = 62,
  OpType_reduction = 63,
  OpType_expand_dims = 64,
  OpType_normalize = 65,
  OpType_unsupported = 66,
  OpType_film_lpn = 67,
  OpType_cubic = 68,
  OpType_MIN = OpType_argmax,
  OpType_MAX = OpType_cubic
};

inline const OpType (&EnumValuesOpType())[69] {
  static const OpType values[] = {
    OpType_argmax,
    OpType_argmin,
    OpType_const_,
    OpType_conv1d,
    OpType_conv2d,
    OpType_conv3d,
    OpType_pool2d,
    OpType_pool3d,
    OpType_adaptive_avg_pool2d,
    OpType_batchnorm,
    OpType_layernorm,
    OpType_relu,
    OpType_relu6,
    OpType_elu,
    OpType_prelu,
    OpType_leakyrelu,
    OpType_tanh,
    OpType_silu,
    OpType_mish,
    OpType_hardswish,
    OpType_hardsigmoid,
    OpType_sigmoid,
    OpType_fc,
    OpType_flatten,
    OpType_matmul,
    OpType_fc_share,
    OpType_lstm,
    OpType_onehot,
    OpType_transpose,
    OpType_gather,
    OpType_split,
    OpType_concat,
    OpType_activation,
    OpType_binary_op,
    OpType_fill,
    OpType_pad,
    OpType_reshape,
    OpType_instancenorm,
    OpType_conv_depthwise,
    OpType_quantized_avgpool,
    OpType_quantized_concat,
    OpType_quantized_matmul,
    OpType_quantized_relu,
    OpType_quantized_relu6,
    OpType_quantized_softmax,
    OpType_roipooling,
    OpType_roialign,
    OpType_unary,
    OpType_unary_square,
    OpType_unary_sqrt,
    OpType_binary,
    OpType_binary_add,
    OpType_binary_mul,
    OpType_binary_div,
    OpType_binary_sub,
    OpType_softmax,
    OpType_scatternd,
    OpType_gathernd,
    OpType_nms,
    OpType_input,
    OpType_output,
    OpType_extra,
    OpType_eltwise,
    OpType_reduction,
    OpType_expand_dims,
    OpType_normalize,
    OpType_unsupported,
    OpType_film_lpn,
    OpType_cubic
  };
  return values;
}

inline const char * const *EnumNamesOpType() {
  static const char * const names[70] = {
    "argmax",
    "argmin",
    "const_",
    "conv1d",
    "conv2d",
    "conv3d",
    "pool2d",
    "pool3d",
    "adaptive_avg_pool2d",
    "batchnorm",
    "layernorm",
    "relu",
    "relu6",
    "elu",
    "prelu",
    "leakyrelu",
    "tanh",
    "silu",
    "mish",
    "hardswish",
    "hardsigmoid",
    "sigmoid",
    "fc",
    "flatten",
    "matmul",
    "fc_share",
    "lstm",
    "onehot",
    "transpose",
    "gather",
    "split",
    "concat",
    "activation",
    "binary_op",
    "fill",
    "pad",
    "reshape",
    "instancenorm",
    "conv_depthwise",
    "quantized_avgpool",
    "quantized_concat",
    "quantized_matmul",
    "quantized_relu",
    "quantized_relu6",
    "quantized_softmax",
    "roipooling",
    "roialign",
    "unary",
    "unary_square",
    "unary_sqrt",
    "binary",
    "binary_add",
    "binary_mul",
    "binary_div",
    "binary_sub",
    "softmax",
    "scatternd",
    "gathernd",
    "nms",
    "input",
    "output",
    "extra",
    "eltwise",
    "reduction",
    "expand_dims",
    "normalize",
    "unsupported",
    "film_lpn",
    "cubic",
    nullptr
  };
  return names;
}

inline const char *EnumNameOpType(OpType e) {
  if (flatbuffers::IsOutRange(e, OpType_argmax, OpType_cubic)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOpType()[index];
}

enum PadMode : int8_t {
  PadMode_CAFFE = 0,
  PadMode_VALID = 1,
  PadMode_SAME = 2,
  PadMode_MIN = PadMode_CAFFE,
  PadMode_MAX = PadMode_SAME
};

inline const PadMode (&EnumValuesPadMode())[3] {
  static const PadMode values[] = {
    PadMode_CAFFE,
    PadMode_VALID,
    PadMode_SAME
  };
  return values;
}

inline const char * const *EnumNamesPadMode() {
  static const char * const names[4] = {
    "CAFFE",
    "VALID",
    "SAME",
    nullptr
  };
  return names;
}

inline const char *EnumNamePadMode(PadMode e) {
  if (flatbuffers::IsOutRange(e, PadMode_CAFFE, PadMode_SAME)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPadMode()[index];
}

enum ActivationType : int8_t {
  ActivationType_RELU = 0,
  ActivationType_RELU6 = 1,
  ActivationType_LEAKY_RELU = 2,
  ActivationType_ELU = 3,
  ActivationType_TANH = 4,
  ActivationType_PRELU = 5,
  ActivationType_MISH = 6,
  ActivationType_SWISH = 7,
  ActivationType_MIN = ActivationType_RELU,
  ActivationType_MAX = ActivationType_SWISH
};

inline const ActivationType (&EnumValuesActivationType())[8] {
  static const ActivationType values[] = {
    ActivationType_RELU,
    ActivationType_RELU6,
    ActivationType_LEAKY_RELU,
    ActivationType_ELU,
    ActivationType_TANH,
    ActivationType_PRELU,
    ActivationType_MISH,
    ActivationType_SWISH
  };
  return values;
}

inline const char * const *EnumNamesActivationType() {
  static const char * const names[9] = {
    "RELU",
    "RELU6",
    "LEAKY_RELU",
    "ELU",
    "TANH",
    "PRELU",
    "MISH",
    "SWISH",
    nullptr
  };
  return names;
}

inline const char *EnumNameActivationType(ActivationType e) {
  if (flatbuffers::IsOutRange(e, ActivationType_RELU, ActivationType_SWISH)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesActivationType()[index];
}

enum PoolType : int8_t {
  PoolType_MAXPOOL = 0,
  PoolType_AVEPOOL = 1,
  PoolType_MIN = PoolType_MAXPOOL,
  PoolType_MAX = PoolType_AVEPOOL
};

inline const PoolType (&EnumValuesPoolType())[2] {
  static const PoolType values[] = {
    PoolType_MAXPOOL,
    PoolType_AVEPOOL
  };
  return values;
}

inline const char * const *EnumNamesPoolType() {
  static const char * const names[3] = {
    "MAXPOOL",
    "AVEPOOL",
    nullptr
  };
  return names;
}

inline const char *EnumNamePoolType(PoolType e) {
  if (flatbuffers::IsOutRange(e, PoolType_MAXPOOL, PoolType_AVEPOOL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPoolType()[index];
}

enum PoolPadType : int8_t {
  PoolPadType_CAFFE = 0,
  PoolPadType_VALID = 1,
  PoolPadType_SAME = 2,
  PoolPadType_MIN = PoolPadType_CAFFE,
  PoolPadType_MAX = PoolPadType_SAME
};

inline const PoolPadType (&EnumValuesPoolPadType())[3] {
  static const PoolPadType values[] = {
    PoolPadType_CAFFE,
    PoolPadType_VALID,
    PoolPadType_SAME
  };
  return values;
}

inline const char * const *EnumNamesPoolPadType() {
  static const char * const names[4] = {
    "CAFFE",
    "VALID",
    "SAME",
    nullptr
  };
  return names;
}

inline const char *EnumNamePoolPadType(PoolPadType e) {
  if (flatbuffers::IsOutRange(e, PoolPadType_CAFFE, PoolPadType_SAME)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPoolPadType()[index];
}

enum AvgPoolCountType : int8_t {
  AvgPoolCountType_DEFAULT = 0,
  AvgPoolCountType_INCLUDE_PADDING = 1,
  AvgPoolCountType_EXCLUDE_PADDING = 2,
  AvgPoolCountType_MIN = AvgPoolCountType_DEFAULT,
  AvgPoolCountType_MAX = AvgPoolCountType_EXCLUDE_PADDING
};

inline const AvgPoolCountType (&EnumValuesAvgPoolCountType())[3] {
  static const AvgPoolCountType values[] = {
    AvgPoolCountType_DEFAULT,
    AvgPoolCountType_INCLUDE_PADDING,
    AvgPoolCountType_EXCLUDE_PADDING
  };
  return values;
}

inline const char * const *EnumNamesAvgPoolCountType() {
  static const char * const names[4] = {
    "DEFAULT",
    "INCLUDE_PADDING",
    "EXCLUDE_PADDING",
    nullptr
  };
  return names;
}

inline const char *EnumNameAvgPoolCountType(AvgPoolCountType e) {
  if (flatbuffers::IsOutRange(e, AvgPoolCountType_DEFAULT, AvgPoolCountType_EXCLUDE_PADDING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAvgPoolCountType()[index];
}

enum BinaryOperation : int8_t {
  BinaryOperation_ADD = 0,
  BinaryOperation_SUB = 1,
  BinaryOperation_MUL = 2,
  BinaryOperation_DIV = 3,
  BinaryOperation_MAX_TEMP = 4,
  BinaryOperation_MIN_TEMP = 5,
  BinaryOperation_POW = 6,
  BinaryOperation_REALDIV = 7,
  BinaryOperation_MINIMUM = 8,
  BinaryOperation_MAXIMUM = 9,
  BinaryOperation_GREATER = 10,
  BinaryOperation_GREATER_EQUAL = 11,
  BinaryOperation_LESS = 12,
  BinaryOperation_FLOORDIV = 13,
  BinaryOperation_SquaredDifference = 14,
  BinaryOperation_EQUAL = 15,
  BinaryOperation_LESS_EQUAL = 16,
  BinaryOperation_FLOORMOD = 17,
  BinaryOperation_MOD = 19,
  BinaryOperation_ATAN2 = 20,
  BinaryOperation_LOGICALOR = 21,
  BinaryOperation_NOTEQUAL = 22,
  BinaryOperation_BITWISE_AND = 23,
  BinaryOperation_BITWISE_OR = 24,
  BinaryOperation_BITWISE_XOR = 25,
  BinaryOperation_LOGICALXOR = 26,
  BinaryOperation_LEFTSHIFT = 27,
  BinaryOperation_RIGHTSHIFT = 28,
  BinaryOperation_RSUB = 29,
  BinaryOperation_MIN = BinaryOperation_ADD,
  BinaryOperation_MAX = BinaryOperation_RSUB
};

inline const BinaryOperation (&EnumValuesBinaryOperation())[29] {
  static const BinaryOperation values[] = {
    BinaryOperation_ADD,
    BinaryOperation_SUB,
    BinaryOperation_MUL,
    BinaryOperation_DIV,
    BinaryOperation_MAX_TEMP,
    BinaryOperation_MIN_TEMP,
    BinaryOperation_POW,
    BinaryOperation_REALDIV,
    BinaryOperation_MINIMUM,
    BinaryOperation_MAXIMUM,
    BinaryOperation_GREATER,
    BinaryOperation_GREATER_EQUAL,
    BinaryOperation_LESS,
    BinaryOperation_FLOORDIV,
    BinaryOperation_SquaredDifference,
    BinaryOperation_EQUAL,
    BinaryOperation_LESS_EQUAL,
    BinaryOperation_FLOORMOD,
    BinaryOperation_MOD,
    BinaryOperation_ATAN2,
    BinaryOperation_LOGICALOR,
    BinaryOperation_NOTEQUAL,
    BinaryOperation_BITWISE_AND,
    BinaryOperation_BITWISE_OR,
    BinaryOperation_BITWISE_XOR,
    BinaryOperation_LOGICALXOR,
    BinaryOperation_LEFTSHIFT,
    BinaryOperation_RIGHTSHIFT,
    BinaryOperation_RSUB
  };
  return values;
}

inline const char * const *EnumNamesBinaryOperation() {
  static const char * const names[31] = {
    "ADD",
    "SUB",
    "MUL",
    "DIV",
    "MAX_TEMP",
    "MIN_TEMP",
    "POW",
    "REALDIV",
    "MINIMUM",
    "MAXIMUM",
    "GREATER",
    "GREATER_EQUAL",
    "LESS",
    "FLOORDIV",
    "SquaredDifference",
    "EQUAL",
    "LESS_EQUAL",
    "FLOORMOD",
    "",
    "MOD",
    "ATAN2",
    "LOGICALOR",
    "NOTEQUAL",
    "BITWISE_AND",
    "BITWISE_OR",
    "BITWISE_XOR",
    "LOGICALXOR",
    "LEFTSHIFT",
    "RIGHTSHIFT",
    "RSUB",
    nullptr
  };
  return names;
}

inline const char *EnumNameBinaryOperation(BinaryOperation e) {
  if (flatbuffers::IsOutRange(e, BinaryOperation_ADD, BinaryOperation_RSUB)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBinaryOperation()[index];
}

enum UnaryOperation : int32_t {
  UnaryOperation_ABS = 0,
  UnaryOperation_NEG = 1,
  UnaryOperation_FLOOR = 2,
  UnaryOperation_CEIL = 3,
  UnaryOperation_SQUARE = 4,
  UnaryOperation_SQRT = 5,
  UnaryOperation_RSQRT = 6,
  UnaryOperation_EXP = 7,
  UnaryOperation_LOG = 8,
  UnaryOperation_SIN = 9,
  UnaryOperation_COS = 10,
  UnaryOperation_TAN = 11,
  UnaryOperation_ASIN = 12,
  UnaryOperation_ACOS = 13,
  UnaryOperation_ATAN = 14,
  UnaryOperation_RECIPROCAL = 15,
  UnaryOperation_LOG1P = 16,
  UnaryOperation_BNLL = 17,
  UnaryOperation_ACOSH = 18,
  UnaryOperation_SINH = 19,
  UnaryOperation_ASINH = 20,
  UnaryOperation_ATANH = 21,
  UnaryOperation_SIGN = 22,
  UnaryOperation_ROUND = 23,
  UnaryOperation_COSH = 24,
  UnaryOperation_ERF = 25,
  UnaryOperation_ERFC = 26,
  UnaryOperation_ERFINV = 27,
  UnaryOperation_EXPM1 = 28,
  UnaryOperation_SIGMOID = 29,
  UnaryOperation_TANH = 30,
  UnaryOperation_HARDSWISH = 31,
  UnaryOperation_GELU = 32,
  UnaryOperation_GELU_STANDARD = 33,
  UnaryOperation_NOT = 34,
  UnaryOperation_BOOL = 35,
  UnaryOperation_MIN = UnaryOperation_ABS,
  UnaryOperation_MAX = UnaryOperation_BOOL
};

inline const UnaryOperation (&EnumValuesUnaryOperation())[36] {
  static const UnaryOperation values[] = {
    UnaryOperation_ABS,
    UnaryOperation_NEG,
    UnaryOperation_FLOOR,
    UnaryOperation_CEIL,
    UnaryOperation_SQUARE,
    UnaryOperation_SQRT,
    UnaryOperation_RSQRT,
    UnaryOperation_EXP,
    UnaryOperation_LOG,
    UnaryOperation_SIN,
    UnaryOperation_COS,
    UnaryOperation_TAN,
    UnaryOperation_ASIN,
    UnaryOperation_ACOS,
    UnaryOperation_ATAN,
    UnaryOperation_RECIPROCAL,
    UnaryOperation_LOG1P,
    UnaryOperation_BNLL,
    UnaryOperation_ACOSH,
    UnaryOperation_SINH,
    UnaryOperation_ASINH,
    UnaryOperation_ATANH,
    UnaryOperation_SIGN,
    UnaryOperation_ROUND,
    UnaryOperation_COSH,
    UnaryOperation_ERF,
    UnaryOperation_ERFC,
    UnaryOperation_ERFINV,
    UnaryOperation_EXPM1,
    UnaryOperation_SIGMOID,
    UnaryOperation_TANH,
    UnaryOperation_HARDSWISH,
    UnaryOperation_GELU,
    UnaryOperation_GELU_STANDARD,
    UnaryOperation_NOT,
    UnaryOperation_BOOL
  };
  return values;
}

inline const char * const *EnumNamesUnaryOperation() {
  static const char * const names[37] = {
    "ABS",
    "NEG",
    "FLOOR",
    "CEIL",
    "SQUARE",
    "SQRT",
    "RSQRT",
    "EXP",
    "LOG",
    "SIN",
    "COS",
    "TAN",
    "ASIN",
    "ACOS",
    "ATAN",
    "RECIPROCAL",
    "LOG1P",
    "BNLL",
    "ACOSH",
    "SINH",
    "ASINH",
    "ATANH",
    "SIGN",
    "ROUND",
    "COSH",
    "ERF",
    "ERFC",
    "ERFINV",
    "EXPM1",
    "SIGMOID",
    "TANH",
    "HARDSWISH",
    "GELU",
    "GELU_STANDARD",
    "NOT",
    "BOOL",
    nullptr
  };
  return names;
}

inline const char *EnumNameUnaryOperation(UnaryOperation e) {
  if (flatbuffers::IsOutRange(e, UnaryOperation_ABS, UnaryOperation_BOOL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUnaryOperation()[index];
}

enum EltwiseType : int8_t {
  EltwiseType_PROD = 0,
  EltwiseType_SUM = 1,
  EltwiseType_MAXIUM = 2,
  EltwiseType_SUB = 3,
  EltwiseType_SOFTMAX = 4,
  EltwiseType_MIN = EltwiseType_PROD,
  EltwiseType_MAX = EltwiseType_SOFTMAX
};

inline const EltwiseType (&EnumValuesEltwiseType())[5] {
  static const EltwiseType values[] = {
    EltwiseType_PROD,
    EltwiseType_SUM,
    EltwiseType_MAXIUM,
    EltwiseType_SUB,
    EltwiseType_SOFTMAX
  };
  return values;
}

inline const char * const *EnumNamesEltwiseType() {
  static const char * const names[6] = {
    "PROD",
    "SUM",
    "MAXIUM",
    "SUB",
    "SOFTMAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameEltwiseType(EltwiseType e) {
  if (flatbuffers::IsOutRange(e, EltwiseType_PROD, EltwiseType_SOFTMAX)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEltwiseType()[index];
}

enum ReductionType : int8_t {
  ReductionType_SUM = 0,
  ReductionType_ASUM = 1,
  ReductionType_SUMSQ = 2,
  ReductionType_MEAN = 3,
  ReductionType_MAXIMUM = 4,
  ReductionType_MINIMUM = 5,
  ReductionType_PROD = 6,
  ReductionType_ANY = 7,
  ReductionType_ALL = 8,
  ReductionType_MIN = ReductionType_SUM,
  ReductionType_MAX = ReductionType_ALL
};

inline const ReductionType (&EnumValuesReductionType())[9] {
  static const ReductionType values[] = {
    ReductionType_SUM,
    ReductionType_ASUM,
    ReductionType_SUMSQ,
    ReductionType_MEAN,
    ReductionType_MAXIMUM,
    ReductionType_MINIMUM,
    ReductionType_PROD,
    ReductionType_ANY,
    ReductionType_ALL
  };
  return values;
}

inline const char * const *EnumNamesReductionType() {
  static const char * const names[10] = {
    "SUM",
    "ASUM",
    "SUMSQ",
    "MEAN",
    "MAXIMUM",
    "MINIMUM",
    "PROD",
    "ANY",
    "ALL",
    nullptr
  };
  return names;
}

inline const char *EnumNameReductionType(ReductionType e) {
  if (flatbuffers::IsOutRange(e, ReductionType_SUM, ReductionType_ALL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReductionType()[index];
}

struct Conv2DCommonT : public flatbuffers::NativeTable {
  typedef Conv2DCommon TableType;
  int32_t pad_x = 0;
  int32_t pad_y = 0;
  int32_t kernel_x = 1;
  int32_t kernel_y = 1;
  int32_t stride_x = 1;
  int32_t stride_y = 1;
  int32_t dilate_x = 1;
  int32_t dilate_y = 1;
  wnn::PadMode padmode = wnn::PadMode_SAME;
  int32_t group = 1;
  int32_t output_count = 0;
  int32_t input_count = 0;
  int32_t sparse_output_count = 0;
  int32_t in_channels = 0;
  int32_t out_channels = 0;
  bool relu = false;
  bool relu6 = false;
  std::vector<int32_t> pads{};
  std::vector<int32_t> out_pads{};
  bool has_outputshape = false;
};

struct Conv2DCommon FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Conv2DCommonT NativeTableType;
  typedef Conv2DCommonBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Conv2DCommonTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAD_X = 4,
    VT_PAD_Y = 6,
    VT_KERNEL_X = 8,
    VT_KERNEL_Y = 10,
    VT_STRIDE_X = 12,
    VT_STRIDE_Y = 14,
    VT_DILATE_X = 16,
    VT_DILATE_Y = 18,
    VT_PADMODE = 20,
    VT_GROUP = 22,
    VT_OUTPUT_COUNT = 24,
    VT_INPUT_COUNT = 26,
    VT_SPARSE_OUTPUT_COUNT = 28,
    VT_IN_CHANNELS = 30,
    VT_OUT_CHANNELS = 32,
    VT_RELU = 34,
    VT_RELU6 = 36,
    VT_PADS = 38,
    VT_OUT_PADS = 40,
    VT_HAS_OUTPUTSHAPE = 42
  };
  int32_t pad_x() const {
    return GetField<int32_t>(VT_PAD_X, 0);
  }
  int32_t pad_y() const {
    return GetField<int32_t>(VT_PAD_Y, 0);
  }
  int32_t kernel_x() const {
    return GetField<int32_t>(VT_KERNEL_X, 1);
  }
  int32_t kernel_y() const {
    return GetField<int32_t>(VT_KERNEL_Y, 1);
  }
  int32_t stride_x() const {
    return GetField<int32_t>(VT_STRIDE_X, 1);
  }
  int32_t stride_y() const {
    return GetField<int32_t>(VT_STRIDE_Y, 1);
  }
  int32_t dilate_x() const {
    return GetField<int32_t>(VT_DILATE_X, 1);
  }
  int32_t dilate_y() const {
    return GetField<int32_t>(VT_DILATE_Y, 1);
  }
  wnn::PadMode padmode() const {
    return static_cast<wnn::PadMode>(GetField<int8_t>(VT_PADMODE, 2));
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 1);
  }
  int32_t output_count() const {
    return GetField<int32_t>(VT_OUTPUT_COUNT, 0);
  }
  int32_t input_count() const {
    return GetField<int32_t>(VT_INPUT_COUNT, 0);
  }
  int32_t sparse_output_count() const {
    return GetField<int32_t>(VT_SPARSE_OUTPUT_COUNT, 0);
  }
  int32_t in_channels() const {
    return GetField<int32_t>(VT_IN_CHANNELS, 0);
  }
  int32_t out_channels() const {
    return GetField<int32_t>(VT_OUT_CHANNELS, 0);
  }
  bool relu() const {
    return GetField<uint8_t>(VT_RELU, 0) != 0;
  }
  bool relu6() const {
    return GetField<uint8_t>(VT_RELU6, 0) != 0;
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  const flatbuffers::Vector<int32_t> *out_pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUT_PADS);
  }
  bool has_outputshape() const {
    return GetField<uint8_t>(VT_HAS_OUTPUTSHAPE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PAD_X, 4) &&
           VerifyField<int32_t>(verifier, VT_PAD_Y, 4) &&
           VerifyField<int32_t>(verifier, VT_KERNEL_X, 4) &&
           VerifyField<int32_t>(verifier, VT_KERNEL_Y, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_X, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_Y, 4) &&
           VerifyField<int32_t>(verifier, VT_DILATE_X, 4) &&
           VerifyField<int32_t>(verifier, VT_DILATE_Y, 4) &&
           VerifyField<int8_t>(verifier, VT_PADMODE, 1) &&
           VerifyField<int32_t>(verifier, VT_GROUP, 4) &&
           VerifyField<int32_t>(verifier, VT_OUTPUT_COUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_INPUT_COUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_SPARSE_OUTPUT_COUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_IN_CHANNELS, 4) &&
           VerifyField<int32_t>(verifier, VT_OUT_CHANNELS, 4) &&
           VerifyField<uint8_t>(verifier, VT_RELU, 1) &&
           VerifyField<uint8_t>(verifier, VT_RELU6, 1) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyOffset(verifier, VT_OUT_PADS) &&
           verifier.VerifyVector(out_pads()) &&
           VerifyField<uint8_t>(verifier, VT_HAS_OUTPUTSHAPE, 1) &&
           verifier.EndTable();
  }
  Conv2DCommonT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Conv2DCommonT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Conv2DCommon> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DCommonT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv2DCommonBuilder {
  typedef Conv2DCommon Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pad_x(int32_t pad_x) {
    fbb_.AddElement<int32_t>(Conv2DCommon::VT_PAD_X, pad_x, 0);
  }
  void add_pad_y(int32_t pad_y) {
    fbb_.AddElement<int32_t>(Conv2DCommon::VT_PAD_Y, pad_y, 0);
  }
  void add_kernel_x(int32_t kernel_x) {
    fbb_.AddElement<int32_t>(Conv2DCommon::VT_KERNEL_X, kernel_x, 1);
  }
  void add_kernel_y(int32_t kernel_y) {
    fbb_.AddElement<int32_t>(Conv2DCommon::VT_KERNEL_Y, kernel_y, 1);
  }
  void add_stride_x(int32_t stride_x) {
    fbb_.AddElement<int32_t>(Conv2DCommon::VT_STRIDE_X, stride_x, 1);
  }
  void add_stride_y(int32_t stride_y) {
    fbb_.AddElement<int32_t>(Conv2DCommon::VT_STRIDE_Y, stride_y, 1);
  }
  void add_dilate_x(int32_t dilate_x) {
    fbb_.AddElement<int32_t>(Conv2DCommon::VT_DILATE_X, dilate_x, 1);
  }
  void add_dilate_y(int32_t dilate_y) {
    fbb_.AddElement<int32_t>(Conv2DCommon::VT_DILATE_Y, dilate_y, 1);
  }
  void add_padmode(wnn::PadMode padmode) {
    fbb_.AddElement<int8_t>(Conv2DCommon::VT_PADMODE, static_cast<int8_t>(padmode), 2);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(Conv2DCommon::VT_GROUP, group, 1);
  }
  void add_output_count(int32_t output_count) {
    fbb_.AddElement<int32_t>(Conv2DCommon::VT_OUTPUT_COUNT, output_count, 0);
  }
  void add_input_count(int32_t input_count) {
    fbb_.AddElement<int32_t>(Conv2DCommon::VT_INPUT_COUNT, input_count, 0);
  }
  void add_sparse_output_count(int32_t sparse_output_count) {
    fbb_.AddElement<int32_t>(Conv2DCommon::VT_SPARSE_OUTPUT_COUNT, sparse_output_count, 0);
  }
  void add_in_channels(int32_t in_channels) {
    fbb_.AddElement<int32_t>(Conv2DCommon::VT_IN_CHANNELS, in_channels, 0);
  }
  void add_out_channels(int32_t out_channels) {
    fbb_.AddElement<int32_t>(Conv2DCommon::VT_OUT_CHANNELS, out_channels, 0);
  }
  void add_relu(bool relu) {
    fbb_.AddElement<uint8_t>(Conv2DCommon::VT_RELU, static_cast<uint8_t>(relu), 0);
  }
  void add_relu6(bool relu6) {
    fbb_.AddElement<uint8_t>(Conv2DCommon::VT_RELU6, static_cast<uint8_t>(relu6), 0);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(Conv2DCommon::VT_PADS, pads);
  }
  void add_out_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> out_pads) {
    fbb_.AddOffset(Conv2DCommon::VT_OUT_PADS, out_pads);
  }
  void add_has_outputshape(bool has_outputshape) {
    fbb_.AddElement<uint8_t>(Conv2DCommon::VT_HAS_OUTPUTSHAPE, static_cast<uint8_t>(has_outputshape), 0);
  }
  explicit Conv2DCommonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Conv2DCommon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2DCommon>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2DCommon> CreateConv2DCommon(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pad_x = 0,
    int32_t pad_y = 0,
    int32_t kernel_x = 1,
    int32_t kernel_y = 1,
    int32_t stride_x = 1,
    int32_t stride_y = 1,
    int32_t dilate_x = 1,
    int32_t dilate_y = 1,
    wnn::PadMode padmode = wnn::PadMode_SAME,
    int32_t group = 1,
    int32_t output_count = 0,
    int32_t input_count = 0,
    int32_t sparse_output_count = 0,
    int32_t in_channels = 0,
    int32_t out_channels = 0,
    bool relu = false,
    bool relu6 = false,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> out_pads = 0,
    bool has_outputshape = false) {
  Conv2DCommonBuilder builder_(_fbb);
  builder_.add_out_pads(out_pads);
  builder_.add_pads(pads);
  builder_.add_out_channels(out_channels);
  builder_.add_in_channels(in_channels);
  builder_.add_sparse_output_count(sparse_output_count);
  builder_.add_input_count(input_count);
  builder_.add_output_count(output_count);
  builder_.add_group(group);
  builder_.add_dilate_y(dilate_y);
  builder_.add_dilate_x(dilate_x);
  builder_.add_stride_y(stride_y);
  builder_.add_stride_x(stride_x);
  builder_.add_kernel_y(kernel_y);
  builder_.add_kernel_x(kernel_x);
  builder_.add_pad_y(pad_y);
  builder_.add_pad_x(pad_x);
  builder_.add_has_outputshape(has_outputshape);
  builder_.add_relu6(relu6);
  builder_.add_relu(relu);
  builder_.add_padmode(padmode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Conv2DCommon> CreateConv2DCommonDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pad_x = 0,
    int32_t pad_y = 0,
    int32_t kernel_x = 1,
    int32_t kernel_y = 1,
    int32_t stride_x = 1,
    int32_t stride_y = 1,
    int32_t dilate_x = 1,
    int32_t dilate_y = 1,
    wnn::PadMode padmode = wnn::PadMode_SAME,
    int32_t group = 1,
    int32_t output_count = 0,
    int32_t input_count = 0,
    int32_t sparse_output_count = 0,
    int32_t in_channels = 0,
    int32_t out_channels = 0,
    bool relu = false,
    bool relu6 = false,
    const std::vector<int32_t> *pads = nullptr,
    const std::vector<int32_t> *out_pads = nullptr,
    bool has_outputshape = false) {
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  auto out_pads__ = out_pads ? _fbb.CreateVector<int32_t>(*out_pads) : 0;
  return wnn::CreateConv2DCommon(
      _fbb,
      pad_x,
      pad_y,
      kernel_x,
      kernel_y,
      stride_x,
      stride_y,
      dilate_x,
      dilate_y,
      padmode,
      group,
      output_count,
      input_count,
      sparse_output_count,
      in_channels,
      out_channels,
      relu,
      relu6,
      pads__,
      out_pads__,
      has_outputshape);
}

flatbuffers::Offset<Conv2DCommon> CreateConv2DCommon(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DCommonT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv2DT : public flatbuffers::NativeTable {
  typedef Conv2D TableType;
  std::unique_ptr<wnn::Conv2DCommonT> common{};
  std::vector<float> weight{};
  std::vector<float> bias{};
  bool has_act = false;
  wnn::OpType act_type = wnn::OpType_argmax;
  std::vector<int32_t> input_shape{};
  std::unique_ptr<wnn::QuantT> quant_param{};
  Conv2DT() = default;
  Conv2DT(const Conv2DT &o);
  Conv2DT(Conv2DT&&) FLATBUFFERS_NOEXCEPT = default;
  Conv2DT &operator=(Conv2DT o) FLATBUFFERS_NOEXCEPT;
};

struct Conv2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Conv2DT NativeTableType;
  typedef Conv2DBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Conv2DTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON = 4,
    VT_WEIGHT = 6,
    VT_BIAS = 8,
    VT_HAS_ACT = 10,
    VT_ACT_TYPE = 12,
    VT_INPUT_SHAPE = 14,
    VT_QUANT_PARAM = 16
  };
  const wnn::Conv2DCommon *common() const {
    return GetPointer<const wnn::Conv2DCommon *>(VT_COMMON);
  }
  const flatbuffers::Vector<float> *weight() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_WEIGHT);
  }
  const flatbuffers::Vector<float> *bias() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BIAS);
  }
  bool has_act() const {
    return GetField<uint8_t>(VT_HAS_ACT, 0) != 0;
  }
  wnn::OpType act_type() const {
    return static_cast<wnn::OpType>(GetField<int32_t>(VT_ACT_TYPE, 0));
  }
  const flatbuffers::Vector<int32_t> *input_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUT_SHAPE);
  }
  const wnn::Quant *quant_param() const {
    return GetPointer<const wnn::Quant *>(VT_QUANT_PARAM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyVector(bias()) &&
           VerifyField<uint8_t>(verifier, VT_HAS_ACT, 1) &&
           VerifyField<int32_t>(verifier, VT_ACT_TYPE, 4) &&
           VerifyOffset(verifier, VT_INPUT_SHAPE) &&
           verifier.VerifyVector(input_shape()) &&
           VerifyOffset(verifier, VT_QUANT_PARAM) &&
           verifier.VerifyTable(quant_param()) &&
           verifier.EndTable();
  }
  Conv2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Conv2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Conv2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv2DBuilder {
  typedef Conv2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_common(flatbuffers::Offset<wnn::Conv2DCommon> common) {
    fbb_.AddOffset(Conv2D::VT_COMMON, common);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(Conv2D::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(Conv2D::VT_BIAS, bias);
  }
  void add_has_act(bool has_act) {
    fbb_.AddElement<uint8_t>(Conv2D::VT_HAS_ACT, static_cast<uint8_t>(has_act), 0);
  }
  void add_act_type(wnn::OpType act_type) {
    fbb_.AddElement<int32_t>(Conv2D::VT_ACT_TYPE, static_cast<int32_t>(act_type), 0);
  }
  void add_input_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> input_shape) {
    fbb_.AddOffset(Conv2D::VT_INPUT_SHAPE, input_shape);
  }
  void add_quant_param(flatbuffers::Offset<wnn::Quant> quant_param) {
    fbb_.AddOffset(Conv2D::VT_QUANT_PARAM, quant_param);
  }
  explicit Conv2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Conv2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2D> CreateConv2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<wnn::Conv2DCommon> common = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bias = 0,
    bool has_act = false,
    wnn::OpType act_type = wnn::OpType_argmax,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> input_shape = 0,
    flatbuffers::Offset<wnn::Quant> quant_param = 0) {
  Conv2DBuilder builder_(_fbb);
  builder_.add_quant_param(quant_param);
  builder_.add_input_shape(input_shape);
  builder_.add_act_type(act_type);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_common(common);
  builder_.add_has_act(has_act);
  return builder_.Finish();
}

inline flatbuffers::Offset<Conv2D> CreateConv2DDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<wnn::Conv2DCommon> common = 0,
    const std::vector<float> *weight = nullptr,
    const std::vector<float> *bias = nullptr,
    bool has_act = false,
    wnn::OpType act_type = wnn::OpType_argmax,
    const std::vector<int32_t> *input_shape = nullptr,
    flatbuffers::Offset<wnn::Quant> quant_param = 0) {
  auto weight__ = weight ? _fbb.CreateVector<float>(*weight) : 0;
  auto bias__ = bias ? _fbb.CreateVector<float>(*bias) : 0;
  auto input_shape__ = input_shape ? _fbb.CreateVector<int32_t>(*input_shape) : 0;
  return wnn::CreateConv2D(
      _fbb,
      common,
      weight__,
      bias__,
      has_act,
      act_type,
      input_shape__,
      quant_param);
}

flatbuffers::Offset<Conv2D> CreateConv2D(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PoolT : public flatbuffers::NativeTable {
  typedef Pool TableType;
  int32_t pad_x = 0;
  int32_t pad_y = 0;
  bool is_global = false;
  int32_t kernel_x = 0;
  int32_t kernel_y = 0;
  int32_t stride_x = 0;
  int32_t stride_y = 0;
  wnn::PoolType type = wnn::PoolType_MAXPOOL;
  wnn::PoolPadType pad_type = wnn::PoolPadType_CAFFE;
  wnn::DataType data_type = wnn::DataType_DT_FLOAT;
  bool ceil_model = true;
  std::vector<int32_t> pads{};
  wnn::AvgPoolCountType count_type = wnn::AvgPoolCountType_DEFAULT;
  int32_t in_channels = 0;
  int32_t in_width = 0;
  int32_t in_height = 0;
  bool is_adaptive = false;
  int32_t out_height = 0;
  int32_t out_width = 0;
};

struct Pool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PoolT NativeTableType;
  typedef PoolBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PoolTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAD_X = 4,
    VT_PAD_Y = 6,
    VT_IS_GLOBAL = 8,
    VT_KERNEL_X = 10,
    VT_KERNEL_Y = 12,
    VT_STRIDE_X = 14,
    VT_STRIDE_Y = 16,
    VT_TYPE = 18,
    VT_PAD_TYPE = 20,
    VT_DATA_TYPE = 22,
    VT_CEIL_MODEL = 24,
    VT_PADS = 26,
    VT_COUNT_TYPE = 28,
    VT_IN_CHANNELS = 30,
    VT_IN_WIDTH = 32,
    VT_IN_HEIGHT = 34,
    VT_IS_ADAPTIVE = 36,
    VT_OUT_HEIGHT = 38,
    VT_OUT_WIDTH = 40
  };
  int32_t pad_x() const {
    return GetField<int32_t>(VT_PAD_X, 0);
  }
  int32_t pad_y() const {
    return GetField<int32_t>(VT_PAD_Y, 0);
  }
  bool is_global() const {
    return GetField<uint8_t>(VT_IS_GLOBAL, 0) != 0;
  }
  int32_t kernel_x() const {
    return GetField<int32_t>(VT_KERNEL_X, 0);
  }
  int32_t kernel_y() const {
    return GetField<int32_t>(VT_KERNEL_Y, 0);
  }
  int32_t stride_x() const {
    return GetField<int32_t>(VT_STRIDE_X, 0);
  }
  int32_t stride_y() const {
    return GetField<int32_t>(VT_STRIDE_Y, 0);
  }
  wnn::PoolType type() const {
    return static_cast<wnn::PoolType>(GetField<int8_t>(VT_TYPE, 0));
  }
  wnn::PoolPadType pad_type() const {
    return static_cast<wnn::PoolPadType>(GetField<int8_t>(VT_PAD_TYPE, 0));
  }
  wnn::DataType data_type() const {
    return static_cast<wnn::DataType>(GetField<int32_t>(VT_DATA_TYPE, 1));
  }
  bool ceil_model() const {
    return GetField<uint8_t>(VT_CEIL_MODEL, 1) != 0;
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  wnn::AvgPoolCountType count_type() const {
    return static_cast<wnn::AvgPoolCountType>(GetField<int8_t>(VT_COUNT_TYPE, 0));
  }
  int32_t in_channels() const {
    return GetField<int32_t>(VT_IN_CHANNELS, 0);
  }
  int32_t in_width() const {
    return GetField<int32_t>(VT_IN_WIDTH, 0);
  }
  int32_t in_height() const {
    return GetField<int32_t>(VT_IN_HEIGHT, 0);
  }
  bool is_adaptive() const {
    return GetField<uint8_t>(VT_IS_ADAPTIVE, 0) != 0;
  }
  int32_t out_height() const {
    return GetField<int32_t>(VT_OUT_HEIGHT, 0);
  }
  int32_t out_width() const {
    return GetField<int32_t>(VT_OUT_WIDTH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PAD_X, 4) &&
           VerifyField<int32_t>(verifier, VT_PAD_Y, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_GLOBAL, 1) &&
           VerifyField<int32_t>(verifier, VT_KERNEL_X, 4) &&
           VerifyField<int32_t>(verifier, VT_KERNEL_Y, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_X, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_Y, 4) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_PAD_TYPE, 1) &&
           VerifyField<int32_t>(verifier, VT_DATA_TYPE, 4) &&
           VerifyField<uint8_t>(verifier, VT_CEIL_MODEL, 1) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyField<int8_t>(verifier, VT_COUNT_TYPE, 1) &&
           VerifyField<int32_t>(verifier, VT_IN_CHANNELS, 4) &&
           VerifyField<int32_t>(verifier, VT_IN_WIDTH, 4) &&
           VerifyField<int32_t>(verifier, VT_IN_HEIGHT, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_ADAPTIVE, 1) &&
           VerifyField<int32_t>(verifier, VT_OUT_HEIGHT, 4) &&
           VerifyField<int32_t>(verifier, VT_OUT_WIDTH, 4) &&
           verifier.EndTable();
  }
  PoolT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoolT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pool> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoolT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoolBuilder {
  typedef Pool Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pad_x(int32_t pad_x) {
    fbb_.AddElement<int32_t>(Pool::VT_PAD_X, pad_x, 0);
  }
  void add_pad_y(int32_t pad_y) {
    fbb_.AddElement<int32_t>(Pool::VT_PAD_Y, pad_y, 0);
  }
  void add_is_global(bool is_global) {
    fbb_.AddElement<uint8_t>(Pool::VT_IS_GLOBAL, static_cast<uint8_t>(is_global), 0);
  }
  void add_kernel_x(int32_t kernel_x) {
    fbb_.AddElement<int32_t>(Pool::VT_KERNEL_X, kernel_x, 0);
  }
  void add_kernel_y(int32_t kernel_y) {
    fbb_.AddElement<int32_t>(Pool::VT_KERNEL_Y, kernel_y, 0);
  }
  void add_stride_x(int32_t stride_x) {
    fbb_.AddElement<int32_t>(Pool::VT_STRIDE_X, stride_x, 0);
  }
  void add_stride_y(int32_t stride_y) {
    fbb_.AddElement<int32_t>(Pool::VT_STRIDE_Y, stride_y, 0);
  }
  void add_type(wnn::PoolType type) {
    fbb_.AddElement<int8_t>(Pool::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_pad_type(wnn::PoolPadType pad_type) {
    fbb_.AddElement<int8_t>(Pool::VT_PAD_TYPE, static_cast<int8_t>(pad_type), 0);
  }
  void add_data_type(wnn::DataType data_type) {
    fbb_.AddElement<int32_t>(Pool::VT_DATA_TYPE, static_cast<int32_t>(data_type), 1);
  }
  void add_ceil_model(bool ceil_model) {
    fbb_.AddElement<uint8_t>(Pool::VT_CEIL_MODEL, static_cast<uint8_t>(ceil_model), 1);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(Pool::VT_PADS, pads);
  }
  void add_count_type(wnn::AvgPoolCountType count_type) {
    fbb_.AddElement<int8_t>(Pool::VT_COUNT_TYPE, static_cast<int8_t>(count_type), 0);
  }
  void add_in_channels(int32_t in_channels) {
    fbb_.AddElement<int32_t>(Pool::VT_IN_CHANNELS, in_channels, 0);
  }
  void add_in_width(int32_t in_width) {
    fbb_.AddElement<int32_t>(Pool::VT_IN_WIDTH, in_width, 0);
  }
  void add_in_height(int32_t in_height) {
    fbb_.AddElement<int32_t>(Pool::VT_IN_HEIGHT, in_height, 0);
  }
  void add_is_adaptive(bool is_adaptive) {
    fbb_.AddElement<uint8_t>(Pool::VT_IS_ADAPTIVE, static_cast<uint8_t>(is_adaptive), 0);
  }
  void add_out_height(int32_t out_height) {
    fbb_.AddElement<int32_t>(Pool::VT_OUT_HEIGHT, out_height, 0);
  }
  void add_out_width(int32_t out_width) {
    fbb_.AddElement<int32_t>(Pool::VT_OUT_WIDTH, out_width, 0);
  }
  explicit PoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pool>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pool> CreatePool(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pad_x = 0,
    int32_t pad_y = 0,
    bool is_global = false,
    int32_t kernel_x = 0,
    int32_t kernel_y = 0,
    int32_t stride_x = 0,
    int32_t stride_y = 0,
    wnn::PoolType type = wnn::PoolType_MAXPOOL,
    wnn::PoolPadType pad_type = wnn::PoolPadType_CAFFE,
    wnn::DataType data_type = wnn::DataType_DT_FLOAT,
    bool ceil_model = true,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    wnn::AvgPoolCountType count_type = wnn::AvgPoolCountType_DEFAULT,
    int32_t in_channels = 0,
    int32_t in_width = 0,
    int32_t in_height = 0,
    bool is_adaptive = false,
    int32_t out_height = 0,
    int32_t out_width = 0) {
  PoolBuilder builder_(_fbb);
  builder_.add_out_width(out_width);
  builder_.add_out_height(out_height);
  builder_.add_in_height(in_height);
  builder_.add_in_width(in_width);
  builder_.add_in_channels(in_channels);
  builder_.add_pads(pads);
  builder_.add_data_type(data_type);
  builder_.add_stride_y(stride_y);
  builder_.add_stride_x(stride_x);
  builder_.add_kernel_y(kernel_y);
  builder_.add_kernel_x(kernel_x);
  builder_.add_pad_y(pad_y);
  builder_.add_pad_x(pad_x);
  builder_.add_is_adaptive(is_adaptive);
  builder_.add_count_type(count_type);
  builder_.add_ceil_model(ceil_model);
  builder_.add_pad_type(pad_type);
  builder_.add_type(type);
  builder_.add_is_global(is_global);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pool> CreatePoolDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pad_x = 0,
    int32_t pad_y = 0,
    bool is_global = false,
    int32_t kernel_x = 0,
    int32_t kernel_y = 0,
    int32_t stride_x = 0,
    int32_t stride_y = 0,
    wnn::PoolType type = wnn::PoolType_MAXPOOL,
    wnn::PoolPadType pad_type = wnn::PoolPadType_CAFFE,
    wnn::DataType data_type = wnn::DataType_DT_FLOAT,
    bool ceil_model = true,
    const std::vector<int32_t> *pads = nullptr,
    wnn::AvgPoolCountType count_type = wnn::AvgPoolCountType_DEFAULT,
    int32_t in_channels = 0,
    int32_t in_width = 0,
    int32_t in_height = 0,
    bool is_adaptive = false,
    int32_t out_height = 0,
    int32_t out_width = 0) {
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  return wnn::CreatePool(
      _fbb,
      pad_x,
      pad_y,
      is_global,
      kernel_x,
      kernel_y,
      stride_x,
      stride_y,
      type,
      pad_type,
      data_type,
      ceil_model,
      pads__,
      count_type,
      in_channels,
      in_width,
      in_height,
      is_adaptive,
      out_height,
      out_width);
}

flatbuffers::Offset<Pool> CreatePool(flatbuffers::FlatBufferBuilder &_fbb, const PoolT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AdaptiveAvgPool2DT : public flatbuffers::NativeTable {
  typedef AdaptiveAvgPool2D TableType;
  int32_t out_h = 0;
  int32_t out_w = 0;
  wnn::DataType data_type = wnn::DataType_DT_FLOAT;
};

struct AdaptiveAvgPool2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AdaptiveAvgPool2DT NativeTableType;
  typedef AdaptiveAvgPool2DBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AdaptiveAvgPool2DTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUT_H = 4,
    VT_OUT_W = 6,
    VT_DATA_TYPE = 8
  };
  int32_t out_h() const {
    return GetField<int32_t>(VT_OUT_H, 0);
  }
  int32_t out_w() const {
    return GetField<int32_t>(VT_OUT_W, 0);
  }
  wnn::DataType data_type() const {
    return static_cast<wnn::DataType>(GetField<int32_t>(VT_DATA_TYPE, 1));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OUT_H, 4) &&
           VerifyField<int32_t>(verifier, VT_OUT_W, 4) &&
           VerifyField<int32_t>(verifier, VT_DATA_TYPE, 4) &&
           verifier.EndTable();
  }
  AdaptiveAvgPool2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AdaptiveAvgPool2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AdaptiveAvgPool2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AdaptiveAvgPool2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AdaptiveAvgPool2DBuilder {
  typedef AdaptiveAvgPool2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_out_h(int32_t out_h) {
    fbb_.AddElement<int32_t>(AdaptiveAvgPool2D::VT_OUT_H, out_h, 0);
  }
  void add_out_w(int32_t out_w) {
    fbb_.AddElement<int32_t>(AdaptiveAvgPool2D::VT_OUT_W, out_w, 0);
  }
  void add_data_type(wnn::DataType data_type) {
    fbb_.AddElement<int32_t>(AdaptiveAvgPool2D::VT_DATA_TYPE, static_cast<int32_t>(data_type), 1);
  }
  explicit AdaptiveAvgPool2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AdaptiveAvgPool2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AdaptiveAvgPool2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<AdaptiveAvgPool2D> CreateAdaptiveAvgPool2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t out_h = 0,
    int32_t out_w = 0,
    wnn::DataType data_type = wnn::DataType_DT_FLOAT) {
  AdaptiveAvgPool2DBuilder builder_(_fbb);
  builder_.add_data_type(data_type);
  builder_.add_out_w(out_w);
  builder_.add_out_h(out_h);
  return builder_.Finish();
}

flatbuffers::Offset<AdaptiveAvgPool2D> CreateAdaptiveAvgPool2D(flatbuffers::FlatBufferBuilder &_fbb, const AdaptiveAvgPool2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LayerNormT : public flatbuffers::NativeTable {
  typedef LayerNorm TableType;
  std::vector<int32_t> axis{};
  float epsilon = 0.0f;
  std::vector<float> gamma{};
  std::vector<float> beta{};
  int32_t group = 1;
  bool elmentwise_affine = true;
};

struct LayerNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LayerNormT NativeTableType;
  typedef LayerNormBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LayerNormTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_EPSILON = 6,
    VT_GAMMA = 8,
    VT_BETA = 10,
    VT_GROUP = 12,
    VT_ELMENTWISE_AFFINE = 14
  };
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.0f);
  }
  const flatbuffers::Vector<float> *gamma() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_GAMMA);
  }
  const flatbuffers::Vector<float> *beta() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BETA);
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 1);
  }
  bool elmentwise_affine() const {
    return GetField<uint8_t>(VT_ELMENTWISE_AFFINE, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           VerifyField<float>(verifier, VT_EPSILON, 4) &&
           VerifyOffset(verifier, VT_GAMMA) &&
           verifier.VerifyVector(gamma()) &&
           VerifyOffset(verifier, VT_BETA) &&
           verifier.VerifyVector(beta()) &&
           VerifyField<int32_t>(verifier, VT_GROUP, 4) &&
           VerifyField<uint8_t>(verifier, VT_ELMENTWISE_AFFINE, 1) &&
           verifier.EndTable();
  }
  LayerNormT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LayerNormT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LayerNorm> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LayerNormBuilder {
  typedef LayerNorm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(LayerNorm::VT_AXIS, axis);
  }
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(LayerNorm::VT_EPSILON, epsilon, 0.0f);
  }
  void add_gamma(flatbuffers::Offset<flatbuffers::Vector<float>> gamma) {
    fbb_.AddOffset(LayerNorm::VT_GAMMA, gamma);
  }
  void add_beta(flatbuffers::Offset<flatbuffers::Vector<float>> beta) {
    fbb_.AddOffset(LayerNorm::VT_BETA, beta);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(LayerNorm::VT_GROUP, group, 1);
  }
  void add_elmentwise_affine(bool elmentwise_affine) {
    fbb_.AddElement<uint8_t>(LayerNorm::VT_ELMENTWISE_AFFINE, static_cast<uint8_t>(elmentwise_affine), 1);
  }
  explicit LayerNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LayerNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LayerNorm>(end);
    return o;
  }
};

inline flatbuffers::Offset<LayerNorm> CreateLayerNorm(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0,
    float epsilon = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<float>> gamma = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> beta = 0,
    int32_t group = 1,
    bool elmentwise_affine = true) {
  LayerNormBuilder builder_(_fbb);
  builder_.add_group(group);
  builder_.add_beta(beta);
  builder_.add_gamma(gamma);
  builder_.add_epsilon(epsilon);
  builder_.add_axis(axis);
  builder_.add_elmentwise_affine(elmentwise_affine);
  return builder_.Finish();
}

inline flatbuffers::Offset<LayerNorm> CreateLayerNormDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr,
    float epsilon = 0.0f,
    const std::vector<float> *gamma = nullptr,
    const std::vector<float> *beta = nullptr,
    int32_t group = 1,
    bool elmentwise_affine = true) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  auto gamma__ = gamma ? _fbb.CreateVector<float>(*gamma) : 0;
  auto beta__ = beta ? _fbb.CreateVector<float>(*beta) : 0;
  return wnn::CreateLayerNorm(
      _fbb,
      axis__,
      epsilon,
      gamma__,
      beta__,
      group,
      elmentwise_affine);
}

flatbuffers::Offset<LayerNorm> CreateLayerNorm(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchNormT : public flatbuffers::NativeTable {
  typedef BatchNorm TableType;
  int32_t channels = 0;
  std::vector<float> slope_data{};
  std::vector<float> mean_data{};
  std::vector<float> var_data{};
  std::vector<float> bias_data{};
  std::vector<float> a_data{};
  std::vector<float> b_data{};
  float epsilon = 0.001f;
};

struct BatchNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchNormT NativeTableType;
  typedef BatchNormBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BatchNormTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHANNELS = 4,
    VT_SLOPE_DATA = 6,
    VT_MEAN_DATA = 8,
    VT_VAR_DATA = 10,
    VT_BIAS_DATA = 12,
    VT_A_DATA = 14,
    VT_B_DATA = 16,
    VT_EPSILON = 18
  };
  int32_t channels() const {
    return GetField<int32_t>(VT_CHANNELS, 0);
  }
  const flatbuffers::Vector<float> *slope_data() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SLOPE_DATA);
  }
  const flatbuffers::Vector<float> *mean_data() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MEAN_DATA);
  }
  const flatbuffers::Vector<float> *var_data() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VAR_DATA);
  }
  const flatbuffers::Vector<float> *bias_data() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BIAS_DATA);
  }
  const flatbuffers::Vector<float> *a_data() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_A_DATA);
  }
  const flatbuffers::Vector<float> *b_data() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_B_DATA);
  }
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.001f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHANNELS, 4) &&
           VerifyOffset(verifier, VT_SLOPE_DATA) &&
           verifier.VerifyVector(slope_data()) &&
           VerifyOffset(verifier, VT_MEAN_DATA) &&
           verifier.VerifyVector(mean_data()) &&
           VerifyOffset(verifier, VT_VAR_DATA) &&
           verifier.VerifyVector(var_data()) &&
           VerifyOffset(verifier, VT_BIAS_DATA) &&
           verifier.VerifyVector(bias_data()) &&
           VerifyOffset(verifier, VT_A_DATA) &&
           verifier.VerifyVector(a_data()) &&
           VerifyOffset(verifier, VT_B_DATA) &&
           verifier.VerifyVector(b_data()) &&
           VerifyField<float>(verifier, VT_EPSILON, 4) &&
           verifier.EndTable();
  }
  BatchNormT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchNormT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchNorm> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchNormBuilder {
  typedef BatchNorm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channels(int32_t channels) {
    fbb_.AddElement<int32_t>(BatchNorm::VT_CHANNELS, channels, 0);
  }
  void add_slope_data(flatbuffers::Offset<flatbuffers::Vector<float>> slope_data) {
    fbb_.AddOffset(BatchNorm::VT_SLOPE_DATA, slope_data);
  }
  void add_mean_data(flatbuffers::Offset<flatbuffers::Vector<float>> mean_data) {
    fbb_.AddOffset(BatchNorm::VT_MEAN_DATA, mean_data);
  }
  void add_var_data(flatbuffers::Offset<flatbuffers::Vector<float>> var_data) {
    fbb_.AddOffset(BatchNorm::VT_VAR_DATA, var_data);
  }
  void add_bias_data(flatbuffers::Offset<flatbuffers::Vector<float>> bias_data) {
    fbb_.AddOffset(BatchNorm::VT_BIAS_DATA, bias_data);
  }
  void add_a_data(flatbuffers::Offset<flatbuffers::Vector<float>> a_data) {
    fbb_.AddOffset(BatchNorm::VT_A_DATA, a_data);
  }
  void add_b_data(flatbuffers::Offset<flatbuffers::Vector<float>> b_data) {
    fbb_.AddOffset(BatchNorm::VT_B_DATA, b_data);
  }
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(BatchNorm::VT_EPSILON, epsilon, 0.001f);
  }
  explicit BatchNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BatchNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchNorm>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchNorm> CreateBatchNorm(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t channels = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> slope_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> mean_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> var_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bias_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> a_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> b_data = 0,
    float epsilon = 0.001f) {
  BatchNormBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  builder_.add_b_data(b_data);
  builder_.add_a_data(a_data);
  builder_.add_bias_data(bias_data);
  builder_.add_var_data(var_data);
  builder_.add_mean_data(mean_data);
  builder_.add_slope_data(slope_data);
  builder_.add_channels(channels);
  return builder_.Finish();
}

inline flatbuffers::Offset<BatchNorm> CreateBatchNormDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t channels = 0,
    const std::vector<float> *slope_data = nullptr,
    const std::vector<float> *mean_data = nullptr,
    const std::vector<float> *var_data = nullptr,
    const std::vector<float> *bias_data = nullptr,
    const std::vector<float> *a_data = nullptr,
    const std::vector<float> *b_data = nullptr,
    float epsilon = 0.001f) {
  auto slope_data__ = slope_data ? _fbb.CreateVector<float>(*slope_data) : 0;
  auto mean_data__ = mean_data ? _fbb.CreateVector<float>(*mean_data) : 0;
  auto var_data__ = var_data ? _fbb.CreateVector<float>(*var_data) : 0;
  auto bias_data__ = bias_data ? _fbb.CreateVector<float>(*bias_data) : 0;
  auto a_data__ = a_data ? _fbb.CreateVector<float>(*a_data) : 0;
  auto b_data__ = b_data ? _fbb.CreateVector<float>(*b_data) : 0;
  return wnn::CreateBatchNorm(
      _fbb,
      channels,
      slope_data__,
      mean_data__,
      var_data__,
      bias_data__,
      a_data__,
      b_data__,
      epsilon);
}

flatbuffers::Offset<BatchNorm> CreateBatchNorm(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReluT : public flatbuffers::NativeTable {
  typedef Relu TableType;
  float slope = 0.0f;
};

struct Relu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReluT NativeTableType;
  typedef ReluBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReluTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SLOPE = 4
  };
  float slope() const {
    return GetField<float>(VT_SLOPE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SLOPE, 4) &&
           verifier.EndTable();
  }
  ReluT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReluT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Relu> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReluT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReluBuilder {
  typedef Relu Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slope(float slope) {
    fbb_.AddElement<float>(Relu::VT_SLOPE, slope, 0.0f);
  }
  explicit ReluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Relu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Relu>(end);
    return o;
  }
};

inline flatbuffers::Offset<Relu> CreateRelu(
    flatbuffers::FlatBufferBuilder &_fbb,
    float slope = 0.0f) {
  ReluBuilder builder_(_fbb);
  builder_.add_slope(slope);
  return builder_.Finish();
}

flatbuffers::Offset<Relu> CreateRelu(flatbuffers::FlatBufferBuilder &_fbb, const ReluT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Relu6T : public flatbuffers::NativeTable {
  typedef Relu6 TableType;
  float min_value = 0.0f;
  float max_value = 6.0f;
};

struct Relu6 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Relu6T NativeTableType;
  typedef Relu6Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Relu6TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN_VALUE = 4,
    VT_MAX_VALUE = 6
  };
  float min_value() const {
    return GetField<float>(VT_MIN_VALUE, 0.0f);
  }
  float max_value() const {
    return GetField<float>(VT_MAX_VALUE, 6.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MIN_VALUE, 4) &&
           VerifyField<float>(verifier, VT_MAX_VALUE, 4) &&
           verifier.EndTable();
  }
  Relu6T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Relu6T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Relu6> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Relu6T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Relu6Builder {
  typedef Relu6 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min_value(float min_value) {
    fbb_.AddElement<float>(Relu6::VT_MIN_VALUE, min_value, 0.0f);
  }
  void add_max_value(float max_value) {
    fbb_.AddElement<float>(Relu6::VT_MAX_VALUE, max_value, 6.0f);
  }
  explicit Relu6Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Relu6> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Relu6>(end);
    return o;
  }
};

inline flatbuffers::Offset<Relu6> CreateRelu6(
    flatbuffers::FlatBufferBuilder &_fbb,
    float min_value = 0.0f,
    float max_value = 6.0f) {
  Relu6Builder builder_(_fbb);
  builder_.add_max_value(max_value);
  builder_.add_min_value(min_value);
  return builder_.Finish();
}

flatbuffers::Offset<Relu6> CreateRelu6(flatbuffers::FlatBufferBuilder &_fbb, const Relu6T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SoftmaxT : public flatbuffers::NativeTable {
  typedef Softmax TableType;
  int32_t dim = 1;
};

struct Softmax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SoftmaxT NativeTableType;
  typedef SoftmaxBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SoftmaxTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM = 4
  };
  int32_t dim() const {
    return GetField<int32_t>(VT_DIM, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DIM, 4) &&
           verifier.EndTable();
  }
  SoftmaxT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SoftmaxT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Softmax> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SoftmaxBuilder {
  typedef Softmax Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dim(int32_t dim) {
    fbb_.AddElement<int32_t>(Softmax::VT_DIM, dim, 1);
  }
  explicit SoftmaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Softmax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Softmax>(end);
    return o;
  }
};

inline flatbuffers::Offset<Softmax> CreateSoftmax(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t dim = 1) {
  SoftmaxBuilder builder_(_fbb);
  builder_.add_dim(dim);
  return builder_.Finish();
}

flatbuffers::Offset<Softmax> CreateSoftmax(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PReluT : public flatbuffers::NativeTable {
  typedef PRelu TableType;
  int32_t slope_count = 0;
  std::vector<float> slope{};
};

struct PRelu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PReluT NativeTableType;
  typedef PReluBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PReluTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SLOPE_COUNT = 4,
    VT_SLOPE = 6
  };
  int32_t slope_count() const {
    return GetField<int32_t>(VT_SLOPE_COUNT, 0);
  }
  const flatbuffers::Vector<float> *slope() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SLOPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SLOPE_COUNT, 4) &&
           VerifyOffset(verifier, VT_SLOPE) &&
           verifier.VerifyVector(slope()) &&
           verifier.EndTable();
  }
  PReluT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PReluT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PRelu> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PReluT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PReluBuilder {
  typedef PRelu Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slope_count(int32_t slope_count) {
    fbb_.AddElement<int32_t>(PRelu::VT_SLOPE_COUNT, slope_count, 0);
  }
  void add_slope(flatbuffers::Offset<flatbuffers::Vector<float>> slope) {
    fbb_.AddOffset(PRelu::VT_SLOPE, slope);
  }
  explicit PReluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PRelu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PRelu>(end);
    return o;
  }
};

inline flatbuffers::Offset<PRelu> CreatePRelu(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t slope_count = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> slope = 0) {
  PReluBuilder builder_(_fbb);
  builder_.add_slope(slope);
  builder_.add_slope_count(slope_count);
  return builder_.Finish();
}

inline flatbuffers::Offset<PRelu> CreatePReluDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t slope_count = 0,
    const std::vector<float> *slope = nullptr) {
  auto slope__ = slope ? _fbb.CreateVector<float>(*slope) : 0;
  return wnn::CreatePRelu(
      _fbb,
      slope_count,
      slope__);
}

flatbuffers::Offset<PRelu> CreatePRelu(flatbuffers::FlatBufferBuilder &_fbb, const PReluT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ELUT : public flatbuffers::NativeTable {
  typedef ELU TableType;
  float alpha = 0.0f;
};

struct ELU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ELUT NativeTableType;
  typedef ELUBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ELUTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA, 4) &&
           verifier.EndTable();
  }
  ELUT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ELUT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ELU> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ELUT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ELUBuilder {
  typedef ELU Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(ELU::VT_ALPHA, alpha, 0.0f);
  }
  explicit ELUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ELU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ELU>(end);
    return o;
  }
};

inline flatbuffers::Offset<ELU> CreateELU(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0f) {
  ELUBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

flatbuffers::Offset<ELU> CreateELU(flatbuffers::FlatBufferBuilder &_fbb, const ELUT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LRNT : public flatbuffers::NativeTable {
  typedef LRN TableType;
  int32_t region_type = 0;
  int32_t local_size = 0;
  float alpha = 0.0f;
  float beta = 0.0f;
  float bias = 1.0f;
};

struct LRN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LRNT NativeTableType;
  typedef LRNBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LRNTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REGION_TYPE = 4,
    VT_LOCAL_SIZE = 6,
    VT_ALPHA = 8,
    VT_BETA = 10,
    VT_BIAS = 12
  };
  int32_t region_type() const {
    return GetField<int32_t>(VT_REGION_TYPE, 0);
  }
  int32_t local_size() const {
    return GetField<int32_t>(VT_LOCAL_SIZE, 0);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REGION_TYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_LOCAL_SIZE, 4) &&
           VerifyField<float>(verifier, VT_ALPHA, 4) &&
           VerifyField<float>(verifier, VT_BETA, 4) &&
           VerifyField<float>(verifier, VT_BIAS, 4) &&
           verifier.EndTable();
  }
  LRNT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LRNT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LRN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LRNT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LRNBuilder {
  typedef LRN Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_region_type(int32_t region_type) {
    fbb_.AddElement<int32_t>(LRN::VT_REGION_TYPE, region_type, 0);
  }
  void add_local_size(int32_t local_size) {
    fbb_.AddElement<int32_t>(LRN::VT_LOCAL_SIZE, local_size, 0);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LRN::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(LRN::VT_BETA, beta, 0.0f);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(LRN::VT_BIAS, bias, 1.0f);
  }
  explicit LRNBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LRN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LRN>(end);
    return o;
  }
};

inline flatbuffers::Offset<LRN> CreateLRN(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t region_type = 0,
    int32_t local_size = 0,
    float alpha = 0.0f,
    float beta = 0.0f,
    float bias = 1.0f) {
  LRNBuilder builder_(_fbb);
  builder_.add_bias(bias);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_local_size(local_size);
  builder_.add_region_type(region_type);
  return builder_.Finish();
}

flatbuffers::Offset<LRN> CreateLRN(flatbuffers::FlatBufferBuilder &_fbb, const LRNT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FCT : public flatbuffers::NativeTable {
  typedef FC TableType;
  int32_t in_features = 0;
  int32_t out_features = 0;
  int32_t weight_size = 0;
  std::vector<float> weights{};
  std::vector<float> bias{};
  int32_t axis = 0;
  bool transpose = false;
  bool has_act = false;
  wnn::OpType act_type = wnn::OpType_argmax;
  std::vector<float> act_params{};
  std::unique_ptr<wnn::QuantT> quant_param{};
  FCT() = default;
  FCT(const FCT &o);
  FCT(FCT&&) FLATBUFFERS_NOEXCEPT = default;
  FCT &operator=(FCT o) FLATBUFFERS_NOEXCEPT;
};

struct FC FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FCT NativeTableType;
  typedef FCBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FCTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IN_FEATURES = 4,
    VT_OUT_FEATURES = 6,
    VT_WEIGHT_SIZE = 8,
    VT_WEIGHTS = 10,
    VT_BIAS = 12,
    VT_AXIS = 14,
    VT_TRANSPOSE = 16,
    VT_HAS_ACT = 18,
    VT_ACT_TYPE = 20,
    VT_ACT_PARAMS = 22,
    VT_QUANT_PARAM = 24
  };
  int32_t in_features() const {
    return GetField<int32_t>(VT_IN_FEATURES, 0);
  }
  int32_t out_features() const {
    return GetField<int32_t>(VT_OUT_FEATURES, 0);
  }
  int32_t weight_size() const {
    return GetField<int32_t>(VT_WEIGHT_SIZE, 0);
  }
  const flatbuffers::Vector<float> *weights() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_WEIGHTS);
  }
  const flatbuffers::Vector<float> *bias() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BIAS);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool transpose() const {
    return GetField<uint8_t>(VT_TRANSPOSE, 0) != 0;
  }
  bool has_act() const {
    return GetField<uint8_t>(VT_HAS_ACT, 0) != 0;
  }
  wnn::OpType act_type() const {
    return static_cast<wnn::OpType>(GetField<int32_t>(VT_ACT_TYPE, 0));
  }
  const flatbuffers::Vector<float> *act_params() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ACT_PARAMS);
  }
  const wnn::Quant *quant_param() const {
    return GetPointer<const wnn::Quant *>(VT_QUANT_PARAM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_IN_FEATURES, 4) &&
           VerifyField<int32_t>(verifier, VT_OUT_FEATURES, 4) &&
           VerifyField<int32_t>(verifier, VT_WEIGHT_SIZE, 4) &&
           VerifyOffset(verifier, VT_WEIGHTS) &&
           verifier.VerifyVector(weights()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyVector(bias()) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSE, 1) &&
           VerifyField<uint8_t>(verifier, VT_HAS_ACT, 1) &&
           VerifyField<int32_t>(verifier, VT_ACT_TYPE, 4) &&
           VerifyOffset(verifier, VT_ACT_PARAMS) &&
           verifier.VerifyVector(act_params()) &&
           VerifyOffset(verifier, VT_QUANT_PARAM) &&
           verifier.VerifyTable(quant_param()) &&
           verifier.EndTable();
  }
  FCT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FCT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FC> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FCT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FCBuilder {
  typedef FC Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_in_features(int32_t in_features) {
    fbb_.AddElement<int32_t>(FC::VT_IN_FEATURES, in_features, 0);
  }
  void add_out_features(int32_t out_features) {
    fbb_.AddElement<int32_t>(FC::VT_OUT_FEATURES, out_features, 0);
  }
  void add_weight_size(int32_t weight_size) {
    fbb_.AddElement<int32_t>(FC::VT_WEIGHT_SIZE, weight_size, 0);
  }
  void add_weights(flatbuffers::Offset<flatbuffers::Vector<float>> weights) {
    fbb_.AddOffset(FC::VT_WEIGHTS, weights);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(FC::VT_BIAS, bias);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(FC::VT_AXIS, axis, 0);
  }
  void add_transpose(bool transpose) {
    fbb_.AddElement<uint8_t>(FC::VT_TRANSPOSE, static_cast<uint8_t>(transpose), 0);
  }
  void add_has_act(bool has_act) {
    fbb_.AddElement<uint8_t>(FC::VT_HAS_ACT, static_cast<uint8_t>(has_act), 0);
  }
  void add_act_type(wnn::OpType act_type) {
    fbb_.AddElement<int32_t>(FC::VT_ACT_TYPE, static_cast<int32_t>(act_type), 0);
  }
  void add_act_params(flatbuffers::Offset<flatbuffers::Vector<float>> act_params) {
    fbb_.AddOffset(FC::VT_ACT_PARAMS, act_params);
  }
  void add_quant_param(flatbuffers::Offset<wnn::Quant> quant_param) {
    fbb_.AddOffset(FC::VT_QUANT_PARAM, quant_param);
  }
  explicit FCBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FC>(end);
    return o;
  }
};

inline flatbuffers::Offset<FC> CreateFC(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t in_features = 0,
    int32_t out_features = 0,
    int32_t weight_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> weights = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bias = 0,
    int32_t axis = 0,
    bool transpose = false,
    bool has_act = false,
    wnn::OpType act_type = wnn::OpType_argmax,
    flatbuffers::Offset<flatbuffers::Vector<float>> act_params = 0,
    flatbuffers::Offset<wnn::Quant> quant_param = 0) {
  FCBuilder builder_(_fbb);
  builder_.add_quant_param(quant_param);
  builder_.add_act_params(act_params);
  builder_.add_act_type(act_type);
  builder_.add_axis(axis);
  builder_.add_bias(bias);
  builder_.add_weights(weights);
  builder_.add_weight_size(weight_size);
  builder_.add_out_features(out_features);
  builder_.add_in_features(in_features);
  builder_.add_has_act(has_act);
  builder_.add_transpose(transpose);
  return builder_.Finish();
}

inline flatbuffers::Offset<FC> CreateFCDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t in_features = 0,
    int32_t out_features = 0,
    int32_t weight_size = 0,
    const std::vector<float> *weights = nullptr,
    const std::vector<float> *bias = nullptr,
    int32_t axis = 0,
    bool transpose = false,
    bool has_act = false,
    wnn::OpType act_type = wnn::OpType_argmax,
    const std::vector<float> *act_params = nullptr,
    flatbuffers::Offset<wnn::Quant> quant_param = 0) {
  auto weights__ = weights ? _fbb.CreateVector<float>(*weights) : 0;
  auto bias__ = bias ? _fbb.CreateVector<float>(*bias) : 0;
  auto act_params__ = act_params ? _fbb.CreateVector<float>(*act_params) : 0;
  return wnn::CreateFC(
      _fbb,
      in_features,
      out_features,
      weight_size,
      weights__,
      bias__,
      axis,
      transpose,
      has_act,
      act_type,
      act_params__,
      quant_param);
}

flatbuffers::Offset<FC> CreateFC(flatbuffers::FlatBufferBuilder &_fbb, const FCT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InputT : public flatbuffers::NativeTable {
  typedef Input TableType;
  std::vector<int32_t> dims{};
  wnn::DataType dtype = wnn::DataType_DT_FLOAT;
  wnn::WNN_DATA_FORMAT dformat = wnn::WNN_DATA_FORMAT_NCHW;
};

struct Input FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InputT NativeTableType;
  typedef InputBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InputTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMS = 4,
    VT_DTYPE = 6,
    VT_DFORMAT = 8
  };
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  wnn::DataType dtype() const {
    return static_cast<wnn::DataType>(GetField<int32_t>(VT_DTYPE, 1));
  }
  wnn::WNN_DATA_FORMAT dformat() const {
    return static_cast<wnn::WNN_DATA_FORMAT>(GetField<int8_t>(VT_DFORMAT, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int32_t>(verifier, VT_DTYPE, 4) &&
           VerifyField<int8_t>(verifier, VT_DFORMAT, 1) &&
           verifier.EndTable();
  }
  InputT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InputT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Input> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InputBuilder {
  typedef Input Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(Input::VT_DIMS, dims);
  }
  void add_dtype(wnn::DataType dtype) {
    fbb_.AddElement<int32_t>(Input::VT_DTYPE, static_cast<int32_t>(dtype), 1);
  }
  void add_dformat(wnn::WNN_DATA_FORMAT dformat) {
    fbb_.AddElement<int8_t>(Input::VT_DFORMAT, static_cast<int8_t>(dformat), 0);
  }
  explicit InputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Input> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Input>(end);
    return o;
  }
};

inline flatbuffers::Offset<Input> CreateInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0,
    wnn::DataType dtype = wnn::DataType_DT_FLOAT,
    wnn::WNN_DATA_FORMAT dformat = wnn::WNN_DATA_FORMAT_NCHW) {
  InputBuilder builder_(_fbb);
  builder_.add_dtype(dtype);
  builder_.add_dims(dims);
  builder_.add_dformat(dformat);
  return builder_.Finish();
}

inline flatbuffers::Offset<Input> CreateInputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dims = nullptr,
    wnn::DataType dtype = wnn::DataType_DT_FLOAT,
    wnn::WNN_DATA_FORMAT dformat = wnn::WNN_DATA_FORMAT_NCHW) {
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  return wnn::CreateInput(
      _fbb,
      dims__,
      dtype,
      dformat);
}

flatbuffers::Offset<Input> CreateInput(flatbuffers::FlatBufferBuilder &_fbb, const InputT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMaxT : public flatbuffers::NativeTable {
  typedef ArgMax TableType;
  int32_t out_max_val = 0;
  int32_t top_k = 0;
  int32_t axis = 0;
  int32_t softmax_thresh = 0;
};

struct ArgMax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArgMaxT NativeTableType;
  typedef ArgMaxBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ArgMaxTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUT_MAX_VAL = 4,
    VT_TOP_K = 6,
    VT_AXIS = 8,
    VT_SOFTMAX_THRESH = 10
  };
  int32_t out_max_val() const {
    return GetField<int32_t>(VT_OUT_MAX_VAL, 0);
  }
  int32_t top_k() const {
    return GetField<int32_t>(VT_TOP_K, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  int32_t softmax_thresh() const {
    return GetField<int32_t>(VT_SOFTMAX_THRESH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OUT_MAX_VAL, 4) &&
           VerifyField<int32_t>(verifier, VT_TOP_K, 4) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyField<int32_t>(verifier, VT_SOFTMAX_THRESH, 4) &&
           verifier.EndTable();
  }
  ArgMaxT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArgMaxT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ArgMax> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMaxBuilder {
  typedef ArgMax Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_out_max_val(int32_t out_max_val) {
    fbb_.AddElement<int32_t>(ArgMax::VT_OUT_MAX_VAL, out_max_val, 0);
  }
  void add_top_k(int32_t top_k) {
    fbb_.AddElement<int32_t>(ArgMax::VT_TOP_K, top_k, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ArgMax::VT_AXIS, axis, 0);
  }
  void add_softmax_thresh(int32_t softmax_thresh) {
    fbb_.AddElement<int32_t>(ArgMax::VT_SOFTMAX_THRESH, softmax_thresh, 0);
  }
  explicit ArgMaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArgMax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMax>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMax> CreateArgMax(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t out_max_val = 0,
    int32_t top_k = 0,
    int32_t axis = 0,
    int32_t softmax_thresh = 0) {
  ArgMaxBuilder builder_(_fbb);
  builder_.add_softmax_thresh(softmax_thresh);
  builder_.add_axis(axis);
  builder_.add_top_k(top_k);
  builder_.add_out_max_val(out_max_val);
  return builder_.Finish();
}

flatbuffers::Offset<ArgMax> CreateArgMax(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BinaryT : public flatbuffers::NativeTable {
  typedef Binary TableType;
  wnn::BinaryOperation operation_type = wnn::BinaryOperation_ADD;
  wnn::DataType dtype = wnn::DataType_DT_FLOAT;
};

struct Binary FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BinaryT NativeTableType;
  typedef BinaryBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BinaryTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPERATION_TYPE = 4,
    VT_DTYPE = 6
  };
  wnn::BinaryOperation operation_type() const {
    return static_cast<wnn::BinaryOperation>(GetField<int8_t>(VT_OPERATION_TYPE, 0));
  }
  wnn::DataType dtype() const {
    return static_cast<wnn::DataType>(GetField<int32_t>(VT_DTYPE, 1));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OPERATION_TYPE, 1) &&
           VerifyField<int32_t>(verifier, VT_DTYPE, 4) &&
           verifier.EndTable();
  }
  BinaryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BinaryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Binary> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BinaryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BinaryBuilder {
  typedef Binary Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_operation_type(wnn::BinaryOperation operation_type) {
    fbb_.AddElement<int8_t>(Binary::VT_OPERATION_TYPE, static_cast<int8_t>(operation_type), 0);
  }
  void add_dtype(wnn::DataType dtype) {
    fbb_.AddElement<int32_t>(Binary::VT_DTYPE, static_cast<int32_t>(dtype), 1);
  }
  explicit BinaryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Binary> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Binary>(end);
    return o;
  }
};

inline flatbuffers::Offset<Binary> CreateBinary(
    flatbuffers::FlatBufferBuilder &_fbb,
    wnn::BinaryOperation operation_type = wnn::BinaryOperation_ADD,
    wnn::DataType dtype = wnn::DataType_DT_FLOAT) {
  BinaryBuilder builder_(_fbb);
  builder_.add_dtype(dtype);
  builder_.add_operation_type(operation_type);
  return builder_.Finish();
}

flatbuffers::Offset<Binary> CreateBinary(flatbuffers::FlatBufferBuilder &_fbb, const BinaryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnaryT : public flatbuffers::NativeTable {
  typedef Unary TableType;
  wnn::UnaryOperation operation_type = wnn::UnaryOperation_ABS;
  wnn::DataType dtype = wnn::DataType_DT_INVALID;
};

struct Unary FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnaryT NativeTableType;
  typedef UnaryBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UnaryTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPERATION_TYPE = 4,
    VT_DTYPE = 6
  };
  wnn::UnaryOperation operation_type() const {
    return static_cast<wnn::UnaryOperation>(GetField<int32_t>(VT_OPERATION_TYPE, 0));
  }
  wnn::DataType dtype() const {
    return static_cast<wnn::DataType>(GetField<int32_t>(VT_DTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OPERATION_TYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_DTYPE, 4) &&
           verifier.EndTable();
  }
  UnaryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnaryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Unary> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnaryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnaryBuilder {
  typedef Unary Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_operation_type(wnn::UnaryOperation operation_type) {
    fbb_.AddElement<int32_t>(Unary::VT_OPERATION_TYPE, static_cast<int32_t>(operation_type), 0);
  }
  void add_dtype(wnn::DataType dtype) {
    fbb_.AddElement<int32_t>(Unary::VT_DTYPE, static_cast<int32_t>(dtype), 0);
  }
  explicit UnaryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Unary> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Unary>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unary> CreateUnary(
    flatbuffers::FlatBufferBuilder &_fbb,
    wnn::UnaryOperation operation_type = wnn::UnaryOperation_ABS,
    wnn::DataType dtype = wnn::DataType_DT_INVALID) {
  UnaryBuilder builder_(_fbb);
  builder_.add_dtype(dtype);
  builder_.add_operation_type(operation_type);
  return builder_.Finish();
}

flatbuffers::Offset<Unary> CreateUnary(flatbuffers::FlatBufferBuilder &_fbb, const UnaryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EltwiseT : public flatbuffers::NativeTable {
  typedef Eltwise TableType;
  wnn::EltwiseType type = wnn::EltwiseType_PROD;
  std::vector<float> coeff{};
};

struct Eltwise FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EltwiseT NativeTableType;
  typedef EltwiseBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EltwiseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_COEFF = 6
  };
  wnn::EltwiseType type() const {
    return static_cast<wnn::EltwiseType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<float> *coeff() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_COEFF);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_COEFF) &&
           verifier.VerifyVector(coeff()) &&
           verifier.EndTable();
  }
  EltwiseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EltwiseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Eltwise> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EltwiseBuilder {
  typedef Eltwise Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(wnn::EltwiseType type) {
    fbb_.AddElement<int8_t>(Eltwise::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_coeff(flatbuffers::Offset<flatbuffers::Vector<float>> coeff) {
    fbb_.AddOffset(Eltwise::VT_COEFF, coeff);
  }
  explicit EltwiseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Eltwise> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Eltwise>(end);
    return o;
  }
};

inline flatbuffers::Offset<Eltwise> CreateEltwise(
    flatbuffers::FlatBufferBuilder &_fbb,
    wnn::EltwiseType type = wnn::EltwiseType_PROD,
    flatbuffers::Offset<flatbuffers::Vector<float>> coeff = 0) {
  EltwiseBuilder builder_(_fbb);
  builder_.add_coeff(coeff);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Eltwise> CreateEltwiseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    wnn::EltwiseType type = wnn::EltwiseType_PROD,
    const std::vector<float> *coeff = nullptr) {
  auto coeff__ = coeff ? _fbb.CreateVector<float>(*coeff) : 0;
  return wnn::CreateEltwise(
      _fbb,
      type,
      coeff__);
}

flatbuffers::Offset<Eltwise> CreateEltwise(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReductionT : public flatbuffers::NativeTable {
  typedef Reduction TableType;
  wnn::ReductionType operation = wnn::ReductionType_SUM;
  std::vector<int32_t> dim{};
  float coeff = 0.0f;
  bool keep_dims = false;
  wnn::DataType dtype = wnn::DataType_DT_FLOAT;
};

struct Reduction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReductionT NativeTableType;
  typedef ReductionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReductionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPERATION = 4,
    VT_DIM = 6,
    VT_COEFF = 8,
    VT_KEEP_DIMS = 10,
    VT_DTYPE = 12
  };
  wnn::ReductionType operation() const {
    return static_cast<wnn::ReductionType>(GetField<int8_t>(VT_OPERATION, 0));
  }
  const flatbuffers::Vector<int32_t> *dim() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIM);
  }
  float coeff() const {
    return GetField<float>(VT_COEFF, 0.0f);
  }
  bool keep_dims() const {
    return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;
  }
  wnn::DataType dtype() const {
    return static_cast<wnn::DataType>(GetField<int32_t>(VT_DTYPE, 1));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OPERATION, 1) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyVector(dim()) &&
           VerifyField<float>(verifier, VT_COEFF, 4) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_DIMS, 1) &&
           VerifyField<int32_t>(verifier, VT_DTYPE, 4) &&
           verifier.EndTable();
  }
  ReductionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReductionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reduction> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReductionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReductionBuilder {
  typedef Reduction Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_operation(wnn::ReductionType operation) {
    fbb_.AddElement<int8_t>(Reduction::VT_OPERATION, static_cast<int8_t>(operation), 0);
  }
  void add_dim(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dim) {
    fbb_.AddOffset(Reduction::VT_DIM, dim);
  }
  void add_coeff(float coeff) {
    fbb_.AddElement<float>(Reduction::VT_COEFF, coeff, 0.0f);
  }
  void add_keep_dims(bool keep_dims) {
    fbb_.AddElement<uint8_t>(Reduction::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
  }
  void add_dtype(wnn::DataType dtype) {
    fbb_.AddElement<int32_t>(Reduction::VT_DTYPE, static_cast<int32_t>(dtype), 1);
  }
  explicit ReductionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Reduction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reduction>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reduction> CreateReduction(
    flatbuffers::FlatBufferBuilder &_fbb,
    wnn::ReductionType operation = wnn::ReductionType_SUM,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dim = 0,
    float coeff = 0.0f,
    bool keep_dims = false,
    wnn::DataType dtype = wnn::DataType_DT_FLOAT) {
  ReductionBuilder builder_(_fbb);
  builder_.add_dtype(dtype);
  builder_.add_coeff(coeff);
  builder_.add_dim(dim);
  builder_.add_keep_dims(keep_dims);
  builder_.add_operation(operation);
  return builder_.Finish();
}

inline flatbuffers::Offset<Reduction> CreateReductionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    wnn::ReductionType operation = wnn::ReductionType_SUM,
    const std::vector<int32_t> *dim = nullptr,
    float coeff = 0.0f,
    bool keep_dims = false,
    wnn::DataType dtype = wnn::DataType_DT_FLOAT) {
  auto dim__ = dim ? _fbb.CreateVector<int32_t>(*dim) : 0;
  return wnn::CreateReduction(
      _fbb,
      operation,
      dim__,
      coeff,
      keep_dims,
      dtype);
}

flatbuffers::Offset<Reduction> CreateReduction(flatbuffers::FlatBufferBuilder &_fbb, const ReductionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SqueezeT : public flatbuffers::NativeTable {
  typedef Squeeze TableType;
  std::vector<int32_t> squeeze_dims{};
};

struct Squeeze FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SqueezeT NativeTableType;
  typedef SqueezeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SqueezeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SQUEEZE_DIMS = 4
  };
  const flatbuffers::Vector<int32_t> *squeeze_dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SQUEEZE_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SQUEEZE_DIMS) &&
           verifier.VerifyVector(squeeze_dims()) &&
           verifier.EndTable();
  }
  SqueezeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SqueezeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Squeeze> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SqueezeBuilder {
  typedef Squeeze Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_squeeze_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeeze_dims) {
    fbb_.AddOffset(Squeeze::VT_SQUEEZE_DIMS, squeeze_dims);
  }
  explicit SqueezeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Squeeze> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Squeeze>(end);
    return o;
  }
};

inline flatbuffers::Offset<Squeeze> CreateSqueeze(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeeze_dims = 0) {
  SqueezeBuilder builder_(_fbb);
  builder_.add_squeeze_dims(squeeze_dims);
  return builder_.Finish();
}

inline flatbuffers::Offset<Squeeze> CreateSqueezeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *squeeze_dims = nullptr) {
  auto squeeze_dims__ = squeeze_dims ? _fbb.CreateVector<int32_t>(*squeeze_dims) : 0;
  return wnn::CreateSqueeze(
      _fbb,
      squeeze_dims__);
}

flatbuffers::Offset<Squeeze> CreateSqueeze(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GatherT : public flatbuffers::NativeTable {
  typedef Gather TableType;
  wnn::DataType indices_dtype = wnn::DataType_DT_INVALID;
  wnn::DataType dtype = wnn::DataType_DT_INVALID;
  bool validateindices = false;
  int32_t axis = 0;
};

struct Gather FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GatherT NativeTableType;
  typedef GatherBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GatherTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDICES_DTYPE = 4,
    VT_DTYPE = 6,
    VT_VALIDATEINDICES = 8,
    VT_AXIS = 10
  };
  wnn::DataType indices_dtype() const {
    return static_cast<wnn::DataType>(GetField<int32_t>(VT_INDICES_DTYPE, 0));
  }
  wnn::DataType dtype() const {
    return static_cast<wnn::DataType>(GetField<int32_t>(VT_DTYPE, 0));
  }
  bool validateindices() const {
    return GetField<uint8_t>(VT_VALIDATEINDICES, 0) != 0;
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDICES_DTYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_DTYPE, 4) &&
           VerifyField<uint8_t>(verifier, VT_VALIDATEINDICES, 1) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
  GatherT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GatherT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Gather> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GatherBuilder {
  typedef Gather Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_indices_dtype(wnn::DataType indices_dtype) {
    fbb_.AddElement<int32_t>(Gather::VT_INDICES_DTYPE, static_cast<int32_t>(indices_dtype), 0);
  }
  void add_dtype(wnn::DataType dtype) {
    fbb_.AddElement<int32_t>(Gather::VT_DTYPE, static_cast<int32_t>(dtype), 0);
  }
  void add_validateindices(bool validateindices) {
    fbb_.AddElement<uint8_t>(Gather::VT_VALIDATEINDICES, static_cast<uint8_t>(validateindices), 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Gather::VT_AXIS, axis, 0);
  }
  explicit GatherBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Gather> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Gather>(end);
    return o;
  }
};

inline flatbuffers::Offset<Gather> CreateGather(
    flatbuffers::FlatBufferBuilder &_fbb,
    wnn::DataType indices_dtype = wnn::DataType_DT_INVALID,
    wnn::DataType dtype = wnn::DataType_DT_INVALID,
    bool validateindices = false,
    int32_t axis = 0) {
  GatherBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_dtype(dtype);
  builder_.add_indices_dtype(indices_dtype);
  builder_.add_validateindices(validateindices);
  return builder_.Finish();
}

flatbuffers::Offset<Gather> CreateGather(flatbuffers::FlatBufferBuilder &_fbb, const GatherT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpandDimsT : public flatbuffers::NativeTable {
  typedef ExpandDims TableType;
  wnn::DataType dtype = wnn::DataType_DT_INVALID;
  wnn::DataType dim_dtype = wnn::DataType_DT_INVALID;
  int32_t axis = 0;
};

struct ExpandDims FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExpandDimsT NativeTableType;
  typedef ExpandDimsBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ExpandDimsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DTYPE = 4,
    VT_DIM_DTYPE = 6,
    VT_AXIS = 8
  };
  wnn::DataType dtype() const {
    return static_cast<wnn::DataType>(GetField<int32_t>(VT_DTYPE, 0));
  }
  wnn::DataType dim_dtype() const {
    return static_cast<wnn::DataType>(GetField<int32_t>(VT_DIM_DTYPE, 0));
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DTYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_DIM_DTYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
  ExpandDimsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpandDimsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExpandDims> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpandDimsBuilder {
  typedef ExpandDims Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dtype(wnn::DataType dtype) {
    fbb_.AddElement<int32_t>(ExpandDims::VT_DTYPE, static_cast<int32_t>(dtype), 0);
  }
  void add_dim_dtype(wnn::DataType dim_dtype) {
    fbb_.AddElement<int32_t>(ExpandDims::VT_DIM_DTYPE, static_cast<int32_t>(dim_dtype), 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ExpandDims::VT_AXIS, axis, 0);
  }
  explicit ExpandDimsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExpandDims> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpandDims>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpandDims> CreateExpandDims(
    flatbuffers::FlatBufferBuilder &_fbb,
    wnn::DataType dtype = wnn::DataType_DT_INVALID,
    wnn::DataType dim_dtype = wnn::DataType_DT_INVALID,
    int32_t axis = 0) {
  ExpandDimsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_dim_dtype(dim_dtype);
  builder_.add_dtype(dtype);
  return builder_.Finish();
}

flatbuffers::Offset<ExpandDims> CreateExpandDims(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlattenT : public flatbuffers::NativeTable {
  typedef Flatten TableType;
  int32_t start_dim = 0;
  int32_t end_dim = 0;
};

struct Flatten FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlattenT NativeTableType;
  typedef FlattenBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FlattenTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START_DIM = 4,
    VT_END_DIM = 6
  };
  int32_t start_dim() const {
    return GetField<int32_t>(VT_START_DIM, 0);
  }
  int32_t end_dim() const {
    return GetField<int32_t>(VT_END_DIM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_START_DIM, 4) &&
           VerifyField<int32_t>(verifier, VT_END_DIM, 4) &&
           verifier.EndTable();
  }
  FlattenT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlattenT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Flatten> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlattenBuilder {
  typedef Flatten Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_start_dim(int32_t start_dim) {
    fbb_.AddElement<int32_t>(Flatten::VT_START_DIM, start_dim, 0);
  }
  void add_end_dim(int32_t end_dim) {
    fbb_.AddElement<int32_t>(Flatten::VT_END_DIM, end_dim, 0);
  }
  explicit FlattenBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Flatten> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Flatten>(end);
    return o;
  }
};

inline flatbuffers::Offset<Flatten> CreateFlatten(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t start_dim = 0,
    int32_t end_dim = 0) {
  FlattenBuilder builder_(_fbb);
  builder_.add_end_dim(end_dim);
  builder_.add_start_dim(start_dim);
  return builder_.Finish();
}

flatbuffers::Offset<Flatten> CreateFlatten(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline Conv2DCommonT *Conv2DCommon::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Conv2DCommonT>(new Conv2DCommonT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Conv2DCommon::UnPackTo(Conv2DCommonT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pad_x(); _o->pad_x = _e; }
  { auto _e = pad_y(); _o->pad_y = _e; }
  { auto _e = kernel_x(); _o->kernel_x = _e; }
  { auto _e = kernel_y(); _o->kernel_y = _e; }
  { auto _e = stride_x(); _o->stride_x = _e; }
  { auto _e = stride_y(); _o->stride_y = _e; }
  { auto _e = dilate_x(); _o->dilate_x = _e; }
  { auto _e = dilate_y(); _o->dilate_y = _e; }
  { auto _e = padmode(); _o->padmode = _e; }
  { auto _e = group(); _o->group = _e; }
  { auto _e = output_count(); _o->output_count = _e; }
  { auto _e = input_count(); _o->input_count = _e; }
  { auto _e = sparse_output_count(); _o->sparse_output_count = _e; }
  { auto _e = in_channels(); _o->in_channels = _e; }
  { auto _e = out_channels(); _o->out_channels = _e; }
  { auto _e = relu(); _o->relu = _e; }
  { auto _e = relu6(); _o->relu6 = _e; }
  { auto _e = pads(); if (_e) { _o->pads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pads[_i] = _e->Get(_i); } } }
  { auto _e = out_pads(); if (_e) { _o->out_pads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->out_pads[_i] = _e->Get(_i); } } }
  { auto _e = has_outputshape(); _o->has_outputshape = _e; }
}

inline flatbuffers::Offset<Conv2DCommon> Conv2DCommon::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DCommonT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConv2DCommon(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Conv2DCommon> CreateConv2DCommon(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DCommonT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv2DCommonT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pad_x = _o->pad_x;
  auto _pad_y = _o->pad_y;
  auto _kernel_x = _o->kernel_x;
  auto _kernel_y = _o->kernel_y;
  auto _stride_x = _o->stride_x;
  auto _stride_y = _o->stride_y;
  auto _dilate_x = _o->dilate_x;
  auto _dilate_y = _o->dilate_y;
  auto _padmode = _o->padmode;
  auto _group = _o->group;
  auto _output_count = _o->output_count;
  auto _input_count = _o->input_count;
  auto _sparse_output_count = _o->sparse_output_count;
  auto _in_channels = _o->in_channels;
  auto _out_channels = _o->out_channels;
  auto _relu = _o->relu;
  auto _relu6 = _o->relu6;
  auto _pads = _o->pads.size() ? _fbb.CreateVector(_o->pads) : 0;
  auto _out_pads = _o->out_pads.size() ? _fbb.CreateVector(_o->out_pads) : 0;
  auto _has_outputshape = _o->has_outputshape;
  return wnn::CreateConv2DCommon(
      _fbb,
      _pad_x,
      _pad_y,
      _kernel_x,
      _kernel_y,
      _stride_x,
      _stride_y,
      _dilate_x,
      _dilate_y,
      _padmode,
      _group,
      _output_count,
      _input_count,
      _sparse_output_count,
      _in_channels,
      _out_channels,
      _relu,
      _relu6,
      _pads,
      _out_pads,
      _has_outputshape);
}

inline Conv2DT::Conv2DT(const Conv2DT &o)
      : common((o.common) ? new wnn::Conv2DCommonT(*o.common) : nullptr),
        weight(o.weight),
        bias(o.bias),
        has_act(o.has_act),
        act_type(o.act_type),
        input_shape(o.input_shape),
        quant_param((o.quant_param) ? new wnn::QuantT(*o.quant_param) : nullptr) {
}

inline Conv2DT &Conv2DT::operator=(Conv2DT o) FLATBUFFERS_NOEXCEPT {
  std::swap(common, o.common);
  std::swap(weight, o.weight);
  std::swap(bias, o.bias);
  std::swap(has_act, o.has_act);
  std::swap(act_type, o.act_type);
  std::swap(input_shape, o.input_shape);
  std::swap(quant_param, o.quant_param);
  return *this;
}

inline Conv2DT *Conv2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Conv2DT>(new Conv2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Conv2D::UnPackTo(Conv2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = common(); if (_e) { if(_o->common) { _e->UnPackTo(_o->common.get(), _resolver); } else { _o->common = std::unique_ptr<wnn::Conv2DCommonT>(_e->UnPack(_resolver)); } } }
  { auto _e = weight(); if (_e) { _o->weight.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weight[_i] = _e->Get(_i); } } }
  { auto _e = bias(); if (_e) { _o->bias.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bias[_i] = _e->Get(_i); } } }
  { auto _e = has_act(); _o->has_act = _e; }
  { auto _e = act_type(); _o->act_type = _e; }
  { auto _e = input_shape(); if (_e) { _o->input_shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->input_shape[_i] = _e->Get(_i); } } }
  { auto _e = quant_param(); if (_e) { if(_o->quant_param) { _e->UnPackTo(_o->quant_param.get(), _resolver); } else { _o->quant_param = std::unique_ptr<wnn::QuantT>(_e->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<Conv2D> Conv2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConv2D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Conv2D> CreateConv2D(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _common = _o->common ? CreateConv2DCommon(_fbb, _o->common.get(), _rehasher) : 0;
  auto _weight = _o->weight.size() ? _fbb.CreateVector(_o->weight) : 0;
  auto _bias = _o->bias.size() ? _fbb.CreateVector(_o->bias) : 0;
  auto _has_act = _o->has_act;
  auto _act_type = _o->act_type;
  auto _input_shape = _o->input_shape.size() ? _fbb.CreateVector(_o->input_shape) : 0;
  auto _quant_param = _o->quant_param ? CreateQuant(_fbb, _o->quant_param.get(), _rehasher) : 0;
  return wnn::CreateConv2D(
      _fbb,
      _common,
      _weight,
      _bias,
      _has_act,
      _act_type,
      _input_shape,
      _quant_param);
}

inline PoolT *Pool::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PoolT>(new PoolT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pool::UnPackTo(PoolT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pad_x(); _o->pad_x = _e; }
  { auto _e = pad_y(); _o->pad_y = _e; }
  { auto _e = is_global(); _o->is_global = _e; }
  { auto _e = kernel_x(); _o->kernel_x = _e; }
  { auto _e = kernel_y(); _o->kernel_y = _e; }
  { auto _e = stride_x(); _o->stride_x = _e; }
  { auto _e = stride_y(); _o->stride_y = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = pad_type(); _o->pad_type = _e; }
  { auto _e = data_type(); _o->data_type = _e; }
  { auto _e = ceil_model(); _o->ceil_model = _e; }
  { auto _e = pads(); if (_e) { _o->pads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pads[_i] = _e->Get(_i); } } }
  { auto _e = count_type(); _o->count_type = _e; }
  { auto _e = in_channels(); _o->in_channels = _e; }
  { auto _e = in_width(); _o->in_width = _e; }
  { auto _e = in_height(); _o->in_height = _e; }
  { auto _e = is_adaptive(); _o->is_adaptive = _e; }
  { auto _e = out_height(); _o->out_height = _e; }
  { auto _e = out_width(); _o->out_width = _e; }
}

inline flatbuffers::Offset<Pool> Pool::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoolT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePool(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pool> CreatePool(flatbuffers::FlatBufferBuilder &_fbb, const PoolT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PoolT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pad_x = _o->pad_x;
  auto _pad_y = _o->pad_y;
  auto _is_global = _o->is_global;
  auto _kernel_x = _o->kernel_x;
  auto _kernel_y = _o->kernel_y;
  auto _stride_x = _o->stride_x;
  auto _stride_y = _o->stride_y;
  auto _type = _o->type;
  auto _pad_type = _o->pad_type;
  auto _data_type = _o->data_type;
  auto _ceil_model = _o->ceil_model;
  auto _pads = _o->pads.size() ? _fbb.CreateVector(_o->pads) : 0;
  auto _count_type = _o->count_type;
  auto _in_channels = _o->in_channels;
  auto _in_width = _o->in_width;
  auto _in_height = _o->in_height;
  auto _is_adaptive = _o->is_adaptive;
  auto _out_height = _o->out_height;
  auto _out_width = _o->out_width;
  return wnn::CreatePool(
      _fbb,
      _pad_x,
      _pad_y,
      _is_global,
      _kernel_x,
      _kernel_y,
      _stride_x,
      _stride_y,
      _type,
      _pad_type,
      _data_type,
      _ceil_model,
      _pads,
      _count_type,
      _in_channels,
      _in_width,
      _in_height,
      _is_adaptive,
      _out_height,
      _out_width);
}

inline AdaptiveAvgPool2DT *AdaptiveAvgPool2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AdaptiveAvgPool2DT>(new AdaptiveAvgPool2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AdaptiveAvgPool2D::UnPackTo(AdaptiveAvgPool2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = out_h(); _o->out_h = _e; }
  { auto _e = out_w(); _o->out_w = _e; }
  { auto _e = data_type(); _o->data_type = _e; }
}

inline flatbuffers::Offset<AdaptiveAvgPool2D> AdaptiveAvgPool2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AdaptiveAvgPool2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAdaptiveAvgPool2D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AdaptiveAvgPool2D> CreateAdaptiveAvgPool2D(flatbuffers::FlatBufferBuilder &_fbb, const AdaptiveAvgPool2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AdaptiveAvgPool2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _out_h = _o->out_h;
  auto _out_w = _o->out_w;
  auto _data_type = _o->data_type;
  return wnn::CreateAdaptiveAvgPool2D(
      _fbb,
      _out_h,
      _out_w,
      _data_type);
}

inline LayerNormT *LayerNorm::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LayerNormT>(new LayerNormT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LayerNorm::UnPackTo(LayerNormT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); if (_e) { _o->axis.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axis[_i] = _e->Get(_i); } } }
  { auto _e = epsilon(); _o->epsilon = _e; }
  { auto _e = gamma(); if (_e) { _o->gamma.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->gamma[_i] = _e->Get(_i); } } }
  { auto _e = beta(); if (_e) { _o->beta.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->beta[_i] = _e->Get(_i); } } }
  { auto _e = group(); _o->group = _e; }
  { auto _e = elmentwise_affine(); _o->elmentwise_affine = _e; }
}

inline flatbuffers::Offset<LayerNorm> LayerNorm::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLayerNorm(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LayerNorm> CreateLayerNorm(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LayerNormT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis.size() ? _fbb.CreateVector(_o->axis) : 0;
  auto _epsilon = _o->epsilon;
  auto _gamma = _o->gamma.size() ? _fbb.CreateVector(_o->gamma) : 0;
  auto _beta = _o->beta.size() ? _fbb.CreateVector(_o->beta) : 0;
  auto _group = _o->group;
  auto _elmentwise_affine = _o->elmentwise_affine;
  return wnn::CreateLayerNorm(
      _fbb,
      _axis,
      _epsilon,
      _gamma,
      _beta,
      _group,
      _elmentwise_affine);
}

inline BatchNormT *BatchNorm::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BatchNormT>(new BatchNormT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BatchNorm::UnPackTo(BatchNormT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = channels(); _o->channels = _e; }
  { auto _e = slope_data(); if (_e) { _o->slope_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slope_data[_i] = _e->Get(_i); } } }
  { auto _e = mean_data(); if (_e) { _o->mean_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mean_data[_i] = _e->Get(_i); } } }
  { auto _e = var_data(); if (_e) { _o->var_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->var_data[_i] = _e->Get(_i); } } }
  { auto _e = bias_data(); if (_e) { _o->bias_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bias_data[_i] = _e->Get(_i); } } }
  { auto _e = a_data(); if (_e) { _o->a_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->a_data[_i] = _e->Get(_i); } } }
  { auto _e = b_data(); if (_e) { _o->b_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->b_data[_i] = _e->Get(_i); } } }
  { auto _e = epsilon(); _o->epsilon = _e; }
}

inline flatbuffers::Offset<BatchNorm> BatchNorm::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchNorm(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchNorm> CreateBatchNorm(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchNormT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _channels = _o->channels;
  auto _slope_data = _o->slope_data.size() ? _fbb.CreateVector(_o->slope_data) : 0;
  auto _mean_data = _o->mean_data.size() ? _fbb.CreateVector(_o->mean_data) : 0;
  auto _var_data = _o->var_data.size() ? _fbb.CreateVector(_o->var_data) : 0;
  auto _bias_data = _o->bias_data.size() ? _fbb.CreateVector(_o->bias_data) : 0;
  auto _a_data = _o->a_data.size() ? _fbb.CreateVector(_o->a_data) : 0;
  auto _b_data = _o->b_data.size() ? _fbb.CreateVector(_o->b_data) : 0;
  auto _epsilon = _o->epsilon;
  return wnn::CreateBatchNorm(
      _fbb,
      _channels,
      _slope_data,
      _mean_data,
      _var_data,
      _bias_data,
      _a_data,
      _b_data,
      _epsilon);
}

inline ReluT *Relu::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReluT>(new ReluT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Relu::UnPackTo(ReluT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slope(); _o->slope = _e; }
}

inline flatbuffers::Offset<Relu> Relu::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReluT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRelu(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Relu> CreateRelu(flatbuffers::FlatBufferBuilder &_fbb, const ReluT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReluT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slope = _o->slope;
  return wnn::CreateRelu(
      _fbb,
      _slope);
}

inline Relu6T *Relu6::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Relu6T>(new Relu6T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Relu6::UnPackTo(Relu6T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = min_value(); _o->min_value = _e; }
  { auto _e = max_value(); _o->max_value = _e; }
}

inline flatbuffers::Offset<Relu6> Relu6::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Relu6T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRelu6(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Relu6> CreateRelu6(flatbuffers::FlatBufferBuilder &_fbb, const Relu6T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Relu6T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _min_value = _o->min_value;
  auto _max_value = _o->max_value;
  return wnn::CreateRelu6(
      _fbb,
      _min_value,
      _max_value);
}

inline SoftmaxT *Softmax::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SoftmaxT>(new SoftmaxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Softmax::UnPackTo(SoftmaxT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dim(); _o->dim = _e; }
}

inline flatbuffers::Offset<Softmax> Softmax::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSoftmax(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Softmax> CreateSoftmax(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SoftmaxT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dim = _o->dim;
  return wnn::CreateSoftmax(
      _fbb,
      _dim);
}

inline PReluT *PRelu::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PReluT>(new PReluT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PRelu::UnPackTo(PReluT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slope_count(); _o->slope_count = _e; }
  { auto _e = slope(); if (_e) { _o->slope.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slope[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<PRelu> PRelu::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PReluT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePRelu(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PRelu> CreatePRelu(flatbuffers::FlatBufferBuilder &_fbb, const PReluT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PReluT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slope_count = _o->slope_count;
  auto _slope = _o->slope.size() ? _fbb.CreateVector(_o->slope) : 0;
  return wnn::CreatePRelu(
      _fbb,
      _slope_count,
      _slope);
}

inline ELUT *ELU::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ELUT>(new ELUT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ELU::UnPackTo(ELUT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = alpha(); _o->alpha = _e; }
}

inline flatbuffers::Offset<ELU> ELU::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ELUT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateELU(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ELU> CreateELU(flatbuffers::FlatBufferBuilder &_fbb, const ELUT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ELUT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _alpha = _o->alpha;
  return wnn::CreateELU(
      _fbb,
      _alpha);
}

inline LRNT *LRN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LRNT>(new LRNT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LRN::UnPackTo(LRNT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = region_type(); _o->region_type = _e; }
  { auto _e = local_size(); _o->local_size = _e; }
  { auto _e = alpha(); _o->alpha = _e; }
  { auto _e = beta(); _o->beta = _e; }
  { auto _e = bias(); _o->bias = _e; }
}

inline flatbuffers::Offset<LRN> LRN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LRNT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLRN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LRN> CreateLRN(flatbuffers::FlatBufferBuilder &_fbb, const LRNT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LRNT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _region_type = _o->region_type;
  auto _local_size = _o->local_size;
  auto _alpha = _o->alpha;
  auto _beta = _o->beta;
  auto _bias = _o->bias;
  return wnn::CreateLRN(
      _fbb,
      _region_type,
      _local_size,
      _alpha,
      _beta,
      _bias);
}

inline FCT::FCT(const FCT &o)
      : in_features(o.in_features),
        out_features(o.out_features),
        weight_size(o.weight_size),
        weights(o.weights),
        bias(o.bias),
        axis(o.axis),
        transpose(o.transpose),
        has_act(o.has_act),
        act_type(o.act_type),
        act_params(o.act_params),
        quant_param((o.quant_param) ? new wnn::QuantT(*o.quant_param) : nullptr) {
}

inline FCT &FCT::operator=(FCT o) FLATBUFFERS_NOEXCEPT {
  std::swap(in_features, o.in_features);
  std::swap(out_features, o.out_features);
  std::swap(weight_size, o.weight_size);
  std::swap(weights, o.weights);
  std::swap(bias, o.bias);
  std::swap(axis, o.axis);
  std::swap(transpose, o.transpose);
  std::swap(has_act, o.has_act);
  std::swap(act_type, o.act_type);
  std::swap(act_params, o.act_params);
  std::swap(quant_param, o.quant_param);
  return *this;
}

inline FCT *FC::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FCT>(new FCT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FC::UnPackTo(FCT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = in_features(); _o->in_features = _e; }
  { auto _e = out_features(); _o->out_features = _e; }
  { auto _e = weight_size(); _o->weight_size = _e; }
  { auto _e = weights(); if (_e) { _o->weights.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weights[_i] = _e->Get(_i); } } }
  { auto _e = bias(); if (_e) { _o->bias.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bias[_i] = _e->Get(_i); } } }
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = transpose(); _o->transpose = _e; }
  { auto _e = has_act(); _o->has_act = _e; }
  { auto _e = act_type(); _o->act_type = _e; }
  { auto _e = act_params(); if (_e) { _o->act_params.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->act_params[_i] = _e->Get(_i); } } }
  { auto _e = quant_param(); if (_e) { if(_o->quant_param) { _e->UnPackTo(_o->quant_param.get(), _resolver); } else { _o->quant_param = std::unique_ptr<wnn::QuantT>(_e->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<FC> FC::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FCT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFC(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FC> CreateFC(flatbuffers::FlatBufferBuilder &_fbb, const FCT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FCT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _in_features = _o->in_features;
  auto _out_features = _o->out_features;
  auto _weight_size = _o->weight_size;
  auto _weights = _o->weights.size() ? _fbb.CreateVector(_o->weights) : 0;
  auto _bias = _o->bias.size() ? _fbb.CreateVector(_o->bias) : 0;
  auto _axis = _o->axis;
  auto _transpose = _o->transpose;
  auto _has_act = _o->has_act;
  auto _act_type = _o->act_type;
  auto _act_params = _o->act_params.size() ? _fbb.CreateVector(_o->act_params) : 0;
  auto _quant_param = _o->quant_param ? CreateQuant(_fbb, _o->quant_param.get(), _rehasher) : 0;
  return wnn::CreateFC(
      _fbb,
      _in_features,
      _out_features,
      _weight_size,
      _weights,
      _bias,
      _axis,
      _transpose,
      _has_act,
      _act_type,
      _act_params,
      _quant_param);
}

inline InputT *Input::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InputT>(new InputT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Input::UnPackTo(InputT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } }
  { auto _e = dtype(); _o->dtype = _e; }
  { auto _e = dformat(); _o->dformat = _e; }
}

inline flatbuffers::Offset<Input> Input::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInput(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Input> CreateInput(flatbuffers::FlatBufferBuilder &_fbb, const InputT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InputT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  auto _dtype = _o->dtype;
  auto _dformat = _o->dformat;
  return wnn::CreateInput(
      _fbb,
      _dims,
      _dtype,
      _dformat);
}

inline ArgMaxT *ArgMax::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ArgMaxT>(new ArgMaxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ArgMax::UnPackTo(ArgMaxT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = out_max_val(); _o->out_max_val = _e; }
  { auto _e = top_k(); _o->top_k = _e; }
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = softmax_thresh(); _o->softmax_thresh = _e; }
}

inline flatbuffers::Offset<ArgMax> ArgMax::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArgMax(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArgMax> CreateArgMax(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArgMaxT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _out_max_val = _o->out_max_val;
  auto _top_k = _o->top_k;
  auto _axis = _o->axis;
  auto _softmax_thresh = _o->softmax_thresh;
  return wnn::CreateArgMax(
      _fbb,
      _out_max_val,
      _top_k,
      _axis,
      _softmax_thresh);
}

inline BinaryT *Binary::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BinaryT>(new BinaryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Binary::UnPackTo(BinaryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = operation_type(); _o->operation_type = _e; }
  { auto _e = dtype(); _o->dtype = _e; }
}

inline flatbuffers::Offset<Binary> Binary::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BinaryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBinary(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Binary> CreateBinary(flatbuffers::FlatBufferBuilder &_fbb, const BinaryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BinaryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _operation_type = _o->operation_type;
  auto _dtype = _o->dtype;
  return wnn::CreateBinary(
      _fbb,
      _operation_type,
      _dtype);
}

inline UnaryT *Unary::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UnaryT>(new UnaryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Unary::UnPackTo(UnaryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = operation_type(); _o->operation_type = _e; }
  { auto _e = dtype(); _o->dtype = _e; }
}

inline flatbuffers::Offset<Unary> Unary::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnaryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnary(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Unary> CreateUnary(flatbuffers::FlatBufferBuilder &_fbb, const UnaryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnaryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _operation_type = _o->operation_type;
  auto _dtype = _o->dtype;
  return wnn::CreateUnary(
      _fbb,
      _operation_type,
      _dtype);
}

inline EltwiseT *Eltwise::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EltwiseT>(new EltwiseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Eltwise::UnPackTo(EltwiseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = coeff(); if (_e) { _o->coeff.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->coeff[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Eltwise> Eltwise::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEltwise(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Eltwise> CreateEltwise(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EltwiseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _coeff = _o->coeff.size() ? _fbb.CreateVector(_o->coeff) : 0;
  return wnn::CreateEltwise(
      _fbb,
      _type,
      _coeff);
}

inline ReductionT *Reduction::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReductionT>(new ReductionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Reduction::UnPackTo(ReductionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = operation(); _o->operation = _e; }
  { auto _e = dim(); if (_e) { _o->dim.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dim[_i] = _e->Get(_i); } } }
  { auto _e = coeff(); _o->coeff = _e; }
  { auto _e = keep_dims(); _o->keep_dims = _e; }
  { auto _e = dtype(); _o->dtype = _e; }
}

inline flatbuffers::Offset<Reduction> Reduction::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReductionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReduction(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reduction> CreateReduction(flatbuffers::FlatBufferBuilder &_fbb, const ReductionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReductionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _operation = _o->operation;
  auto _dim = _o->dim.size() ? _fbb.CreateVector(_o->dim) : 0;
  auto _coeff = _o->coeff;
  auto _keep_dims = _o->keep_dims;
  auto _dtype = _o->dtype;
  return wnn::CreateReduction(
      _fbb,
      _operation,
      _dim,
      _coeff,
      _keep_dims,
      _dtype);
}

inline SqueezeT *Squeeze::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SqueezeT>(new SqueezeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Squeeze::UnPackTo(SqueezeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = squeeze_dims(); if (_e) { _o->squeeze_dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->squeeze_dims[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Squeeze> Squeeze::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSqueeze(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Squeeze> CreateSqueeze(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SqueezeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _squeeze_dims = _o->squeeze_dims.size() ? _fbb.CreateVector(_o->squeeze_dims) : 0;
  return wnn::CreateSqueeze(
      _fbb,
      _squeeze_dims);
}

inline GatherT *Gather::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GatherT>(new GatherT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Gather::UnPackTo(GatherT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = indices_dtype(); _o->indices_dtype = _e; }
  { auto _e = dtype(); _o->dtype = _e; }
  { auto _e = validateindices(); _o->validateindices = _e; }
  { auto _e = axis(); _o->axis = _e; }
}

inline flatbuffers::Offset<Gather> Gather::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGather(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Gather> CreateGather(flatbuffers::FlatBufferBuilder &_fbb, const GatherT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GatherT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _indices_dtype = _o->indices_dtype;
  auto _dtype = _o->dtype;
  auto _validateindices = _o->validateindices;
  auto _axis = _o->axis;
  return wnn::CreateGather(
      _fbb,
      _indices_dtype,
      _dtype,
      _validateindices,
      _axis);
}

inline ExpandDimsT *ExpandDims::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExpandDimsT>(new ExpandDimsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExpandDims::UnPackTo(ExpandDimsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dtype(); _o->dtype = _e; }
  { auto _e = dim_dtype(); _o->dim_dtype = _e; }
  { auto _e = axis(); _o->axis = _e; }
}

inline flatbuffers::Offset<ExpandDims> ExpandDims::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExpandDims(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExpandDims> CreateExpandDims(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExpandDimsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dtype = _o->dtype;
  auto _dim_dtype = _o->dim_dtype;
  auto _axis = _o->axis;
  return wnn::CreateExpandDims(
      _fbb,
      _dtype,
      _dim_dtype,
      _axis);
}

inline FlattenT *Flatten::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlattenT>(new FlattenT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Flatten::UnPackTo(FlattenT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = start_dim(); _o->start_dim = _e; }
  { auto _e = end_dim(); _o->end_dim = _e; }
}

inline flatbuffers::Offset<Flatten> Flatten::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlatten(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Flatten> CreateFlatten(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlattenT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _start_dim = _o->start_dim;
  auto _end_dim = _o->end_dim;
  return wnn::CreateFlatten(
      _fbb,
      _start_dim,
      _end_dim);
}

inline const flatbuffers::TypeTable *OpTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::OpTypeTypeTable
  };
  static const char * const names[] = {
    "argmax",
    "argmin",
    "const_",
    "conv1d",
    "conv2d",
    "conv3d",
    "pool2d",
    "pool3d",
    "adaptive_avg_pool2d",
    "batchnorm",
    "layernorm",
    "relu",
    "relu6",
    "elu",
    "prelu",
    "leakyrelu",
    "tanh",
    "silu",
    "mish",
    "hardswish",
    "hardsigmoid",
    "sigmoid",
    "fc",
    "flatten",
    "matmul",
    "fc_share",
    "lstm",
    "onehot",
    "transpose",
    "gather",
    "split",
    "concat",
    "activation",
    "binary_op",
    "fill",
    "pad",
    "reshape",
    "instancenorm",
    "conv_depthwise",
    "quantized_avgpool",
    "quantized_concat",
    "quantized_matmul",
    "quantized_relu",
    "quantized_relu6",
    "quantized_softmax",
    "roipooling",
    "roialign",
    "unary",
    "unary_square",
    "unary_sqrt",
    "binary",
    "binary_add",
    "binary_mul",
    "binary_div",
    "binary_sub",
    "softmax",
    "scatternd",
    "gathernd",
    "nms",
    "input",
    "output",
    "extra",
    "eltwise",
    "reduction",
    "expand_dims",
    "normalize",
    "unsupported",
    "film_lpn",
    "cubic"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 69, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PadModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::PadModeTypeTable
  };
  static const char * const names[] = {
    "CAFFE",
    "VALID",
    "SAME"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ActivationTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::ActivationTypeTypeTable
  };
  static const char * const names[] = {
    "RELU",
    "RELU6",
    "LEAKY_RELU",
    "ELU",
    "TANH",
    "PRELU",
    "MISH",
    "SWISH"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 8, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PoolTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::PoolTypeTypeTable
  };
  static const char * const names[] = {
    "MAXPOOL",
    "AVEPOOL"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PoolPadTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::PoolPadTypeTypeTable
  };
  static const char * const names[] = {
    "CAFFE",
    "VALID",
    "SAME"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AvgPoolCountTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::AvgPoolCountTypeTypeTable
  };
  static const char * const names[] = {
    "DEFAULT",
    "INCLUDE_PADDING",
    "EXCLUDE_PADDING"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BinaryOperationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::BinaryOperationTypeTable
  };
  static const int64_t values[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29 };
  static const char * const names[] = {
    "ADD",
    "SUB",
    "MUL",
    "DIV",
    "MAX_TEMP",
    "MIN_TEMP",
    "POW",
    "REALDIV",
    "MINIMUM",
    "MAXIMUM",
    "GREATER",
    "GREATER_EQUAL",
    "LESS",
    "FLOORDIV",
    "SquaredDifference",
    "EQUAL",
    "LESS_EQUAL",
    "FLOORMOD",
    "MOD",
    "ATAN2",
    "LOGICALOR",
    "NOTEQUAL",
    "BITWISE_AND",
    "BITWISE_OR",
    "BITWISE_XOR",
    "LOGICALXOR",
    "LEFTSHIFT",
    "RIGHTSHIFT",
    "RSUB"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 29, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UnaryOperationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::UnaryOperationTypeTable
  };
  static const char * const names[] = {
    "ABS",
    "NEG",
    "FLOOR",
    "CEIL",
    "SQUARE",
    "SQRT",
    "RSQRT",
    "EXP",
    "LOG",
    "SIN",
    "COS",
    "TAN",
    "ASIN",
    "ACOS",
    "ATAN",
    "RECIPROCAL",
    "LOG1P",
    "BNLL",
    "ACOSH",
    "SINH",
    "ASINH",
    "ATANH",
    "SIGN",
    "ROUND",
    "COSH",
    "ERF",
    "ERFC",
    "ERFINV",
    "EXPM1",
    "SIGMOID",
    "TANH",
    "HARDSWISH",
    "GELU",
    "GELU_STANDARD",
    "NOT",
    "BOOL"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 36, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EltwiseTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::EltwiseTypeTypeTable
  };
  static const char * const names[] = {
    "PROD",
    "SUM",
    "MAXIUM",
    "SUB",
    "SOFTMAX"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReductionTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::ReductionTypeTypeTable
  };
  static const char * const names[] = {
    "SUM",
    "ASUM",
    "SUMSQ",
    "MEAN",
    "MAXIMUM",
    "MINIMUM",
    "PROD",
    "ANY",
    "ALL"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 9, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Conv2DCommonTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::PadModeTypeTable
  };
  static const char * const names[] = {
    "pad_x",
    "pad_y",
    "kernel_x",
    "kernel_y",
    "stride_x",
    "stride_y",
    "dilate_x",
    "dilate_y",
    "padmode",
    "group",
    "output_count",
    "input_count",
    "sparse_output_count",
    "in_channels",
    "out_channels",
    "relu",
    "relu6",
    "pads",
    "out_pads",
    "has_outputshape"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 20, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Conv2DTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, 1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::Conv2DCommonTypeTable,
    wnn::OpTypeTypeTable,
    wnn::QuantTypeTable
  };
  static const char * const names[] = {
    "common",
    "weight",
    "bias",
    "has_act",
    "act_type",
    "input_shape",
    "quant_param"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PoolTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_INT, 0, 2 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 3 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::PoolTypeTypeTable,
    wnn::PoolPadTypeTypeTable,
    wnn::DataTypeTypeTable,
    wnn::AvgPoolCountTypeTypeTable
  };
  static const char * const names[] = {
    "pad_x",
    "pad_y",
    "is_global",
    "kernel_x",
    "kernel_y",
    "stride_x",
    "stride_y",
    "type",
    "pad_type",
    "data_type",
    "ceil_model",
    "pads",
    "count_type",
    "in_channels",
    "in_width",
    "in_height",
    "is_adaptive",
    "out_height",
    "out_width"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 19, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AdaptiveAvgPool2DTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::DataTypeTypeTable
  };
  static const char * const names[] = {
    "out_h",
    "out_w",
    "data_type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LayerNormTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "axis",
    "epsilon",
    "gamma",
    "beta",
    "group",
    "elmentwise_affine"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BatchNormTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "channels",
    "slope_data",
    "mean_data",
    "var_data",
    "bias_data",
    "a_data",
    "b_data",
    "epsilon"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReluTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "slope"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Relu6TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "min_value",
    "max_value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SoftmaxTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "dim"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PReluTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "slope_count",
    "slope"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ELUTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "alpha"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LRNTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "region_type",
    "local_size",
    "alpha",
    "beta",
    "bias"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FCTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::OpTypeTypeTable,
    wnn::QuantTypeTable
  };
  static const char * const names[] = {
    "in_features",
    "out_features",
    "weight_size",
    "weights",
    "bias",
    "axis",
    "transpose",
    "has_act",
    "act_type",
    "act_params",
    "quant_param"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InputTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::DataTypeTypeTable,
    wnn::WNN_DATA_FORMATTypeTable
  };
  static const char * const names[] = {
    "dims",
    "dtype",
    "dformat"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ArgMaxTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "out_max_val",
    "top_k",
    "axis",
    "softmax_thresh"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BinaryTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::BinaryOperationTypeTable,
    wnn::DataTypeTypeTable
  };
  static const char * const names[] = {
    "operation_type",
    "dtype"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UnaryTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::UnaryOperationTypeTable,
    wnn::DataTypeTypeTable
  };
  static const char * const names[] = {
    "operation_type",
    "dtype"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EltwiseTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::EltwiseTypeTypeTable
  };
  static const char * const names[] = {
    "type",
    "coeff"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReductionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::ReductionTypeTypeTable,
    wnn::DataTypeTypeTable
  };
  static const char * const names[] = {
    "operation",
    "dim",
    "coeff",
    "keep_dims",
    "dtype"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SqueezeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "squeeze_dims"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GatherTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::DataTypeTypeTable
  };
  static const char * const names[] = {
    "indices_dtype",
    "dtype",
    "validateindices",
    "axis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ExpandDimsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::DataTypeTypeTable
  };
  static const char * const names[] = {
    "dtype",
    "dim_dtype",
    "axis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FlattenTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "start_dim",
    "end_dim"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace wnn

#endif  // FLATBUFFERS_GENERATED_WNNOPS_WNN_H_
